1
00:00:00,000 --> 00:00:14,480
 Hello everyone. So today we are going to talk about a few things, I think all very interesting

2
00:00:14,480 --> 00:00:22,920
 topics. In particular, we are going to talk about transactions, how in general, how do

3
00:00:22,920 --> 00:00:28,360
 different computers can agree with each other. And then we are going to talk quite a bit

4
00:00:28,360 --> 00:00:38,420
 about networking. So let's start. So if you remember from last time, we discussed about

5
00:00:38,420 --> 00:00:46,920
 retouching the protocols. And protocol is a fundamental concept when two parties are

6
00:00:46,920 --> 00:00:54,020
 communicating. Because you need a protocol to see how everyone is going to perform the

7
00:00:54,020 --> 00:00:59,800
 communication and how it's going to interpret the communication. And like we discussed last

8
00:00:59,800 --> 00:01:08,040
 time, there are two parts of a protocol. It's a syntax, and the syntax is basically described

9
00:01:08,040 --> 00:01:16,200
 as a structure, the commands of the communication protocol. And then there is a semantics which

10
00:01:16,200 --> 00:01:27,160
 describes the meaning of the messages, the meaning of the commands. And these are typically

11
00:01:27,160 --> 00:01:34,320
 implemented by state machines. So you send a message, what is a state machine means here

12
00:01:34,320 --> 00:01:40,000
 is that you are going in initial state and from initial state, you are going to send

13
00:01:40,000 --> 00:01:45,440
 a message and then you may transition in a state in which you are waiting for a reply.

14
00:01:45,440 --> 00:01:51,120
 That's the difference. If you wait for a reply, the reply doesn't come, then you may have

15
00:01:51,120 --> 00:01:55,200
 experienced a timeout and you are going to go into another state and you are maybe you

16
00:01:55,200 --> 00:02:04,200
 are going to resend the original message. Just to give you a sense. And also if you

17
00:02:04,200 --> 00:02:14,600
 want the protocol to be fault tolerant, one way to do it is to store its state, the current

18
00:02:14,600 --> 00:02:21,860
 state of the protocol, so that when you are going, when you come back up after the failures,

19
00:02:21,860 --> 00:02:33,440
 you know where you left. And here it's a very simple classic example. So this is about,

20
00:02:33,440 --> 00:02:39,920
 for instance, when you talk with someone who is by telephone, by phone, you pick up the

21
00:02:39,920 --> 00:02:47,320
 phone, you open it and listen for dial tone. Today on the cell phones, there are no longer

22
00:02:47,320 --> 00:02:53,720
 dial phones, but if you used one of these older phones, you know that it's a dial phone,

23
00:02:53,720 --> 00:03:02,400
 dial tone. And dial tone, meaning that the phone is available, you can dial in the number.

24
00:03:02,400 --> 00:03:07,720
 If it's busy signals, then you cannot. Well, you can, but nothing will happen. So you dial

25
00:03:07,720 --> 00:03:15,680
 a phone number and then you hear the ringing. This means that the other person, the phone

26
00:03:15,680 --> 00:03:24,400
 rings to the other person and then colleagues is going to answer hello. And then you are

27
00:03:24,400 --> 00:03:34,440
 going to start the conversation. And then typically there is some kind of protocol.

28
00:03:34,440 --> 00:03:40,440
 This is again, describe the protocol. Then typically when you wait for an answer, what

29
00:03:40,440 --> 00:03:46,640
 do you do? You pause, you don't continue speaking. You ask a question and then you are pausing

30
00:03:46,640 --> 00:03:55,440
 or when you want to give the other part of the chance to talk. And then when the conversation

31
00:03:55,440 --> 00:04:04,400
 ends, you say something like bye or see you soon and then you hang up. So this is an example

32
00:04:04,400 --> 00:04:11,840
 of protocol. And we are going to talk about some of the most important protocols in networking.

33
00:04:11,840 --> 00:04:20,320
 Next lecture in particular, we are going to talk about TCP transfer control protocol.

34
00:04:20,320 --> 00:04:32,600
 Any questions? Okay. So again, these are red lines represent basically the communication

35
00:04:32,600 --> 00:04:45,560
 exchange of the information between the two parties. The first group of arrows exchange

36
00:04:45,560 --> 00:04:54,320
 represents setting up the connection, setting up the call. You ring and then the other party

37
00:04:54,320 --> 00:05:00,600
 answers. But from that point you can start communicating. Then the second group of arrows

38
00:05:00,600 --> 00:05:08,040
 represents the communication after the connection has been established. And the last group,

39
00:05:08,040 --> 00:05:16,080
 it's obviously closing the connection. Last two arrows.

40
00:05:16,080 --> 00:05:24,040
 So now, so fundamentally now we are having an network and we are having different machines.

41
00:05:24,040 --> 00:05:31,120
 And like we discussed last time, many of the applications are running on different machines.

42
00:05:31,120 --> 00:05:40,680
 All these, your client, Facebook client and backend of Facebook is the same application.

43
00:05:40,680 --> 00:05:48,240
 The backend of Facebook or Google consists of many machines. On Serana queries, there

44
00:05:48,240 --> 00:05:56,720
 are a large number of machines which are going to contribute to provide you with the answer.

45
00:05:56,720 --> 00:06:04,880
 So these machines somehow needs to communicate, needs to synchronize among themselves. And

46
00:06:04,880 --> 00:06:14,440
 the biggest challenge here is that it's again, it's like you need to, on a single machine,

47
00:06:14,440 --> 00:06:23,640
 we have the same problem to synchronize multiple threads. But in the case of a single machine,

48
00:06:23,640 --> 00:06:29,400
 we've done that at the end of the day by using this kind of hardware primitives like test

49
00:06:29,400 --> 00:06:34,320
 and set, which are atomics, right? Checking a value and setting a value and that operation

50
00:06:34,320 --> 00:06:41,720
 is atomic. So if you remember, it's all very, very helpful to build also the higher level

51
00:06:41,720 --> 00:06:47,640
 of communication, synchronization primitives like PNB and things like that, or locks and

52
00:06:47,640 --> 00:07:01,240
 semaphores. The problem in a distributed system, that's the only way to application processes

53
00:07:01,240 --> 00:07:06,880
 running on different machines can communicate is through sending a receiving message. That's

54
00:07:06,880 --> 00:07:18,400
 the only thing you have. And sending and receiving a message is atomic in the sense that typically

55
00:07:18,400 --> 00:07:30,360
 the receiver gets the entire message you send by the sender, you don't get half a message.

56
00:07:30,360 --> 00:07:40,960
 But you don't have more than that. Anyway, if you can think about this, about what the

57
00:07:40,960 --> 00:07:47,400
 abstraction looks like to exchange information between two processes running on different

58
00:07:47,400 --> 00:07:54,480
 machines, sending and receiving message abstraction is like a mailbox, right? You put a letter,

59
00:07:54,480 --> 00:08:02,000
 you send a letter, the recipient gets a letter and sends you back, right? So you have a send

60
00:08:02,000 --> 00:08:11,120
 primitive and a receive primitive. That's pretty much what you have. So now let's think

61
00:08:11,120 --> 00:08:18,240
 about how we are going to use these primitives to build higher level primitives. And one

62
00:08:18,240 --> 00:08:24,440
 of the most basic primitives is about consensus. So basically what consensus is about is that

63
00:08:24,440 --> 00:08:38,520
 you want multiple nodes, multiple parties to agree on a value, right? So this is what

64
00:08:38,520 --> 00:08:48,480
 consensus means, to agree on something, right? To pick one choice from multiple choices.

65
00:08:48,480 --> 00:09:00,160
 So you need to do this in an environment in which different nodes may fail, stop responding

66
00:09:00,160 --> 00:09:08,100
 and messages can be lost. And also the message, how long it takes a message to be delivered

67
00:09:08,100 --> 00:09:24,180
 can be unbounded. Okay. So this is a problem, right? And just to simplify the problem, actually,

68
00:09:24,180 --> 00:09:31,060
 you just think about there are two parties which wants to choose between true and false,

69
00:09:31,060 --> 00:09:41,040
 right? And if they choose the same, have the same choice, they commit, otherwise they abort.

70
00:09:41,040 --> 00:09:48,520
 Okay. And again, you need to do that in a globally scalable system and the decision

71
00:09:48,520 --> 00:09:54,500
 shouldn't be forgotten, especially when there is a failure, right? So you need to have some

72
00:09:54,500 --> 00:10:00,240
 sort of durability. So here is the example. The example is this general paradox. This

73
00:10:00,240 --> 00:10:03,040
 This is the one formulation of the problem.

74
00:10:03,170 --> 00:10:06,730
 To just illustrate the point.

75
00:10:06,730 --> 00:10:09,530
 So here's assume that you have two generals

76
00:10:09,530 --> 00:10:14,530
 who want to attack, who must attack the enemy.

77
00:10:14,530 --> 00:10:17,610
 In this case, the red enemy,

78
00:10:17,610 --> 00:10:19,050
 the red castle in the middle.

79
00:10:19,050 --> 00:10:24,650
 Now, if both of these armies on each side

80
00:10:24,650 --> 00:10:28,810
 attack at the same time, they are going to win.

81
00:10:31,730 --> 00:10:34,970
 If they attack at different times,

82
00:10:34,970 --> 00:10:37,570
 they are going to lose.

83
00:10:37,570 --> 00:10:43,450
 Because the enemy is more powerful than a single army,

84
00:10:43,450 --> 00:10:47,890
 but it's less powerful than two army put together.

85
00:10:47,890 --> 00:10:53,570
 So as such, in this case, the two armies need,

86
00:10:53,570 --> 00:11:00,450
 and the generals of the two armies need to agree

87
00:11:01,450 --> 00:11:02,330
 when to attack.

88
00:11:02,330 --> 00:11:06,370
 Now the biggest problem, and obviously here,

89
00:11:06,370 --> 00:11:10,330
 think about all times, you need to send messengers.

90
00:11:10,330 --> 00:11:13,210
 But the messenger can be intercepted by the enemy

91
00:11:13,210 --> 00:11:15,210
 because the enemy is in the valley,

92
00:11:15,210 --> 00:11:18,410
 so say in this case, between the two armies.

93
00:11:18,410 --> 00:11:22,170
 Okay?

94
00:11:22,170 --> 00:11:29,210
 And, you know, this is, it was a real similar situation

95
00:11:29,850 --> 00:11:34,850
 like this caster in the history of United States,

96
00:11:34,850 --> 00:11:42,770
 that was a battle, little big horn when he arrived earlier,

97
00:11:42,770 --> 00:11:47,170
 and he engaged earlier, and I believe he died.

98
00:11:47,170 --> 00:11:49,650
 But it's a problem.

99
00:11:49,650 --> 00:11:53,090
 So the power, you know, what we need to do here

100
00:11:53,090 --> 00:11:58,090
 is to develop a solution in which, you know,

101
00:11:58,090 --> 00:12:03,090
 the two generals are going to agree on the time

102
00:12:03,090 --> 00:12:04,130
 when to attack.

103
00:12:04,130 --> 00:12:06,570
 Okay? That's a problem.

104
00:12:06,570 --> 00:12:17,850
 So can you develop such a protocol in an environment

105
00:12:17,850 --> 00:12:23,530
 in which the messages can be lost, can be arbitrarily late?

106
00:12:26,930 --> 00:12:29,810
 It turns out that the answer is no.

107
00:12:29,810 --> 00:12:36,970
 And fundamentally it's, again, say one general say,

108
00:12:36,970 --> 00:12:41,170
 you know, I want to attack at 11 AM.

109
00:12:41,170 --> 00:12:44,810
 The other one say, okay, yes, 11 AM works.

110
00:12:44,810 --> 00:12:48,370
 But then the second one who says that,

111
00:12:48,370 --> 00:12:51,890
 how he knows that the first general got his message,

112
00:12:51,890 --> 00:12:56,850
 the confirmation, because if he didn't, right,

113
00:12:56,850 --> 00:12:59,010
 if he didn't get the confirmation,

114
00:12:59,010 --> 00:13:02,370
 then he's not going to attack, right?

115
00:13:02,370 --> 00:13:06,530
 And the second general will attack alone, right?

116
00:13:06,530 --> 00:13:07,370
 And so forth.

117
00:13:07,370 --> 00:13:13,970
 So I told you that there is already no solution.

118
00:13:13,970 --> 00:13:18,490
 Now I just want you to think a little bit,

119
00:13:18,490 --> 00:13:21,490
 and here is an example about an instance, right?

120
00:13:25,570 --> 00:13:30,570
 But can you think about, and can you argue convincingly,

121
00:13:30,570 --> 00:13:38,210
 there is no protocol such that under these conditions,

122
00:13:38,210 --> 00:13:41,210
 in which the messages can be lost

123
00:13:41,210 --> 00:13:43,090
 and can be arbitrarily delayed,

124
00:13:43,090 --> 00:13:48,290
 the two generals can agree on the time to attack.

125
00:13:48,290 --> 00:13:52,850
 Why don't you take, you know, a few seconds,

126
00:13:52,850 --> 00:13:54,770
 maybe half a minute?

127
00:13:55,770 --> 00:13:59,210
 To think about this problem.

128
00:13:59,210 --> 00:14:03,050
 And during this time, I'll get some other.

129
00:14:03,050 --> 00:14:05,290
 (clicking)

130
00:14:05,290 --> 00:14:07,530
 (clicking)

131
00:14:34,650 --> 00:14:36,130
 Okay, any idea?

132
00:14:36,130 --> 00:14:51,770
 Yes, there is always a final message required, Allison,

133
00:14:51,770 --> 00:14:54,650
 answer, there is always a final message required

134
00:14:54,650 --> 00:14:55,810
 to terminate the protocol,

135
00:14:55,810 --> 00:14:58,170
 and if that message is delayed or does not arrive,

136
00:14:58,170 --> 00:14:59,690
 the protocol cannot terminate.

137
00:14:59,690 --> 00:15:01,930
 (clicking)

138
00:15:01,930 --> 00:15:10,930
 Okay, yeah, this is a pretty good answer.

139
00:15:10,930 --> 00:15:15,370
 Anyone wants to chime in?

140
00:15:15,370 --> 00:15:28,610
 So the more formal proof is the following.

141
00:15:29,610 --> 00:15:34,610
 Assume that the protocol, a protocol exists,

142
00:15:34,610 --> 00:15:43,610
 and assume that the protocol has m messages, right?

143
00:15:43,610 --> 00:15:48,570
 Any protocol has to terminate, right?

144
00:15:48,570 --> 00:15:52,930
 So it must have a finite number of messages, right?

145
00:15:52,930 --> 00:15:54,930
 Otherwise, if it never terminates,

146
00:15:54,930 --> 00:15:57,090
 the general by definition will never agree.

147
00:15:57,090 --> 00:16:01,650
 But now think about the last message.

148
00:16:01,650 --> 00:16:09,410
 I am sending the last message to you, so you want to agree.

149
00:16:09,410 --> 00:16:14,490
 So I send the message, but that's the last message.

150
00:16:14,490 --> 00:16:18,130
 And I have no idea whether that message

151
00:16:18,130 --> 00:16:22,970
 was received by you or it wasn't received by you.

152
00:16:25,130 --> 00:16:29,410
 So from my perspective, that message, it's useless.

153
00:16:29,410 --> 00:16:33,810
 Okay?

154
00:16:33,810 --> 00:16:36,810
 And it shouldn't be needed for the agreement.

155
00:16:36,810 --> 00:16:39,410
 Okay?

156
00:16:39,410 --> 00:16:42,090
 So then this means that the protocol

157
00:16:42,090 --> 00:16:44,250
 doesn't have a messages.

158
00:16:44,250 --> 00:16:47,930
 It's, you know, it's a protocol with m minus 1 messages

159
00:16:47,930 --> 00:16:49,290
 is going to be good enough.

160
00:16:49,290 --> 00:16:52,810
 Okay?

161
00:16:54,010 --> 00:16:56,650
 But then you go, so now the protocol

162
00:16:56,650 --> 00:16:59,330
 has m minus 1 messages, right?

163
00:16:59,330 --> 00:17:03,090
 And you kind of go recursively because now m minus 1,

164
00:17:03,090 --> 00:17:06,330
 the last message doesn't have any value for you.

165
00:17:06,330 --> 00:17:08,210
 So it should be m minus 2 messages.

166
00:17:08,210 --> 00:17:10,050
 Okay?

167
00:17:10,050 --> 00:17:16,610
 So that's kind of the way to think about it.

168
00:17:16,610 --> 00:17:21,170
 But yes, it's, Allison, it's correct.

169
00:17:21,170 --> 00:17:23,290
 It's about thinking about the last message.

170
00:17:23,890 --> 00:17:24,730
 Right?

171
00:17:24,730 --> 00:17:28,650
 So there always the last message for the person

172
00:17:28,650 --> 00:17:30,650
 who is going to send it, it's useless

173
00:17:30,650 --> 00:17:33,370
 because they don't know whether it was received or not

174
00:17:33,370 --> 00:17:34,410
 by the other party.

175
00:17:34,410 --> 00:17:39,330
 So now this is a hard problem, right?

176
00:17:39,330 --> 00:17:41,690
 It's really hard problem.

177
00:17:41,690 --> 00:17:48,010
 And of course, in real life, you can use other things,

178
00:17:48,010 --> 00:17:50,250
 but how do we get out of it?

179
00:17:50,250 --> 00:17:51,090
 Right?

180
00:17:51,090 --> 00:17:56,090
 Because we still need different parties to agree

181
00:17:56,090 --> 00:18:02,730
 to build any useful applications, right?

182
00:18:02,730 --> 00:18:07,530
 And this is where it comes,

183
00:18:07,530 --> 00:18:12,530
 the two-phase commit protocol.

184
00:18:12,530 --> 00:18:18,930
 Because we cannot solve this general problem

185
00:18:18,930 --> 00:18:23,930
 or general paradox, we solve a related problem.

186
00:18:23,930 --> 00:18:28,290
 Before going here, any questions so far

187
00:18:28,290 --> 00:18:31,330
 about the general paradox, the general problem?

188
00:18:31,330 --> 00:18:36,610
 Okay.

189
00:18:36,610 --> 00:18:46,970
 So the way to do so is that,

190
00:18:48,530 --> 00:18:50,890
 to get around the problem is that,

191
00:18:50,890 --> 00:18:53,730
 and now the challenges of the general paradox,

192
00:18:53,730 --> 00:18:57,530
 is that you still have the same problem,

193
00:18:57,530 --> 00:19:03,890
 which you have more than one parties agree on something,

194
00:19:03,890 --> 00:19:12,410
 but you remove that time during which they must agree.

195
00:19:16,450 --> 00:19:19,690
 So you basically say there are no constraints on time,

196
00:19:19,690 --> 00:19:23,090
 they just eventually will happen, eventually will agree.

197
00:19:23,090 --> 00:19:26,970
 Right?

198
00:19:26,970 --> 00:19:29,250
 So that's kind of the big deal.

199
00:19:29,250 --> 00:19:32,530
 And this is a two-phase commit protocol.

200
00:19:32,530 --> 00:19:37,490
 It was developed by Jim Gray, who has huge influences.

201
00:19:37,490 --> 00:19:41,170
 He was the first Berkeley PhD student,

202
00:19:41,170 --> 00:19:44,130
 computer science PhD in '69,

203
00:19:44,130 --> 00:19:49,130
 and has a huge impact on databases.

204
00:19:49,130 --> 00:19:54,410
 And many important database breakthroughs

205
00:19:54,410 --> 00:19:56,930
 are going back to Jim.

206
00:19:56,930 --> 00:20:00,170
 Unfortunately, he disappeared several years back

207
00:20:00,170 --> 00:20:01,170
 while sailing.

208
00:20:01,170 --> 00:20:07,170
 So what is a two-phase commit protocol?

209
00:20:07,170 --> 00:20:08,340
 commit protocol is very simple.

210
00:20:08,340 --> 00:20:12,300
 First of all, you do have a persistent storage,

211
00:20:12,300 --> 00:20:14,000
 so you can save the state.

212
00:20:14,000 --> 00:20:18,820
 And then you have two phases,

213
00:20:18,820 --> 00:20:21,040
 prepare phase and commit phase.

214
00:20:21,040 --> 00:20:27,000
 Also, not all members are equal.

215
00:20:27,000 --> 00:20:31,580
 You have a coordinator and you have a bunch of workers.

216
00:20:31,580 --> 00:20:34,540
 And the coordinator executes a protocol.

217
00:20:34,540 --> 00:20:39,540
 It basically sends to every worker a message,

218
00:20:39,540 --> 00:20:45,060
 basically asking to agree with something

219
00:20:45,060 --> 00:20:49,260
 or not agree.

220
00:20:49,260 --> 00:20:55,460
 If every worker responds that they agreed,

221
00:20:55,460 --> 00:21:02,340
 the coordinator is going to tell in the commit phase,

222
00:21:04,300 --> 00:21:05,700
 all the workers to commit.

223
00:21:05,700 --> 00:21:12,060
 If at least one worker says abort,

224
00:21:12,060 --> 00:21:16,180
 then all the workers will abort

225
00:21:16,180 --> 00:21:20,660
 and that entire operation is aborted.

226
00:21:20,660 --> 00:21:25,100
 So again, to take a step back here,

227
00:21:25,100 --> 00:21:29,300
 we want here that another way to think about

228
00:21:29,300 --> 00:21:33,920
 it's all workers, they must execute an operation.

229
00:21:34,920 --> 00:21:37,320
 Is that all of them execute the operation

230
00:21:37,320 --> 00:21:39,360
 or none of them execute the operation?

231
00:21:39,360 --> 00:21:43,840
 In the case of databases, that operation is a transaction.

232
00:21:43,840 --> 00:21:50,100
 So is that all of them execute transaction

233
00:21:50,100 --> 00:21:51,040
 or none of them?

234
00:21:51,040 --> 00:21:55,440
 So if all of them are ready,

235
00:21:55,440 --> 00:21:57,320
 are they going to execute the transaction,

236
00:21:57,320 --> 00:22:00,280
 say we are ready,

237
00:22:00,280 --> 00:22:05,280
 we then coordinate, they sent that to coordinator,

238
00:22:05,280 --> 00:22:07,360
 the coordinator will send back commit.

239
00:22:07,360 --> 00:22:11,540
 So everyone will commit the transaction.

240
00:22:11,540 --> 00:22:16,900
 Otherwise, the coordinator will send abort

241
00:22:16,900 --> 00:22:18,900
 and everyone will abort the transaction.

242
00:22:18,900 --> 00:22:22,480
 Make sense?

243
00:22:22,480 --> 00:22:27,080
 And like you'll see,

244
00:22:27,080 --> 00:22:30,640
 the logs will be fundamental to guarantee

245
00:22:30,640 --> 00:22:32,960
 that this protocol is going to work correctly,

246
00:22:32,960 --> 00:22:36,840
 which means that either all workers commit

247
00:22:36,840 --> 00:22:38,200
 or abort the transaction.

248
00:22:38,200 --> 00:22:47,400
 So again, you have one coordinator in summary,

249
00:22:47,400 --> 00:22:49,480
 you have N workers,

250
00:22:49,480 --> 00:22:51,360
 the high level algorithms is the following,

251
00:22:51,360 --> 00:22:55,200
 the coordinator asks all workers if they can commit.

252
00:22:55,200 --> 00:22:59,560
 If all workers reply, yes, we can commit,

253
00:22:59,560 --> 00:23:03,040
 then the coordinator broke us to everyone commit.

254
00:23:03,040 --> 00:23:06,960
 Otherwise, the coordinator broke us abort

255
00:23:06,960 --> 00:23:11,320
 because there is at least one worker you cannot commit.

256
00:23:11,320 --> 00:23:15,000
 And the worker just obey these global messages

257
00:23:15,000 --> 00:23:16,600
 where there is commit and abort.

258
00:23:16,600 --> 00:23:18,840
 That's it.

259
00:23:18,840 --> 00:23:22,320
 And we use persistent log in order to make sure

260
00:23:22,320 --> 00:23:24,680
 that the protocol will work correctly

261
00:23:24,680 --> 00:23:26,220
 when machines fail.

262
00:23:26,220 --> 00:23:30,640
 Now, here we assume that the machine fails

263
00:23:30,640 --> 00:23:32,960
 is going to eventually come up,

264
00:23:32,960 --> 00:23:35,120
 look at the log and continue the protocol.

265
00:23:35,120 --> 00:23:42,320
 But again, we don't put any bound

266
00:23:42,320 --> 00:23:47,320
 in terms of the time that this protocol it takes to finish.

267
00:23:51,600 --> 00:23:56,600
 So it's again, there are only two possible votes

268
00:23:56,600 --> 00:24:02,040
 a worker can make and can do, commit and abort.

269
00:24:02,040 --> 00:24:07,560
 And commit, it only happens if anonymously

270
00:24:07,560 --> 00:24:09,000
 everyone says commit.

271
00:24:09,000 --> 00:24:18,480
 So in the previous slide,

272
00:24:18,480 --> 00:24:23,480
 in the preparing phase, you remember the preparing phase

273
00:24:23,480 --> 00:24:29,680
 is a phase in which the coordinator asks every worker

274
00:24:29,680 --> 00:24:34,440
 whether they can commit or they are going to,

275
00:24:34,440 --> 00:24:35,280
 they can commit.

276
00:24:35,280 --> 00:24:43,280
 If a worker says that it can commit,

277
00:24:43,280 --> 00:24:48,280
 then it can do that only if it should commit.

278
00:24:48,320 --> 00:24:52,320
 And it's also to ensure that can accept the transaction.

279
00:24:52,320 --> 00:24:58,560
 And this assurance, this vote must be recorded

280
00:24:58,560 --> 00:25:00,360
 in the stable log.

281
00:25:00,360 --> 00:25:08,120
 If the worker votes abort, it must guarantee

282
00:25:08,120 --> 00:25:12,680
 that it will never accept the transaction.

283
00:25:12,680 --> 00:25:16,520
 And this is also going to be recorded in the log.

284
00:25:17,520 --> 00:25:22,520
 And finishing, it's all the machines have agreed to commit.

285
00:25:22,520 --> 00:25:26,920
 Then if all the machines have agreed to commit,

286
00:25:26,920 --> 00:25:33,360
 you record the decisions to commit in the local log.

287
00:25:33,360 --> 00:25:35,720
 And this is for the coordinator.

288
00:25:35,720 --> 00:25:39,360
 And then the coordinator inform every voter to commit.

289
00:25:39,360 --> 00:25:44,360
 Otherwise the coordinator logs the decision

290
00:25:45,880 --> 00:25:50,080
 to abort and send the rest abort to every worker.

291
00:25:50,080 --> 00:25:56,960
 The machines remember the workers from the previous slide,

292
00:25:56,960 --> 00:25:59,200
 they cannot take back its decision.

293
00:25:59,200 --> 00:26:05,080
 So we are guaranteed that exactly one of this will happen.

294
00:26:05,080 --> 00:26:09,480
 So basically if a worker says,

295
00:26:09,480 --> 00:26:11,080
 I can commit this transaction,

296
00:26:11,080 --> 00:26:15,080
 it cannot let later say I cannot accept the transaction.

297
00:26:16,080 --> 00:26:19,080
 And the other way, if the worker says,

298
00:26:19,080 --> 00:26:22,040
 I abort this transaction, it cannot later say,

299
00:26:22,040 --> 00:26:24,880
 oh, I changed my mind, I am committing this transaction.

300
00:26:24,880 --> 00:26:30,640
 Here is another way to look at the algorithms.

301
00:26:30,640 --> 00:26:35,480
 You have coordinator on the left, worker on the right.

302
00:26:35,480 --> 00:26:38,720
 The coordinator sends vote request to all the workers.

303
00:26:40,200 --> 00:26:45,080
 The workers are waiting for this vote request message.

304
00:26:45,080 --> 00:26:47,600
 If they are ready,

305
00:26:47,600 --> 00:26:50,760
 they are going to send to vote commit to coordinator.

306
00:26:50,760 --> 00:26:52,680
 So this means that they can commit.

307
00:26:52,680 --> 00:26:57,680
 Otherwise they send vote abort and are going to abort.

308
00:26:57,680 --> 00:27:04,880
 The coordinator collects all the votes.

309
00:27:04,880 --> 00:27:07,160
 If all the votes are commit,

310
00:27:07,160 --> 00:27:09,000
 they send the global commit.

311
00:27:09,880 --> 00:27:12,720
 If at least the vote is abort,

312
00:27:12,720 --> 00:27:19,040
 then the coordinator sends abort to every other worker.

313
00:27:19,040 --> 00:27:29,040
 And if the worker then receives global commits

314
00:27:29,040 --> 00:27:31,520
 and commits, otherwise they abort.

315
00:27:31,520 --> 00:27:33,720
 Any questions here?

316
00:27:33,720 --> 00:27:36,240
 Pretty simple problem, right?

317
00:27:36,240 --> 00:27:38,400
 (silence)

318
00:27:38,400 --> 00:27:48,120
 Okay.

319
00:27:48,120 --> 00:27:51,440
 So now, although despite the fact

320
00:27:51,440 --> 00:27:55,280
 that this protocol is simple, it's yeah.

321
00:27:55,280 --> 00:27:56,840
 Okay.

322
00:27:56,840 --> 00:27:57,840
 Two questions.

323
00:27:57,840 --> 00:28:03,240
 Allison question is that,

324
00:28:03,240 --> 00:28:05,840
 so it's okay if the algorithm stands forever.

325
00:28:06,840 --> 00:28:10,560
 In theory, theoretically it can hang.

326
00:28:10,560 --> 00:28:12,360
 It can take forever.

327
00:28:12,360 --> 00:28:15,880
 I'll show you how later.

328
00:28:15,880 --> 00:28:19,760
 Actually, let me give you an example.

329
00:28:19,760 --> 00:28:22,440
 One example in which you can hang forever

330
00:28:22,440 --> 00:28:27,440
 is that a machine fails before getting the global commit.

331
00:28:27,440 --> 00:28:35,040
 It says commit everything,

332
00:28:35,040 --> 00:28:37,240
 everyone votes for commit.

333
00:28:37,240 --> 00:28:39,760
 And the coordinator is going to send everyone commit.

334
00:28:39,760 --> 00:28:43,960
 But that machine or the coordinator,

335
00:28:43,960 --> 00:28:47,960
 the coordinator gets, let's do this example.

336
00:28:47,960 --> 00:28:50,320
 The coordinator collects all the votes.

337
00:28:50,320 --> 00:28:56,240
 But before, and write the result of the vote.

338
00:28:56,240 --> 00:28:59,520
 But before going,

339
00:29:00,640 --> 00:29:05,200
 replying with a global message

340
00:29:05,200 --> 00:29:08,840
 or sending a global message to every worker, it fails.

341
00:29:08,840 --> 00:29:12,560
 Now we come back,

342
00:29:12,560 --> 00:29:15,360
 we're looking at the global storage,

343
00:29:15,360 --> 00:29:18,640
 is a log that it has,

344
00:29:18,640 --> 00:29:21,520
 as a result of the vote, says commit.

345
00:29:21,520 --> 00:29:23,240
 But before again,

346
00:29:23,240 --> 00:29:27,120
 can has a chance to send a global commit, fails again.

347
00:29:28,080 --> 00:29:31,280
 So this can happen indefinitely, right?

348
00:29:31,280 --> 00:29:33,120
 For the coordinator.

349
00:29:33,120 --> 00:29:35,480
 Come up, see the results of the vote.

350
00:29:35,480 --> 00:29:39,080
 But before has a chance to broadcast

351
00:29:39,080 --> 00:29:41,760
 the global message to everyone, fails again.

352
00:29:41,760 --> 00:29:46,320
 Now, this is unlikely to happen.

353
00:29:46,320 --> 00:29:49,680
 So in life, everything is probabilistic, right?

354
00:29:49,680 --> 00:29:52,880
 So the probability for this to happen every time

355
00:29:52,880 --> 00:29:53,960
 is extremely low,

356
00:29:53,960 --> 00:29:58,960
 unless there is some persistent bug in the program.

357
00:29:58,960 --> 00:30:02,680
 Okay.

358
00:30:02,680 --> 00:30:09,760
 Since messages are unreliable, does the worker...

359
00:30:09,760 --> 00:30:13,830
 is the next question from Michael.

360
00:30:13,830 --> 00:30:15,910
 Since messages are unreliable,

361
00:30:15,910 --> 00:30:17,910
 does a worker keep sending his vote

362
00:30:17,910 --> 00:30:20,030
 until it gets a global procedure?

363
00:30:20,030 --> 00:30:28,270
 Yes, the workers can do that,

364
00:30:28,270 --> 00:30:33,270
 but if the messages are unreliable,

365
00:30:33,270 --> 00:30:37,230
 the coordinator, like we will see next,

366
00:30:37,230 --> 00:30:42,230
 if the coordinator didn't hear from the worker

367
00:30:42,230 --> 00:30:47,110
 for some time, the timeout,

368
00:30:47,110 --> 00:30:52,110
 then he can declare that the worker

369
00:30:52,110 --> 00:30:55,990
 who is not able to accept the transaction

370
00:30:55,990 --> 00:31:01,110
 and is going to log the result of the vote as being abort

371
00:31:01,110 --> 00:31:02,830
 and ask everyone else to abort.

372
00:31:02,830 --> 00:31:06,550
 That protocol is still caught.

373
00:31:06,550 --> 00:31:11,550
 What about when the worker doesn't hear from the coordinator?

374
00:31:11,550 --> 00:31:23,390
 So, in that particular case,

375
00:31:23,390 --> 00:31:28,390
 the worker has to wait for the protocol to be correct

376
00:31:28,390 --> 00:31:33,750
 because the worker doesn't know whether,

377
00:31:33,750 --> 00:31:35,150
 especially for a worker,

378
00:31:35,150 --> 00:31:37,510
 I hear you are talking about a worker

379
00:31:37,510 --> 00:31:39,270
 who said that it can commit.

380
00:31:39,270 --> 00:31:44,510
 We cannot finish the protocol

381
00:31:44,510 --> 00:31:48,990
 until it gets a message from the coordinator

382
00:31:48,990 --> 00:31:52,430
 because it doesn't know what to do.

383
00:31:52,430 --> 00:31:55,030
 It doesn't know whether the vote is commit or abort.

384
00:31:55,030 --> 00:32:02,390
 Yeah, so in this case, you have to ask to retransmit.

385
00:32:04,310 --> 00:32:08,110
 The coordinator for to retransmit is a global commit

386
00:32:08,110 --> 00:32:08,950
 or global abort.

387
00:32:08,950 --> 00:32:17,910
 But it's again, the probability this to happen is very low.

388
00:32:17,910 --> 00:32:22,910
 And in practice, it's working.

389
00:32:22,910 --> 00:32:24,430
 It's a very good protocol.

390
00:32:24,430 --> 00:32:32,190
 We'll go through a little bit of these questions next.

391
00:32:32,190 --> 00:32:34,710
 So, here is a failure-free example.

392
00:32:34,710 --> 00:32:37,110
 This is a timeline on the horizontal axis.

393
00:32:37,110 --> 00:32:39,350
 You have one coordinator, three workers.

394
00:32:39,350 --> 00:32:41,790
 The coordinator sends vote requests.

395
00:32:41,790 --> 00:32:44,990
 Then, say every worker sends vote commit,

396
00:32:44,990 --> 00:32:48,150
 and then the coordinator sends global commit.

397
00:32:48,150 --> 00:32:50,590
 Very simple, no failures.

398
00:32:50,590 --> 00:32:51,430
 Easy.

399
00:32:51,430 --> 00:32:54,830
 Remember, you are discussing in these protocols,

400
00:32:54,830 --> 00:32:56,910
 you have a state machine.

401
00:32:56,910 --> 00:32:59,310
 This is a coordinator state machine.

402
00:32:59,310 --> 00:33:02,670
 You are in a unique state, you receive start.

403
00:33:02,670 --> 00:33:04,030
 When you receive start, the next thing

404
00:33:04,030 --> 00:33:06,750
 what you are going to do, a coordinator, what it is.

405
00:33:06,750 --> 00:33:08,190
 You send the vote request.

406
00:33:08,190 --> 00:33:09,910
 When you send the vote request,

407
00:33:09,910 --> 00:33:12,670
 you go to a different state because you need to wait

408
00:33:12,670 --> 00:33:15,190
 for the votes from the workers.

409
00:33:15,190 --> 00:33:17,790
 Okay?

410
00:33:17,790 --> 00:33:20,870
 So, you receive all vote commits, right?

411
00:33:20,870 --> 00:33:22,830
 And if you receive all votes commits,

412
00:33:22,830 --> 00:33:25,670
 now you are going to go into different,

413
00:33:25,670 --> 00:33:27,110
 you are going to record.

414
00:33:27,110 --> 00:33:30,270
 Now, this is the result of the vote is commit.

415
00:33:30,270 --> 00:33:32,270
 And you send the global commit,

416
00:33:32,270 --> 00:33:35,310
 and now you go to the commit, the commit state.

417
00:33:35,310 --> 00:33:38,830
 Right?

418
00:33:38,830 --> 00:33:43,830
 Otherwise, you log the results of the vote as being abort,

419
00:33:43,830 --> 00:33:49,190
 and go send a global abort and go into the abort state.

420
00:33:49,190 --> 00:33:52,830
 So, while you are in this state,

421
00:33:52,830 --> 00:33:56,750
 if the worker blows a message,

422
00:33:56,750 --> 00:33:58,790
 like we discussed earlier,

423
00:33:58,790 --> 00:34:02,950
 and wants to get,

424
00:34:02,950 --> 00:34:07,950
 sends a request for the coordinator

425
00:34:07,950 --> 00:34:10,270
 to resend the decision,

426
00:34:10,270 --> 00:34:12,510
 the coordinator knows exactly what to send

427
00:34:12,510 --> 00:34:16,190
 because based on what state it is, it's commit or abort.

428
00:34:16,190 --> 00:34:20,390
 The workers is similar.

429
00:34:20,390 --> 00:34:23,870
 State diagram, state machine.

430
00:34:23,870 --> 00:34:27,390
 It's again, it says, "init," I am in it,

431
00:34:27,390 --> 00:34:29,190
 and I'm starting.

432
00:34:29,190 --> 00:34:32,190
 In the init,

433
00:34:32,190 --> 00:34:35,990
 I am waiting for receiving the vote request.

434
00:34:35,990 --> 00:34:37,870
 And from here, from the vote request,

435
00:34:37,870 --> 00:34:39,430
 I can do two things.

436
00:34:39,430 --> 00:34:42,230
 I can say, I want to abort,

437
00:34:42,230 --> 00:34:45,830
 case in which I am going directly into the abort state

438
00:34:45,830 --> 00:34:48,990
 and I'm sending vote abort,

439
00:34:48,990 --> 00:34:51,350
 or I'm going to go to commit.

440
00:34:53,390 --> 00:34:55,950
 And then I'm going to vote to commit.

441
00:34:55,950 --> 00:35:01,190
 Then I'm going to go to the, in the ready state,

442
00:35:01,190 --> 00:35:02,310
 I'm ready to commit.

443
00:35:02,310 --> 00:35:05,510
 And here I'm going to wait for what?

444
00:35:05,510 --> 00:35:08,110
 To receive either global abort or global commit.

445
00:35:08,110 --> 00:35:09,670
 I'm going to receive global abort.

446
00:35:09,670 --> 00:35:11,630
 I'm going to go to abort state.

447
00:35:11,630 --> 00:35:13,190
 I'm going to receive a global commit.

448
00:35:13,190 --> 00:35:15,110
 I'm going to go to the commit state.

449
00:35:20,550 --> 00:35:24,950
 So, let's see dealing first with worker failures.

450
00:35:24,950 --> 00:35:29,390
 So when I can be affected, if I am the coordinator,

451
00:35:29,390 --> 00:35:32,230
 when can I be affected about a failure?

452
00:35:32,230 --> 00:35:37,310
 It's really only when I am waiting for something

453
00:35:37,310 --> 00:35:38,750
 with the wait state,

454
00:35:38,750 --> 00:35:42,990
 because for init, I'm just sending a vote request.

455
00:35:42,990 --> 00:35:46,590
 And for commit and abort,

456
00:35:46,590 --> 00:35:51,590
 I just send the transition to go to the states

457
00:35:51,590 --> 00:35:53,510
 by sending a message.

458
00:35:53,510 --> 00:35:55,950
 So here I am, when as a coordinator,

459
00:35:55,950 --> 00:35:58,710
 I'm going to be impacted when I'm in the wait state.

460
00:35:58,710 --> 00:36:00,870
 Okay.

461
00:36:00,870 --> 00:36:06,590
 So in wait, if it doesn't receive N votes,

462
00:36:06,590 --> 00:36:08,910
 like I mentioned, you can timeout,

463
00:36:08,910 --> 00:36:11,350
 the coordinator will timeout and send global abort.

464
00:36:11,350 --> 00:36:13,310
 This will work perfectly fine.

465
00:36:13,310 --> 00:36:14,230
 It will be correct.

466
00:36:14,230 --> 00:36:16,270
 Right?

467
00:36:17,270 --> 00:36:20,350
 So here is what the examples.

468
00:36:20,350 --> 00:36:23,350
 Coordinator send vote requests,

469
00:36:23,350 --> 00:36:27,670
 but somehow worker three didn't send vote commit.

470
00:36:27,670 --> 00:36:29,310
 What is the message of the most?

471
00:36:29,310 --> 00:36:36,110
 So coordinator waits for some time

472
00:36:36,110 --> 00:36:40,830
 to get the commit, the vote from worker three.

473
00:36:40,830 --> 00:36:45,590
 But if he doesn't get it, when the timeout expires,

474
00:36:45,590 --> 00:36:50,590
 he sends global abort to all workers.

475
00:36:50,590 --> 00:36:52,150
 Okay.

476
00:36:52,150 --> 00:36:53,310
 And that's ended.

477
00:36:53,310 --> 00:37:00,950
 Now let's look at the coordinator failures.

478
00:37:00,950 --> 00:37:06,270
 When you can be impacted as a worker,

479
00:37:06,270 --> 00:37:08,830
 it's again, you are impacted by the failures

480
00:37:08,830 --> 00:37:12,870
 when you are waiting for something from the party,

481
00:37:12,870 --> 00:37:14,430
 which can fail.

482
00:37:14,430 --> 00:37:17,750
 And you are waiting as a worker from coordinators

483
00:37:17,750 --> 00:37:22,030
 for two messages, vote request, this is in any state,

484
00:37:22,030 --> 00:37:25,070
 and global commit or global abort.

485
00:37:25,070 --> 00:37:27,590
 So here where you can be affected.

486
00:37:27,590 --> 00:37:30,190
 So here you need to look at, right?

487
00:37:30,190 --> 00:37:35,990
 And now this is the answer I gave to the question

488
00:37:35,990 --> 00:37:37,950
 of what happens on coordinator fails.

489
00:37:37,950 --> 00:37:42,870
 So if coordinator fails, worker must block waiting

490
00:37:42,870 --> 00:37:47,150
 for the coordinator to recover and send the global message.

491
00:37:47,150 --> 00:37:49,510
 Right?

492
00:37:49,510 --> 00:37:54,310
 Like we discussed before, the worker has no choice

493
00:37:54,310 --> 00:37:56,590
 but to wait for coordinator.

494
00:37:56,590 --> 00:38:03,030
 Anyway, so let's see as a failure happening in it,

495
00:38:03,030 --> 00:38:08,030
 the coordinators somehow doesn't send the vote requests

496
00:38:08,030 --> 00:38:11,910
 because it fails before the vote request is sent out.

497
00:38:11,910 --> 00:38:16,190
 The workers will timeout and they can now send vote abort.

498
00:38:16,190 --> 00:38:18,110
 They can timeout and send vote abort.

499
00:38:18,110 --> 00:38:22,190
 Now you are in the ready state.

500
00:38:22,190 --> 00:38:25,790
 In the ready state a worker waits for the global messages.

501
00:38:25,790 --> 00:38:33,430
 Okay, so vote request, and somehow you have vote request,

502
00:38:33,430 --> 00:38:37,870
 vote commit, but now the coordinator failed.

503
00:38:39,710 --> 00:38:43,030
 So now the worker in this case have to wait

504
00:38:43,030 --> 00:38:45,390
 for the coordinator to restart

505
00:38:45,390 --> 00:38:49,870
 and to send the global abort in this case.

506
00:38:49,870 --> 00:38:54,870
 And in this example, and only then they can finish.

507
00:38:54,870 --> 00:38:58,790
 Okay.

508
00:38:58,790 --> 00:39:07,150
 But it's again, the reason for the worker,

509
00:39:07,150 --> 00:39:10,550
 why the worker needs to wait for the coordinator,

510
00:39:10,550 --> 00:39:11,750
 it's again, it's very simple

511
00:39:11,750 --> 00:39:14,830
 because if the worker decides, he says, I can commit,

512
00:39:14,830 --> 00:39:20,270
 he doesn't know what to do

513
00:39:20,270 --> 00:39:22,470
 because the both choices are valid.

514
00:39:22,470 --> 00:39:27,230
 He either has to abort or he has to commit.

515
00:39:27,230 --> 00:39:31,110
 And he must know exactly what has to be done, has to do

516
00:39:31,110 --> 00:39:34,110
 because he has to be consistent.

517
00:39:34,110 --> 00:39:36,110
 The decision has to be the same decision

518
00:39:36,110 --> 00:39:37,670
 as all the other workers.

519
00:39:37,670 --> 00:39:48,630
 So obviously you need to keep the lock in a stable storage.

520
00:39:48,630 --> 00:39:49,990
 You need to provide your ability

521
00:39:49,990 --> 00:39:54,990
 so when the coordinator or say he's going to restart,

522
00:39:54,990 --> 00:39:59,630
 he's going to find the state,

523
00:39:59,630 --> 00:40:02,830
 the accurate state in the stable storage.

524
00:40:02,830 --> 00:40:05,550
 Okay.

525
00:40:05,550 --> 00:40:08,830
 So that's basically what it is.

526
00:40:08,830 --> 00:40:12,070
 And open recovery, you have the set of rules.

527
00:40:12,680 --> 00:40:14,720
 if the coordinator recovers a board,

528
00:40:14,720 --> 00:40:18,160
 if it's in the init, wait or abort state,

529
00:40:18,160 --> 00:40:19,400
 the coordinator commits,

530
00:40:19,400 --> 00:40:21,560
 he sees the commit state, right?

531
00:40:21,560 --> 00:40:23,200
 So if they have, right?

532
00:40:23,200 --> 00:40:27,440
 The worker aborts, if it's in init and abort state,

533
00:40:27,440 --> 00:40:29,080
 and commits in the commit state.

534
00:40:29,080 --> 00:40:31,680
 And if it's a coordinator,

535
00:40:31,680 --> 00:40:33,080
 if the worker is in ready,

536
00:40:33,080 --> 00:40:35,080
 so he's asking for,

537
00:40:35,080 --> 00:40:38,120
 which is exactly the question we had before,

538
00:40:38,120 --> 00:40:41,320
 if the worker is in the ready state,

539
00:40:41,320 --> 00:40:43,040
 when it fails and it comes back

540
00:40:43,040 --> 00:40:45,440
 and you see how it was in the ready state,

541
00:40:45,440 --> 00:40:48,320
 it has to ask again,

542
00:40:48,320 --> 00:40:51,120
 the coordinator whether to commit or to abort.

543
00:40:51,120 --> 00:40:54,960
 Any questions?

544
00:41:09,040 --> 00:41:13,600
 Okay, so Miles asks the following question,

545
00:41:13,600 --> 00:41:17,040
 if only one global commit message

546
00:41:17,040 --> 00:41:20,080
 from the coordinator to worker fails,

547
00:41:20,080 --> 00:41:21,280
 we'd be in trouble.

548
00:41:21,280 --> 00:41:25,760
 Yeah, so let's see what happens.

549
00:41:25,760 --> 00:41:30,760
 So assume that the worker,

550
00:41:30,760 --> 00:41:34,040
 so the coordinator said again,

551
00:41:34,040 --> 00:41:35,480
 in the previous example,

552
00:41:35,480 --> 00:41:37,240
 we had three workers.

553
00:41:37,240 --> 00:41:39,960
 So assume that two messages gets through,

554
00:41:39,960 --> 00:41:41,720
 but one global message,

555
00:41:41,720 --> 00:41:43,880
 global commit message doesn't get through.

556
00:41:43,880 --> 00:41:48,040
 Say third worker didn't get it.

557
00:41:48,040 --> 00:41:49,560
 What will happen in that case?

558
00:41:49,560 --> 00:41:55,720
 What do you think it should happen?

559
00:41:55,720 --> 00:41:57,000
 If you design the protocol,

560
00:41:57,000 --> 00:41:58,080
 implement the protocol,

561
00:41:58,080 --> 00:41:58,920
 what do you do?

562
00:41:58,920 --> 00:42:02,000
 What do you think we should do?

563
00:42:06,160 --> 00:42:08,320
 Third worker blocks for how long?

564
00:42:08,320 --> 00:42:21,240
 A certain amount of time,

565
00:42:21,240 --> 00:42:22,920
 or that amount of time expires,

566
00:42:22,920 --> 00:42:24,120
 what you are going to do.

567
00:42:24,120 --> 00:42:32,240
 If you are to implement it.

568
00:42:32,240 --> 00:42:37,240
 So what is the natural thing to do?

569
00:42:37,240 --> 00:42:43,600
 Maybe it wasn't in the previous diagrams,

570
00:42:43,600 --> 00:42:45,400
 but that is the natural thing to do.

571
00:42:45,400 --> 00:42:49,560
 I don't know as a coordinator,

572
00:42:49,560 --> 00:42:52,640
 decide it, what I'm going to do.

573
00:42:52,640 --> 00:43:00,720
 Don't do anything, you are blocked.

574
00:43:01,720 --> 00:43:03,440
 But what else can you do?

575
00:43:03,440 --> 00:43:05,040
 That's something you can do that.

576
00:43:05,040 --> 00:43:06,360
 No, don't ask it.

577
00:43:06,360 --> 00:43:09,440
 It's a valid option.

578
00:43:09,440 --> 00:43:16,120
 Another thing you can do

579
00:43:16,120 --> 00:43:18,160
 is ask against the coordinator.

580
00:43:18,160 --> 00:43:19,880
 That's good action, yes.

581
00:43:19,880 --> 00:43:21,600
 You can ask against the coordinator

582
00:43:21,600 --> 00:43:23,920
 what you decide, that's correct.

583
00:43:23,920 --> 00:43:25,040
 That's what you'll do

584
00:43:25,040 --> 00:43:27,680
 if you implement this protocol.

585
00:43:27,680 --> 00:43:32,680
 Okay, so let's go for,

586
00:43:32,680 --> 00:43:36,280
 have this short discussion.

587
00:43:36,280 --> 00:43:42,280
 So why do you need DCBC decision-making?

588
00:43:42,280 --> 00:43:48,160
 Well, you need it because you want

589
00:43:48,160 --> 00:43:50,560
 in four different programs,

590
00:43:50,560 --> 00:43:52,720
 you want different parts of the program

591
00:43:52,720 --> 00:43:55,280
 which run on different machines to agree.

592
00:43:55,280 --> 00:43:58,880
 A very simple example is that you want

593
00:43:58,880 --> 00:44:02,160
 to replicate the state for durability

594
00:44:02,160 --> 00:44:04,560
 on different machines, right?

595
00:44:04,560 --> 00:44:09,560
 So you need, for instance, that's one example.

596
00:44:22,880 --> 00:44:25,880
 And by the way, a group of machines can come to a decision

597
00:44:25,880 --> 00:44:28,760
 if any one or more of them fail during the process, right?

598
00:44:28,760 --> 00:44:32,320
 In that particular case, if some process fails,

599
00:44:32,320 --> 00:44:36,200
 the other can still come to a decision, right?

600
00:44:36,200 --> 00:44:39,280
 Because they are okay to record,

601
00:44:39,280 --> 00:44:41,080
 say to commit the transaction.

602
00:44:41,080 --> 00:44:44,000
 So if the third worker fails,

603
00:44:44,000 --> 00:44:47,960
 two can still commit the transaction.

604
00:44:47,960 --> 00:44:51,400
 And maybe the other one, the third worker,

605
00:44:51,400 --> 00:44:55,400
 when it fails, it comes back and as a coordinator

606
00:44:55,400 --> 00:44:56,920
 and the coordinator says to commit

607
00:44:56,920 --> 00:44:59,760
 and it's going eventually also to commit the transaction.

608
00:44:59,760 --> 00:45:04,720
 So, and we said, we discussed that just to reemphasize

609
00:45:04,720 --> 00:45:07,760
 why 2PC is working and Generals Paradox doesn't,

610
00:45:07,760 --> 00:45:14,000
 is because 2PC relaxes the problem

611
00:45:14,000 --> 00:45:20,880
 in that it doesn't require the nodes to commit the transaction

612
00:45:20,880 --> 00:45:23,360
 and the nodes to agree by a certain time.

613
00:45:23,360 --> 00:45:28,640
 They only say that eventually there will be agreement.

614
00:45:28,640 --> 00:45:35,160
 And it also allows us, that's why, to reboot and continue.

615
00:45:35,160 --> 00:45:37,640
 Okay?

616
00:45:37,640 --> 00:45:45,080
 Announcements, homework five is due on Monday.

617
00:45:45,080 --> 00:45:48,480
 Midterm pre-grades will close on Sunday

618
00:45:49,880 --> 00:45:51,040
 by the end of the day.

619
00:45:51,040 --> 00:45:53,400
 Okay.

620
00:45:53,400 --> 00:45:57,080
 Any more questions about consensus,

621
00:45:57,080 --> 00:46:01,080
 General Paradox and the 2PC protocol?

622
00:46:01,080 --> 00:46:10,800
 Okay.

623
00:46:10,800 --> 00:46:14,120
 If not, we are really going to switch gears now.

624
00:46:14,120 --> 00:46:16,240
 And we are going to talk about networking.

625
00:46:16,240 --> 00:46:18,840
 Networking is obviously a fundamental part

626
00:46:18,840 --> 00:46:20,400
 of the operating system,

627
00:46:20,400 --> 00:46:23,400
 especially today where everything is connected.

628
00:46:23,400 --> 00:46:26,600
 Like we discussed so many times.

629
00:46:26,600 --> 00:46:32,800
 So here are the main concepts you need to keep in mind.

630
00:46:32,800 --> 00:46:36,960
 First is the network interfaces.

631
00:46:36,960 --> 00:46:40,200
 Each of your machines, the machines you are watching now

632
00:46:40,200 --> 00:46:45,520
 has a network card, some network or a network chip, right?

633
00:46:47,840 --> 00:46:51,640
 And that's a chip which communicates with the outside world,

634
00:46:51,640 --> 00:46:56,640
 sending physical signals, radio signals and so forth,

635
00:46:56,640 --> 00:46:59,760
 or signals through the wire.

636
00:46:59,760 --> 00:47:02,920
 Okay.

637
00:47:02,920 --> 00:47:04,400
 These are the physical, you know,

638
00:47:04,400 --> 00:47:05,840
 these are the network cards.

639
00:47:05,840 --> 00:47:10,080
 One computer can have multiple network cards

640
00:47:10,080 --> 00:47:14,320
 because a computer can communicate multiple ways.

641
00:47:16,920 --> 00:47:18,960
 Can you give examples about a few ways

642
00:47:18,960 --> 00:47:20,440
 the computer can communicate?

643
00:47:20,440 --> 00:47:29,760
 How can your computer communicate with some other computer?

644
00:47:29,760 --> 00:47:43,680
 Land, wireless optical copper.

645
00:47:43,680 --> 00:47:45,040
 This is good. This is good.

646
00:47:46,200 --> 00:47:48,360
 Right? Wireless, wifi, right?

647
00:47:48,360 --> 00:47:49,600
 Sounds is good.

648
00:47:49,600 --> 00:47:51,240
 It's a good one.

649
00:47:51,240 --> 00:47:53,000
 Bluetooth is another one.

650
00:47:53,000 --> 00:47:55,200
 Bluetooth, wifi and so forth, right?

651
00:47:55,200 --> 00:47:58,840
 Ethernet, you may have heard.

652
00:47:58,840 --> 00:48:01,240
 So therefore it's again,

653
00:48:01,240 --> 00:48:04,680
 one machine can have multiple cards.

654
00:48:04,680 --> 00:48:05,520
 Remember that.

655
00:48:05,520 --> 00:48:08,400
 That's network.

656
00:48:08,400 --> 00:48:14,800
 Okay.

657
00:48:14,800 --> 00:48:19,800
 So, typically each network card is associated two addresses.

658
00:48:19,800 --> 00:48:29,440
 One, it's a media access control address or MAC address.

659
00:48:29,440 --> 00:48:33,960
 This is a physical address.

660
00:48:33,960 --> 00:48:38,720
 And this is burned into the card

661
00:48:39,920 --> 00:48:44,920
 by the company which produces these cards.

662
00:48:44,920 --> 00:48:47,720
 So when a card was produced,

663
00:48:47,720 --> 00:48:50,000
 it comes with a MAC address.

664
00:48:50,000 --> 00:48:53,360
 Like we'll see it's 48 bits.

665
00:48:53,360 --> 00:48:56,480
 And then there is an IP address,

666
00:48:56,480 --> 00:49:00,000
 the internet protocol address.

667
00:49:00,000 --> 00:49:03,920
 And this is the address to which, you know,

668
00:49:03,920 --> 00:49:07,000
 when we send a packet, operating system sends a packet,

669
00:49:08,240 --> 00:49:11,600
 is going to send to one of these IP addresses,

670
00:49:11,600 --> 00:49:13,360
 not to the MAC address.

671
00:49:13,360 --> 00:49:16,120
 We'll learn more about how they bump to each other.

672
00:49:16,120 --> 00:49:18,800
 Okay.

673
00:49:18,800 --> 00:49:22,720
 So this is what you have.

674
00:49:22,720 --> 00:49:28,560
 MAC address, like I mentioned, is 48 bit unique identifier.

675
00:49:28,560 --> 00:49:30,920
 And it's assigned by the card vendor.

676
00:49:30,920 --> 00:49:37,760
 IP address used to be 32 bits.

677
00:49:38,760 --> 00:49:42,400
 It's assigned by the network administrator

678
00:49:42,400 --> 00:49:46,600
 or is dynamically when you connect to the network.

679
00:49:46,600 --> 00:49:54,560
 Typically today, almost everyone is dynamically connected.

680
00:49:54,560 --> 00:50:00,320
 Your laptop, your phone, when you get an IP address,

681
00:50:00,320 --> 00:50:02,120
 that's dynamically allocated to you.

682
00:50:02,120 --> 00:50:07,080
 Right, when you connect to wifi, that in a wifi network,

683
00:50:07,080 --> 00:50:10,160
 someone is, there is a process

684
00:50:10,160 --> 00:50:12,240
 by which you are going to get an IP address.

685
00:50:12,240 --> 00:50:14,520
 Without an IP address, you cannot communicate.

686
00:50:14,520 --> 00:50:42,520
 [ Silence ]

687
00:50:42,520 --> 00:50:23,850
 Right now with IPv6, you have 128 bits. That's the length of the address.

688
00:50:23,850 --> 00:50:33,850
 Then you have a connection. The connection happens between two processes.

689
00:50:33,850 --> 00:50:39,850
 Now, on one machine, you can have multiple processes.

690
00:50:39,850 --> 00:50:48,850
 One machine, you can identify it remotely by its IP address or a MAC address.

691
00:50:48,850 --> 00:50:58,850
 But how you are going to identify when you send a message that you want to send to a particular process out of many that are running on the same machine?

692
00:50:58,850 --> 00:51:04,850
 That is done using a port number. A port number is a 16-bit identifier.

693
00:51:04,850 --> 00:51:12,850
 It has a local scope to an operating system on which the process is running.

694
00:51:12,850 --> 00:51:15,850
 Local scope to the machine.

695
00:51:15,850 --> 00:51:20,850
 So therefore, a connection is identified by two endpoints.

696
00:51:20,850 --> 00:51:26,850
 Each endpoint is identified by an IP address and a port number.

697
00:51:26,850 --> 00:51:36,850
 And this is how two processes communicate. This is how your application communicates.

698
00:51:36,850 --> 00:51:43,850
 OK.

699
00:51:43,850 --> 00:51:47,850
 So you have MAC addresses, which comes with each card.

700
00:51:47,850 --> 00:51:53,850
 These are assigned and they cannot be changed.

701
00:51:53,850 --> 00:52:01,850
 They are assigned by the vendor, card vendor. You have IP addresses, which in general are assigned dynamically.

702
00:52:01,850 --> 00:52:08,850
 And then you have four numbers which are assigned by the operating system to the process.

703
00:52:08,850 --> 00:52:23,850
 So now, in order to identify, to send a package to one process, you need to specify both the IP address of the node on which the process runs and the port number of the process.

704
00:52:23,850 --> 00:52:34,850
 The port numbers are again used to differentiate between different processes on the same machine.

705
00:52:34,850 --> 00:52:45,850
 So what is the main network functionality? The main network functionality is delivery of a packet from between two hosts.

706
00:52:45,850 --> 00:52:50,850
 Across the globe. That's a problem.

707
00:52:50,850 --> 00:52:54,850
 You know, that's a service it implements.

708
00:52:54,850 --> 00:52:57,850
 What do you need to look for?

709
00:52:57,850 --> 00:53:05,850
 What are some properties of such service functionality?

710
00:53:05,850 --> 00:53:09,850
 Well, you certainly may want to be reliable.

711
00:53:09,850 --> 00:53:14,850
 The packet may be lost, may be lost for different reasons.

712
00:53:14,850 --> 00:53:31,850
 Can you think about actually some reasons why packets can be lost in the network?

713
00:53:31,850 --> 00:53:40,850
 If it's on Wi-Fi, yes. Radio interference and disturbance. Yeah, very good.

714
00:53:40,850 --> 00:53:50,850
 Someone turned on the microwave. That definitely can happen.

715
00:53:50,850 --> 00:53:56,850
 Cord was not plugged. Yes, I mean.

716
00:53:56,850 --> 00:54:03,850
 And we'll see in the packet, even in the wired networks, they can be still lost.

717
00:54:03,850 --> 00:54:10,850
 If, for instance, there are too many packets arriving at the routers, more than the router can handle.

718
00:54:10,850 --> 00:54:19,850
 So therefore, the buffer the router has is full. Then you have to drop packets.

719
00:54:19,850 --> 00:54:26,850
 So that's one. And now this is what we are talking about. Another thing is a flow control.

720
00:54:26,850 --> 00:54:31,850
 The flow control is avoid overflowing the receiver buffer.

721
00:54:31,850 --> 00:54:44,850
 So say you have a cell phone or whatever, which is all cell phone, which you can get data only at one, say, one megabit per second.

722
00:54:44,850 --> 00:54:50,850
 And I am a big server. I can send you packets. I can blast you to 100 megabits per second.

723
00:54:50,850 --> 00:54:54,850
 100 times faster than you can receive.

724
00:54:54,850 --> 00:55:00,850
 What you are going to do? There is no way you can get at that rate. Many packets will be lost.

725
00:55:00,850 --> 00:55:10,850
 So therefore, what you have to do, you need to push back on the sender and tell the sender, don't send that fast.

726
00:55:10,850 --> 00:55:14,850
 Just send, say, at one megabit per second.

727
00:55:14,850 --> 00:55:25,850
 OK, so this is what you need to do. This is flow control. The receiver pushing back to the server to not send too fast.

728
00:55:25,850 --> 00:55:33,850
 Then is a congestion control. The congestion control is avoid overflowing the buffer in the routers.

729
00:55:33,850 --> 00:55:43,850
 And we discussed that if the buffer in a router overflows, you lose packets. The packets are dropped.

730
00:55:43,850 --> 00:55:45,850
 OK.

731
00:55:45,850 --> 00:55:59,850
 So congestion control is making sure that the sender doesn't send too much data so that the router is overwhelmed and these buffers are overflowing.

732
00:55:59,850 --> 00:56:02,850
 So packets are lost.

733
00:56:02,850 --> 00:56:07,850
 So flow control is slowing down because of the receiver.

734
00:56:07,850 --> 00:56:16,850
 Congestion control is slowing down because the routers are in the network. There's a difference.

735
00:56:16,850 --> 00:56:25,850
 Now, we have to have right now, today, we have different nodes communicating between themselves.

736
00:56:25,850 --> 00:56:33,850
 Each of them executing the protocol. It has a syntax. The syntax will describe what is the packet format.

737
00:56:33,850 --> 00:56:43,850
 The types. Right. Right. And the syntax will specify, OK, I get this packet, what I'm going to do with it.

738
00:56:43,850 --> 00:56:48,850
 What action I should take.

739
00:56:48,850 --> 00:56:57,850
 This means that the two parties have to speak the same language, have to understand and execute the same protocol.

740
00:56:57,850 --> 00:56:59,850
 So we need to standardize.

741
00:56:59,850 --> 00:57:05,850
 If you want to communicate with someone, they have to run the same protocol.

742
00:57:05,850 --> 00:57:07,850
 Right.

743
00:57:07,850 --> 00:57:14,850
 If you want to speak with someone else, that person should speak English.

744
00:57:14,850 --> 00:57:18,850
 Or maybe another language, both of you know.

745
00:57:18,850 --> 00:57:23,850
 OK. So how does this standardization happen?

746
00:57:23,850 --> 00:57:40,850
 There are multiple ways. One is there is a standard out there and every software developers follow the standard when it drives the application.

747
00:57:40,850 --> 00:57:54,850
 Of course, the other one is basically have only one person, only one company, but I think the entire software, of course, is not desirable and is not realistic.

748
00:57:54,850 --> 00:57:58,850
 So that's why in general, you have the standard bodies for the Internet.

749
00:57:58,850 --> 00:58:05,850
 The standard bodies is IETF, Internet Engineering Task Force.

750
00:58:05,850 --> 00:58:22,850
 And typically the standardization happens for a new protocol, you know, someone's right, a document, we specify the protocol syntax and semantics and send to the other members of this task force requesting for comments.

751
00:58:22,850 --> 00:58:25,850
 It's called request for comments.

752
00:58:25,850 --> 00:58:32,850
 And after multiple rounds, that can become us can be approved to become a standard.

753
00:58:32,850 --> 00:58:37,850
 Become a standard in IETF, you don't need consensus.

754
00:58:37,850 --> 00:58:41,850
 Right. It's not like to PC, to face comment.

755
00:58:41,850 --> 00:58:51,850
 The majority has to agree. But one thing that always required in IETF is to have running code to demonstrate, which demonstrate that the protocol is feasible.

756
00:58:51,850 --> 00:58:58,850
 And typically you are asked for two implementation, different implementation of the same protocol.

757
00:58:58,850 --> 00:59:01,850
 OK.

758
00:59:01,850 --> 00:59:11,850
 There are also other ways to have de facto standards when some software becomes so popular, it becomes de facto standard.

759
00:59:11,850 --> 00:59:15,850
 And others will follow after it, like Linux.

760
00:59:15,850 --> 00:59:19,850
 There is no standard body for Linux, but it's a de facto standard.

761
00:59:19,850 --> 00:59:25,850
 So everyone follows that standard of writing the application.

762
00:59:25,850 --> 00:59:29,850
 OK.

763
00:59:29,850 --> 00:59:39,850
 So one thing about and this is a title of this networking section we are doing, we are learning during this class, during this lecture is layering.

764
00:59:39,850 --> 00:59:47,850
 So what about layering? What is a problem?

765
00:59:47,850 --> 01:00:01,850
 So the layering is a problem here is that think about you write, you know, you want to send a message from your application, from one process to another.

766
01:00:01,850 --> 01:00:09,850
 And that is what you know, you write some instructions, high level language, maybe send, receive.

767
01:00:09,850 --> 01:00:15,850
 That will be compiled down in machine code and will be executed by the processor.

768
01:00:15,850 --> 01:00:18,610
 And now you send it, but then you send it.

769
01:00:19,020 --> 01:00:25,020
 Eventually, that information you send, it needs to go all the way to the wire

770
01:00:25,020 --> 01:00:31,020
 or all the way to be transformed in a physical signal.

771
01:00:31,020 --> 01:00:46,020
 So there are many kind of steps from a send to all the way to that information to be sent on a wire, on radio,

772
01:00:46,020 --> 01:00:57,020
 and then to be received, the signal to be received on the other side and to make its way back to the receiving process,

773
01:00:57,020 --> 01:01:07,020
 which invokes probably a receive command and ultimately get the data.

774
01:01:07,020 --> 01:01:14,020
 And the problem here also is like we discussed, that is there is not only one way to send a signal.

775
01:01:14,020 --> 01:01:21,020
 There are many ways you can send the signals. You can use Bluetooth, radio signals, Wi-Fi.

776
01:01:21,020 --> 01:01:30,020
 You can use optical networks, optical signals. You can use electrical signals like in wire networks.

777
01:01:30,020 --> 01:01:38,020
 So you have many of these things. So you need to organize all of these.

778
01:01:38,020 --> 01:01:46,020
 Carrier pigeon. Yes, yes, yes. That's a very good one. You can do that as well.

779
01:01:46,020 --> 01:01:56,020
 You can send the information. Right. So this is a problem. Just thinking about application and transmission media.

780
01:01:56,020 --> 01:02:00,020
 So how are we going to do it? Like one way to do it.

781
01:02:00,020 --> 01:02:15,020
 It's basically for your application, you write your application so that it's able your converters or adapters to send to use every communication media.

782
01:02:15,020 --> 01:02:36,020
 Wire fiber optic, Wi-Fi, Bluetooth name it. That's one way to do it. What is the problem with this?

783
01:02:36,020 --> 01:02:43,020
 Kind of a lot of work. That's correct, Arison. Right.

784
01:02:43,020 --> 01:02:49,020
 Because you have a new application, now you need to implement this application over all this communication media.

785
01:02:49,020 --> 01:02:55,020
 And if you if you are the new transmission media, it's even worse. Every application now, if you want to support it,

786
01:02:55,020 --> 01:03:04,020
 you need to update the application to work on this over this communication radio radio over this new communication.

787
01:03:04,020 --> 01:03:09,020
 Over this new transmission media.

788
01:03:09,020 --> 01:03:28,020
 OK. So, yes, a lot of work. So what is the solution?

789
01:03:28,020 --> 01:03:45,020
 Encapsulations almost, but encapsulation assume something else. You encapsulate in what?

790
01:03:45,020 --> 01:03:50,020
 Layer protocols. Yes, you are talking about layers. That's absolutely correct.

791
01:03:50,020 --> 01:03:53,020
 So here is a solution. You add an intermediate layer.

792
01:03:53,020 --> 01:04:09,020
 There is a quote, a famous quote, basically saying that any problem in computer science can be solved by adding another level of indirection.

793
01:04:09,020 --> 01:04:20,020
 So this is indirection at work. You have an intermediate layer and then intermediate layer provides only one interface to the application.

794
01:04:20,020 --> 01:04:29,020
 And all of these applications are going to be written against the same API, the same interface.

795
01:04:29,020 --> 01:04:39,020
 And then if I am going to add so basically this is easy, right? I'm going to a new application.

796
01:04:39,020 --> 01:04:43,020
 I need to only be worried about only one interface.

797
01:04:43,020 --> 01:04:57,020
 To work with. And if you are going to add to add another transmission media, you just need to provide the same interface of the intermediate layer.

798
01:04:57,020 --> 01:05:02,020
 And then everything will work.

799
01:05:02,020 --> 01:05:12,020
 If a new application is going to if a new application is developed, no need to touch the transmission media part.

800
01:05:12,020 --> 01:05:20,020
 If a new transmission media is added, no need to touch existing applications.

801
01:05:20,020 --> 01:05:24,020
 Pretty cool, right?

802
01:05:24,020 --> 01:05:28,020
 And this has to do with software system modularity.

803
01:05:28,020 --> 01:05:37,020
 Right? And the modularity, whatever is going to provide the abstractions, differentiate between the interface and the implementation.

804
01:05:37,020 --> 01:05:43,020
 How is the implementation details? That's why when you develop the code, you are going to write functions.

805
01:05:43,020 --> 01:05:47,020
 The function provides a signature that's the interface of the function.

806
01:05:47,020 --> 01:05:54,020
 Typically the implementation shouldn't matter. You write a function to do sort.

807
01:05:54,020 --> 01:06:02,020
 The sorting, the interface looks the same. You provide a list.

808
01:06:02,020 --> 01:06:07,020
 And you get out the list order ascending or descending order.

809
01:06:07,020 --> 01:06:11,020
 How the implementation, how that is done doesn't matter.

810
01:06:11,020 --> 01:06:17,020
 Bubble sort, quick sort, heap sort, whatever.

811
01:06:17,020 --> 01:06:25,020
 So this kind of modularity and also it's related with encapsulation, encapsulate the functionality.

812
01:06:25,020 --> 01:06:37,020
 It's widely used as a method in computer science. Right? To simplify complex things.

813
01:06:37,020 --> 01:06:44,020
 Modularized. Right?

814
01:06:44,020 --> 01:06:54,020
 Now, fundamentally, you there is a there is one disadvantage of modularity is great.

815
01:06:54,020 --> 01:07:06,020
 Because, again, I can sense I can change the implementation can be a lot of lines of code without anything else in the application to be changed.

816
01:07:06,020 --> 01:07:10,020
 However.

817
01:07:10,020 --> 01:07:15,020
 This interface is also hide information.

818
01:07:15,020 --> 01:07:19,020
 Some information can be very useful.

819
01:07:19,020 --> 01:07:26,020
 And without this information, the performance can be impaired.

820
01:07:26,020 --> 01:07:31,020
 Let me give you a classic example.

821
01:07:31,020 --> 01:07:37,020
 I send a packet to the network.

822
01:07:37,020 --> 01:07:42,020
 And the packet doesn't make it is not acknowledge. I expect an acknowledge.

823
01:07:42,020 --> 01:07:46,020
 I don't get acknowledge.

824
01:07:46,020 --> 01:07:49,020
 What I should do.

825
01:07:49,020 --> 01:07:53,020
 Resend it again. Right?

826
01:07:53,020 --> 01:08:02,020
 But how aggressively I'm going to resend it and after how long it will depend on how the packet was lost.

827
01:08:02,020 --> 01:08:09,020
 It was because the interference like we discussed. I want to resend it immediately.

828
01:08:09,020 --> 01:08:15,020
 If it is because the congestion is a network.

829
01:08:15,020 --> 01:08:17,020
 Then I want to slow down.

830
01:08:17,020 --> 01:08:26,020
 Because if I send the same right, you know, probably the packet was lost because I was sending too fast.

831
01:08:26,020 --> 01:08:30,020
 So if I'm just resending and resending and resending.

832
01:08:30,020 --> 01:08:34,020
 That more packets are going to be lost.

833
01:08:34,020 --> 01:08:36,020
 So in that case, I want to slow down.

834
01:08:36,020 --> 01:08:43,020
 So if the interface doesn't allow me to expose this information and today doesn't.

835
01:08:43,020 --> 01:08:49,020
 I don't know exactly what to do. So the performance will suffer.

836
01:08:49,020 --> 01:09:00,020
 So network is like system modularity, but network modularity is like system modularity.

837
01:09:00,020 --> 01:09:03,020
 But it's simplified.

838
01:09:03,020 --> 01:09:09,020
 And it's simplified because they have layers. Modules can be connected in any ways.

839
01:09:09,020 --> 01:09:15,020
 Layering is connected in only one way. It's basically one layer on top of the other.

840
01:09:15,020 --> 01:09:29,020
 One layer can use only the functionality of the layer beneath, which is beneath it.

841
01:09:29,020 --> 01:09:32,020
 Right?

842
01:09:32,020 --> 01:09:38,020
 So only the two nearby layers are going to interact with each other.

843
01:09:38,020 --> 01:09:44,020
 Now you have a bunch of layers. The next question is about, okay, you have a bunch of functionality you need to implement.

844
01:09:44,020 --> 01:09:47,020
 Reliability, flow control, congestion control. We discuss about that.

845
01:09:47,020 --> 01:09:50,020
 Which layer is going to implement them?

846
01:09:50,020 --> 01:10:00,020
 And we are going to learn next time about end-to-end principles, which provide a guiding principle of where to implement certain functionalities.

847
01:10:00,020 --> 01:10:10,020
 And then there's a question about where the state is stopped.

848
01:10:10,020 --> 01:10:16,020
 So when you have a failure, right, then you can lose a piece of state.

849
01:10:16,020 --> 01:10:22,020
 Then you need to recover it. So this kind of stuff, you know, how you are going to think about the state.

850
01:10:22,190 --> 01:10:26,470
 state, shared state, in the distributed system.

851
01:10:26,470 --> 01:10:31,710
 And we are going to address all of those.

852
01:10:31,710 --> 01:10:34,350
 So we have 10 more minutes.

853
01:10:34,350 --> 01:10:37,790
 So let's dive in now in other things.

854
01:10:37,790 --> 01:10:42,990
 So I said the layering, it's this partition of the system

855
01:10:42,990 --> 01:10:50,270
 where a layer relies only on the services from the layer

856
01:10:50,270 --> 01:10:56,430
 below it and provides services only to the layers above it.

857
01:10:56,430 --> 01:11:04,790
 And the interfaces between layers

858
01:11:04,790 --> 01:11:09,190
 abstract away the implementation of a layer which

859
01:11:09,190 --> 01:11:13,950
 provides that interface from the layer using that interface.

860
01:11:13,950 --> 01:11:17,630
 So a layer can be changed in isolation

861
01:11:17,630 --> 01:11:21,710
 without in a transparent manner to the layers above it.

862
01:11:21,710 --> 01:11:27,670
 So there are several concepts which

863
01:11:27,670 --> 01:11:32,390
 are associated with each layer and we care to answer.

864
01:11:32,390 --> 01:11:39,230
 Service, what a layer does, what functionality it provides.

865
01:11:39,230 --> 01:11:43,150
 Service interface, how to access a service,

866
01:11:43,150 --> 01:11:45,350
 how do you access a service, what is the API,

867
01:11:45,350 --> 01:11:48,270
 what is the interface.

868
01:11:48,270 --> 01:11:50,390
 And then is a protocol.

869
01:11:50,390 --> 01:11:52,270
 The protocol like we discussed in the past

870
01:11:52,270 --> 01:11:56,790
 is how the peers, two peers, communicate with each other.

871
01:11:56,790 --> 01:12:00,110
 What is the packet format, syntax, what do I do

872
01:12:00,110 --> 01:12:02,310
 when I receive a packet.

873
01:12:02,310 --> 01:12:05,510
 When I don't receive a packet, when I have a timeout,

874
01:12:05,510 --> 01:12:07,350
 there's a semantics.

875
01:12:07,350 --> 01:12:11,750
 So it's service, service interface, and protocol.

876
01:12:11,750 --> 01:12:15,230
 So this is a network layering.

877
01:12:15,230 --> 01:12:20,270
 Initially, it was a standard body, open system

878
01:12:20,270 --> 01:12:21,830
 interconnection.

879
01:12:21,830 --> 01:12:24,070
 And that declares that there should

880
01:12:24,070 --> 01:12:29,350
 be seven layers, physical, data link, network, transport,

881
01:12:29,350 --> 01:12:33,390
 session, presentation, and application.

882
01:12:33,390 --> 01:12:38,750
 However, the internet protocol, this standard,

883
01:12:38,750 --> 01:12:41,430
 it was unsuccessful in the end.

884
01:12:41,430 --> 01:12:50,150
 It was overtaken by internet protocol, which was initially

885
01:12:50,150 --> 01:12:52,710
 grew as a de facto standard.

886
01:12:52,710 --> 01:13:01,510
 And only later, it was an idea, it was created later.

887
01:13:01,510 --> 01:13:05,310
 I think nine, 10 years later after IP was designed.

888
01:13:05,310 --> 01:13:10,870
 IP and TCP/IP protocol, remember, it was a software,

889
01:13:10,870 --> 01:13:15,590
 it was a protocol which was implemented in Unix BSD,

890
01:13:15,590 --> 01:13:20,070
 Verical Assistant Distribution.

891
01:13:20,070 --> 01:13:23,990
 So you should be very proud about that.

892
01:13:23,990 --> 01:13:25,790
 OK?

893
01:13:25,790 --> 01:13:29,190
 And with this layer, with the internet protocol,

894
01:13:29,190 --> 01:13:30,950
 you have only five layers.

895
01:13:30,950 --> 01:13:32,710
 The presentation and session layers

896
01:13:32,710 --> 01:13:34,390
 are included in the application layer.

897
01:13:34,390 --> 01:13:40,270
 So this you are going to learn about what each layer is doing.

898
01:13:40,270 --> 01:13:43,550
 So let's start.

899
01:13:43,550 --> 01:13:46,630
 Bottom up, physical layer.

900
01:13:46,630 --> 01:13:50,630
 Service moves the information between two systems connected

901
01:13:50,630 --> 01:13:53,110
 by a physical link.

902
01:13:53,110 --> 01:14:01,630
 The physical link can be wired, optical, or through the air.

903
01:14:01,630 --> 01:14:04,430
 The interface specifies how to send and receive bits.

904
01:14:04,430 --> 01:14:05,910
 What are the level of voltages?

905
01:14:05,910 --> 01:14:08,910
 How you encode one, the ones?

906
01:14:08,910 --> 01:14:10,150
 How do you encode zeros?

907
01:14:10,150 --> 01:14:20,710
 And the protocol represents actually the coding scheme.

908
01:14:20,710 --> 01:14:25,470
 So it's like the interface is basically here,

909
01:14:25,470 --> 01:14:29,150
 I am saying about a bit what is a bit.

910
01:14:29,150 --> 01:14:32,190
 It's like transition from low to high voltage,

911
01:14:32,190 --> 01:14:34,750
 or transition from low to high voltage,

912
01:14:34,750 --> 01:14:38,150
 from high to low voltage.

913
01:14:38,150 --> 01:14:39,590
 What is the duration of a bit?

914
01:14:39,590 --> 01:14:43,110
 How long is sent?

915
01:14:43,110 --> 01:14:46,230
 And these are the examples, coaxial cable, optical fiber

916
01:14:46,230 --> 01:14:47,310
 link, and so forth.

917
01:14:47,310 --> 01:14:52,190
 The next is data link layer.

918
01:14:52,190 --> 01:14:53,830
 So by the way, the physical layer

919
01:14:53,830 --> 01:14:57,870
 is between two machines which are directly connected.

920
01:14:57,870 --> 01:15:01,270
 The data link layer, it's the same,

921
01:15:01,270 --> 01:15:03,390
 but here there are multiple machines

922
01:15:03,390 --> 01:15:07,870
 which are connected to the same communication media.

923
01:15:07,870 --> 01:15:11,670
 Typically, like for instance, the same local area network,

924
01:15:11,670 --> 01:15:12,830
 what is called.

925
01:15:12,830 --> 01:15:17,350
 All the machines on a Wi-Fi network, right?

926
01:15:17,350 --> 01:15:18,950
 If you are connected with the Wi-Fi

927
01:15:18,950 --> 01:15:23,590
 to the same base stations, you are on the same network.

928
01:15:23,590 --> 01:15:25,910
 And in this case, you need to arbitrate the access

929
01:15:25,910 --> 01:15:27,750
 because you have multiple machines sending

930
01:15:27,750 --> 01:15:29,470
 on the same communication media.

931
01:15:29,470 --> 01:15:34,990
 They can send at the same time, so they can have collisions.

932
01:15:34,990 --> 01:15:39,190
 So you need to think about that.

933
01:15:39,190 --> 01:15:43,030
 But this is a service data link layer provides.

934
01:15:43,030 --> 01:15:45,790
 It can also provide reliable transmission and flow control.

935
01:15:45,790 --> 01:15:49,350
 Remember, flow control is what?

936
01:15:49,350 --> 01:15:53,950
 Not overflowing the receiver, slowing down

937
01:15:53,950 --> 01:15:56,630
 to not overflow the receiver.

938
01:15:56,630 --> 01:15:58,230
 The interface is sent frames.

939
01:15:58,230 --> 01:15:59,510
 So here are the packets.

940
01:15:59,510 --> 01:16:02,230
 Initially, with physical layer, you send bits.

941
01:16:02,230 --> 01:16:06,630
 Here you aggregate the bits into frames.

942
01:16:06,630 --> 01:16:08,230
 And you send frames.

943
01:16:08,230 --> 01:16:09,550
 Each frame has a header.

944
01:16:09,550 --> 01:16:21,910
 And the header will have this MAC address, as you'll see.

945
01:16:21,910 --> 01:16:25,430
 Finally, you have the protocols.

946
01:16:25,430 --> 01:16:28,390
 It is media access protocol to arbitrate access.

947
01:16:28,390 --> 01:16:29,990
 And there are many implementations.

948
01:16:29,990 --> 01:16:32,710
 We are going to briefly talk about that.

949
01:16:32,710 --> 01:16:37,270
 So here is what you have.

950
01:16:37,270 --> 01:16:38,310
 You have a frame.

951
01:16:38,310 --> 01:16:39,350
 We have a frame header.

952
01:16:39,350 --> 01:16:44,510
 The frame header has a MAC destination and source address.

953
01:16:44,510 --> 01:16:46,950
 And then they are converted as a lower level

954
01:16:46,950 --> 01:16:50,510
 in bits, which are sent on the wire.

955
01:16:50,510 --> 01:16:53,110
 You see?

956
01:16:53,110 --> 01:16:53,950
 OK.

957
01:16:53,950 --> 01:16:56,510
 So you see that you have the counterpoint.

958
01:16:56,510 --> 01:17:01,230
 You have the instantiation of the layers at both peers,

959
01:17:01,230 --> 01:17:02,270
 at both endpoints.

960
01:17:02,270 --> 01:17:08,710
 OK.

961
01:17:08,710 --> 01:17:18,030
 So now, you can actually-- you can look about your--

962
01:17:18,030 --> 01:17:19,030
 on your machines.

963
01:17:19,030 --> 01:17:21,550
 And if you are curious about this physical address

964
01:17:21,550 --> 01:17:25,790
 or the MAC address, you can easily find those.

965
01:17:25,790 --> 01:17:27,750
 And as well as the IP addresses.

966
01:17:27,750 --> 01:17:35,190
 But this is what-- if you do if config in Linux or IP config

967
01:17:35,190 --> 01:17:37,870
 in your Windows machine, then you

968
01:17:37,870 --> 01:17:41,110
 are going to get these physical addresses or Ethernet adapter

969
01:17:41,110 --> 01:17:41,670
 and so forth.

970
01:17:41,670 --> 01:17:44,870
 These are the MAC addresses.

971
01:17:44,870 --> 01:17:45,350
 OK?

972
01:17:45,350 --> 01:17:54,710
 So like I mentioned, a group of machines

973
01:17:54,710 --> 01:17:57,350
 which are on the same communication media,

974
01:17:57,350 --> 01:18:00,630
 they are called form a LAN, Local Area Network.

975
01:18:00,630 --> 01:18:05,350
 And these are the examples.

976
01:18:05,350 --> 01:18:09,790
 Computers in your home, Starbucks, wireless Starbucks,

977
01:18:09,790 --> 01:18:12,630
 and Starbucks and so forth.

978
01:18:12,630 --> 01:18:14,270
 But the most important thing here

979
01:18:14,270 --> 01:18:19,310
 is that when you send a frame on a LAN,

980
01:18:19,310 --> 01:18:24,470
 that can reach any other machine on the same LAN.

981
01:18:24,470 --> 01:18:30,270
 So it's a-- generally, it's a broadcast media.

982
01:18:30,270 --> 01:18:34,070
 It's like we are in a room or on this webinar.

983
01:18:34,070 --> 01:18:35,470
 I'm saying something.

984
01:18:35,470 --> 01:18:36,870
 Everyone else will hear me.

985
01:18:36,870 --> 01:18:41,350
 OK?

986
01:18:41,350 --> 01:18:42,830
 Now, how do you know?

987
01:18:42,830 --> 01:18:45,750
 How does it know?

988
01:18:45,750 --> 01:18:49,830
 Because everyone will get the same frame.

989
01:18:49,830 --> 01:18:53,150
 How does it know the recipient, the intended recipient

990
01:18:53,150 --> 01:18:56,950
 of the frame to get the frame and others not get the frame?

991
01:18:56,950 --> 01:19:02,830
 It's because of MAC address.

992
01:19:02,830 --> 01:19:08,550
 When the sender sends a frame, it's a frame header.

993
01:19:08,550 --> 01:19:10,910
 It puts the MAC address of the recipient.

994
01:19:10,910 --> 01:19:15,590
 In this case, it's B. So now, yes, the frame

995
01:19:15,590 --> 01:19:18,870
 is going to be forwarded to everyone.

996
01:19:18,870 --> 01:19:22,630
 But only B is going to look at the header

997
01:19:22,630 --> 01:19:25,790
 and is going to see that it's addressed to itself

998
01:19:25,790 --> 01:19:32,750
 and is going to pass the frame to the next layer.

999
01:19:32,750 --> 01:19:43,430
 The second, the C, if a computer looks at the frame

1000
01:19:43,430 --> 01:19:46,430
 and it doesn't recognize its MAC address, it drops it.

1001
01:19:46,430 --> 01:19:51,270
 OK?

1002
01:19:51,270 --> 01:19:54,510
 Now, things are more complicated.

1003
01:19:54,510 --> 01:19:59,390
 Even for a LAN, there are switches and so forth.

1004
01:19:59,390 --> 01:20:01,510
 And this is what we are going to continue

1005
01:20:01,510 --> 01:20:05,150
 to discuss next lecture.

1006
01:20:05,150 --> 01:20:07,790
 And with that, stopping here, please,

1007
01:20:07,790 --> 01:20:11,470
 if you have any other questions, let me know on Piazza

1008
01:20:11,470 --> 01:20:13,390
 or send an email.

1009
01:20:13,390 --> 01:20:18,510
 And I'll see you all on next Tuesday.

1010
01:20:18,510 --> 01:20:20,110
 Good luck with the homework.

1011
01:20:20,110 --> 01:20:25,750
 Bye.

