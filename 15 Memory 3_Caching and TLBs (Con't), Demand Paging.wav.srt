1
00:00:00,000 --> 00:00:07,460
Okay. Cool. So we're recording and I can do stuff.
好的。很酷。所以我们正在录音，我可以做一些事情。

2
00:00:07,460 --> 00:00:12,080
Okay, great. So I'm going to try and keep my eye on the chat.
好的，太棒了。所以我会尽量留意聊天窗口。

3
00:00:12,080 --> 00:00:15,000
But I'm not very good at this yet,
但是我还不太擅长这个，

4
00:00:15,000 --> 00:00:16,620
so this is all new to me.
所以这对我来说都是新的。

5
00:00:16,620 --> 00:00:18,860
So I'm going to do my best.
所以我会尽力而为。

6
00:00:18,860 --> 00:00:20,660
Okay. So I'm Nathan.
好的。所以我是Nathan。

7
00:00:20,660 --> 00:00:21,900
I'm filling in for you on today.
我今天替你工作。

8
00:00:21,900 --> 00:00:23,280
I'm a grad student.
我是一名研究生。

9
00:00:23,280 --> 00:00:25,360
I work with you on sometimes.
我有时候和你一起工作。

10
00:00:25,360 --> 00:00:27,280
I study a lot of stuff.
我学习了很多东西。

11
00:00:27,280 --> 00:00:29,100
I do like kind of cloud stuff.
我确实喜欢云计算这种东西。

12
00:00:29,100 --> 00:00:31,200
Serverless computing, if ever heard of that.
无服务器计算，如果你听说过的话。

13
00:00:31,200 --> 00:00:33,000
I goof around with some hardware,
我在玩弄一些硬件，

14
00:00:33,000 --> 00:00:34,440
lots of stuff like that.
很多类似的东西。

15
00:00:34,440 --> 00:00:36,940
But today we're going to be talking about
但是今天我们要谈论的是什么呢？

16
00:00:36,940 --> 00:00:41,060
more stuff to do with paging and virtual memory.
更多关于分页和虚拟内存的内容。

17
00:00:41,060 --> 00:00:43,440
And particularly today, there's a big focus
尤其是今天，有一个很大的关注点。

18
00:00:43,440 --> 00:00:48,440
on how paging actually works kind of in practice.
关于分页实际上是如何在实践中工作的。

19
00:00:48,440 --> 00:00:49,980
So a lot of the tips and tricks,
所以很多的技巧和窍门，

20
00:00:49,980 --> 00:00:51,560
how the hardware deals with it,
硬件如何处理它？

21
00:00:51,560 --> 00:00:53,000
and some of the more kind of
和一些更加友善的

22
00:00:53,000 --> 00:00:55,700
advanced detailed concepts around that.
高级详细的概念围绕着那个。

23
00:00:55,700 --> 00:00:59,080
So starting from what you guys saw last week,
所以从你们上周看到的开始，

24
00:00:59,080 --> 00:01:01,360
and you guys can interrupt me in the chat
你们可以在聊天中打断我。

25
00:01:01,360 --> 00:01:04,440
if I'm sort of off in sync.
如果我有点不协调。

26
00:01:04,440 --> 00:01:07,280
I think Jan told me where he left off last time.
我想Jan告诉我他上次停下来的地方。

27
00:01:07,280 --> 00:01:09,400
We talked about flat page tables.
我们谈论了平面页表。

28
00:01:09,400 --> 00:01:12,940
We talked about first level, single level page tables.
我们谈论了一级、单级页表。

29
00:01:12,940 --> 00:01:16,160
And so a single level page table is going to have
因此，一个单级页表将会有多少个级别？

30
00:01:16,160 --> 00:01:18,900
one entry for every virtual page
每个虚拟页面对应一个条目。

31
00:01:18,900 --> 00:01:20,460
that you could possibly have.
你可能拥有的一切。

32
00:01:20,460 --> 00:01:22,080
So if you have a 32 bit system,
那么如果你有一个32位的系统，

33
00:01:22,080 --> 00:01:24,280
that's going to be two to the 32 entries,
这将会有2的32次方个条目。

34
00:01:24,280 --> 00:01:28,580
about 4 billion, well, 4 billion divided by the page size,
大约40亿，嗯，40亿除以页面大小，

35
00:01:28,580 --> 00:01:30,300
which is 4K.
这是4K。

36
00:01:30,300 --> 00:01:31,680
If you're on a 64 bit machine,
如果你使用的是64位机器，

37
00:01:31,680 --> 00:01:34,540
which is obviously the most popular today,
显然，这是当今最受欢迎的。

38
00:01:34,540 --> 00:01:37,080
at least for high end sort of systems,
至少对于高端系统来说，

39
00:01:37,080 --> 00:01:38,520
that's going to be two to the 64,
那将是2的64次方，

40
00:01:38,520 --> 00:01:40,680
which is a completely outrageous number.
这是一个完全荒谬的数字。

41
00:01:40,680 --> 00:01:44,280
So single level page tables are just not practical.
单层页表实际上并不实用。

42
00:01:44,280 --> 00:01:47,100
You'd have to have an entry for every virtual address.
你需要为每个虚拟地址创建一个条目。

43
00:01:47,100 --> 00:01:51,360
And the reality is that no program uses anywhere near
而事实是，没有任何一个程序使用的地方接近这个数量。

44
00:01:51,360 --> 00:01:53,040
all available virtual addresses.
所有可用的虚拟地址。

45
00:01:53,040 --> 00:01:55,880
The vast majority of programs use a tiny, tiny fraction
绝大多数程序只使用了极小的一部分。

46
00:01:55,880 --> 00:01:57,240
of virtual memory.
虚拟内存。

47
00:01:57,240 --> 00:01:58,220
So what do we do?
那么我们该怎么办呢？

48
00:01:58,220 --> 00:02:00,920
Well, we go back to our data structures class
好的，我们回到我们的数据结构课程。

49
00:02:00,920 --> 00:02:02,120
that we learned,
我们学到的是，

50
00:02:02,120 --> 00:02:04,480
and we learned about all these neat data structures.
我们学习了所有这些很棒的数据结构。

51
00:02:04,480 --> 00:02:06,840
And we remember that there's a thing called a tree.
我们记得有一种东西叫做树。

52
00:02:06,840 --> 00:02:09,840
So what we do is instead of having that first level
我们所做的是，不再有第一层。

53
00:02:09,840 --> 00:02:11,860
page table address everything,
页表地址一切，

54
00:02:11,860 --> 00:02:16,160
what it instead does is it points to child nodes in a tree.
它实际上是指向树中的子节点。

55
00:02:16,160 --> 00:02:17,400
So this isn't a binary tree.
所以这不是一个二叉树。

56
00:02:17,400 --> 00:02:21,180
It's a tree with as many leaves as you need
这是一棵树，上面有你需要的那么多叶子。

57
00:02:21,180 --> 00:02:23,660
in order to cover the virtual address space.
为了覆盖虚拟地址空间。

58
00:02:23,660 --> 00:02:26,360
But it's the same idea, just like a tree.
但是这个想法是一样的，就像一棵树一样。

59
00:02:26,360 --> 00:02:30,200
And instead of treating your virtual address bits
而不是处理您的虚拟地址位

60
00:02:30,200 --> 00:02:33,540
as an index into a single table, we split it up.
作为一个索引，我们将它拆分成多个表。

61
00:02:33,540 --> 00:02:35,600
So now there's two parts here.
所以现在这里有两个部分。

62
00:02:35,600 --> 00:02:37,640
So you can see there's one part that indexes
所以你可以看到有一个部分进行了索引。

63
00:02:37,640 --> 00:02:39,800
into the first level page table.
进入第一级页表。

64
00:02:39,800 --> 00:02:41,360
And then the second half of it,
然后是它的后半部分，

65
00:02:41,360 --> 00:02:44,040
we're going to use here to index
我们要在这里使用索引。

66
00:02:44,040 --> 00:02:46,280
into the second level page table.
进入第二级页表。

67
00:02:46,280 --> 00:02:48,160
So it's just an index scheme, right?
是的，这只是一个索引方案，对吗？

68
00:02:48,160 --> 00:02:50,480
It's just a scheme in order to structure a page table
这只是为了构建一个页面表的方案。

69
00:02:50,480 --> 00:02:53,840
more like a tree than a single table.
更像是一棵树而不是一个单独的桌子。

70
00:02:53,840 --> 00:02:57,120
And then this one here is actually like what you learned
然后这个在这里实际上就像你所学到的一样。

71
00:02:57,120 --> 00:03:00,120
about before, this is your standard page table entry.
关于之前的内容，这是您的标准页表项。

72
00:03:00,120 --> 00:03:01,760
We call that a PTE for short.
我们简称它为PTE。

73
00:03:01,760 --> 00:03:04,180
I'm going to use that word a lot today.
我今天会经常用到那个词。

74
00:03:04,180 --> 00:03:06,740
So page table entry is a PTE.
所以页表项是一个PTE。

75
00:03:06,740 --> 00:03:10,200
And this is the normal one we saw just like when it was
而这就是我们看到的普通的那个，就像当时一样。

76
00:03:10,200 --> 00:03:11,860
in a first level page table.
在一个一级页表中。

77
00:03:11,860 --> 00:03:14,760
So you've got the physical page number here.
所以这里有物理页码。

78
00:03:14,760 --> 00:03:16,860
So in Linux, I think they call this a frame.
所以在Linux中，我认为他们称之为框架。

79
00:03:16,860 --> 00:03:19,800
So they call this the physical frame number or PFN.
所以他们称之为物理框架号码或PFN。

80
00:03:19,800 --> 00:03:21,560
So you might hear me say page number.
所以你可能会听到我说页码。

81
00:03:21,560 --> 00:03:23,360
You might hear me say frame number.
你可能会听到我说“frame number”。

82
00:03:23,360 --> 00:03:26,960
Often frame tends to get used for the physical
经常会使用框架来指代物理结构。

83
00:03:26,960 --> 00:03:28,280
just to make it a little more clear
只是为了更加清楚一点。

84
00:03:28,280 --> 00:03:30,420
that whether we're talking about virtual pages
我们是否在讨论虚拟页面。

85
00:03:30,420 --> 00:03:31,780
or physical pages.
或者物理页面。

86
00:03:31,780 --> 00:03:33,500
Also, when you say frame, you tend to refer
此外，当你说“frame”时，你倾向于指的是什么？

87
00:03:33,500 --> 00:03:37,760
to an actual literal like particular address in memory.
到实际的字面上的特定内存地址。

88
00:03:37,760 --> 00:03:40,380
So either way, we have a physical page number in the table.
所以无论如何，在表格中我们都有一个物理页码。

89
00:03:40,380 --> 00:03:42,200
So we use the virtual page number.
所以我们使用虚拟页号。

90
00:03:42,200 --> 00:03:43,820
So that was this part.
那就是这部分了。

91
00:03:43,820 --> 00:03:46,140
This was what you thought the address was.
这是你认为的地址。

92
00:03:46,140 --> 00:03:50,160
We use that in order to find the physical page number.
我们使用这个来找到物理页码。

93
00:03:50,160 --> 00:03:52,700
And then because pages have multiple bytes in them
然后因为页面中有多个字节。

94
00:03:52,700 --> 00:03:54,960
and you're trying to address a particular byte,
并且你正在尝试访问特定的字节，

95
00:03:54,960 --> 00:03:56,780
there's this offset part you provided.
你提供了一个偏移部分。

96
00:03:56,780 --> 00:03:58,500
And that offset is gonna be the same
这个偏移量将会是一样的。

97
00:03:58,500 --> 00:04:00,420
whether it's physical or virtual.
无论是实体的还是虚拟的。

98
00:04:00,420 --> 00:04:02,460
It's just the offset in here,
这里只是偏移量。

99
00:04:02,460 --> 00:04:04,300
whether it's here, here, here, here.
无论是这里、这里、这里还是这里。

100
00:04:04,300 --> 00:04:07,460
Okay, so multi-level page tables,
好的，多级页表，

101
00:04:07,460 --> 00:04:08,620
pretty sure we talked about this
我很确定我们谈过这个。

102
00:04:08,620 --> 00:04:10,320
or you talked about this last week.
或者你上周已经谈论过这个了。

103
00:04:10,320 --> 00:04:13,020
But they're pretty cool.
但是它们很酷。

104
00:04:13,020 --> 00:04:15,060
And one of the nice things here is that
这里的一个好处是

105
00:04:15,060 --> 00:04:17,360
I don't actually have to have every one of these.
我实际上不需要每一个。

106
00:04:17,360 --> 00:04:21,100
So I could have, maybe this doesn't even have to exist.
所以我可能可以，也许这甚至不必存在。

107
00:04:21,100 --> 00:04:22,780
If I haven't allocated any pages,
如果我没有分配任何页面，

108
00:04:22,780 --> 00:04:25,500
why should I even bother creating the leaf node yet?
为什么我要费心去创建叶节点呢？

109
00:04:25,500 --> 00:04:28,180
And so what you might do is you might just sort of
然后你可能会做的是，你可能只是有点

110
00:04:28,180 --> 00:04:30,620
mark this as empty, right?
将这个标记为空，对吗？

111
00:04:30,620 --> 00:04:32,360
In this entry, you might have some sort of bit
在这个条目中，你可能有一些某种程度的信息。

112
00:04:32,360 --> 00:04:33,200
that you set that said,
关于你所说的，

113
00:04:33,200 --> 00:04:35,780
"Ah, this doesn't actually exist, ignore it."
啊，这实际上不存在，忽略它。

114
00:04:35,780 --> 00:04:38,220
In which case we didn't have to allocate this other one
在哪种情况下，我们不需要分配这另一个。

115
00:04:38,220 --> 00:04:39,520
and we saved ourselves some memory.
我们节省了一些内存。

116
00:04:39,520 --> 00:04:41,460
So with multi-level page tables,
因此，使用多级页表，

117
00:04:41,460 --> 00:04:42,980
we no longer have to store,
我们不再需要存储，

118
00:04:42,980 --> 00:04:44,780
we don't have to allocate memory
我们不需要分配内存。

119
00:04:44,780 --> 00:04:47,300
for all the empty spots in the table anymore.
桌子上再也没有任何空位了。

120
00:04:47,300 --> 00:04:49,140
We just have to allocate memory
我们只需要分配内存

121
00:04:49,140 --> 00:04:52,780
for the ones that actually have been assigned.
对于那些实际上已经被分配的人。

122
00:04:52,780 --> 00:04:55,380
Or at least, you know, one page's worth
或者至少，你知道，值得一页的内容。

123
00:04:55,380 --> 00:04:56,320
of ones that have been assigned.
已经被分配的那些。

124
00:04:56,320 --> 00:04:58,640
We still are gonna have empty slots
我们仍然会有空位。

125
00:04:58,640 --> 00:05:00,420
in this second level page table,
在这个二级页表中，

126
00:05:00,420 --> 00:05:01,640
but there's a lot fewer of them.
但是它们的数量要少得多。

127
00:05:01,640 --> 00:05:02,840
So it kind of works out.
所以它有点起作用。

128
00:05:02,840 --> 00:05:08,220
Okay, so what are the pros and cons here?
好的，这里有哪些利弊呢？

129
00:05:08,220 --> 00:05:11,420
So the pros of the multi-level page table is that,
多级页表的优点是，

130
00:05:11,420 --> 00:05:13,780
like I said, sparse address spaces,
就像我说的，地址空间稀疏，

131
00:05:13,780 --> 00:05:17,140
address spaces that are mostly empty, mostly unassigned.
大部分为空的地址空间，大部分未分配的。

132
00:05:17,140 --> 00:05:18,420
This is reasonably good at,
这个相当不错。

133
00:05:18,420 --> 00:05:21,700
because you don't have to store all the empty ones.
因为你不需要存储所有的空的。

134
00:05:21,700 --> 00:05:23,100
Because we're using paging rather
因为我们正在使用分页而不是连续存储

135
00:05:23,100 --> 00:05:25,660
than something more complicated like segmentation,
比如一些更复杂的东西，比如分割。

136
00:05:25,660 --> 00:05:27,780
then it makes memory allocation a lot easier,
然后它使内存分配变得更加容易，

137
00:05:27,780 --> 00:05:29,980
because you have fixed size pages.
因为你有固定大小的页面。

138
00:05:29,980 --> 00:05:32,340
You have these fixed size allocation units,
你有这些固定大小的分配单元，

139
00:05:32,340 --> 00:05:34,540
and that makes life a lot easier
这使得生活变得更加容易。

140
00:05:34,540 --> 00:05:36,060
when you're writing memory allocators.
当你编写内存分配器时。

141
00:05:36,060 --> 00:05:38,540
Now, I don't know if you guys have a memory allocator project
现在，我不知道你们是否有一个内存分配器项目。

142
00:05:38,540 --> 00:05:41,420
in this class or if you've done one yet,
在这个班级里或者如果你已经完成了一个的话，

143
00:05:41,420 --> 00:05:43,100
but when you do, you're gonna start to realize
但是当你这样做时，你会开始意识到

144
00:05:43,100 --> 00:05:44,980
how incredibly annoying it would be
多么令人难以忍受啊

145
00:05:44,980 --> 00:05:47,060
to try and allocate variable size things.
尝试分配可变大小的物品。

146
00:05:47,060 --> 00:05:50,020
It's much easier if they're fixed size and aligned.
如果它们是固定大小并对齐的话，会更容易。

147
00:05:50,020 --> 00:05:52,780
The other nice thing is that every process
另一个好处是每个过程都很不错。

148
00:05:52,780 --> 00:05:54,300
has its own page table.
有自己的页表。

149
00:05:54,300 --> 00:05:55,940
And so it makes it really easy to share.
所以它使分享变得非常容易。

150
00:05:55,940 --> 00:05:57,500
So even though two people
所以即使有两个人

151
00:05:57,500 --> 00:06:00,340
might have different virtual addresses, it's pretty neat.
可能有不同的虚拟地址，这很酷。

152
00:06:00,340 --> 00:06:03,220
We can actually just have those virtual addresses map
我们实际上可以只是让这些虚拟地址映射

153
00:06:03,220 --> 00:06:05,060
to the same physical address,
到相同的实际地址，

154
00:06:05,060 --> 00:06:07,460
and then people can share physical memory
然后人们可以分享实际的记忆。

155
00:06:07,460 --> 00:06:08,620
without even realizing it.
甚至没有意识到。

156
00:06:08,620 --> 00:06:09,460
And that's pretty neat.
这很不错。

157
00:06:09,460 --> 00:06:10,380
So we'll talk a little bit more
所以我们会再多聊一点

158
00:06:10,380 --> 00:06:11,980
about that later in the lecture.
关于那个稍后在讲座中会提到。

159
00:06:11,980 --> 00:06:13,980
It's not perfect though.
虽然不完美。

160
00:06:13,980 --> 00:06:15,700
I mean, there's downsides, right?
我的意思是，有一些不利的方面，对吧？

161
00:06:15,700 --> 00:06:18,900
One of them is that because they're not variable size,
其中一个原因是它们不是可变大小的。

162
00:06:18,900 --> 00:06:20,100
because they're fixed size,
因为它们是固定大小的。

163
00:06:20,100 --> 00:06:22,540
we actually have to have an entry per page.
我们实际上需要每页都有一个入口。

164
00:06:22,540 --> 00:06:25,020
So even though I might allocate you like a gigabyte
所以即使我可能分配给你像一千兆字节那样的空间

165
00:06:25,020 --> 00:06:28,100
in one shot, I actually am gonna have to have one entry
一次性，我实际上需要有一个入口。

166
00:06:28,100 --> 00:06:31,940
for every 4K in that big four gigabyte section.
每4K在那个四GB的大区块中。

167
00:06:31,940 --> 00:06:34,100
So I can give you these big allocations,
所以我可以给你这些大额分配，

168
00:06:34,100 --> 00:06:37,540
but I'm allocating a lot of kind of redundant information.
但是我分配了很多有点多余的信息。

169
00:06:37,540 --> 00:06:39,140
With segments, you wouldn't have that problem, right?
使用分段，你就不会有那个问题了，对吗？

170
00:06:39,140 --> 00:06:41,620
With segmentation, I could give you a base register
使用分割技术，我可以为您提供一个基本的注册表。

171
00:06:41,620 --> 00:06:43,060
and just a four gigabyte bound
并且只有四千兆字节的限制。

172
00:06:43,060 --> 00:06:44,700
and then everything would work out.
然后一切都会解决的。

173
00:06:44,700 --> 00:06:47,500
So it's kind of a drawback of this paging approach.
所以这种分页方法有点不足之处。

174
00:06:47,500 --> 00:06:49,780
The way people deal with that is they tend to allow
人们处理这个问题的方式是他们倾向于允许

175
00:06:49,780 --> 00:06:51,500
for different sized pages.
适用于不同尺寸的页面。

176
00:06:51,500 --> 00:06:52,340
They're still aligned,
它们仍然对齐。

177
00:06:52,340 --> 00:06:55,020
but today you can do things called huge pages.
但是今天你可以做一些被称为巨大页面的事情。

178
00:06:55,020 --> 00:06:57,500
So maybe you could allocate a one megabyte
所以也许你可以分配一个一兆字节的空间。

179
00:06:57,500 --> 00:07:00,660
or even bigger page size.
或者更大的页面尺寸。

180
00:07:00,660 --> 00:07:03,780
And so that is a trick that modern systems use,
而这就是现代系统使用的一个技巧，

181
00:07:03,780 --> 00:07:05,620
but we won't really go into too much more detail
但我们不会详细讨论太多。

182
00:07:05,620 --> 00:07:07,100
beyond that for huge pages.
除此之外，还有针对大型页面的优化。

183
00:07:07,100 --> 00:07:10,460
You know, they have to be contiguous.
你知道，它们必须是连续的。

184
00:07:10,460 --> 00:07:13,340
It's not such a problem
这不是什么大问题。

185
00:07:13,340 --> 00:07:15,420
when you have multi-level page tables.
当你有多级页表时。

186
00:07:15,420 --> 00:07:17,860
All we do is we make each one of those levels.
我们所做的就是制作每一个层级。

187
00:07:17,860 --> 00:07:20,540
So each one of those, you know, let's see.
所以每一个，你知道的，让我看看。

188
00:07:20,540 --> 00:07:25,540
So each one of these, where are we going?
那么这些中的每一个，我们要去哪里？

189
00:07:25,540 --> 00:07:27,060
What happened here?
这里发生了什么事情？

190
00:07:27,060 --> 00:07:36,140
Sorry guys, still getting used to this.
对不起，大家，我还在适应中。

191
00:07:36,140 --> 00:07:36,980
Okay.
Sure, I can help you with that. Please go ahead and provide me with the text you would like me to translate.

192
00:07:39,500 --> 00:07:43,500
So, you know, we make each one of these happen to fit
所以，你知道，我们会让每一个都适应。

193
00:07:43,500 --> 00:07:44,620
precisely in one page
确切地说，需要一页纸。

194
00:07:44,620 --> 00:07:47,900
and that makes life an awful lot easier for everybody.
这使得每个人的生活都变得轻松得多。

195
00:07:47,900 --> 00:07:49,700
So it's not really that big a deal,
所以这并不是真的很重要，

196
00:07:49,700 --> 00:07:53,220
but it does add us another little constraint
但它确实给我们增加了另一个小限制。

197
00:07:53,220 --> 00:07:55,820
that we have to have a very particular organization
我们必须有一个非常特定的组织

198
00:07:55,820 --> 00:07:57,100
of our page table,
我们的页表的一部分。

199
00:07:57,100 --> 00:07:58,420
because as we're gonna talk about later,
因为正如我们稍后要讨论的那样，

200
00:07:58,420 --> 00:08:00,300
the hardware has to be able to interact with it.
硬件必须能够与其进行交互。

201
00:08:00,300 --> 00:08:02,620
So it's a little bit of a constraint,
所以这有点限制，

202
00:08:02,620 --> 00:08:05,260
but the big one, the one that really screws us up here
但是最大的问题，真正让我们在这里陷入困境的问题是什么？

203
00:08:05,260 --> 00:08:06,700
is this last point.
这是最后一个点吗？

204
00:08:06,700 --> 00:08:09,660
So the problem we have is that when you have
所以我们遇到的问题是，当你拥有的时候

205
00:08:09,660 --> 00:08:11,420
multi-level page tables,
多级页表

206
00:08:11,420 --> 00:08:14,220
then you have to kind of hunt around it.
那么你就需要在周围四处搜索一下。

207
00:08:14,220 --> 00:08:16,780
So you gotta read that first level page table first,
所以你首先需要读取那个一级页表。

208
00:08:16,780 --> 00:08:18,740
figure out where the second level one is,
找出第二层级的位置在哪里。

209
00:08:18,740 --> 00:08:21,820
and then go read the second level one to find your answer.
然后去阅读第二级的内容，找到你的答案。

210
00:08:21,820 --> 00:08:23,060
And if you have more, right,
如果你还有更多的话，对吗？

211
00:08:23,060 --> 00:08:24,780
like some things have more than two levels,
有些事情有超过两个层次，

212
00:08:24,780 --> 00:08:27,040
there's four level page tables or more,
有四级或更多级的页表。

213
00:08:27,040 --> 00:08:28,900
then it's like four hops.
然后就像是四个跳跃。

214
00:08:28,900 --> 00:08:31,420
And every time you have to follow a pointer, that's time.
每次你需要跟随一个指针，那就是时间。

215
00:08:31,420 --> 00:08:32,700
That takes time, right?
是的，那需要时间，对吗？

216
00:08:32,700 --> 00:08:35,340
Jumping around memory, chasing pointers.
跳跃在内存中，追逐指针。

217
00:08:35,340 --> 00:08:38,300
And we have to do address translation
我们需要进行地址转换。

218
00:08:38,300 --> 00:08:40,340
on every single load and store.
在每一次加载和存储操作中。

219
00:08:40,340 --> 00:08:42,740
So every time you load, every time you store,
每次你加载，每次你存储，

220
00:08:42,740 --> 00:08:43,820
including instruction,
包括指示。

221
00:08:43,820 --> 00:08:45,820
so every time you fetch the next instruction,
所以每次你获取下一条指令时，

222
00:08:45,820 --> 00:08:47,520
that's kind of like a load,
这有点像一种负担，

223
00:08:47,520 --> 00:08:49,460
you have to do address translation.
你需要进行地址翻译。

224
00:08:49,460 --> 00:08:51,660
So it's important that it be super, super fast
所以它非常重要要非常非常快速。

225
00:08:51,660 --> 00:08:53,760
and hopping around is kind of slow.
而且跳来跳去有点慢。

226
00:08:53,760 --> 00:08:55,020
So this is a big issue
这是一个大问题。

227
00:08:55,020 --> 00:08:57,300
that we're gonna have to figure out how to solve.
我们将不得不找出解决办法。

228
00:08:57,300 --> 00:09:01,220
Okay, so the next question is,
好的，下一个问题是，

229
00:09:01,220 --> 00:09:02,620
we talked about how they're organized,
我们谈论了他们的组织方式，

230
00:09:02,620 --> 00:09:04,500
what they're kind of doing at a high level.
他们在高层次上正在做的事情是什么。

231
00:09:04,500 --> 00:09:07,560
The next question is who's managing these, right?
下一个问题是谁在管理这些，对吗？

232
00:09:07,560 --> 00:09:11,220
How are you actually filling in these translations?
我是通过使用自然语言处理技术和机器学习算法来进行翻译的。我会分析你提供的中文文本，并将其转换成英文或中文，具体取决于原始文本的语言。然后，我会根据上下文和语法规则生成相应的翻译结果。请注意，虽然我会尽力提供准确的翻译，但由于语言的复杂性和多义性，翻译结果可能会有一定的误差。如果你对翻译结果有任何疑问或需要进一步的解释，请随时告诉我。

233
00:09:11,220 --> 00:09:14,500
And so we got to remember that this is an operating system.
所以我们要记住这是一个操作系统。

234
00:09:14,500 --> 00:09:17,620
The operating system's job, one of its big jobs,
操作系统的工作之一，也是其中一个重要的工作，

235
00:09:17,620 --> 00:09:19,900
is allowing multiple applications,
允许多个应用程序，

236
00:09:19,900 --> 00:09:22,740
like multiple processes to safely share a machine
喜欢多个进程安全地共享一台机器

237
00:09:22,740 --> 00:09:24,840
so they can't screw with each other, right?
所以他们不能互相捣乱，对吗？

238
00:09:24,840 --> 00:09:26,920
So like, even if you have a process
所以，即使你有一个过程

239
00:09:26,920 --> 00:09:29,300
running some sensitive information,
运行一些敏感信息，

240
00:09:29,300 --> 00:09:31,600
other processes that you're running at the same time
同时运行的其他进程

241
00:09:31,600 --> 00:09:32,640
aren't allowed to read that.
不允许阅读那个。

242
00:09:32,640 --> 00:09:34,000
So it's security.
所以这是安全问题。

243
00:09:34,000 --> 00:09:35,620
And also if one of them screws up, right?
而且，如果其中一个搞砸了，对吧？

244
00:09:35,620 --> 00:09:37,920
You have a mistake, you start writing to some random address,
您有一个错误，您开始写给一个随机地址，

245
00:09:37,920 --> 00:09:39,620
you get a segfault, whatever,
你遇到了段错误，无论如何，

246
00:09:39,620 --> 00:09:41,760
we don't wanna be able to screw everybody else up.
我们不想能够搞乱其他人。

247
00:09:41,760 --> 00:09:43,420
So if one badly written program
那么，如果一个写得很糟糕的程序

248
00:09:43,420 --> 00:09:44,780
can take your whole system down,
可以让你的整个系统崩溃，

249
00:09:44,780 --> 00:09:46,360
you kind of have a problem.
你有点问题。

250
00:09:46,360 --> 00:09:49,220
So the trick we do with most, you know,
所以我们通常用的那个技巧，你知道的，

251
00:09:49,220 --> 00:09:52,000
any sort of CPU that really supports
任何真正支持的CPU类型

252
00:09:52,000 --> 00:09:55,000
or any ISA that really supports an operating system
或者任何真正支持操作系统的ISA

253
00:09:55,000 --> 00:09:57,500
is gonna have this dual mode operation.
将会具备双模式操作。

254
00:09:57,500 --> 00:10:01,180
So instead of letting processes set up their own page tables,
所以，与其让进程自己设置页面表，

255
00:10:01,180 --> 00:10:04,960
we have kernel mode.
我们有内核模式。

256
00:10:04,960 --> 00:10:07,560
So in kernel mode, you can do anything you want, right?
在内核模式下，你可以做任何你想做的事情，对吗？

257
00:10:07,560 --> 00:10:10,740
You have super high privilege to do anything you want.
你拥有超高的特权，可以做任何你想做的事情。

258
00:10:10,740 --> 00:10:11,780
And then in user mode,
然后在用户模式下，

259
00:10:11,780 --> 00:10:13,860
there's a bunch of stuff you're not allowed to do.
有很多事情是你不被允许做的。

260
00:10:13,860 --> 00:10:15,460
And a lot of the stuff you're not allowed to do
而且有很多你不被允许做的事情。

261
00:10:15,460 --> 00:10:18,800
boils down to like what memory regions you can write
这归结为你可以写入哪些内存区域。

262
00:10:18,800 --> 00:10:21,400
and which like control registers you can set
你可以设置哪些控制寄存器？

263
00:10:21,400 --> 00:10:22,820
and things like that.
等等之类的东西。

264
00:10:22,820 --> 00:10:24,920
So when the system first boots up, it's in kernel mode,
所以当系统首次启动时，它处于内核模式下，

265
00:10:24,920 --> 00:10:27,020
when you first press that power button,
当你第一次按下那个电源按钮时，

266
00:10:27,020 --> 00:10:28,580
then your operating system loads
然后你的操作系统加载。

267
00:10:28,580 --> 00:10:30,780
and it sets up anything it wants to set up,
并且它可以设置任何它想要设置的东西，

268
00:10:30,780 --> 00:10:34,100
page tables, control bits, all this kind of junk.
页表、控制位，还有这些垃圾。

269
00:10:34,100 --> 00:10:36,820
And then it decides to run a program.
然后它决定运行一个程序。

270
00:10:36,820 --> 00:10:38,460
So it's gonna jump into that program.
所以它将会进入那个程序。

271
00:10:38,460 --> 00:10:42,600
It's gonna say, okay, let's go and execute some PC
这句话的意思是“好的，让我们去执行一些PC”。

272
00:10:42,600 --> 00:10:44,540
that represents some process.
那代表了某个过程。

273
00:10:44,540 --> 00:10:45,640
And when it does that,
而当它这样做时，

274
00:10:45,640 --> 00:10:47,880
it's gonna deselect the privilege bit.
它将取消选择特权位。

275
00:10:47,880 --> 00:10:50,020
So it's gonna turn off that privilege bit.
所以它将关闭那个特权位。

276
00:10:50,020 --> 00:10:51,580
And now we're in user mode
现在我们处于用户模式下。

277
00:10:51,580 --> 00:10:53,520
and the user's not allowed to do anything.
用户不被允许做任何事情。

278
00:10:53,520 --> 00:10:55,360
And the only way you get back to kernel mode
是通过执行特权指令。

279
00:10:55,360 --> 00:10:56,600
is through a trap.
是通过一个陷阱。

280
00:10:56,600 --> 00:10:58,380
So there might be some hardware event
所以可能会发生一些硬件事件。

281
00:10:58,380 --> 00:11:00,080
or there might be some software event that says,
或者可能有一些软件事件表明，

282
00:11:00,080 --> 00:11:02,680
hey, it's time for the kernel to do something.
嘿，是时候让内核做些什么了。

283
00:11:02,680 --> 00:11:05,540
And the kernel has registered very specific things
而内核已经注册了非常具体的事物。

284
00:11:05,540 --> 00:11:06,520
that it's allowed to do.
那是允许做的。

285
00:11:06,520 --> 00:11:09,360
So it says, if I get trap five,
那么它说，如果我得到第五个陷阱，

286
00:11:09,360 --> 00:11:11,780
then you should run this code in my kernel.
那么你应该在我的内核中运行这段代码。

287
00:11:11,780 --> 00:11:14,380
If I get trapped six, you should run that code.
如果我被困住了六次，你应该运行那段代码。

288
00:11:14,380 --> 00:11:16,120
So the user can't touch anything,
所以用户不能触碰任何东西，

289
00:11:16,120 --> 00:11:18,180
but they can hand control back to the kernel
但是他们可以将控制权交还给内核。

290
00:11:18,180 --> 00:11:19,500
in a very controlled way.
以非常受控制的方式。

291
00:11:19,500 --> 00:11:24,560
It's obviously more complicated than that.
这显然比那复杂多了。

292
00:11:24,560 --> 00:11:26,020
And there's gonna be this caveat
然后会有一个附加条件。

293
00:11:26,020 --> 00:11:27,500
through this entire lecture.
通过整个讲座。

294
00:11:27,500 --> 00:11:30,300
In this class, we're mostly focused on x86
在这个课程中，我们主要关注x86。

295
00:11:30,300 --> 00:11:33,820
because that's the one you're using in your projects.
因为那是你在你的项目中使用的那个。

296
00:11:33,820 --> 00:11:38,120
And basically x86 is like thousands and thousands of pages
基本上，x86就像是成千上万页的内容。

297
00:11:38,120 --> 00:11:40,080
for its instruction manual.
为了它的使用说明书。

298
00:11:40,080 --> 00:11:42,840
It's old, it's grown very organically.
它很古老，它的发展非常有机。

299
00:11:42,840 --> 00:11:45,860
And so things tend to get a little complicated.
所以事情往往会变得有点复杂。

300
00:11:45,860 --> 00:11:46,940
Not too important to know,
不是太重要知道的，

301
00:11:46,940 --> 00:11:50,180
but what you can realize is that
但你能意识到的是

302
00:11:50,180 --> 00:11:51,680
we have a lot of flexibility here.
我们这里非常灵活。

303
00:11:51,680 --> 00:11:54,060
So traditionally ring zero would be kernel mode,
所以传统上，零环将是内核模式，

304
00:11:54,060 --> 00:11:55,780
ring three is user mode.
环三是用户模式。

305
00:11:55,780 --> 00:11:58,660
There's a ring one and two that nobody really uses.
有一个环形的一和二，没人真正使用。

306
00:11:58,660 --> 00:12:02,580
And then when they wanted to add hypervisors, yeah, right.
然后当他们想要添加虚拟化软件时，是的，没错。

307
00:12:02,580 --> 00:12:05,120
And then there's minus one and there's more, right?
然后还有负一和更多的数，对吗？

308
00:12:05,120 --> 00:12:08,160
Yeah, like there's minus three that Michael's mentioning.
是的，就像迈克尔提到的那样，有一个负三。

309
00:12:08,160 --> 00:12:11,260
In RISC-V, what you have are also different modes.
在RISC-V中，你也有不同的模式。

310
00:12:11,260 --> 00:12:13,500
I don't think they call them rings in RISC-V,
我不认为他们在RISC-V中称之为"rings"。

311
00:12:13,500 --> 00:12:14,780
but you have machine mode,
但你有机器模式，

312
00:12:14,780 --> 00:12:17,420
which is kind of like this Intel management engine
这有点像英特尔管理引擎。

313
00:12:17,420 --> 00:12:20,420
style thing where you're setting up
风格的事情，你正在设置中。

314
00:12:20,420 --> 00:12:22,260
very, very, very low level stuff.
非常、非常、非常低级的东西。

315
00:12:22,260 --> 00:12:24,420
It's where you might like emulate instructions
这是你可能喜欢模仿指示的地方。

316
00:12:24,420 --> 00:12:27,280
that you haven't implemented or other stuff like that.
你还没有实施或其他类似的东西。

317
00:12:27,280 --> 00:12:29,580
And then there's supervisor mode where the kernel runs
然后还有监管模式，内核在其中运行。

318
00:12:29,580 --> 00:12:31,300
and then there's user mode.
然后还有用户模式。

319
00:12:31,300 --> 00:12:33,020
And I actually don't know a lot about
而实际上，我对这个并不了解很多。

320
00:12:33,020 --> 00:12:34,960
how RISC-V handles hypervisors.
RISC-V如何处理虚拟化监控程序。

321
00:12:34,960 --> 00:12:37,020
So I can't talk too much about that.
所以我不能谈太多关于那个的事情。

322
00:12:37,020 --> 00:12:39,680
But the point is that the CPU has control modes.
但关键是CPU有控制模式。

323
00:12:39,680 --> 00:12:40,620
They have protection modes
他们有保护模式

324
00:12:40,620 --> 00:12:42,880
and that's how operating systems work in practice.
这就是操作系统在实践中的工作原理。

325
00:12:42,880 --> 00:12:44,080
That's how they're safe.
这就是他们的安全方式。

326
00:12:44,080 --> 00:12:49,460
Okay, we're gonna just take a quick detour
好的，我们只是要稍微绕道一下。

327
00:12:49,460 --> 00:12:50,300
into segmentation.
分割。

328
00:12:50,300 --> 00:12:52,460
I just talked about how Intel's got all sorts
我刚刚谈到了英特尔拥有各种各样的东西。

329
00:12:52,460 --> 00:12:54,900
of old stuff floating around in it.
里面漂浮着很多旧东西。

330
00:12:54,900 --> 00:12:59,340
And one of those old, moldy old things is segmentation.
其中一个古老而陈旧的事物就是细分。

331
00:12:59,340 --> 00:13:02,020
It's not really used a lot these days,
这个东西现在并不是很常用。

332
00:13:02,020 --> 00:13:03,920
but it does still exist.
但它确实仍然存在。

333
00:13:03,920 --> 00:13:06,180
So just real quickly, I think this slide will be
所以很快地，我认为这张幻灯片会是...

334
00:13:06,180 --> 00:13:08,740
mostly good for your reference after.
主要是供您参考的。

335
00:13:08,740 --> 00:13:10,500
So I'm gonna go through it real quick.
所以我会快速浏览一下。

336
00:13:10,500 --> 00:13:14,140
But x86 supports a bunch of different segments.
但是x86支持许多不同的段。

337
00:13:14,140 --> 00:13:16,180
You have these registers.
你有这些登记册。

338
00:13:16,180 --> 00:13:18,020
So registers are right in your pipeline.
所以寄存器在你的流水线中是正确的。

339
00:13:18,020 --> 00:13:19,600
They're right next to your CPU.
它们就在你的CPU旁边。

340
00:13:19,600 --> 00:13:20,980
So you can't have very many of them
所以你不能有很多个。

341
00:13:20,980 --> 00:13:22,420
and they can't be too complicated
并且它们不能太复杂。

342
00:13:22,420 --> 00:13:24,980
'cause you have like limited number of bits,
因为你只有有限的比特数，

343
00:13:24,980 --> 00:13:26,900
limited number of wires and flip-flops
有限数量的电线和触发器

344
00:13:26,900 --> 00:13:29,580
and whatever right next to your CPU.
以及紧挨着你的CPU的任何东西。

345
00:13:29,580 --> 00:13:31,540
So you can't have too many.
所以你不能有太多。

346
00:13:31,540 --> 00:13:33,380
So what they do is they have a register
所以他们做的是他们有一个注册

347
00:13:33,380 --> 00:13:35,580
to represent segments.
表示分段。

348
00:13:35,580 --> 00:13:38,420
And then that register is actually a pointer
然后那个寄存器实际上是一个指针。

349
00:13:38,420 --> 00:13:43,280
to a more rich description of the segment that you want.
对于您所需的片段，提供更丰富的描述。

350
00:13:43,280 --> 00:13:46,680
And then that segment has a whole bunch of details in it
然后那个部分有很多细节。

351
00:13:46,680 --> 00:13:47,620
about the segment.
关于这个片段。

352
00:13:47,620 --> 00:13:48,980
So it's got permission bits.
所以它有权限位。

353
00:13:48,980 --> 00:13:51,860
It's got a base and a limit,
它有一个基准和一个限制，

354
00:13:51,860 --> 00:13:54,880
which is the bottom line for segments.
底线是指分段的底部。

355
00:13:54,880 --> 00:13:57,000
You notice that the address bits
你注意到地址位。

356
00:13:57,000 --> 00:13:59,200
are spread around in funny places.
散落在有趣的地方。

357
00:13:59,200 --> 00:14:00,980
You might remember from 61C,
你可能还记得61C课程中的内容，

358
00:14:00,980 --> 00:14:03,900
how RISC-V does the same thing for, I think loads,
RISC-V如何为我认为的许多任务提供相同的功能？

359
00:14:03,900 --> 00:14:05,420
like certain loads or certain jumps
像某些负载或某些跳跃一样

360
00:14:05,420 --> 00:14:07,140
have kind of a funny layout.
布局有点滑稽。

361
00:14:07,140 --> 00:14:10,060
And these are all just micro architectural details.
这些只是微观架构的细节。

362
00:14:10,060 --> 00:14:11,700
At the time when they wrote this,
当他们写这篇文章的时候，

363
00:14:11,700 --> 00:14:15,260
it was easier to put this wire here or that wire there.
将这根电线放在这里或者将那根电线放在那里都更容易。

364
00:14:15,260 --> 00:14:18,220
It tends to be sort of boring reasons that it's shaped funny.
它往往是因为形状奇怪而显得有点无聊。

365
00:14:18,220 --> 00:14:22,660
And you can come back to this slide
你可以回到这张幻灯片。

366
00:14:22,660 --> 00:14:24,760
to understand what all these bits do.
理解这些位元的作用。

367
00:14:24,760 --> 00:14:26,640
But let's just quickly talk about
但是我们先快速谈谈关于

368
00:14:26,640 --> 00:14:28,660
what they're actually used for.
它们实际上用于什么。

369
00:14:28,660 --> 00:14:33,060
So there's different ways that you can use the segments.
所以有不同的方法可以使用这些片段。

370
00:14:33,060 --> 00:14:36,220
The most common use originally was in
最常见的用法最初是在...中。

371
00:14:36,220 --> 00:14:39,340
the old, old, old 16 bit version of x86.
x86的古老、古老、古老的16位版本。

372
00:14:39,340 --> 00:14:43,320
The very first time people were writing 16 bit processors,
人们第一次编写16位处理器时，

373
00:14:43,320 --> 00:14:45,100
having more than a few kilobytes of memory
拥有超过几千字节的内存

374
00:14:45,100 --> 00:14:46,680
was a ridiculous concept, right?
是一个荒谬的概念，对吗？

375
00:14:46,680 --> 00:14:49,280
Nobody, having a megabyte of memory was insane.
没有人，拥有一兆字节的内存是疯狂的。

376
00:14:49,280 --> 00:14:51,480
Nobody ever thought that could happen, right?
没有人曾经想过那可能发生，对吗？

377
00:14:51,480 --> 00:14:54,880
And so they had this 16 bit addressing mode
然后他们有了这个16位寻址模式。

378
00:14:54,880 --> 00:14:57,000
and they had a lot of segments.
并且它们有很多部分。

379
00:14:57,000 --> 00:14:58,820
Again, you can't have page tables
再次强调，你不能拥有页面表。

380
00:14:58,820 --> 00:15:01,420
if you only have like less than a kilobyte of memory.
如果你只有不到一千字节的内存。

381
00:15:01,420 --> 00:15:04,880
So they would use segments originally.
所以他们最初会使用片段。

382
00:15:04,880 --> 00:15:09,760
Then, okay, we use the word modern here loosely.
那么，好的，我们这里使用"现代"这个词比较宽泛。

383
00:15:09,760 --> 00:15:13,120
Most application level sorts of processors
大多数应用级别的处理器

384
00:15:13,120 --> 00:15:14,960
are 64 bit these days,
现在的电脑都是64位的。

385
00:15:14,960 --> 00:15:16,560
but some embedded low power,
但是一些嵌入式低功耗设备，

386
00:15:16,560 --> 00:15:18,680
that kind of stuff would be 32 bit.
这种东西应该是32位的。

387
00:15:18,680 --> 00:15:22,040
I don't think there's a lot of 32 bit x86 processors
我认为32位x86处理器并不多。

388
00:15:22,040 --> 00:15:23,660
out there, but in RISC-V,
在外面，但在RISC-V中，

389
00:15:23,660 --> 00:15:26,800
there's lots of 32 bit RISC-V processors floating around.
有很多32位的RISC-V处理器在市面上流通。

390
00:15:26,800 --> 00:15:28,720
So in this case,
那么在这种情况下，

391
00:15:28,720 --> 00:15:30,820
they kind of weakened the segmentation support.
他们在一定程度上削弱了分割支持。

392
00:15:30,820 --> 00:15:32,640
It's still there, but not great.
还在，但不是很好。

393
00:15:32,640 --> 00:15:35,000
The one exception is thread local storage.
唯一的例外是线程本地存储。

394
00:15:35,000 --> 00:15:40,000
So a process is not like a super precise concept.
所以一个过程不像一个非常精确的概念。

395
00:15:40,000 --> 00:15:41,240
I mean, it is in the spec,
我的意思是，这在规格中有明确说明。

396
00:15:41,240 --> 00:15:45,200
but a process is just some sort of logically connected set
但是一个过程只是一种逻辑上相互连接的集合。

397
00:15:45,200 --> 00:15:47,760
of things that all share most of their resources.
所有这些事物共享大部分资源。

398
00:15:47,760 --> 00:15:49,840
So they have one process ID.
所以他们有一个进程ID。

399
00:15:49,840 --> 00:15:51,180
They most, for the most part,
他们大多数时候，大部分时间，

400
00:15:51,180 --> 00:15:53,840
they have one set of like virtual addresses,
他们有一组类似虚拟地址的地址。

401
00:15:53,840 --> 00:15:55,040
things like that.
这样的事情。

402
00:15:55,040 --> 00:15:56,840
But sometimes it's handy to have a little bit
但有时候拥有一点点是很方便的。

403
00:15:56,840 --> 00:15:59,360
of private memory space per thread.
每个线程的私有内存空间为X。

404
00:15:59,360 --> 00:16:02,420
The threads in this case are like different PCs
这个案例中的线程就像不同的个人电脑。

405
00:16:02,420 --> 00:16:05,220
that you could potentially be jumping between, right?
你是指你可能会在其中跳来跳去，对吗？

406
00:16:05,220 --> 00:16:10,220
So different program counters into the same basic program.
所以不同的程序计数器进入同一个基本程序。

407
00:16:10,800 --> 00:16:15,660
So on x86, they use segments in order to implement that.
所以在x86上，他们使用段来实现这个功能。

408
00:16:15,660 --> 00:16:17,400
On RISC-V, they do something different.
在RISC-V上，他们做了一些不同的事情。

409
00:16:17,400 --> 00:16:18,980
I actually was looking for that earlier.
我之前确实在找那个。

410
00:16:18,980 --> 00:16:19,820
I couldn't find it.
我找不到它。

411
00:16:19,820 --> 00:16:22,120
So I'm not sure how RISC-V implements thread local storage,
所以我不确定RISC-V如何实现线程本地存储。

412
00:16:22,120 --> 00:16:24,760
but I'm sure it's not with segments.
但我确定它不是用分段的方式。

413
00:16:24,760 --> 00:16:26,720
And then on 64 bit mode,
然后在64位模式下，

414
00:16:26,720 --> 00:16:30,480
which is the most common x86 mode today,
当今最常见的x86模式是什么？

415
00:16:30,480 --> 00:16:32,200
they have been basically nerfed.
他们基本上被削弱了。

416
00:16:32,200 --> 00:16:36,620
So like they work in like the most limited possible way,
所以他们以最有限的方式工作，

417
00:16:36,620 --> 00:16:38,600
except again for thread local storage,
除了线程本地存储之外，

418
00:16:38,600 --> 00:16:40,640
which still gets used.
仍然在使用。

419
00:16:40,640 --> 00:16:43,560
But otherwise, just keep in mind segments kind of made sense
但是其他方面，只要记住片段的意思就可以了。

420
00:16:43,560 --> 00:16:45,820
when you had very, very little memory.
当你的记忆非常非常有限的时候。

421
00:16:45,820 --> 00:16:47,480
And they make a lot less sense
而且它们没有多少意义。

422
00:16:47,480 --> 00:16:49,760
as your virtual address space starts to get bigger
随着您的虚拟地址空间变得越来越大

423
00:16:49,760 --> 00:16:52,740
and you need like more and more flexible management
你需要更加灵活的管理方式。

424
00:16:52,740 --> 00:16:55,080
and you have enough memory where the memory overhead
并且你有足够的内存来处理内存开销。

425
00:16:55,080 --> 00:16:56,880
of keeping a bunch of page tables around
保留一堆页表的好处是什么？

426
00:16:56,880 --> 00:16:57,940
isn't gonna kill you.
不会杀了你。

427
00:16:57,940 --> 00:17:02,140
Okay, so enough about segmentation.
好的，关于细分就说到这里吧。

428
00:17:02,140 --> 00:17:03,440
Coming back to paging,
回到分页的话题，

429
00:17:03,440 --> 00:17:06,760
I mentioned that you could have more than two levels, right?
我提到过你可以有超过两个层级，对吗？

430
00:17:06,760 --> 00:17:10,080
So if two levels is good, then four levels is gooder.
如果两个层级好，那么四个层级就更好了。

431
00:17:10,080 --> 00:17:11,760
And there's really nothing different here.
这里真的没有什么不同。

432
00:17:11,760 --> 00:17:13,700
So there's nothing special.
所以没有什么特别的。

433
00:17:13,700 --> 00:17:16,400
You know, whatever you learned about two level page tables,
你知道，无论你学到了关于两级页表的什么知识，

434
00:17:16,400 --> 00:17:18,660
just like recurse on that a couple more times
就像再递归几次那样。

435
00:17:18,660 --> 00:17:21,240
and you've got multi-level page tables.
你有多级页表。

436
00:17:21,240 --> 00:17:23,040
So you still have your base here,
所以你还在这里有你的基地，

437
00:17:23,040 --> 00:17:25,420
you have your top level page table,
你有你的顶层页表，

438
00:17:25,420 --> 00:17:28,520
that is gonna point into some lower level page table,
这将指向一些较低级的页表。

439
00:17:28,520 --> 00:17:30,800
which is sort of like this one.
这个有点像这个。

440
00:17:30,800 --> 00:17:32,880
And now it points here and then it points here.
现在它指向这里，然后又指向这里。

441
00:17:32,880 --> 00:17:35,200
And then finally you get your PTE here.
然后最后你在这里获得你的PTE成绩。

442
00:17:35,200 --> 00:17:37,240
So it's not fundamentally different in any way
所以它在任何方面都没有根本上的不同。

443
00:17:37,240 --> 00:17:38,500
than a two level page table.
比一个两级页表更好。

444
00:17:38,500 --> 00:17:40,040
You just have more hops.
你只是有更多的跳跃力。

445
00:17:40,040 --> 00:17:41,200
And that's gonna keep shrinking
而且这将会持续缩小。

446
00:17:41,200 --> 00:17:43,240
this top level page table, right?
是的，这是顶层页表。

447
00:17:43,240 --> 00:17:44,600
Every time you add a hop,
每次你添加一个跳跃点，

448
00:17:44,600 --> 00:17:47,400
that's gonna exponentially drop the number of entries
这将指数级地减少参赛人数。

449
00:17:47,400 --> 00:17:49,560
you have to have here, which can be handy.
你必须在这里有一个，这可能会很方便。

450
00:17:49,560 --> 00:17:53,720
But again, otherwise nothing special,
但是除此之外，没有什么特别的。

451
00:17:53,720 --> 00:17:55,000
just like you saw before.
就像你之前看到的一样。

452
00:17:55,000 --> 00:17:58,080
You keep going, right?
你会继续前进，对吗？

453
00:17:58,080 --> 00:18:00,780
So, all right, well, we had four, why don't we do six?
好的，我们本来有四个，为什么不做六个呢？

454
00:18:00,780 --> 00:18:04,080
It starts to get ridiculous, basically.
开始变得荒谬了，基本上。

455
00:18:04,080 --> 00:18:06,120
I mean, there are drawbacks, right?
我的意思是，有一些缺点，对吧？

456
00:18:06,120 --> 00:18:08,880
We talked about having to do all this pointer hopping, right?
我们谈到过要做所有这些指针跳转的事情，对吗？

457
00:18:08,880 --> 00:18:10,760
You have to keep following through each level
你必须继续跟进每个层次。

458
00:18:10,760 --> 00:18:12,120
and that takes time.
这需要时间。

459
00:18:12,120 --> 00:18:14,000
There's a point where you're just not saving anything.
有一个点，你就是在浪费。

460
00:18:14,000 --> 00:18:15,240
It just starts to get out of hand.
它刚刚开始失控了。

461
00:18:15,240 --> 00:18:18,640
So six level page tables aren't really common.
所以六级页表并不常见。

462
00:18:18,640 --> 00:18:19,880
I think Itanium might have.
我认为Itanium可能有。

463
00:18:19,880 --> 00:18:23,900
Itanium was an attempt by Intel to create a new ISA.
Itanium是英特尔试图创建一种新的ISA。

464
00:18:23,900 --> 00:18:25,400
It went horrifically wrong.
它出了严重的问题。

465
00:18:25,400 --> 00:18:29,280
It's a long and tragic story and somewhat funny
这是一个又长又悲惨的故事，有点好笑。

466
00:18:29,280 --> 00:18:32,720
involving lawsuits between Hewlett-Packard and Intel.
涉及惠普和英特尔之间的诉讼。

467
00:18:32,720 --> 00:18:35,880
And it's a great story that I won't tell you now.
这是一个很棒的故事，我现在不会告诉你。

468
00:18:35,880 --> 00:18:39,000
But basically, they did a lot of crazy things
但基本上，他们做了很多疯狂的事情。

469
00:18:39,000 --> 00:18:40,320
and some of them didn't work out,
其中一些并没有成功，

470
00:18:40,320 --> 00:18:42,320
including six level page tables.
包括六级页表。

471
00:18:42,320 --> 00:18:44,960
Okay, so what else can we do?
好的，我们还能做什么呢？

472
00:18:44,960 --> 00:18:47,520
And then this is, I'm gonna ask for a little bit
然后这个是，我要求一点点。

473
00:18:47,520 --> 00:18:50,760
of audience thought here, if not participation.
听众在这里是被动的，没有参与。

474
00:18:50,760 --> 00:18:54,160
So the problem we're facing here is that
我们在这里面临的问题是

475
00:18:54,160 --> 00:18:59,520
these page tables have drawbacks.
这些页表有缺点。

476
00:18:59,520 --> 00:19:02,760
You have to have an entry for every virtual memory address.
你必须为每个虚拟内存地址都有一个条目。

477
00:19:02,760 --> 00:19:04,400
So there's still a lot of space.
所以还有很多空间。

478
00:19:04,400 --> 00:19:07,480
Every process gets their own page table.
每个进程都有自己的页表。

479
00:19:07,480 --> 00:19:09,640
And even with multi-level page tables,
即使使用多级页表，

480
00:19:09,640 --> 00:19:11,640
you still have a lot of empty spots.
你还有很多空位。

481
00:19:11,640 --> 00:19:15,520
And typically your address space is way, way bigger
通常情况下，你的地址空间要大得多。

482
00:19:15,520 --> 00:19:17,360
than your physical memory, right?
比你的物理内存更大，对吗？

483
00:19:17,360 --> 00:19:21,440
You might have two for 32 gigs of RAM,
你可能有两个32GB的内存条。

484
00:19:21,440 --> 00:19:24,240
but you've got two to the 64 virtual addresses.
但是你有2的64次方个虚拟地址。

485
00:19:24,240 --> 00:19:26,080
So it's not even a competition.
所以这根本不是竞争的问题。

486
00:19:26,080 --> 00:19:27,860
So the question for you guys is,
那么，对于你们来说的问题是，

487
00:19:27,860 --> 00:19:31,440
let's look at what is the problem we're trying to solve?
让我们来看看我们试图解决的问题是什么？

488
00:19:31,440 --> 00:19:33,600
The problem is given a virtual address,
问题是给定一个虚拟地址，

489
00:19:33,600 --> 00:19:37,560
I want to be able to map that to a physical address.
我想要能够将其映射到一个物理地址。

490
00:19:37,560 --> 00:19:40,020
So one of the data structures we thought about
所以我们考虑的数据结构之一是什么？

491
00:19:40,020 --> 00:19:41,520
for doing that was a tree.
因为那是一棵树。

492
00:19:41,520 --> 00:19:45,600
Trees have this login sort of traversal pattern,
树具有这种类似登录的遍历模式，

493
00:19:45,600 --> 00:19:48,320
and they have these properties,
而且它们具有以下特性：

494
00:19:48,320 --> 00:19:50,600
but we wanna have better than login, right?
但是我们想要比登录更好的东西，对吗？

495
00:19:50,600 --> 00:19:52,920
We'd like to have fewer pointer chases.
我们希望减少指针追踪。

496
00:19:52,920 --> 00:19:59,360
we want a faster look at. So what data structure might we consider that isn't a table? We have a
我们希望能够更快地查看。那么，除了表格之外，我们应该考虑哪种数据结构？我们有...

497
00:19:59,360 --> 00:20:04,400
lot of data structures. Y'all took, I guess it's 61b that teaches you these. So I'm going to give
很多数据结构。你们学的应该是61b，它教授这些内容。所以我要给你们提供一些。

498
00:20:04,400 --> 00:20:19,680
you 10 seconds to think up what data structure you would use other than a tree. And we got it.
你有10秒钟的时间来想出除了树以外的数据结构。我们想到了。

499
00:20:19,680 --> 00:20:26,720
Hash tables are super cool. So hash tables are great. They've got constant access time,
哈希表非常酷。所以哈希表很棒。它们具有常数时间的访问速度，

500
00:20:26,720 --> 00:20:32,800
at least, you know, big O constant access time. And we can do some cool tricks with these. So
至少，你知道，大O常数访问时间。而且我们可以用这些做一些很酷的技巧。所以

501
00:20:32,800 --> 00:20:38,400
one of the things we do here is we can have a hash table where it has an entry for every
我们这里做的一件事是可以使用哈希表，其中每个条目都有一个

502
00:20:38,400 --> 00:20:44,080
physical page. Like we don't need more virtual addresses mapped than we have physical memory
物理页面。就像我们不需要将更多的虚拟地址映射到物理内存中一样。

503
00:20:44,080 --> 00:20:49,360
because like it doesn't make sense. You can't map, you know, more than physical memory anyways,
因为这样没有意义。无论如何，你都不能映射超过物理内存的内容。

504
00:20:49,360 --> 00:20:54,800
because you only have that much memory. So you can have one hash table for the entire system.
因为你只有那么多的内存。所以你可以为整个系统只有一个哈希表。

505
00:20:54,800 --> 00:20:59,520
And you can use that to look up your virtual page. So you can index into this hash table using
然后你可以使用它来查找你的虚拟页面。这样你就可以使用哈希表进行索引。

506
00:20:59,520 --> 00:21:04,240
virtual page number and get this physical page number back. And this has been used before,
虚拟页号并获取对应的物理页号。这个方法之前已经被使用过了。

507
00:21:04,240 --> 00:21:09,120
right? This is nice when you have these big address spaces, these big virtual address spaces.
对吗？当你拥有这些大的地址空间时，这是很好的，这些大的虚拟地址空间。

508
00:21:09,120 --> 00:21:15,200
And so it has been used in a couple of places and it has some nice properties, but it's not perfect
所以它已经在一些地方使用过，并且具有一些不错的特性，但它并不完美。

509
00:21:15,200 --> 00:21:21,600
either. So the big problem here, there's two big problems here. Actually probably three big
问题。首先，这里存在两个大问题。实际上可能有三个大问题。

510
00:21:21,600 --> 00:21:26,880
problems here, but we're going to list two of them here. One is that keep in mind from your
这里有一些问题，但我们将在这里列举其中两个。一个是要记住从你的角度出发。

511
00:21:26,880 --> 00:21:33,040
algorithms classes and stuff, the limitations of big O notation, right? We say, oh, constants don't
算法课程和相关内容，还有大O符号的局限性，对吗？我们说，哦，常数不重要。

512
00:21:33,040 --> 00:21:39,920
matter in terms of asymptotic complexity, but like insertion sort is way faster than quick sort
在渐近复杂度方面，插入排序确实比快速排序要快得多。

513
00:21:39,920 --> 00:21:44,000
for a small enough list, right? When you were doing merge sort, there was a point where you
对于足够小的列表，对吗？当你进行归并排序时，有一个点在那里你需要停止拆分列表。

514
00:21:44,000 --> 00:21:49,360
bottomed out on merge sort and just switched to like selection sort or insertion sort. And the
我在归并排序上遇到了瓶颈，所以切换到了选择排序或插入排序。而且

515
00:21:49,360 --> 00:21:53,360
same thing applies here. There's a point where the complexity of looking at the hash table,
同样的道理也适用于这里。在查看哈希表的复杂性达到一定程度时，

516
00:21:53,360 --> 00:21:57,920
the constants involved algorithmically and looking at the hash table are actually going to outweigh
算法中涉及的常数和查找哈希表的开销实际上会超过预期。

517
00:21:57,920 --> 00:22:03,600
the benefits. So that can happen. This is particularly true in hardware.
好处。这样就可以发生。这在硬件方面尤为真实。

518
00:22:03,600 --> 00:22:09,360
So because these lookups are happening on every access, we need to do that in hardware. So we're
因为这些查找操作在每次访问时都会发生，所以我们需要在硬件上进行。所以我们正在

519
00:22:09,360 --> 00:22:15,680
actually designing a circuit, a digital logic to access this hash table. And so, you know,
实际上是设计一个电路，一个数字逻辑来访问这个哈希表。所以，你知道的，

520
00:22:15,680 --> 00:22:20,800
it has to be sufficiently simple that you can implement that in hardware. So that's a problem.
它必须足够简单，以便你可以在硬件中实现。这是一个问题。

521
00:22:20,800 --> 00:22:25,680
The other problem is locality. So hash tables kind of by their very nature, right? That's what
另一个问题是局部性。所以哈希表本质上是这样的，对吗？

522
00:22:25,680 --> 00:22:31,360
a hash function does is it's pretty random. It's pretty evenly distributed. There's no locality. So
哈希函数的作用是生成相当随机的结果。它的分布相当均匀，没有局部性。所以

523
00:22:31,360 --> 00:22:37,040
I can't like effectively cache this hash table. Every lookup is going to be in a pretty random
我无法有效地缓存这个哈希表。每次查找都会是相当随机的。

524
00:22:37,040 --> 00:22:41,360
spot in this hash table. So it's not very cache friendly. And that's pretty annoying.
在这个哈希表中找到一个位置。所以它不太友好地缓存。这真的很烦人。

525
00:22:41,360 --> 00:22:48,960
The third problem here actually is that it makes things like sharing really difficult. So this
第三个问题实际上是它使得分享这样的事情变得非常困难。所以这个问题是

526
00:22:48,960 --> 00:22:53,760
assumes there's only ever one virtual page, virtual address mapped to a physical page.
假设只有一个虚拟页面，虚拟地址映射到一个物理页面。

527
00:22:53,760 --> 00:22:58,880
But for sharing, we might want to have multiple virtual addresses point to the same physical
但是为了共享，我们可能希望有多个虚拟地址指向同一个物理地址。

528
00:22:58,880 --> 00:23:02,640
address. And so that makes this a lot more complicated if you want to do that.
地址。所以如果你想这样做，会变得更加复杂。

529
00:23:03,280 --> 00:23:07,600
Nonetheless, it's still pretty handy and people have used them in the past, but they're not
然而，它仍然非常方便，人们过去曾经使用过它们，但它们并不是

530
00:23:07,600 --> 00:23:13,760
especially popular in processors today. I'm not aware of any, you know, mega really popular
特别受欢迎的处理器，尤其是当今的处理器。我不知道有任何，你知道的，超级受欢迎的处理器。

531
00:23:13,760 --> 00:23:20,960
processor. I guess PowerPC might still be around. Okay. So we've got options here. We've got a whole
处理器。我猜PowerPC可能还在使用。好的。所以我们有选择的余地。我们有很多选项。

532
00:23:20,960 --> 00:23:25,120
bunch of options and how we can do paging. At the end of the day, we're all trying to solve the same
一堆选项以及我们如何进行分页。归根结底，我们都在努力解决同样的问题。

533
00:23:25,120 --> 00:23:29,840
problem. You have some address, some virtual address, and you want to map it to some physical
问题。你有一些地址，一些虚拟地址，你想将它映射到一些物理地址。

534
00:23:29,840 --> 00:23:34,480
address. That's it. That's all we're trying to do. Right. And these are a bunch of different
地址。就是这样。这就是我们要做的全部。对的。而且这些是一堆不同的

535
00:23:34,480 --> 00:23:38,080
algorithms and data structures that we could consider using in order to do that.
我们可以考虑使用的算法和数据结构来实现这个目标。

536
00:23:38,080 --> 00:23:44,320
So we've got segmentation. Segmentation's great for simplicity in terms of implementing a CPU,
所以我们有了分段。分段对于实现CPU来说非常简单。

537
00:23:44,320 --> 00:23:49,760
doesn't use too much memory for the metadata, but it's very hard to allocate all these arbitrary
不会使用太多的内存来存储元数据，但是很难分配所有这些任意的。

538
00:23:49,760 --> 00:23:54,640
size things. And it really screws with your ability to share memory and allocate memory.
大小事物。这真的会影响你分享内存和分配内存的能力。

539
00:23:56,240 --> 00:23:59,920
Paging works a lot better. It's a lot more flexible. It's a lot easier to allocate.
分页功能效果更好。它更加灵活。分配起来更容易。

540
00:23:59,920 --> 00:24:04,720
But if you have single level page tables, you can really fill up your memory for a lot of empty
但是如果你使用单级页表，你可以真正填满很多空闲的内存空间。

541
00:24:04,720 --> 00:24:10,960
space. So we use multi-level paging to get around that. Or you could avoid all of this sort of tree
空间。所以我们使用多级分页来解决这个问题。或者你可以避免所有这种树形结构。

542
00:24:10,960 --> 00:24:15,760
walking and use an inverted page table, which works pretty great, but has limitations of its own.
使用反向页表进行行走，效果非常好，但也有自己的限制。

543
00:24:15,760 --> 00:24:23,200
Okay. So enough about the high level strategies and the problem we're trying to solve.
好的。关于高层战略和我们要解决的问题就说到这里。

544
00:24:23,200 --> 00:24:28,000
Let's get into the nitty gritty. Let's start talking about how you might actually physically
让我们深入细节吧。让我们开始讨论你可能如何实际地进行身体上的操作。

545
00:24:28,000 --> 00:24:34,320
implement this. How does this work in practice? So the thing that is in charge of this is called
实施这个。这在实践中是如何工作的？所以负责这个的东西被称为什么？

546
00:24:34,320 --> 00:24:42,000
the MMU. So this is the part of your architecture, the part of your CPU or your chip that is
内存管理单元（MMU）。所以这是你的架构的一部分，也是你的CPU或芯片的一部分。

547
00:24:42,000 --> 00:24:47,120
responsible for handling this virtual address to physical address translation. So we call that the
负责处理这个虚拟地址到物理地址的转换。所以我们称之为

548
00:24:47,120 --> 00:24:53,680
memory management unit. Everyone just says MMU. And it's the one that's in charge of all of this.
内存管理单元。大家都说MMU。它负责所有这些事情。

549
00:24:53,680 --> 00:24:59,920
So it needs to do different things. We're going to focus on paging. So we're going to focus on
所以它需要做不同的事情。我们将专注于分页。所以我们将专注于分页。

550
00:24:59,920 --> 00:25:05,760
page tables probably from now on because it's by far the most common approach, at least in
页表，从现在开始可能会成为最常见的方法，至少在目前来看是如此。

551
00:25:05,760 --> 00:25:11,440
the sort of high end or medium end application processors that you're likely to see.
你可能会看到的高端或中端应用处理器。

552
00:25:12,400 --> 00:25:17,200
So if you have page tables, the MMU is going to have to do the walk. So it's going to walk
所以如果你有页表，MMU就必须进行遍历。所以它会进行遍历。

553
00:25:17,200 --> 00:25:22,800
that tree in hardware. So it reads the page table entry, the PTE from the first level page table,
硬件中的那棵树。因此，它读取了来自一级页表的页表项，即PTE。

554
00:25:22,800 --> 00:25:28,320
checks all the metadata that it needs. And then it goes and finds the address in the second level
检查所有所需的元数据。然后它会去找到第二级的地址。

555
00:25:28,320 --> 00:25:34,400
page table, looks that up, iterates as many times as it needs, gets the final PTE, and then it can
页表，查找它，根据需要迭代多次，获取最终的页表项（PTE），然后就可以了。

556
00:25:34,400 --> 00:25:38,960
form the actual physical address and send that request out to the rest of the memory system.
将实际物理地址形成，并将该请求发送到其余的内存系统。

557
00:25:39,520 --> 00:25:44,000
So the MMU is just translating. Logically, the CPU doesn't know about physical addresses.
所以MMU只是在进行翻译。从逻辑上讲，CPU并不知道物理地址。

558
00:25:44,000 --> 00:25:51,200
So the CPU is just issuing virtual addresses and automagically, the MMU is making them
所以CPU只是发出虚拟地址，然后MMU会自动将其转换成实际物理地址。

559
00:25:51,200 --> 00:25:58,000
behave like physical addresses. Okay. So it's doing this at every, at least conceptually,
表现得像物理地址。好的。所以至少在概念上，它在每个地方都这样做。

560
00:25:58,000 --> 00:26:02,800
it's got to do this all the time. Every single time you do a read or write, and that includes
它必须一直这样做。每次进行读取或写入操作时都要这样，包括

561
00:26:02,800 --> 00:26:07,600
fetching the next instruction, that MMU has to do that translation in order to get to memory.
获取下一条指令时，MMU必须进行翻译以便访问内存。

562
00:26:08,560 --> 00:26:16,720
So this is a bit more of a physical representation of it. You can see you've got all these buses
所以这更像是一个物理的表现。你可以看到有所有这些公交车。

563
00:26:16,720 --> 00:26:22,400
floating around. So you've got your core, your core CPU pipeline, you've got a bunch of buses,
漂浮着。所以你有你的核心，你的核心CPU流水线，你有一堆总线，

564
00:26:22,400 --> 00:26:27,520
and they're going through these hardware blocks. And if you take 152, you're going to see a lot
他们正在处理这些硬件模块。如果你选择152，你会看到很多。

565
00:26:27,520 --> 00:26:36,960
more of this, or maybe some of your digital logic classes. A lot of this can take time. So loads and
更多这样的内容，或者也可以一些你的数字逻辑课程。这些内容可能需要花费很多时间。所以需要很多。

566
00:26:36,960 --> 00:26:41,840
stores, if they hit in the cache, can be really fast. Maybe they don't stall the pipeline too bad.
存储器，如果在缓存中命中，可以非常快速。也许它们不会对流水线造成太大的停顿。

567
00:26:41,840 --> 00:26:46,080
But if you miss or you have to go out to physical memory, then your pipeline has to stall and you
但是如果你错过了或者你必须去访问物理内存，那么你的流水线就必须停顿，而且你

568
00:26:46,080 --> 00:26:52,000
get those bubbles. If you remember seeing bubbles, I think in 61c, you hit a little bit of that,
抓住那些气泡。如果你记得看到气泡，我想是在61c，你碰到了一点那个。

569
00:26:52,000 --> 00:26:59,040
and that can cause problems. So we have to make sure that this translation is really fast. And in
这可能会导致问题。所以我们必须确保这个翻译真的很快。而且在

570
00:26:59,040 --> 00:27:06,000
a really naive sense, if we didn't do any fancy optimizations, a single load or store could turn
一个非常天真的观点，如果我们不进行任何花哨的优化，一个单独的加载或存储操作可能会导致

571
00:27:06,000 --> 00:27:11,760
into like three or four reads and then the loader store, right? So it's multiplying every memory
将其分为三到四次读取，然后进行加载和存储，对吗？所以它在每个内存上进行乘法运算。

572
00:27:11,760 --> 00:27:16,880
access by like four if you have a four level page table. So this is a problem and we're going to have
如果你有一个四级页表，那么可以通过类似的方式访问。所以这是一个问题，我们将会遇到。

573
00:27:16,880 --> 00:27:25,520
to solve this problem. Okay, so this is really, really slow. I mean, unreasonably slow for any
为了解决这个问题。好的，所以这真的，真的很慢。我的意思是，对于任何情况来说都是不合理的慢。

574
00:27:25,520 --> 00:27:32,960
high performance CPU. So what do we do if we have some sort of data access? We do that data access
高性能的CPU。那么如果我们需要进行某种数据访问，我们该怎么办呢？我们会进行数据访问。

575
00:27:32,960 --> 00:27:38,800
multiple times and we want to make it faster. So I already kind of spoiled the answer here by
多次，并且我们希望使其更快。所以我已经有点透露了答案。

576
00:27:38,800 --> 00:27:45,840
switching slides. This is caching. Caching is one of those like fundamental core computer science
切换幻灯片。这是缓存。缓存是计算机科学中的一项基础核心技术之一。

577
00:27:45,840 --> 00:27:51,520
concepts that just comes up again and again and again. You're going to see caching everywhere.
一次又一次地出现的概念。你会在各个地方看到缓存。

578
00:27:51,520 --> 00:27:58,320
It's just everywhere. So that's what we're going to have to deal with is caching. That's the trick.
它就是无处不在的。所以我们需要处理的就是缓存。这就是诀窍。

579
00:27:58,320 --> 00:28:01,840
That's the trick we're going to use to solve this. So I'm going to spend a little bit of time now
这就是我们要用来解决这个问题的诀窍。所以我现在要花一点时间。

580
00:28:01,840 --> 00:28:08,640
reviewing caching. I know you learned a little bit about this in 61c. If you've taken like 152 or
复习缓存。我知道你在61c课程中学了一点关于这个的知识。如果你修过152或者其他相关课程的话，你可能对这个有更深入的了解。

581
00:28:08,640 --> 00:28:13,040
something, you're going to see caching in a lot more detail. But I'm going to take some time now
一些东西，你将会更详细地了解缓存。但是我现在要花一些时间。

582
00:28:13,040 --> 00:28:18,960
to refresh your memory because caching is super important. And you're going to see just in this
为了提醒你，因为缓存非常重要。你将在这个过程中看到。

583
00:28:18,960 --> 00:28:24,800
lecture alone, we're going to see two examples of caching, three examples of caching just in this
讲座中，我们将看到两个缓存的例子，仅在本次讲座中就有三个缓存的例子。

584
00:28:24,800 --> 00:28:31,280
lecture alone. And then every class you take, you're going to see it. So a cache is a smaller,
单独讲课。然后你上的每一门课，你都会看到它。所以缓存是一个较小的，

585
00:28:31,280 --> 00:28:39,680
faster memory in which we store copies of some original data. It's everywhere, like I just said,
更快的内存，我们在其中存储一些原始数据的副本。它无处不在，就像我刚才说的那样，

586
00:28:39,680 --> 00:28:45,680
and it really only works if you have some sort of locality. So basically you have to be able to
而且它只有在你有某种地域性的情况下才能起作用。所以基本上你必须能够

587
00:28:45,680 --> 00:28:52,160
predict whether you're going to reuse some memory. If you can predict it, then caches are going to
预测你是否会重复使用一些内存。如果你能预测到，那么缓存将会被使用。

588
00:28:52,160 --> 00:28:56,480
work well. If you have completely unpredictable accesses, then the cache isn't going to work
工作得很好。如果你的访问完全是不可预测的，那么缓存是不会起作用的。

589
00:28:56,480 --> 00:29:00,480
because what do you store in the cache? Every single one is like totally random.
因为你在缓存中存储了什么？每一个都完全随机。

590
00:29:00,480 --> 00:29:04,320
So they won't work in that case, but as long as you have some locality, caches are great.
所以在那种情况下它们不起作用，但只要有一定的局部性，缓存就非常好用。

591
00:29:04,320 --> 00:29:10,560
Here's a metric. There's a metric that's really important to keep in mind.
这是一个度量标准。有一个非常重要的度量标准需要记住。

592
00:29:10,560 --> 00:29:14,880
This is another one. It's sort of like the iron law. There's a bunch of these equations that seem
这是另一个。它有点像铁律。有一堆这样的方程似乎

593
00:29:14,880 --> 00:29:20,800
really dumb or like Amdahl's law, right? They seem really, they're almost dumb, right? They're just
真的很愚蠢，或者像阿姆达尔定律一样，对吧？它们看起来真的很，几乎愚蠢，对吧？它们只是

594
00:29:20,800 --> 00:29:26,160
obvious like, oh yeah, well, of course this is the time. But they're easy to forget and they're
显而易见，噢是的，当然这是时候。但是它们很容易被忘记，而且它们

595
00:29:26,160 --> 00:29:31,520
really helpful for thinking and like understanding how systems work. So in this case, we're talking
真的很有助于思考和理解系统如何运作。所以在这种情况下，我们正在讨论什么？

596
00:29:31,520 --> 00:29:39,280
about average access time. So that is the hit rate times the hit time plus the miss rate times the
关于平均访问时间。那就是命中率乘以命中时间加上失效率乘以失效时间。

597
00:29:39,280 --> 00:29:44,880
miss time is going to be your average access time. So on average, a memory access is going to take
平均访问时间是指错失时间。因此，平均而言，内存访问将需要多长时间。

598
00:29:44,880 --> 00:29:52,400
that much time. So keep that in mind. You may be asked to do that on homeworks or tests or things.
那么请记住这一点。你可能会被要求在作业、考试或其他事情中做这个。

599
00:29:52,400 --> 00:29:55,920
It's important. And we're going to, I think we're going to walk through an example here in a second.
这很重要。我想我们马上要通过一个例子来演示一下。

600
00:29:55,920 --> 00:30:04,240
Okay. We need to put into context a little bit why we're talking about caching and just how
好的。我们需要稍微解释一下为什么我们要谈论缓存，以及它的作用。

601
00:30:04,240 --> 00:30:11,600
effective it can be, right? I think humans brains are really bad at reasoning about scale. We just
是的，我认为人类的大脑在处理规模问题时确实很差。我们很难理解事物的有效性。

602
00:30:11,600 --> 00:30:15,840
can't handle things that are like orders of magnitude apart. Our brains just aren't wired
无法处理相差数个数量级的事物。我们的大脑并不适应。

603
00:30:15,840 --> 00:30:21,280
for it. So here's an attempt to put it into perspective, an attempt that will probably fail,
对此，我尝试着给出一个透彻的解释，尽管可能会失败。

604
00:30:21,280 --> 00:30:25,120
but you should keep these numbers in mind. It's really important to always have this in your head.
但是你应该记住这些数字。时刻将它们牢记在心非常重要。

605
00:30:25,680 --> 00:30:32,320
So we have multiple ways of storing data in digital logic or in a computer. The fastest
所以我们有多种方式来存储数据在数字逻辑或计算机中。最快的方式是使用寄存器，它们是位于CPU内部的小型存储器单元，可以快速读取和写入数据。另一种常见的存储方式是使用随机存取存储器（RAM），它可以在较大的容量范围内存储数据，并且可以随机访问任何位置。此外，还有只读存储器（ROM）和闪存等其他类型的存储器。

606
00:30:32,320 --> 00:30:38,640
one here is registers and also kind of the L1 cache. The L1 cache might be a little slower
这里有一个寄存器，还有一种L1缓存。L1缓存可能会稍微慢一些。

607
00:30:38,640 --> 00:30:49,920
than registers, but it's close. Both of these are about the cycle time. So these are running
比寄存器多，但接近。这两个都是关于周期时间的。所以这些正在运行。

608
00:30:49,920 --> 00:30:56,560
about the same speed as like your computer processor cycles. So that means that we want
大约和你的计算机处理器周期一样快的速度。这意味着我们希望

609
00:30:56,560 --> 00:31:03,120
to interact with these in hardware. These happen at sort of hardware time scales, right? Then we've
与这些硬件进行交互。这些操作发生在硬件时间尺度上，对吗？然后我们

610
00:31:03,120 --> 00:31:07,040
got all this stuff in the middle. So we've got all these and they're just getting slower and slower
中间有这么多东西。所以我们有这么多东西，它们只是越来越慢。

611
00:31:07,040 --> 00:31:12,800
and slower. And at some point we're going to get all the way to your hard disk. And when you get to
更慢。而且在某个时候我们将会到达你的硬盘。当你到达时，

612
00:31:12,800 --> 00:31:19,360
your hard disk to a first order approximation, the amount of time it takes to read from a hard disk is
您的硬盘在一级近似下，从硬盘读取所需的时间量是多少。

613
00:31:20,080 --> 00:31:27,520
forever. Like from a hardware perspective, it's not even worth thinking about. I mean, it's an
永远。就从硬件角度来看，根本不值得考虑。我的意思是，这是一个

614
00:31:27,520 --> 00:31:34,080
absolutely absurd amount of time. I was going to need bread, but then I cut my finger, so I
绝对荒谬的时间。我本来要去买面包，但是我割伤了手指，所以...

615
00:31:34,080 --> 00:31:43,120
haven't done that recently. Okay, so basically think about hard disks as taking infinite time
最近没有做过那个。好的，基本上可以将硬盘想象为需要无限时间。

616
00:31:43,120 --> 00:31:49,120
from a hardware perspective. If I'm cycling at 4 gigahertz, 10 milliseconds is just a ridiculous
从硬件角度来看。如果我以4千兆赫的速度进行循环，10毫秒简直是荒谬的。

617
00:31:49,120 --> 00:31:54,160
amount of time. And so when we're going to go to these time scales, we're just going to deal with
时间的数量。所以当我们要涉及到这些时间尺度时，我们只需要处理

618
00:31:54,160 --> 00:31:58,240
it in software, right? Because it doesn't make sense for the hardware to even deal with it. It's
对的，这是关于软件的，对硬件来说处理这个是没有意义的。

619
00:31:58,240 --> 00:32:02,400
so slow. And then there's this stuff in the middle and all this stuff in the middle are going to be
太慢了。然后中间还有这些东西，而且所有这些中间的东西都会被...

620
00:32:02,400 --> 00:32:07,840
shades of gray, right? And depending on how you want to deal with this, you might have hardware
灰色的色调，对吗？根据你想要如何处理这个问题，你可能需要硬件设备。

621
00:32:07,840 --> 00:32:12,160
deal with it. You might have software deal with it. You might have some more complicated mix of
应对它。你可以让软件来处理它。你可能有一些更复杂的混合物。

622
00:32:12,160 --> 00:32:17,760
things, right? A lot of my research has focused sort of in this space and understanding where
事情，对吧？我的很多研究都集中在这个领域，了解其中的情况和理解。

623
00:32:17,760 --> 00:32:23,440
exactly that barrier between hardware and software can be. And it's a pretty interesting question.
确切地说，硬件和软件之间可能存在的障碍就是这个问题。这是一个非常有趣的问题。

624
00:32:23,440 --> 00:32:28,240
But way over here, definitely want to deal with that completely in software. Way over here,
但是在这里，肯定希望完全通过软件来处理。在这里，

625
00:32:28,240 --> 00:32:33,840
you definitely want to deal with that completely in hardware. And there's like millions and millions
你肯定希望完全在硬件上处理这个问题。而且有数百万、数千万的情况。

626
00:32:33,840 --> 00:32:39,840
and millions times difference in the performance here. So that's why caches are important. An L1
和这里的性能相差百万倍。这就是为什么缓存很重要。一个L1

627
00:32:39,840 --> 00:32:44,720
cache miss is not a big deal. It's going to happen. You're only going to lose a cycle or something.
缓存未命中并不是什么大问题。这种情况是会发生的。你只会损失一个周期或者类似的时间。

628
00:32:44,720 --> 00:32:50,240
If you try and read something from disk, just give up, right? Like go put your laptop away,
如果你试图从磁盘上读取某个东西，就放弃吧，对吗？就像把你的笔记本电脑收起来一样，

629
00:32:50,240 --> 00:32:54,480
go home, come back, right? At least the hardware thinks it's like that.
回家，再回来，对吗？至少硬件是这样认为的。

630
00:32:54,480 --> 00:33:02,880
And then address translation. Because this is so fast, address translation has to happen
然后是地址转换。由于速度很快，必须进行地址转换。

631
00:33:02,880 --> 00:33:07,680
right here. It has to happen by the time you get into the core. So it's got to be fast.
就在这里。它必须在你进入核心之前发生。所以它必须很快。

632
00:33:07,680 --> 00:33:13,520
Worst case scenario, page tables live here or maybe even here in extreme cases. But for the
最坏的情况是，页表可能存储在这里，甚至在极端情况下也可能存储在这里。但对于...

633
00:33:13,520 --> 00:33:19,200
most part, your page tables are here. So we need this caching in order to be able to access them
大部分，你的页面表都在这里。因此，我们需要这个缓存来能够访问它们。

634
00:33:19,200 --> 00:33:27,040
effectively. Okay, so just real quick, because I think it's really important to understand this
有效地。好的，所以只是简单地说一下，因为我认为理解这一点非常重要。

635
00:33:27,040 --> 00:33:32,480
equation, we're going to go through an example. So let's take a real example or a made up example
方程，我们将通过一个例子来说明。所以让我们来看一个真实的例子或者一个虚构的例子。

636
00:33:32,480 --> 00:33:38,240
that's real enough. And say that it takes about 100 nanoseconds to get to DRAM. This is about
那是真实的。并且说它需要大约100纳秒才能到达DRAM。这大约是

637
00:33:38,240 --> 00:33:44,320
right. And then say it takes one nanosecond to get to your cache, like your L1. Again, it's about
对的。然后说它只需要一纳秒的时间才能到达你的缓存，比如L1缓存。再次强调，这是关于

638
00:33:44,320 --> 00:33:51,920
right. So what's the average memory access time here? I'm going to go through it now just in the
正确。那么这里的平均内存访问时间是多少？我现在要进行一下计算。

639
00:33:51,920 --> 00:33:56,320
interest of time. But this is something that you guys are going to have to get a little bit
时间紧迫。但这是你们需要稍微努力一下的事情。

640
00:33:56,320 --> 00:34:03,040
comfortable running. Okay, so actually, I'll let people sort of think about this for a second. And
舒适的跑步。好的，实际上，我会让人们稍微思考一下。并且

641
00:34:03,040 --> 00:34:08,320
I'm going to answer this question. Yeah, so what do I mean by letting software deal with it? We're
我要回答这个问题。是的，那么我所说的让软件处理是什么意思呢？我们

642
00:34:08,320 --> 00:34:13,760
going to talk about that in a little more detail later in the lecture. But basically, what I mean
稍后在讲座中会详细讨论这个问题。但基本上，我的意思是什么呢？

643
00:34:13,760 --> 00:34:19,680
is that the hardware might notice that it needs to go to disk, like it might notice that the data
是这样的，硬件可能会注意到它需要写入磁盘，比如它可能会注意到数据已经被修改。

644
00:34:19,680 --> 00:34:25,440
it needs is not available. And rather than some circuit, figuring out how to read from the disk,
需要的东西不可用。与其说是一些电路，不如说是弄清楚如何从磁盘读取。

645
00:34:25,440 --> 00:34:30,160
so some digital logic issuing requests to the disk, what it's going to do is it's going to
一些数字逻辑正在向磁盘发送请求，它要做的是

646
00:34:30,160 --> 00:34:36,080
throw what's called a trap. Just like how the user process is able to switch back into kernel mode,
扔一个叫做"陷阱"的东西。就像用户进程能够切换回内核模式一样，

647
00:34:36,080 --> 00:34:40,800
the hardware can decide, you know what, I can't deal with this right now. I'm going to run some
硬件可以决定，你知道的，我现在无法处理这个。我要运行一些

648
00:34:40,800 --> 00:34:47,920
code that the operating system provided. And I'll let that code deal with this. So when we let
操作系统提供的代码。我会让那段代码来处理这个问题。所以当我们让

649
00:34:47,920 --> 00:34:52,080
software deal with it, that means we hand control to the operating system to make some more
软件处理它，这意味着我们将控制权交给操作系统来做一些更多的事情。

650
00:34:52,080 --> 00:34:58,720
complicated decisions than you could in a dedicated like digital logic circuit. And we'll go into more
比起你在一个专门的数字逻辑电路中能够做出的复杂决策。我们将进一步探讨。

651
00:34:58,720 --> 00:35:06,480
details of this later on, assuming we get there. Okay, so we're looking at the average memory
稍后再详细说明，假设我们能到那里。好的，所以我们正在看平均内存。

652
00:35:06,480 --> 00:35:13,200
access time. So this is hit rate times hit time plus miss rate times miss time. So the hit rate
访问时间。因此，这是命中率乘以命中时间加上未命中率乘以未命中时间。因此，命中率是指成功命中的次数与总访问次数之比。

653
00:35:13,200 --> 00:35:18,560
plus the miss rate, obviously they've got a match, right? If I didn't hit, then I missed. If I didn't
加上错过率，显然他们找到了匹配的对象，对吗？如果我没有命中，那就是我错过了。如果我没有...

654
00:35:18,560 --> 00:35:25,920
miss, then I hit. So these are just ratios. So let's assume that our hit rate in this cache is 90%.
错过，然后我命中了。所以这些只是比率。那么让我们假设在这个缓存中，我们的命中率是90%。

655
00:35:26,880 --> 00:35:34,000
That means that our miss rate is going to be 10%. If we hit, then that means it took us a nanosecond
这意味着我们的错误率将为10%。如果我们命中了，那就意味着我们花了一纳秒的时间。

656
00:35:34,000 --> 00:35:40,880
to read. So that'll be 90% times one. And then if we missed, it's going to take us 100 seconds to
阅读。所以这将是90%乘以一。然后如果我们错过了，那将花费我们100秒钟。

657
00:35:40,880 --> 00:35:49,280
read. But I just wrote 101 here. So why did I write 101 and not 100 for the miss time?
读。但是我刚刚在这里写的是101。那么为什么我写的是101而不是100来表示错过的时间呢？

658
00:35:54,000 --> 00:35:57,840
I'll give you guys a few seconds to think about that.
我会给你们几秒钟来考虑一下。

659
00:35:57,840 --> 00:36:07,440
So the reason I did that was that in order to notice that I missed, I had to try and hit.
所以我这样做的原因是，为了注意到我错过的地方，我必须试着去击中。

660
00:36:07,440 --> 00:36:18,000
So not quite. So the, yeah, exactly. So I think Brian's got it here. So the trick is that I had
所以不完全正确。嗯，没错。所以我认为Brian在这里说对了。所以诀窍就是我有...

661
00:36:18,000 --> 00:36:23,280
to notice that I missed and that took a nanosecond all by itself. Then I noticed that I missed
注意到我错过了，这本身只花了一纳秒的时间。然后我注意到我错过了。

662
00:36:23,840 --> 00:36:28,960
and then I could start trying to read from the next level, right? Or actually that might be what
然后我可以开始尝试从下一个级别阅读，对吗？或者实际上那可能就是我要做的事情。

663
00:36:28,960 --> 00:36:33,920
they were just trying to get at too. So that's why. So you have to account for the fact that
他们也只是想要得到而已。所以这就是原因。所以你必须考虑到这个事实。

664
00:36:33,920 --> 00:36:37,440
missing takes extra time because you have to notice that you missed.
错过会花费额外的时间，因为你需要注意到自己错过了。

665
00:36:37,440 --> 00:36:46,560
And so we can look at what happens as you change hit rates and miss rates. Notice that a relatively
较高的命中率和较低的失误率会导致什么结果，我们可以进行观察。请注意，一个相对较高的命中率和较低的失误率会导致什么结果。

666
00:36:46,560 --> 00:36:52,480
small increase in the hit rate can have a very large impact on the overall performance. So hit
率的小幅增加可能对整体性能产生很大的影响。因此，命中率的提高是非常重要的。

667
00:36:52,480 --> 00:37:02,080
rates become very, very important. Okay. Again, I talked about why caching works. I'm going to move
速率变得非常非常重要。好的。再次，我谈到了为什么缓存起作用。我要继续。

668
00:37:02,080 --> 00:37:08,160
a little bit fast here. Well, that's kind of an important concept. We talked about locality. So
这里有点快。嗯，这是一个很重要的概念。我们谈到了局部性。所以

669
00:37:08,160 --> 00:37:14,640
caching works because we have predictability. We can guess what memories are likely to be accessed
缓存的工作原理是因为我们具有可预测性。我们可以猜测哪些内存很可能被访问到。

670
00:37:14,640 --> 00:37:22,160
next. So there's different types of patterns that we might detect. And the most common ones
下一个。所以我们可能会检测到不同类型的模式。其中最常见的类型是什么？

671
00:37:22,160 --> 00:37:28,640
are temporal locality. So if I read or wrote some address, I'm probably going to read or write it
是时间局部性。所以如果我读取或写入某个地址，我很可能会再次读取或写入它。

672
00:37:28,640 --> 00:37:34,640
again. Most likely. Imagine if I have a loop, right? So instructions are memory. If you remember
再说一遍。很有可能。想象一下，如果我有一个循环，对吧？所以指令是存储在内存中的。如果你记得的话。

673
00:37:34,640 --> 00:37:41,280
your whole von Neumann thing, so the program itself is memory. And if I have a loop in my memory,
你整个冯·诺伊曼的概念，所以程序本身就是内存。如果我的内存中有一个循环，

674
00:37:41,280 --> 00:37:45,920
then I'm going to be reusing those instructions over and over and over because I got this loop,
那么我将一遍又一遍地重复使用这些指示，因为我有这个循环。

675
00:37:45,920 --> 00:37:51,040
right? So that's temporal locality. So that's a pretty good guess. That tends to work pretty
对吗？那就是时间局部性。那是一个相当好的猜测。那通常很有效。

676
00:37:51,040 --> 00:37:56,960
well. If I access something recently, I'll probably access it again. The other one is spatial locality.
好的。如果我最近访问了某个东西，我很可能会再次访问它。另一个是空间局部性。

677
00:37:56,960 --> 00:38:01,840
So this is like, imagine scanning an array, right? If I'm reading an array from start to finish.
所以这就像是，想象一下扫描一个数组，对吧？如果我从头到尾读取一个数组。

678
00:38:01,840 --> 00:38:06,720
So if I read an array from start to finish, if I access one piece of information, it's pretty
那么，如果我从头到尾读取一个数组，如果我访问一条信息，那就很简单了。

679
00:38:06,720 --> 00:38:13,600
likely that I'm going to read addresses that are nearby, right? So that is spatial locality. Stuff
很可能我会阅读附近的地址，对吗？所以这就是空间局部性。东西

680
00:38:13,600 --> 00:38:19,360
tends to cluster together physically, like in the address space. That's not always true. I talked
倾向于在物理上聚集在一起，比如在地址空间中。但这并不总是正确的。我谈到过

681
00:38:19,360 --> 00:38:24,960
earlier about how hash tables aren't very cache friendly. This is why. Because hash tables don't
早些时候我们谈到了哈希表不太友好的缓存性能。这就是原因。因为哈希表不会

682
00:38:24,960 --> 00:38:31,600
have a lot of spatial locality. You jump around them a lot. And so things that are physically
具有很高的空间局部性。你经常在它们之间跳转。因此，那些在物理上的东西

683
00:38:31,600 --> 00:38:38,320
near each other aren't necessarily accessed together. But then having an array or a table
彼此靠近的元素并不一定会一起被访问。但是，如果有一个数组或者表格的话，

684
00:38:38,320 --> 00:38:42,560
lookup or something like that, you have more spatial locality. So they tend to behave a little
查找或类似的操作，你有更多的空间局部性。所以它们倾向于表现得稍微一些。

685
00:38:42,560 --> 00:38:52,240
nicer. Right. And then the final thing here is that we have multiple levels. And so we can stack
更好。对的。然后这里最后一件事是我们有多个层级。因此我们可以堆叠。

686
00:38:52,240 --> 00:39:01,520
these together in order to keep track of things. Okay. So what is the trick here? Why was I just
这些东西放在一起是为了跟踪事物。好的。那么这里有什么诀窍吗？为什么我刚才只是...

687
00:39:01,520 --> 00:39:07,120
talking about caching? Well, translations are slow, really painful. And the trick we're going
说到缓存？嗯，翻译真的很慢，非常痛苦。而且我们正在使用的技巧是...

688
00:39:07,120 --> 00:39:13,520
to do, the trick we always do, is we're just going to slap a cache on it. Right? Caches are everywhere
我们经常使用的方法就是给它加一个缓存。对吗？缓存无处不在。

689
00:39:13,520 --> 00:39:19,280
and this is no exception. So we're going to stick a cache on the MMU. And now every time we do a
并且这也不例外。所以我们要在MMU上放置一个缓存。现在每次我们执行一次操作时，

690
00:39:19,280 --> 00:39:24,720
translation, we're going to save that translation in this cache. Now the cache is smaller and it's
翻译，我们将把那个翻译保存在这个缓存中。现在缓存变小了，而且它的

691
00:39:24,720 --> 00:39:29,840
faster to access. So we don't have to do all this table locking. We can just look it up in the cache.
更快地访问。这样我们就不需要进行所有这些表锁定。我们只需在缓存中查找即可。

692
00:39:29,840 --> 00:39:34,640
And the cache is relatively simple. It's just going to have the virtual page, right? That's what
而缓存相对简单。它只会有虚拟页面，对吗？这就是它的内容。

693
00:39:34,640 --> 00:39:39,840
you're using to look up. Then it's going to have the physical frame number. That's the answer you
你正在使用查找。然后它将有物理帧号码。这就是你的答案。

694
00:39:39,840 --> 00:39:45,200
want. And then it's also going to cache a bunch of other metadata. So PTEs have a bunch of extreme
希望。然后它还会缓存一堆其他元数据。所以PTEs有一堆极端的

695
00:39:45,440 --> 00:39:50,840
in them, like whether this mapping is currently valid or whether you're allowed to read or write
在其中，比如说这个映射是否目前有效，或者你是否被允许读取或写入。

696
00:39:50,840 --> 00:39:56,380
to it. Has it been accessed recently? There's a bunch of little metadata. We'll show you a picture
它被最近访问过吗？有一些小的元数据。我们会给你展示一张图片。

697
00:39:56,380 --> 00:40:00,560
at the end of the slides, but a lot of little data that you want to keep around to keep track
在幻灯片的末尾，但有很多你想保留以跟踪的小数据。

698
00:40:00,560 --> 00:40:05,480
of extra information. And that's, so that's what you're caching. So keep in mind here, this is not
额外信息的一部分。这就是你正在缓存的内容。所以请记住，这不是

699
00:40:05,480 --> 00:40:12,160
caching data. So this has nothing to do with what's actually in the page, right? We're not caching the
缓存数据。所以这与页面中实际内容无关，对吗？我们不是在缓存页面中的内容。

700
00:40:12,160 --> 00:40:18,560
information contained in the page. All we're caching is metadata. We're caching information about the
页面中包含的信息。我们只缓存元数据。我们缓存的是关于信息的缓存。

701
00:40:18,560 --> 00:40:23,000
page. So that's what we're trying to cache here. And it's going to save us every time we hit in
页面。这就是我们在这里尝试缓存的内容。每次我们访问时，它都会为我们节省时间。

702
00:40:23,000 --> 00:40:32,280
this cache, we get to avoid walking the table. And that's pretty nice. Okay. So this cache, for
这个缓存，我们可以避免遍历表格。这很不错。好的。所以这个缓存，对于

703
00:40:32,280 --> 00:40:38,360
largely historical reasons, is referred to as a translation lookaside buffer. It's just a fancy
大部分是出于历史原因，被称为翻译查找缓冲区。这只是一个花哨的

704
00:40:38,360 --> 00:40:45,200
word for a cache. Turns out, it's a very old idea. It was, they came up with it quite a long time
缓存的英文单词是"cache"。原来，这是一个非常古老的概念。它是在很久以前提出的。

705
00:40:45,200 --> 00:40:52,560
ago, before the word cache was really coined. And so it has kind of a funny name. But either way,
以前，在“缓存”这个词真正被创造出来之前。所以它有点滑稽的名字。但无论如何，

706
00:40:52,560 --> 00:40:59,000
it's storing these translations. You know, if we hit in that cache, we get to avoid all these slow
它正在存储这些翻译。你知道，如果我们在缓存中命中，就能避免所有这些慢速的操作。

707
00:40:59,000 --> 00:41:04,720
lookups. So that's really nice. Like I said, it was invented actually quite a long time ago,
查找。这真的很好。就像我说的，它实际上是相当久以前发明的，

708
00:41:05,200 --> 00:41:12,080
before the word cache was even being commonly used, hence the funny name. And we call it the
在“缓存”这个词普及之前，因此有了这个有趣的名字。我们称之为

709
00:41:12,080 --> 00:41:16,320
TLB. So you're gonna, I don't think anybody ever says translation lookaside buffer out loud, they
翻译成英文：TLB。所以你要，我觉得没有人会大声说翻译后备缓冲区。

710
00:41:16,320 --> 00:41:22,160
only ever say TLB. So you'll have to get used to hearing that word. But keep in mind, TLB is just a
只说TLB。所以你得习惯听到这个词。但要记住，TLB只是一个

711
00:41:22,160 --> 00:41:28,200
funny word for cache. It's a cache for your page table lookups, a cache for virtual to physical
有一个有趣的词可以用来描述"cache"。它是用于页面表查找的缓存，也是用于虚拟地址到物理地址的缓存。

712
00:41:28,200 --> 00:41:34,720
translations. So how does this work? Let's go through just sort of a flow diagram, a workflow of
翻译。那么这是如何工作的呢？让我们简单地通过一个流程图，一个工作流程来说明。

713
00:41:34,720 --> 00:41:41,200
how this actually goes. So CPU is going to ask for a virtual address, it's going to try and find it
这个实际上是怎么进行的。所以CPU会请求一个虚拟地址，然后尝试找到它。

714
00:41:41,200 --> 00:41:47,120
in the TLB, or the MMU is going to try and find it in the TLB. If it does, great, immediately,
在TLB中，或者MMU将尝试在TLB中找到它。如果找到了，那太好了，立即返回。

715
00:41:47,120 --> 00:41:50,880
it's just going to push that request all the way through to physical memory, and everything's on
它只是将该请求一直推送到物理内存中，而且一切都在上面。

716
00:41:50,880 --> 00:41:56,480
theory. If it's not, so there's nothing cached, then you're going to have to go to the MMU. And
理论上来说，如果不是这样的话，那么就没有缓存，那么你就必须去访问MMU。

717
00:41:56,480 --> 00:42:02,320
the MMU is going to have to go back and forth to memory a couple times to walk that table. But once
MMU将不得不多次在内存和表之间来回传输。但一旦

718
00:42:02,320 --> 00:42:06,640
it's walked the table, and it's looked up the translation, it can save that translation in the
它走到了桌子上，并查找了翻译，它可以保存那个翻译在里面。

719
00:42:06,640 --> 00:42:12,000
TLB, and then go and do the translation for the CPU, and everything starts back up.
TLB，然后进行CPU的翻译，一切重新启动。

720
00:42:12,000 --> 00:42:21,360
So why does this work? And does it work? It's a question of page locality, right? So is there
所以为什么这个有效？它真的有效吗？这是一个页面局部性的问题，对吗？那么有吗？

721
00:42:21,360 --> 00:42:26,400
locality, or is the caching going to work? Is there spatial locality? Is there temporal locality?
地域性，或者缓存会起作用吗？有空间局部性吗？有时间局部性吗？

722
00:42:27,040 --> 00:42:33,200
It turns out there is. So it turns out that physical memory, the pages in physical memory,
原来是有的。所以原来物理内存中的页面，

723
00:42:33,200 --> 00:42:38,160
tend to have quite a lot of locality, actually. The biggest, a really, really big source of this
往往具有相当多的地方特色，实际上。最大的，一个非常非常大的来源是这个。

724
00:42:38,160 --> 00:42:43,600
is your code, right? Code is data. I talked about this before. So when you're reading a program,
这是你的代码，对吗？代码就是数据。我之前谈过这个。所以当你阅读一个程序时，

725
00:42:43,600 --> 00:42:47,440
like when you're running a program, the instructions that make up that program are
就像你运行一个程序时，组成该程序的指令是什么。

726
00:42:47,440 --> 00:42:53,280
all close together. So that's spatial locality. And they tend to get reused a lot. So you have a
所有都紧密地放在一起。这就是空间局部性。它们往往会被频繁地重复使用。所以你有一个

727
00:42:53,280 --> 00:42:58,320
loop, you're reusing the instructions. If you call into functions, one of the whole points of having
循环，你正在重复使用指令。如果你调用函数，那么其中一个重要的目的就是拥有可重用的指令。

728
00:42:58,320 --> 00:43:04,080
subroutines or functions is that you only have one copy of that code, and you call into it lots
子程序或函数的好处是，你只需要一份代码副本，然后可以多次调用它。

729
00:43:04,080 --> 00:43:09,920
of times. So tons and tons of temporal locality in code. You also have other spatial and temporal
的时间。所以代码中有大量的时间局部性。您还有其他的空间和时间

730
00:43:09,920 --> 00:43:16,240
locality. Your stack gets reused again and again and again. A lot of the sort of hard data stuff.
地点。您的堆栈会一次又一次地被重复使用。很多是那种硬数据的东西。

731
00:43:16,240 --> 00:43:21,920
The heap is, you know, more variable. Whether or not your heap has locality, it's the same reasons
堆是更加可变的。无论你的堆是否具有局部性，都是同样的原因。

732
00:43:21,920 --> 00:43:27,520
it has cache locality in your data caches. It's up to you to write a program that has good cache
它在你的数据缓存中具有缓存局部性。如何编写一个具有良好缓存的程序取决于你。

733
00:43:27,520 --> 00:43:35,840
locality, but it tends to. And of course, all the tricks that we play for caches apply to TLBs as
本地性，但它有倾向性。当然，我们为缓存所使用的所有技巧也适用于TLB。

734
00:43:35,840 --> 00:43:41,120
well. They're just a cache. So maybe they got a few different decisions you might make, but
好的。它们只是缓存。所以可能它们有一些你可能会做出的不同决定，但是

735
00:43:41,120 --> 00:43:46,480
ultimately they're caches and all the same tricks work. So we can have a multi-level TLB if we want.
最终它们都是缓存，所有相同的技巧都适用。所以如果我们想要，我们可以拥有多级TLB。

736
00:43:48,640 --> 00:43:53,280
Okay, we've been talking for a while. I'm going to take a break. I'm going to get some water and
好的，我们已经聊了一会儿了。我要休息一下。我要去喝点水，然后...

737
00:43:53,280 --> 00:44:01,360
do a stretch, and I will allow others to do the same. So we're going to take a two-minute break.
做个伸展动作，我会允许其他人也这样做。所以我们要休息两分钟。

738
00:44:01,360 --> 00:44:08,080
So I'll be back at 1.28. Here's a bunch of announcements. I'm just sort of stepping in
所以我会在1.28回来。这里有一些公告。我只是临时顶替一下。

739
00:44:08,080 --> 00:44:13,360
for today, so I have no idea what any of these announcements mean, and it's just what Jan gave
今天的事情，所以我对这些公告的含义一无所知，只是Jan给的。

740
00:44:13,360 --> 00:44:19,360
me. So talk to your TAs or whatever. Okay, 1.28, we'll be back.
我。所以和你的助教或者其他人交流吧。好的，1月28日我们会回来的。

741
00:44:40,080 --> 00:44:46,880
Oh, and while we're waiting, you guys can ask questions and stuff if you want.
哦，在我们等待的时候，如果你们想要问问题或者其他什么的，都可以。

742
00:44:46,880 --> 00:44:48,880
Okay. Thank you.
好的。谢谢你。

743
00:44:48,880 --> 00:44:50,880
Thank you.
谢谢你。

744
00:44:50,880 --> 00:44:52,880
Thank you.
谢谢你。

745
00:44:52,880 --> 00:44:54,880
Thank you.
谢谢。

746
00:44:54,880 --> 00:44:56,880
Thank you.
谢谢你。

747
00:44:56,880 --> 00:44:58,880
Thank you.
谢谢你。

748
00:44:58,880 --> 00:45:00,880
Thank you.
谢谢你。

749
00:45:00,880 --> 00:45:02,880
Thank you.
谢谢你。

750
00:45:02,880 --> 00:45:04,880
Thank you.
谢谢你。

751
00:45:04,880 --> 00:45:06,880
Thank you.
谢谢。

752
00:45:06,880 --> 00:45:08,880
Thank you.
谢谢你。

753
00:45:08,880 --> 00:45:10,880
Thank you.
谢谢。

754
00:45:10,880 --> 00:45:12,880
Thank you.
谢谢。

755
00:45:12,880 --> 00:45:14,880
Thank you.
谢谢你。

756
00:45:14,880 --> 00:45:16,880
Thank you.
谢谢你。

757
00:45:16,880 --> 00:45:18,880
Thank you.
谢谢你。

758
00:45:18,880 --> 00:45:20,880
Thank you.
谢谢你。

759
00:45:20,880 --> 00:45:22,880
Thank you.
谢谢。

760
00:45:22,880 --> 00:45:24,880
Thank you.
谢谢。

761
00:45:24,880 --> 00:45:26,880
Thank you.
谢谢你。

762
00:45:26,880 --> 00:45:28,880
Thank you.
谢谢。

763
00:45:28,880 --> 00:45:30,880
Thank you.
谢谢。

764
00:45:30,880 --> 00:45:32,880
Thank you.
谢谢你。

765
00:45:32,880 --> 00:45:34,880
Thank you.
谢谢你。

766
00:45:34,880 --> 00:45:36,880
Thank you.
谢谢你。

767
00:45:36,880 --> 00:45:38,880
Thank you.
谢谢你。

768
00:45:38,880 --> 00:45:40,880
Thank you.
谢谢你。

769
00:45:40,880 --> 00:45:42,880
Thank you.
谢谢。

770
00:45:42,880 --> 00:45:44,880
Thank you.
谢谢。

771
00:45:44,880 --> 00:45:46,880
Thank you.
谢谢你。

772
00:45:46,880 --> 00:45:48,880
Thank you.
谢谢。

773
00:45:48,880 --> 00:45:50,880
Okay.
Sure, I can help you with that. Please go ahead and provide me with the text you would like me to translate.

774
00:45:50,880 --> 00:46:06,880
Okay, and we're back.
好的，我们回来了。

775
00:46:06,880 --> 00:46:08,880
Quick break.
快速休息一下。

776
00:46:08,880 --> 00:46:12,880
A lot of content to cover.
有很多内容要涵盖。

777
00:46:12,880 --> 00:46:16,880
Okay, so, starting again.
好的，那么，重新开始。

778
00:46:16,880 --> 00:46:18,880
Okay.
Sure, I will translate your Chinese text into English and any non-Chinese text into Chinese. Please provide me with the content you would like to be translated.

779
00:46:18,880 --> 00:46:20,880
Okay. So, we talked about caching a lot.
好的。所以，我们谈论了很多关于缓存的内容。

780
00:46:20,880 --> 00:46:22,880
Real handy to keep this in mind.
记住这个真的很方便。

781
00:46:22,880 --> 00:46:24,880
This is a concept that comes up again and again.
这是一个反复出现的概念。

782
00:46:24,880 --> 00:46:28,880
So, let's talk about, you know, we talked about why caches work.
所以，让我们来谈谈，你知道的，我们已经谈过为什么缓存起作用了。

783
00:46:28,880 --> 00:46:32,880
You know, you talked about temporal locality and spatial locality.
你知道，你谈到了时间局部性和空间局部性。

784
00:46:32,880 --> 00:46:36,880
So, let's talk about what makes caches not work.
所以，让我们来谈谈是什么导致缓存无法工作。

785
00:46:36,880 --> 00:46:38,880
What makes us miss in the cache.
什么导致我们在缓存中丢失。

786
00:46:38,880 --> 00:46:40,880
So, let's categorize them.
所以，让我们对它们进行分类。

787
00:46:40,880 --> 00:46:46,880
So, recall the one of the types of cache miss that you can get is called compulsory.
所以，回想一下你可能遇到的一种缓存未命中类型被称为强制性未命中。

788
00:46:46,880 --> 00:46:50,880
This means it's a miss that you really just can't do anything about.
这意味着这是一个你真的无法改变的错过。

789
00:46:50,880 --> 00:46:54,880
Right? Like, I've never seen this data before, therefore I don't have it cached.
对吗？就像，我以前从未见过这些数据，所以我没有缓存它。

790
00:46:54,880 --> 00:46:59,880
So, called, you know, compulsory misses are mostly unavoidable.
所以，所谓的强制性缺席大多是不可避免的。

791
00:46:59,880 --> 00:47:02,880
There's some tricks you can do with what's called prefetching.
有一些你可以用所谓的预取技巧来做的小技巧。

792
00:47:02,880 --> 00:47:05,880
Where you try and guess what you might need in the future.
你试图猜测未来可能需要什么。

793
00:47:05,880 --> 00:47:10,880
And that's really the only way that you can avoid compulsory misses.
这真的是你能避免强制错过的唯一方法。

794
00:47:10,880 --> 00:47:13,880
Another one is called capacity misses.
另一个被称为容量不足。

795
00:47:13,880 --> 00:47:17,880
So, in this case, I basically just ran out of space.
所以，在这种情况下，我基本上只是用完了空间。

796
00:47:17,880 --> 00:47:19,880
I have cached everything I can cache.
我已经缓存了我能缓存的所有内容。

797
00:47:19,880 --> 00:47:21,880
I have no more room.
我没有更多的空间了。

798
00:47:21,880 --> 00:47:24,880
I had to kick something out of my cache because I ran out of room.
我不得不清除缓存中的某些内容，因为空间不足。

799
00:47:24,880 --> 00:47:27,880
And therefore, I missed the next time you tried to read it.
所以，我错过了你下次尝试阅读它的机会。

800
00:47:27,880 --> 00:47:32,880
So, I saw this data, I cached it, and then I ran out of room and I had to kick it out again.
所以，我看到了这些数据，我将其缓存起来，然后我空间不够了，不得不再次清除它。

801
00:47:32,880 --> 00:47:36,880
So, the way you deal with capacity misses is you make your cache bigger.
所以，你处理容量不足的方法就是扩大缓存。

802
00:47:36,880 --> 00:47:39,880
And you make it bigger and bigger and everything's great.
然后你让它变得越来越大，一切都很棒。

803
00:47:39,880 --> 00:47:43,880
But keep in mind, as you make your cache bigger, it gets slower.
但请记住，随着你增加缓存的大小，它会变得更慢。

804
00:47:43,880 --> 00:47:46,880
So, there's a point where you don't want to make the cache any bigger.
所以，有一个点，你不想让缓存变得更大。

805
00:47:46,880 --> 00:47:50,880
Another one, conflict.
另一个，冲突。

806
00:47:50,880 --> 00:47:56,880
So, in this case, with a conflict miss, I've seen the data before, so it's not compulsory.
所以，在这种情况下，由于冲突缺失，我之前已经看过这些数据，所以不是必须的。

807
00:47:56,880 --> 00:48:01,880
I have enough capacity for it so that I have empty space in my cache.
我有足够的容量，以至于我的缓存中有空余空间。

808
00:48:01,880 --> 00:48:02,880
I could store it.
我可以存储它。

809
00:48:02,880 --> 00:48:11,880
But because of the algorithm and the data structures I chose, so because of the way I chose to design my cache, I had to kick something out.
但是由于我选择的算法和数据结构，因此由于我选择的缓存设计方式，我不得不将某些内容移除。

810
00:48:11,880 --> 00:48:20,880
So, we're going to go into those details again here in a minute about what sort of algorithms you might choose and why those might have conflict misses, even if there was enough room.
所以，我们马上要再次详细讨论一下，关于你可能选择哪种算法以及为什么这些算法可能会有冲突缺失，即使有足够的空间。

811
00:48:20,880 --> 00:48:26,880
But the bottom line here is that I couldn't store it because of the algorithms I chose.
但是关键问题在于，由于我选择的算法，我无法存储它。

812
00:48:26,880 --> 00:48:28,880
And there's different ways of dealing with conflict misses.
并且处理冲突的方法有很多种。

813
00:48:28,880 --> 00:48:34,880
You can make the cache bigger so that you're less likely to have one of these conflicts, or you can change your algorithm.
你可以增加缓存的大小，这样就不太可能出现这种冲突，或者你可以改变你的算法。

814
00:48:34,880 --> 00:48:40,880
You can make your algorithm a little more sophisticated, and then you're less likely to have conflicts.
你可以让你的算法更加复杂一些，这样就不太可能出现冲突了。

815
00:48:40,880 --> 00:48:45,880
There's one more, and I don't think this was talked about very much in 61c, if at all.
还有一个问题，我觉得在61c课程中很少或者根本没有讨论过。

816
00:48:45,880 --> 00:48:49,880
It's been a few years since I taught that class.
我教那门课已经有几年了。

817
00:48:49,880 --> 00:48:53,880
But the last one here is called coherence.
但是这里的最后一个被称为连贯性。

818
00:48:53,880 --> 00:48:56,880
And this is one that's going to come up a lot in TLBs.
这是一个在TLB中经常出现的问题。

819
00:48:56,880 --> 00:49:00,880
So this is kind of a big one for TLBs.
这对于TLBs来说是一个很重要的问题。

820
00:49:00,880 --> 00:49:06,880
And a coherence one is basically that a cache is a copy.
而一个连贯性的概念是，缓存基本上是一个副本。

821
00:49:06,880 --> 00:49:12,880
So I have a copy of data, but the data that's up in, say, main memory, that's the real data.
所以我有一份数据的副本，但是在主内存中的数据才是真正的数据。

822
00:49:12,880 --> 00:49:19,880
That's the official, real ground truth of what that data is.
这是关于数据的官方、真实的真相。

823
00:49:19,880 --> 00:49:22,880
And my cache is just a copy of that.
我的缓存只是那个的一个副本。

824
00:49:22,880 --> 00:49:32,880
And so if somebody changes that data in main memory for whatever reason, some other CPU does it, or some other process or circuit or trigger or whatever did it,
那么如果有人出于任何原因更改了主存储器中的数据，无论是其他CPU、其他进程、电路、触发器还是其他什么导致的，

825
00:49:32,880 --> 00:49:38,880
if it changes for some reason, then I have to invalidate my cache.
如果由于某种原因发生了变化，那么我就需要清除我的缓存。

826
00:49:38,880 --> 00:49:44,880
I have to tell the cache, "Hey, you have a copy of this data, but it's not true anymore. You need to throw it out and read the new data."
我需要告诉缓存：“嘿，你有这个数据的副本，但它已经不正确了。你需要将其丢弃并读取新的数据。”

827
00:49:44,880 --> 00:49:46,880
So that's called a coherence miss.
这就是所谓的连贯性错误。

828
00:49:46,880 --> 00:49:53,880
And this is one that doesn't show up much in data caches for single CPU systems.
这是一个在单CPU系统的数据缓存中很少出现的。

829
00:49:53,880 --> 00:49:57,880
But if you have multiple CPUs, it happens a lot.
但是如果你有多个CPU，这种情况经常发生。

830
00:49:57,880 --> 00:50:08,880
And if you have things like TLBs have it more often because there's more things that change page table entries.
如果你有像TLB这样的东西，那么它会更频繁地发生，因为有更多的东西会改变页表项。

831
00:50:08,880 --> 00:50:10,880
And TLBs are kind of separate from the data cache.
而TLB是与数据缓存有所区别的。

832
00:50:10,880 --> 00:50:13,880
But we'll go into that in more detail.
但我们将会更详细地讨论这个问题。

833
00:50:13,880 --> 00:50:21,880
So false sharing is a particularly degenerate cause of coherence misses.
所以虚假共享是一种特别严重的导致一致性缺失的原因。

834
00:50:21,880 --> 00:50:25,880
So this is a question in the chat.
这是一个聊天中的问题。

835
00:50:25,880 --> 00:50:30,880
So basically, false sharing causes unnecessary coherence misses.
所以基本上，虚假共享会导致不必要的一致性失效。

836
00:50:30,880 --> 00:50:34,880
But you can have coherence misses that don't involve false sharing.
但是你可能会遇到不涉及虚假共享的一致性错误。

837
00:50:34,880 --> 00:50:37,880
So if you have true sharing, right?
所以，如果你有真正的分享，对吗？

838
00:50:37,880 --> 00:50:43,880
So let's say I'm sharing -- you see this a lot in locks, when you're implementing locks.
那么假设我正在分享——你在实现锁时经常会遇到这种情况。

839
00:50:43,880 --> 00:50:45,880
This is really common.
这是非常常见的。

840
00:50:45,880 --> 00:50:48,880
You have lots and lots of entities, lots and lots of different cores.
你有很多很多实体，很多很多不同的核心。

841
00:50:48,880 --> 00:50:51,880
And they're all trying to read and write the same piece of memory.
他们都试图读写同一块内存。

842
00:50:51,880 --> 00:50:54,880
Maybe it's to set a lock, maybe it's just to communicate.
也许是为了设置锁，也许只是为了沟通。

843
00:50:54,880 --> 00:50:56,880
That's real sharing.
这是真正的分享。

844
00:50:56,880 --> 00:50:59,880
And that would cause lots and lots of coherence misses.
这将导致大量的一致性缺失。

845
00:50:59,880 --> 00:51:03,880
What happens with false sharing is that caches store an entire line at a time.
发生伪共享的情况是缓存一次存储整个缓存行。

846
00:51:03,880 --> 00:51:05,880
So you store blocks.
所以你存储块。

847
00:51:05,880 --> 00:51:06,880
You store a cache line.
你存储了一个缓存行。

848
00:51:06,880 --> 00:51:10,880
And so let's say that you're not actually sharing data.
所以假设你实际上并没有共享数据。

849
00:51:10,880 --> 00:51:13,880
Like core zero is writing the first byte.
像核心零正在写入第一个字节。

850
00:51:13,880 --> 00:51:14,880
Core one is writing the next byte.
核心一正在写入下一个字节。

851
00:51:14,880 --> 00:51:17,880
Core two is writing the next byte.
核心二正在写入下一个字节。

852
00:51:17,880 --> 00:51:19,880
So they're not sharing data.
所以他们不共享数据。

853
00:51:19,880 --> 00:51:21,880
But they are sharing the same cache line.
但是它们共享同一缓存行。

854
00:51:21,880 --> 00:51:23,880
So they're sharing the same block.
所以他们共享同一个街区。

855
00:51:23,880 --> 00:51:25,880
So that's why it's called false sharing.
所以这就是为什么它被称为假共享。

856
00:51:25,880 --> 00:51:33,880
The caches can only detect conflicts or coherence issues on a cache line granularity.
缓存只能以缓存行为单位来检测冲突或一致性问题。

857
00:51:33,880 --> 00:51:37,880
So you're not actually sharing data, but you are sharing the same cache line.
所以你实际上并没有共享数据，但你确实共享同一缓存行。

858
00:51:37,880 --> 00:51:41,880
And that's causing a bunch of coherence misses.
这导致了一系列的一致性缺失。

859
00:51:41,880 --> 00:51:47,880
So Albert asks, how do we know if there's been a coherence miss?
所以阿尔伯特问，我们如何知道是否发生了一次连贯性错误？

860
00:51:47,880 --> 00:51:50,880
That is an excellent question.
这是一个很好的问题。

861
00:51:50,880 --> 00:51:54,880
That is -- so there's a famous quote that I love.
那个是——所以有一句我喜欢的名言。

862
00:51:54,880 --> 00:51:58,880
And I'm sorry, I can't think of the originator of the quote off the top of my head.
对不起，我一时想不起这句话的原作者是谁。

863
00:51:58,880 --> 00:52:02,880
But he says, there's only two hard problems in computer science.
但他说，计算机科学只有两个难题。

864
00:52:02,880 --> 00:52:05,880
Naming things and cache invalidation.
命名事物和缓存失效。

865
00:52:05,880 --> 00:52:11,880
So the answer to your question, Albert, is that it is an extremely difficult and complicated problem.
所以，对于你的问题，阿尔伯特，答案是这是一个非常困难和复杂的问题。

866
00:52:11,880 --> 00:52:14,880
One that makes my head spin when I try and understand it.
一个让我头晕的东西，当我试图理解它时。

867
00:52:14,880 --> 00:52:18,880
And one over which many PhDs have been written.
还有一个关于它已经写了许多博士论文的话题。

868
00:52:18,880 --> 00:52:22,880
So cache coherence is hard.
所以缓存一致性很难。

869
00:52:22,880 --> 00:52:24,880
It's very tricky to do.
这很棘手。

870
00:52:24,880 --> 00:52:28,880
And if you take 152, they'll go into it in quite a lot of detail.
如果你选择152，他们会详细介绍它。

871
00:52:28,880 --> 00:52:33,880
The different algorithms they use to detect coherence misses.
它们用于检测一致性缺失的不同算法。

872
00:52:33,880 --> 00:52:35,880
That's for data caches.
这是用于数据缓存的。

873
00:52:35,880 --> 00:52:40,880
And I particularly think 152 is a great class and you'll learn a ton if you take it.
而且我特别认为152是一门很棒的课程，如果你选修它，你会学到很多东西。

874
00:52:40,880 --> 00:52:45,880
TLBs are interesting because they tend not to participate in all those schemes.
TLBs是有趣的，因为它们往往不参与所有那些计划。

875
00:52:45,880 --> 00:52:52,880
Because the only time the data changes is when the operating system chose to change the page tables.
因为数据发生变化的唯一时机是操作系统选择改变页表时。

876
00:52:52,880 --> 00:52:57,880
And so TLBs tend to rely on manual cache invalidation.
因此，TLB通常依赖手动缓存失效。

877
00:52:57,880 --> 00:53:03,880
I know RISC-V does, or at least all the RISC-V implementations I'm familiar with do.
我知道RISC-V有，或者至少我熟悉的所有RISC-V实现都有。

878
00:53:03,880 --> 00:53:06,880
And I'm pretty sure x86 does as well.
我相当确定x86也是这样的。

879
00:53:06,880 --> 00:53:11,880
So in this case, the OS has to tell the CPU, hey, I invalidated this line, go and throw it out.
所以在这种情况下，操作系统必须告诉CPU，嘿，我使这一行无效了，去把它扔掉。

880
00:53:11,880 --> 00:53:16,880
So in that case, there's like the operating system is manually detecting it.
那么在这种情况下，就像操作系统是手动检测它一样。

881
00:53:16,880 --> 00:53:19,880
But for data caches, it gets very complicated.
但是对于数据缓存来说，情况变得非常复杂。

882
00:53:19,880 --> 00:53:21,880
And for distributed systems, too.
对于分布式系统，也是如此。

883
00:53:21,880 --> 00:53:29,880
So if you take a database class, you'll learn about dealing with cache coherence in like a distributed systems networked cluster kind of perspective.
所以如果你上数据库课，你会学习如何处理分布式系统网络集群中的缓存一致性问题。

884
00:53:29,880 --> 00:53:32,880
It's the same problem, slightly different constants.
这是同样的问题，只是常数稍有不同。

885
00:53:32,880 --> 00:53:34,880
So the solutions are a little different.
所以解决方案有些不同。

886
00:53:34,880 --> 00:53:36,880
OK.
Sure, I can help you with that. Please go ahead and provide me with the text you would like me to translate.

887
00:53:36,880 --> 00:53:43,880
So we're going to go through a quick here overview of caching again.
所以我们将再次快速浏览一下缓存的概述。

888
00:53:43,880 --> 00:53:47,880
This is, I think, largely a duplicate of what you learned in 61c.
这个，我想，大部分是你在61c学到的内容的重复。

889
00:53:47,880 --> 00:53:54,880
But obviously, that was quite a long time ago and 61c is a ridiculous class where you learn way too many things in one shot.
但显然，那是很久以前的事了，61c是一门荒谬的课程，你在一次上课中学到了太多的东西。

890
00:53:54,880 --> 00:53:56,880
So it's worth revisiting.
所以值得重新审视。

891
00:53:56,880 --> 00:54:02,880
So how do we find blocks? So we're using blocks. Sometimes we use the word cache line.
那么我们如何找到块呢？我们正在使用块。有时我们使用缓存行这个词。

892
00:54:02,880 --> 00:54:06,880
So how do we actually find them in cache? Most caches are organized this way.
那么我们实际上如何在缓存中找到它们呢？大多数缓存都是按照这种方式组织的。

893
00:54:06,880 --> 00:54:10,880
This is definitely by far the most typical way to organize a cache.
这绝对是迄今为止最典型的缓存组织方式。

894
00:54:10,880 --> 00:54:18,880
I guess in theory, there's other options, but I'm not really aware of anybody that does them in hardware in a way that's different than this.
我猜理论上还有其他选择，但我并不知道有谁在硬件方面以与此不同的方式进行。

895
00:54:18,880 --> 00:54:26,880
So what you do is it's very similar to what we've been seeing for virtual to physical translations.
你所做的事情非常类似于我们一直在看到的虚拟到物理的翻译。

896
00:54:26,880 --> 00:54:32,880
So I've got my address here. So this is the top part of the address.
所以我这里有我的地址。这是地址的上半部分。

897
00:54:32,880 --> 00:54:35,880
And this is whatever I'm asking for.
这就是我所要求的任何东西。

898
00:54:35,880 --> 00:54:39,880
There's also a part and this is the offset within the line.
还有一个部分，这是行内的偏移量。

899
00:54:39,880 --> 00:54:45,880
So I'm storing a block or a cache line. It's some fixed size. It's bigger than a byte.
所以我正在存储一个块或者缓存行。它有固定的大小。它比一个字节大。

900
00:54:45,880 --> 00:54:50,880
Right. So maybe it's 64 bytes, whatever it is. So I've got a 64 byte cache line.
好的。所以也许是64字节，无论是什么。所以我有一个64字节的缓存行。

901
00:54:50,880 --> 00:54:57,880
So I'm going to need some offset to figure out which byte that is.
所以我需要一些偏移量来确定是哪个字节。

902
00:54:57,880 --> 00:55:03,880
And then you've got the block address and the block address is going to help you figure out which cache line it is you're looking at.
然后你有了块地址，块地址将帮助你确定你正在查看的缓存行。

903
00:55:03,880 --> 00:55:09,880
And typically we break this block address into two parts. We'll call one the index and we'll call one the tag.
通常我们将这个块地址分成两部分。我们将其中一部分称为索引，另一部分称为标签。

904
00:55:09,880 --> 00:55:14,880
The index is the one we're actually going to use to find the block in our cache.
索引是我们实际上要用来在缓存中找到块的。

905
00:55:14,880 --> 00:55:18,880
And the tag is the one we're going to use to make sure it's the block we think it is.
并且标签是我们将要使用的，以确保它是我们认为的那个块。

906
00:55:18,880 --> 00:55:21,880
So caches are very, very similar to hash tables.
所以缓存和哈希表非常非常相似。

907
00:55:21,880 --> 00:55:28,880
And a lot of what you can learn learned about hash tables also will help you understand caches.
而且，你可以通过学习哈希表的知识来更好地理解缓存。

908
00:55:28,880 --> 00:55:35,880
So this tag is like, you know, in a hash table, you hash the value and you use that to find it.
所以这个标签就像，在哈希表中，你对值进行哈希处理，然后使用哈希值来查找它。

909
00:55:35,880 --> 00:55:42,880
And then you compare the actual value against what you found to make sure it's the one you wanted and not just like a conflict.
然后，你将实际值与你找到的值进行比较，以确保它是你想要的，而不仅仅是一个冲突。

910
00:55:42,880 --> 00:55:47,880
Same thing here. OK.
我也是一样的。好的。

911
00:55:47,880 --> 00:55:50,880
So one of the options we could do is called direct mapped.
所以我们可以选择的一个选项叫做直接映射。

912
00:55:50,880 --> 00:55:59,880
So in a direct map cache, we are going to have exactly one place that we could put any particular address.
在直接映射缓存中，我们将只有一个位置可以存放任何特定的地址。

913
00:55:59,880 --> 00:56:08,880
So in a way, you're going to use the index to choose exactly one slot.
所以从某种意义上说，你将使用索引来选择一个确切的插槽。

914
00:56:08,880 --> 00:56:11,880
So let's see.
那么让我们来看看。

915
00:56:11,880 --> 00:56:15,880
So if I've got a one kilobyte direct map cache, I got 32 byte blocks.
所以如果我有一个一千字节的直接映射缓存，我有32字节的块。

916
00:56:15,880 --> 00:56:25,880
There's an index and I'm going to use that index to pick a particular line, a particular place in this cache that I want.
有一个索引，我打算使用该索引来选择一个特定的行，一个我想要的缓存中的特定位置。

917
00:56:25,880 --> 00:56:29,880
So let's say that the index here is one.
所以假设这里的索引是一。

918
00:56:29,880 --> 00:56:36,880
We're going to use that to select one of these entries and then we're going to compare the tags.
我们将使用这个来选择其中一个条目，然后我们将比较标签。

919
00:56:36,880 --> 00:56:42,880
So I'm going to make sure that the tag I have in my cache is, in fact, same one as the address I'm looking for.
所以我要确保我缓存中的标签与我要查找的地址是相同的。

920
00:56:42,880 --> 00:56:49,880
And then if so, I'm going to use the byte select to pick a particular byte out of that cache line to return.
然后如果是这样的话，我将使用字节选择来选择缓存行中的特定字节并返回。

921
00:56:49,880 --> 00:56:55,880
So this is direct map. The important thing here about direct map is that you have exactly one option.
这是直接映射。关于直接映射的重要一点是，你只有一个选项。

922
00:56:55,880 --> 00:57:01,880
This index has exactly as many bits as you have entries in the cache.
这个索引的位数与缓存中的条目数量一样多。

923
00:57:01,880 --> 00:57:05,880
And it's just a direct index. If it's one, we go to the index number one.
而且这只是一个直接的索引。如果是一，我们就去索引号为一的地方。

924
00:57:05,880 --> 00:57:10,880
If it was two, we'd go to index number two. That's direct map.
如果是两个的话，我们会去索引号为二的位置。这是直接映射。

925
00:57:10,880 --> 00:57:15,880
Direct map has an issue. The issue with direct map is that it's got lots and lots of conflict misses.
直接映射存在一个问题。直接映射的问题在于它有很多冲突失效。

926
00:57:15,880 --> 00:57:19,880
Since I only have one option about where I'm going to put a piece of data,
由于我只有一个选项来确定我要放置一条数据的位置，

927
00:57:19,880 --> 00:57:26,880
it's pretty likely that somebody is already there and I'm going to have to kick them out in order to fit the new thing.
很有可能已经有人在那里了，我将不得不把他们赶出去，以便安装新的东西。

928
00:57:26,880 --> 00:57:31,880
So they have lots and lots of conflict misses because you only have one choice about where you're going to put anything.
所以他们有很多很多的冲突错失，因为你只有一个选择去放置任何东西的地方。

929
00:57:31,880 --> 00:57:38,880
So what we do instead is we come up with set associative. So in a set associative cache, we give ourselves more options.
所以我们做的是采用集合关联。在集合关联缓存中，我们给自己更多的选择。

930
00:57:38,880 --> 00:57:46,880
So instead of having exactly one place that we could put a particular piece of data, we have in places that we could put it.
所以，与其说我们只有一个特定的位置可以放置某个数据，不如说我们有多个可以放置它的位置。

931
00:57:46,880 --> 00:57:53,880
So you can think of this as having two direct map caches side by side, sort of conceptually.
所以你可以将其想象为两个直接映射缓存并排放置，从概念上来说。

932
00:57:53,880 --> 00:57:57,880
So you can think I have two direct map caches, but I've set them next to each other.
所以你可以认为我有两个直接映射缓存，但是我把它们放在一起。

933
00:57:57,880 --> 00:58:03,880
So each is half the size of my total cache. But I now have more options.
所以每个选项的大小是我的总缓存的一半。但是现在我有更多的选择。

934
00:58:03,880 --> 00:58:11,880
So we do the same thing. I'm going to use that cache index to pick which line in one of these caches it is.
所以我们做同样的事情。我将使用缓存索引来选择它在这些缓存中的哪一行。

935
00:58:11,880 --> 00:58:17,880
But I'm going to have to check two tags. So if I'm a two way set associative cache,
但是我需要检查两个标签。所以如果我是一个两路组相联缓存，

936
00:58:17,880 --> 00:58:24,880
then I have to check two tags at the same time. And then I get to pick whichever one matches, if any.
然后我需要同时检查两个标签。然后我可以选择与之匹配的任何一个，如果有的话。

937
00:58:24,880 --> 00:58:30,880
So the set associative caches are giving us more options. We're less likely to have a cache miss.
所以组相联缓存给我们提供了更多选择。我们更不太可能出现缓存未命中。

938
00:58:30,880 --> 00:58:37,880
Right. Because the data could go here, but this is full. So, OK, I guess we'll just put it here since this one's not full.
对的。因为数据可以放在这里，但这里已经满了。所以，好吧，我猜我们只能把它放在这里，因为这个还没满。

939
00:58:37,880 --> 00:58:43,880
So we have options and that's going to reduce conflict misses. But there's a there's a cost.
所以我们有选择，这将减少冲突失误。但是这是有代价的。

940
00:58:43,880 --> 00:58:55,880
The cost is complexity. So if you remember your Logisim project from 61C, like imagine writing a mux that could handle like a thousand inputs.
成本是复杂性。所以如果你还记得你在61C中的Logisim项目，就像想象一下编写一个能处理一千个输入的多路复用器。

941
00:58:55,880 --> 00:59:01,880
Think about how narrowly that mux would look. Right. It would have just bajillions of wires.
想想看那个多路复用器会有多窄。对，它会有无数根线。

942
00:59:01,880 --> 00:59:06,880
It would be huge. It would be like completely impractical to implement on like a physical chip.
这将是巨大的。在物理芯片上实现这样的功能将完全不切实际。

943
00:59:06,880 --> 00:59:14,880
So there are a limit to how many ways you can have before this stuff starts getting so complicated that your cycle time goes out the window.
所以在这些事情变得如此复杂以至于你的周期时间被抛在了窗外之前，有一定的限制。

944
00:59:14,880 --> 00:59:19,880
But you can do it. So in the extreme, we could say, all right, well, you know what, I don't care.
但是你可以做到。所以在极端情况下，我们可以说，好吧，你知道吗，我不在乎。

945
00:59:19,880 --> 00:59:28,880
My cache is small enough that that multiplexer isn't going to be too unreasonable. So why not have as many ways as I have lines?
我的缓存足够小，以至于多路复用器不会太过分。那么为什么不让路数和线数一样多呢？

946
00:59:28,880 --> 00:59:37,880
In this case, the whole thing is that the the entire the entire address part of your address, the entire selector part of your address.
在这种情况下，整个问题是你地址的整个地址部分，你地址的整个选择器部分。

947
00:59:38,160 --> 00:59:42,800
here is your tag. You just don't even have an index, right? You just search the entire
这是你的标签。你连索引都没有，对吗？你只是搜索整个。

948
00:59:42,800 --> 00:59:48,880
cache simultaneously to find your tag. And these work if the cache is small enough, you
同时在缓存中查找您的标签。如果缓存足够小，这些操作都有效。

949
00:59:48,880 --> 00:59:54,520
can get away with a fully associative cache, but it starts to wear out pretty fast, right?
可以使用全关联缓存，但它很快就会开始磨损，对吗？

950
00:59:54,520 --> 00:59:59,520
You're not going to have like even a multiple kilobyte cache. You couldn't have direct or
你不会有一个多千字节的缓存。你不能直接或者

951
00:59:59,520 --> 01:00:04,920
fully associative. It just wouldn't be possible to implement hardware.
完全关联。这在硬件上是不可能实现的。

952
01:00:04,920 --> 01:00:12,160
Okay, so let's see. So let's put them all together and kind of compare and contrast what would
好的，让我们来看看。让我们把它们都放在一起，然后进行比较和对比，看看会有什么不同。

953
01:00:12,160 --> 01:00:20,360
happen here. So let's say I'm trying to put block number one, I guess, or two, whatever.
发生在这里。所以假设我正在尝试放置第一个方块，或者第二个，随便。

954
01:00:20,360 --> 01:00:26,640
I'm trying to put this block here into a cache. So if it's direct mapped, I'm putting block
我正在尝试将这个块放入缓存中。所以如果是直接映射的话，我正在放置块。

955
01:00:26,640 --> 01:00:33,480
number 12. So I'm going to look at what the index here is 12. I've got eight blocks in
第12号。所以我要看一下这里的指数是12。我有八个方块。

956
01:00:33,480 --> 01:00:42,120
my cache. So I need to split 12 up into eight potential places. So I do 12 mod 8. That's,
我的高速缓存。所以我需要将12分成八个潜在的位置。所以我要做12除以8的余数。那就是，

957
01:00:42,120 --> 01:00:48,000
you know, mod in binary is the same as just like picking some bits. Turns out 12 mod 8,
你知道，二进制中的模运算与选择某些位是一样的。结果是12 mod 8，

958
01:00:48,000 --> 01:00:54,980
that's I think three or four, that's four. So we're going to find it here, direct mapped.
这是我认为的三个或四个，是四个。所以我们要在这里找到它，直接映射。

959
01:00:54,980 --> 01:01:01,760
Set associative. I have fewer slots now. So I have four sets, right? Because I'm two-way
关联集。我现在的插槽更少了。所以我有四个集合，对吗？因为我是双路的。

960
01:01:01,760 --> 01:01:10,040
set associative. So I have four sets, each set has four entries, four times four, or
四路组相联。所以我有四个组，每个组有四个条目，四乘以四，或者

961
01:01:10,040 --> 01:01:14,040
they have two entries. So each set has two entries. I have four sets, you have eight
他们有两个条目。所以每个集合有两个条目。我有四个集合，你有八个。

962
01:01:14,040 --> 01:01:20,440
lines total. So in this case, I'm going to do 12 mod 4 and pick which set it is in. So
总共有12行。在这种情况下，我将进行12除以4的取模运算，并选择它所在的集合。所以

963
01:01:20,440 --> 01:01:26,240
in this case, turns out it's in set zero. And then I'm going to compare both tags simultaneously
在这种情况下，结果是在集合零中。然后我将同时比较两个标签。

964
01:01:26,240 --> 01:01:30,600
and pick whichever one it is. And then of course, for fully associative, I'm not even
并选择其中一个。当然，对于完全关联的情况，我甚至不需要

965
01:01:30,600 --> 01:01:34,120
going to bother looking at the address. I'm just going to compare that address against
不打算费心查看地址。我只是要将那个地址与...进行比较。

966
01:01:34,120 --> 01:01:43,020
every single line until I find it. Okay, so that was a quick kind of whirlwind review
每一行直到我找到它。好的，那么这是一个快速的旋风式回顾。

967
01:01:43,020 --> 01:01:48,480
of cache organization. You can go back and kind of follow that along a little slower.
缓存组织的概念。你可以回过头来，稍微慢一点地跟上。

968
01:01:48,480 --> 01:01:54,520
It's worth keeping in mind, it's worth remembering caches are really important. The next question
值得记住的是，缓存非常重要。下一个问题是什么？

969
01:01:54,520 --> 01:02:01,680
you have with a cache is about what happens to it when you miss. So for direct map cache,
直接映射缓存的缓存未命中时会发生什么。

970
01:02:01,680 --> 01:02:07,980
there's really no choice, right? Like if I have to replace a block, I only had one option.
确实没有选择，对吗？比如说，如果我必须更换一个方块，我只有一个选项。

971
01:02:07,980 --> 01:02:13,360
So that's the one I'm going to kick out. Whoever was in my slot gets kicked out and I go there,
那么这就是我要赶走的那个人。谁曾经占据了我的位置就会被赶走，然后我会去那里。

972
01:02:13,360 --> 01:02:19,640
your only option. For set associative, we have a choice. You know, I have multiple ways.
你唯一的选择。对于集合关联，我们有选择的余地。你知道，我有多种方式。

973
01:02:19,640 --> 01:02:26,320
I have multiple sets in my cache, which if every entry in that set is full, who do I
我在我的缓存中有多个集合，如果每个集合中的每个条目都已满，我该怎么办？

974
01:02:26,320 --> 01:02:32,820
kick out? I can cook out any of them and still be correct. So which one do I choose? Two
踢出？我可以把它们中的任何一个踢出去，而且都是正确的。那么我该选择哪一个？两个。

975
01:02:32,820 --> 01:02:39,000
big strategies here could do it totally randomly, not the worst idea. Or I could do it using
大的策略在这里完全可以随机选择，这并不是最糟糕的想法。或者我可以使用...（需要继续提供翻译内容）

976
01:02:39,000 --> 01:02:44,680
the least recently used algorithm. This ends up being pretty true in practice. Like the
最近最少使用算法。实际上，这在实践中是相当准确的。就像

977
01:02:44,680 --> 01:02:50,840
thing I use the longest ago in the past is the one I'm least likely to use in the future.
过去我使用时间最长的东西，将来我最不可能再使用。

978
01:02:50,840 --> 01:02:58,920
So whichever one hasn't been used recently, that's probably a good choice to kick out.
所以，最近没有使用过的那个，可能是一个好的选择来排除掉。

979
01:02:58,920 --> 01:03:05,880
So we can go through some examples here. We don't need to look at these numbers too detailed.
所以我们可以在这里看一些例子。我们不需要过于详细地看这些数字。

980
01:03:05,880 --> 01:03:11,240
You can come back and stare at these if you'd like, but the trend here is multiple things.
你可以回来盯着这些看，如果你愿意的话，但这里的趋势是多个事物。

981
01:03:11,240 --> 01:03:17,920
So you can see that as you increase the associativity, so when we go this way, miss rates go down
所以你可以看到，当增加关联度时，也就是当我们这样做时，缺失率会下降。

982
01:03:17,920 --> 01:03:22,340
as you go this way. And as you go this way, as the cache gets bigger, miss rates also
随着你沿着这条路走。而随着你沿着这条路走，随着缓存变得更大，缺失率也会增加。

983
01:03:22,340 --> 01:03:31,560
go down. So this is removing conflict misses. This is removing capacity misses. So there's
下降。这是消除冲突缺失。这是消除容量缺失。所以有

984
01:03:31,560 --> 01:03:36,720
a question here about how we keep track of LRU. The way you keep track of LRU is you
一个关于如何追踪最近最少使用（LRU）的问题。你追踪LRU的方式是通过

985
01:03:36,720 --> 01:03:42,640
assign kind of like a shift register. You basically have a few bits. So if I have a
分配有点像一个移位寄存器。基本上你有几个位。所以如果我有一个

986
01:03:42,640 --> 01:03:47,980
two-way set associative cache, I can have one bit in there. And every time I read from
双向组相联缓存，我可以在其中有一个位。每次我从中读取时，

987
01:03:47,980 --> 01:03:54,540
that line, I set the bit. And I set the bit and I clear the other bit. So if I read from
那一行，我设置了位。我设置了这个位，然后清除了其他位。所以如果我从这里读取的话

988
01:03:54,540 --> 01:04:04,480
set zero, then I set its recently used bit to one, and I set way one's bit to false.
将零设置为1，然后将其最近使用的位设置为1，将第一路的位设置为false。

989
01:04:04,480 --> 01:04:09,120
So I can just alternate. If you have four, you can do it that way. But you basically
可以这样交替进行。如果你有四个，你可以这样做。但基本上你只需要

990
01:04:09,120 --> 01:04:13,880
have a counter next to every line and you update the counter on every access. And that
每一行都有一个计数器，每次访问时更新计数器。并且

991
01:04:13,880 --> 01:04:17,760
helps you keep track of LRU. There's other tricks too. You can do things with shift registers
帮助你跟踪最近最少使用（LRU）的东西。还有其他的技巧。你可以使用移位寄存器来做一些事情。

992
01:04:17,760 --> 01:04:23,920
and whatever. You can do approximate LRU if it's cheaper. But when you don't have too
并且随便。如果更便宜的话，你可以使用近似最近最少使用算法（LRU）。但是当你没有太多的资源时，

993
01:04:23,920 --> 01:04:28,260
many sets, it's pretty easy just to have a couple of counters that you update on every
许多集合，只需要几个计数器，每次更新即可。

994
01:04:28,260 --> 01:04:30,400
access.
访问。

995
01:04:30,400 --> 01:04:37,000
Okay. So what happens on a write? So this is another aspect of cache design, another
好的。写操作会发生什么？这是缓存设计的另一个方面，另一个...

996
01:04:37,000 --> 01:04:44,120
design choice we have. We have what happens when I need to write data to cache. So reading
设计选择我们有。我们有当我需要将数据写入缓存时会发生什么。所以阅读

997
01:04:44,120 --> 01:04:48,140
data from the cache is no big deal. That's what we've been talking about pretty much
缓存中的数据没什么大不了的。这就是我们一直在讨论的内容。

998
01:04:48,140 --> 01:04:53,080
this whole time. But what happens when we want to modify that data? So one strategy
这整个时间。但是当我们想要修改这些数据时会发生什么呢？所以有一个策略。

999
01:04:53,080 --> 01:05:00,320
is called write through. So in a write through cache, every time I write to my cache, I also
被称为写透。因此，在写透缓存中，每次我写入缓存时，我也会

1000
01:05:00,320 --> 01:05:04,240
write to the higher levels too. So I write to the next tier of the cache at the same
也要写入更高级别的层次。所以我同时将数据写入缓存的下一层。

1001
01:05:04,240 --> 01:05:12,160
time. The reason this works is that I can return as soon as the data is sort of being
时间。这个方法有效的原因是，只要数据开始排序，我就可以返回。

1002
01:05:12,160 --> 01:05:19,320
written. I can stick it in a queue and just have faith that it will get written eventually.
写好了。我可以把它放在队列中，相信它最终会被写出来。

1003
01:05:19,320 --> 01:05:23,200
So when we're doing write through, we're not limited by the latency of the cache. We're
因此，当我们执行写透模式时，我们不受缓存延迟的限制。我们可以

1004
01:05:23,200 --> 01:05:27,900
only limited by the bandwidth of the cache. And it turns out bandwidth is a lot easier
只受缓存带宽的限制。而事实证明，带宽要容易得多。

1005
01:05:27,900 --> 01:05:34,200
to achieve than latency. But it still has a problem. It's still using a ton of bandwidth
比延迟更难实现。但它仍然存在一个问题。它仍然使用大量的带宽。

1006
01:05:34,200 --> 01:05:40,720
to do that. We're writing a ton of data. And keep in mind, locality is a thing. That's
做那个。我们正在写大量的数据。请记住，局部性是一个重要因素。这是

1007
01:05:40,720 --> 01:05:46,000
the whole reason caches work. So if we wrote to an address once, we're probably going to
整个缓存工作的原因。所以如果我们对一个地址写入了一次，很可能我们会再次读取该地址。

1008
01:05:46,000 --> 01:05:51,900
write to it again soon. And so why should we be wasting all of this bandwidth writing
很快再写给它。那么为什么我们要浪费这么多带宽写东西呢？

1009
01:05:51,900 --> 01:05:56,860
over and over and over if we're just like iterating on a line? So the way to avoid that
一遍又一遍地迭代一行代码，这样有意义吗？所以避免这种情况的方法是什么？

1010
01:05:56,860 --> 01:06:02,720
is called write back. In a write back cache, what we do is we only bother storing the cache
被称为写回。在写回缓存中，我们所做的是只存储缓存。

1011
01:06:02,720 --> 01:06:08,300
line that we've written to. We only bother writing it back to the higher level layers
我们只会将它写回给更高层级的模块。

1012
01:06:08,300 --> 01:06:14,800
in our hierarchy if it gets evicted. So when we come in with a new line and we say, "Okay,
在我们的层级结构中，如果它被驱逐出去。所以当我们带着一条新线进来时，我们会说：“好的，

1013
01:06:14,800 --> 01:06:21,080
we have to kick this block out, this cache line out, but we've modified it. Oh, great.
我们必须将这个块踢出去，将这个缓存行踢出去，但我们已经修改过它了。哦，太好了。

1014
01:06:21,080 --> 01:06:26,800
Well, now we have to write it back as we evicted." So that's called write back. And the way you
好的，现在我们必须将其写回，就像我们被驱逐出去一样。所以这就叫做写回。而你可以这样做的方式是

1015
01:06:26,800 --> 01:06:33,240
do that is the same trick as I was just explaining for LRU. You just keep an extra bit around.
这个方法和我刚刚解释的LRU一样。你只需要多保留一个额外的位。

1016
01:06:33,240 --> 01:06:38,360
You set a bit if you've written to it. So if that bit is set, then, "Okay, well, I've
你写入了一个位，如果你写入了它。所以如果那个位被设置了，那么，“好的，嗯，我已经...

1017
01:06:38,360 --> 01:06:46,020
written to it. I need to write it back." Okay, so this is what I just said. But the bottom
line is, I need to respond to it in writing.

1018
01:06:46,020 --> 01:06:56,760
line here is that there's issues with write amplification. With a write through cache,
问题在于写放大。使用写透传缓存时，

1019
01:06:56,760 --> 01:07:05,000
when I evict a line, it doesn't cost me anything. So there's no additional work that's required
当我驱逐一行时，不会有任何费用。因此，不需要额外的工作。

1020
01:07:05,000 --> 01:07:10,040
in order to evict a line. You get to just delete it right away. No thought. Just, "Nah,
为了删除一行。你只需要立即删除它。不需要思考。只是，“不，

1021
01:07:10,040 --> 01:07:14,200
it's gone." Because I already wrote it higher up. So I can just delete it whenever I want
它已经消失了。因为我已经在上面写过了。所以我可以随时删除它。

1022
01:07:14,200 --> 01:07:19,220
and it won't break anything. But with a write back cache, it's more complicated. If I need
和它不会破坏任何东西。但是使用写回缓存会更加复杂。如果我需要

1023
01:07:19,220 --> 01:07:23,600
to evict a line, now I've got to figure out, "Oh, was it dirty? Oh, it was dirty. Let's
将一行驱逐出去，现在我得弄清楚，“哦，是脏的吗？哦，是脏的。让我们……”

1024
01:07:23,600 --> 01:07:29,200
figure out where to store it now." And it messes things up a little bit. But the real
弄清楚现在把它存放在哪里。这有点搞乱了事情。但是真正的

1025
01:07:29,200 --> 01:07:35,400
problem though is that with a write through cache, you could get hung up on bandwidth.
问题在于使用写透缓存时，可能会受到带宽的限制。

1026
01:07:35,400 --> 01:07:41,200
So I could spend way too much time doing writes that didn't even have to happen. And maybe
所以我可能会花太多时间做一些本来不必要的写作。也许

1027
01:07:41,200 --> 01:07:47,000
that interferes with my ability to read or write data that actually needed to be written.
这干扰了我阅读或写入实际需要写入的数据的能力。

1028
01:07:47,000 --> 01:07:51,200
So pros and cons, I think write backs are more common, but depending on the organization
优缺点来说，我认为回写更常见，但这取决于组织的情况。

1029
01:07:51,200 --> 01:07:57,280
of your cache and the relative speeds of things, write through might be a reasonable choice.
根据你的缓存大小和各项操作的相对速度，写入时更新（write through）可能是一个合理的选择。

1030
01:07:57,280 --> 01:08:07,120
Okay. A lot of stuff here, man. A lot of stuff. Caches are a really rich thing. There's a
好的。这里有很多东西，伙计。很多东西。缓存是一件非常丰富的事情。有一个

1031
01:08:07,120 --> 01:08:13,440
lot of different strategies around caches. So coming back to the theme of this whole
关于缓存有很多不同的策略。所以回到整个主题上来说

1032
01:08:13,440 --> 01:08:20,720
lecture, which is virtual memory, we have to ask the question, "What are the addresses
讲座中，关于虚拟内存，我们必须提出一个问题：“地址是什么？”

1033
01:08:20,720 --> 01:08:25,680
that we're using to look stuff up in the cache? Are we looking things up with physical addresses
我们正在使用来查找缓存中的内容的是什么？我们是使用物理地址来查找吗？

1034
01:08:25,680 --> 01:08:32,560
or are we looking things up with virtual addresses?" So with a physical cache, the way you would
或者我们是用虚拟地址查找东西的吗？所以使用物理缓存时，你会这样做。

1035
01:08:32,560 --> 01:08:37,880
have to implement that is you'd have to figure out what the physical address is first. And
必须实施的是，你首先需要弄清楚物理地址是什么。而且

1036
01:08:37,880 --> 01:08:41,880
once you figured out the physical address, then you can ask the cache to go ahead and
一旦你确定了物理地址，你就可以要求缓存继续进行。

1037
01:08:41,880 --> 01:08:48,160
look it up. So that would be a physically indexed cache. With a virtually indexed cache,
查一下吧。那将是一个物理索引缓存。而使用虚拟索引缓存，

1038
01:08:48,160 --> 01:08:53,520
I could access the cache directly and I would only need to access the TLB if I'm going higher
我可以直接访问缓存，只有当我需要访问更高级别时才需要访问TLB。

1039
01:08:53,520 --> 01:09:00,280
up in the memory. Right? So I could have a cache that only keeps track of virtual addresses.
在内存中提升。对吗？所以我可以有一个只跟踪虚拟地址的缓存。

1040
01:09:00,280 --> 01:09:03,760
And that saves me having to go through the NMU every time. I'd be able to just read and
并且这样就不用每次都经过NMU了。我只需要阅读就可以了。

1041
01:09:03,760 --> 01:09:09,560
write from it directly. So that's pretty slick. That seems really nice, but it has problems.
直接从中写入。这样很方便。听起来很不错，但是它有问题。

1042
01:09:09,560 --> 01:09:14,720
Right? It adds a lot of challenges. One is, remember this whole write through, write back
对吗？这增加了很多挑战。其中一个是，记住这个整个写入过程，写回

1043
01:09:14,720 --> 01:09:20,740
thing. If I want to write to this, so if this cache needs to write to memory, it then has
东西。如果我想要写入这个东西，那么如果这个缓存需要写入内存，它就有

1044
01:09:20,740 --> 01:09:26,920
to go through this NMU, through this TLB. And that can be kind of messy. The bigger
要经历这个NMU，通过这个TLB。而且可能会有点混乱。越大的

1045
01:09:26,920 --> 01:09:32,780
problem here though, a much, much bigger issue is that this cache, because it's storing virtual
问题在于，一个更大的问题是这个缓存，因为它存储的是虚拟的数据。

1046
01:09:32,780 --> 01:09:38,500
addresses, the cache is only valid for one process. If I switch processes, the cache
地址，缓存只对一个进程有效。如果我切换进程，缓存将会失效。

1047
01:09:38,500 --> 01:09:43,320
is like totally wrong now. Right? Because it was keeping track of virtual addresses.
是完全错误的。对吗？因为它一直在跟踪虚拟地址。

1048
01:09:43,320 --> 01:09:47,080
So that's a real problem with virtually address caches. There's, you know, tricks you can
所以这是虚拟地址缓存的一个真正问题。你知道，有一些技巧可以解决这个问题。

1049
01:09:47,080 --> 01:09:52,860
do. You can store which process that particular cache line corresponded to. There's a lot
可以。您可以存储该特定缓存行对应的进程。有很多方式可以实现。

1050
01:09:52,860 --> 01:09:56,900
of different things you can do, but none of them are pretty, right? They're all kind of
有很多不同的事情可以做，但没有一件是美好的，对吗？它们都有点

1051
01:09:56,900 --> 01:10:02,840
messy and they all have their own caveats and problems. So it's very tricky to pull
混乱，而且它们都有各自的限制和问题。所以要解决这个问题非常棘手。

1052
01:10:02,840 --> 01:10:06,800
this off, but it does make sense if you're willing to write all the complex circuitry,
这个关闭，但如果你愿意编写所有复杂的电路，它确实是有道理的。

1053
01:10:06,800 --> 01:10:11,440
if you're willing to make those trade-offs and if your workload supports it, maybe a
如果你愿意做出这些权衡，并且你的工作负荷支持的话，也许可以考虑一下。

1054
01:10:11,440 --> 01:10:17,140
virtually indexed cache makes sense. I think physically indexed is more common. I wish
虚拟索引缓存是有意义的。我认为物理索引更常见。我希望

1055
01:10:17,140 --> 01:10:22,360
I could tell you off the top of my head what RISC-V does, what, not RISC-V, what the Rocket
我可以立即告诉你RISC-V做了什么，不是RISC-V，而是Rocket做了什么。

1056
01:10:22,360 --> 01:10:29,000
Core implementation of RISC-V does. I believe that their L1 is some sort of goofy hybrid
RISC-V的核心实现是这样的。我相信他们的L1缓存是某种奇怪的混合体。

1057
01:10:29,000 --> 01:10:33,920
where the the MMU and TLB are super tightly integrated into the cache. So it's somewhat
在这里，MMU（内存管理单元）和TLB（转换后备缓冲）与缓存紧密集成在一起。因此，它在某种程度上是

1058
01:10:33,920 --> 01:10:38,840
virtually indexed. But I'm not 100% sure how that works.
几乎是索引的。但是我不100%确定它是如何工作的。

1059
01:10:38,840 --> 01:10:44,000
Okay, but for the most part, we're going to talk about physically indexed because that's
好的，但大部分时间我们会讨论物理索引，因为那是最常见的。

1060
01:10:44,000 --> 01:10:46,880
definitely the most common design.
绝对是最常见的设计。

1061
01:10:46,880 --> 01:10:54,640
Okay, so all of this talk about caches, all of this that we just spent a bunch of time
好的，所以所有关于缓存的讨论，我们刚刚花了很多时间在这上面。

1062
01:10:54,640 --> 01:11:01,760
talking about was in service of TLBs, right? This lecture still in theory is about virtual
是的，我们正在讨论TLB的工作原理，对吗？这个讲座仍然是关于虚拟的理论。

1063
01:11:01,760 --> 01:11:08,600
addresses. So let's get back to why we brought this up in the first place. And that is TLBs.
地址。那么让我们回到我们首次提到这个问题的原因。那就是TLB。

1064
01:11:08,600 --> 01:11:14,260
So, again, remember TLB is a cache. It's just a cache of translations. That's it. It's just
所以，再次记住，TLB是一个缓存。它只是一个翻译的缓存。就是这样。它只是一个缓存。

1065
01:11:14,260 --> 01:11:20,520
a cache that keeps track of those virtual to physical mappings.
一个跟踪虚拟到物理映射的缓存。

1066
01:11:20,520 --> 01:11:26,360
What are the properties we want out of a TLB? Well, the first one and, you know, really,
我们希望从TLB中获得哪些属性呢？嗯，第一个属性，你知道的，实际上，

1067
01:11:26,360 --> 01:11:32,080
really important one here is speed. TLB needs to be accessed on every single instruction
真正重要的是速度。TLB需要在每条指令上都被访问到。

1068
01:11:32,080 --> 01:11:37,960
and sometimes multiple times per instruction. So it's very, very important that the TLB
并且有时每个指令都会多次发生。所以非常、非常重要的是TLB

1069
01:11:37,960 --> 01:11:40,800
be fast.
快点。

1070
01:11:40,800 --> 01:11:44,980
So that means you maybe we want to keep it direct mapped or low associativity or something
这意味着你可能希望保持直接映射或低关联度，或者其他什么的。

1071
01:11:44,980 --> 01:11:50,420
like that. But we'll see why that maybe isn't the greatest idea.
那样。但我们会看到为什么那可能不是最好的主意。

1072
01:11:50,420 --> 01:11:55,240
The other issue is that we want to keep conflicts down. I mean, we always do. But the problem
另一个问题是我们希望减少冲突。我的意思是，我们总是这样做。但问题是

1073
01:11:55,240 --> 01:12:01,320
is that like, missing in a TLB is pretty painful, right? Walking those page tables is really
这是不是说，TLB缺失会非常痛苦？遍历那些页表真的很费劲。

1074
01:12:01,320 --> 01:12:07,000
slow. So the miss time here is not pretty. And the hit time is dictated by the clock
慢一点。所以这里的错过时间不太好。而命中时间由时钟决定。

1075
01:12:07,000 --> 01:12:12,240
cycle. So, again, we need it to be really fast in the common case, but we want it to
循环。所以，再次，我们希望它在常见情况下非常快，但我们希望它能够

1076
01:12:12,240 --> 01:12:17,920
not miss very often. And, you know, the trade off between those two properties is what hardware
不经常错过。而且，你知道，这两个属性之间的权衡是硬件的一个方面。

1077
01:12:17,920 --> 01:12:22,620
designers and architects spend a lot of their time doing is deciding how to trade off these
设计师和建筑师花费大量时间的工作是决定如何权衡这些因素。

1078
01:12:22,620 --> 01:12:23,620
goals.
目标。

1079
01:12:23,620 --> 01:12:24,620
Oops, sorry.
哎呀，抱歉。

1080
01:12:24,620 --> 01:12:39,660
I don't know what I'm doing here. Okay, whatever. Moving on. So the question is, how big do
我不知道我在这里做什么。好吧，随便。继续吧。所以问题是，有多大？

1081
01:12:39,660 --> 01:12:45,740
we make it? And what organization do we use? In practice, people usually make TLBs fast
我们成功了吗？我们使用哪个组织？实际上，人们通常会快速制作TLB。

1082
01:12:45,740 --> 01:12:50,800
by keeping them small. So that's the trick that hardware designers tend to use when they
通过保持它们的规模较小。这就是硬件设计师倾向于使用的技巧。

1083
01:12:50,800 --> 01:12:58,400
try and make a TLB fast. Because it's small, they get to be highly associative. And because
尽量让TLB快速。由于它的规模较小，它们可以具有高度关联性。而且由于

1084
01:12:58,400 --> 01:13:03,200
they're highly associative, their miss rate is pretty low. And this is just a trade off,
它们具有很高的关联性，其缺失率非常低。而这只是一个权衡。

1085
01:13:03,200 --> 01:13:06,880
right? You can make a lot of different decisions. But the hardware designers who've done all
是的吗？你可以做出很多不同的决策。但是那些已经完成了所有硬件设计的设计师们

1086
01:13:06,880 --> 01:13:11,480
the math, they've done all the profiling, all the experiments, they decided that, you
数学，他们已经完成了所有的剖析，所有的实验，他们决定，你

1087
01:13:11,480 --> 01:13:18,560
know what, this is probably the best way to make the TLB work the way we want it to. Right,
知道吗，这可能是使TLB按我们想要的方式工作的最佳方法。对吧，

1088
01:13:18,560 --> 01:13:23,720
again, because it's a cache, we can do all the same tricks with caches, right, we can
再次，因为它是一个缓存，我们可以使用所有与缓存相关的技巧，对吗？我们可以

1089
01:13:23,720 --> 01:13:28,880
have a multi level TLB. Why not? Right, we have multi level caches, why not have multi
拥有多级TLB。为什么不呢？对了，我们有多级缓存，为什么不拥有多级TLB呢？

1090
01:13:28,880 --> 01:13:34,400
level TLBs? It'll still work. Right. So you know, we can look at this example, I think
级别的TLB？它仍然可以工作。对的。所以你知道，我们可以看一下这个例子，我觉得

1091
01:13:34,400 --> 01:13:40,880
I want to just get through more content. But ultimately, a TLB is going to store a virtual
我想要更多地浏览内容。但最终，一个TLB将会存储一个虚拟的什么？

1092
01:13:40,880 --> 01:13:47,240
address, a physical address and metadata. Right. And I guess one piece of metadata worth
地址，一个实际地址和元数据。对的。我猜一个值得的元数据。

1093
01:13:47,240 --> 01:13:51,400
mentioning here, there's there's two particularly important ones here that we'll talk about
提到这里，有两个特别重要的事情，我们将会谈论到。

1094
01:13:51,400 --> 01:13:58,520
later. One is ASID, that is the address space identifier. So we want to be able to support
稍后。其中一个是ASID，即地址空间标识符。因此，我们希望能够支持。

1095
01:13:58,520 --> 01:14:04,200
multiple processes. And this ASID is what we use to keep track of that. So you can think
多个进程。而这个ASID就是我们用来跟踪它们的。所以你可以这样想

1096
01:14:04,200 --> 01:14:10,200
of this kind of like the kind of like a pointer or the index of the of the page table. So
这种类似于指针或页面表的索引。所以

1097
01:14:10,200 --> 01:14:15,080
it's like a process ID, who's who does this virtual address belong to? And then the other
这就像一个进程ID，这个虚拟地址属于谁？然后另一个是什么？

1098
01:14:15,080 --> 01:14:20,100
one that's important here is the valid bit. So the valid bit tells us whether or not this
这里重要的是有效位。因此，有效位告诉我们这个是否有效。

1099
01:14:20,100 --> 01:14:25,260
mapping actually exists. So we might have a page table entry, but that page table entry
映射实际上是存在的。所以我们可能有一个页表项，但是这个页表项

1100
01:14:25,260 --> 01:14:29,120
might not point anywhere real, or maybe it's been revoked, or maybe it's been changed,
可能没有指向任何真实的地方，或者可能已被撤销，或者可能已被更改，

1101
01:14:29,120 --> 01:14:33,680
a lot of different reasons why it might not be valid, but we have to know. And that's
有很多不同的原因可能导致它无效，但我们必须知道。而且这是

1102
01:14:33,680 --> 01:14:42,700
going to prevent us from doing the translation if it's not valid. Okay, and just, you know,
如果翻译无效，我们将无法进行翻译。好的，你知道的，

1103
01:14:42,700 --> 01:14:48,660
so you understand the TLBs are tightly integrated into the core, they have to be really fast,
所以你明白TLB（转换后备缓冲器）紧密集成在核心中，它们必须非常快速。

1104
01:14:48,660 --> 01:14:54,040
they have to be very close to the core. And so we have actual different stages, different
它们必须非常接近核心。因此，我们有实际上的不同阶段，不同的...

1105
01:14:54,040 --> 01:14:59,360
designs of the TLB. And there's parts of it that are spread around different parts of
TLB的设计。其中有一些部分分散在不同的地方。

1106
01:14:59,360 --> 01:15:04,240
your of your core. So actually implementing TLBs is quite a very interesting digital logic
你的核心之一是TLB。因此，实际实现TLB是非常有趣的数字逻辑。

1107
01:15:04,240 --> 01:15:13,680
and computer architecture question. Okay, there's all sorts of tricks you can do. Again,
和计算机架构的问题。好的，有各种各样的技巧可以使用。再说一遍，

1108
01:15:13,680 --> 01:15:17,300
just just your computer architects are full of this kind of thing where they have all
只是你的计算机架构师们都充满了这种东西，他们拥有一切。

1109
01:15:17,300 --> 01:15:23,820
these little tricks that make things faster. So for example, you know, you can imagine
这些小技巧可以让事情更快。比如说，你可以想象一下，

1110
01:15:23,820 --> 01:15:31,880
that you have a physically addressed hash and a TLB. And maybe we can play a trick and
你有一个物理地址哈希和一个TLB。也许我们可以玩个小把戏，然后...

1111
01:15:31,880 --> 01:15:38,980
do something in parallel. So we can maybe overlap. So I'm going to, I'm going to show
同时进行一些事情。这样我们可能会有重叠。所以我打算，我打算展示

1112
01:15:38,980 --> 01:15:43,960
an example here of how that might work. So you might imagine that I've got this address
这里有一个例子，展示了它可能是如何工作的。你可以想象一下，我有这个地址。

1113
01:15:43,960 --> 01:15:49,120
here that I'm trying to translate. And it turns out that the say there's these top bits
这里是我正在尝试翻译的内容。结果发现他们说有这些顶部的位。

1114
01:15:49,120 --> 01:15:53,120
here, these top 20 bits, that's the virtual page number. And that's the only thing that
在这里，这前20位是虚拟页码。这是唯一的东西。

1115
01:15:53,120 --> 01:15:57,600
TLB needs to look up, right, the TLB doesn't care about this chunk, it only cares about
TLB 需要查找，对吗？TLB 不关心这个块，它只关心

1116
01:15:57,600 --> 01:16:02,480
the virtual page number. So we'll send that to the TLB, it'll start translating. And if
虚拟页号。所以我们将把它发送给TLB，它将开始翻译。如果

1117
01:16:02,480 --> 01:16:07,980
we have the right size of caches, if everything lines up, we might be able to have the index
我们有合适大小的缓存，如果一切顺利，我们可能能够拥有索引。

1118
01:16:07,980 --> 01:16:13,980
here be these lower bits, and we can send that to the physical cache. And then so now
这里是这些低位，我们可以将其发送到物理缓存。然后现在可以这样做。

1119
01:16:13,980 --> 01:16:18,860
the physical cache tries to find the line, the TLB tries to find the translation. And
物理缓存尝试查找数据行，TLB尝试查找翻译。而且

1120
01:16:18,860 --> 01:16:24,080
then once they've actually done it, we can, we can look at the tag and the physical page
然后一旦他们真正完成了，我们可以，我们可以查看标签和实际页面。

1121
01:16:24,080 --> 01:16:29,480
number. And if they match, we have a hit. So it's a dirty little trick. And it works
数字。如果它们匹配，我们就有一个命中。所以这是一个不光彩的小把戏。而且它有效。

1122
01:16:29,480 --> 01:16:34,300
if all the numbers line up. But as soon as the caches don't line up, it stops working.
如果所有的数字都对齐，但一旦缓存不对齐，它就停止工作了。

1123
01:16:34,300 --> 01:16:40,480
So that's a little tricks. Highly recommend taking 152 if you're interested in all of
这是一个小技巧。如果你对所有的东西都感兴趣，强烈推荐选修152课程。

1124
01:16:40,480 --> 01:16:51,520
these tricks, because there's a ton of them. Okay, um, so we only have a minute left. So
这些技巧，因为有很多。好的，嗯，我们只剩下一分钟了。所以

1125
01:16:51,520 --> 01:16:56,860
let's see. Let's talk about context switches, and then we'll finish. So what happens when
我们来看看。让我们谈谈上下文切换，然后我们就完成了。那么当发生什么情况时，

1126
01:16:56,860 --> 01:17:03,720
I change the process? If I switch processes, I have to be careful to keep track of which
我改变这个流程吗？如果我切换流程，我必须小心地跟踪哪个流程

1127
01:17:03,720 --> 01:17:10,680
process this TLB entry goes to. So maybe I flush the entire entire TLB. If I didn't keep
处理这个TLB条目的过程。所以也许我要刷新整个TLB。如果我没有保留

1128
01:17:10,680 --> 01:17:15,660
track of address spaces, we saw in the RS 3000, which is just an older processor, that
地址空间的跟踪，我们在RS 3000中看到，这只是一个较旧的处理器。

1129
01:17:15,660 --> 01:17:19,340
they do keep track of addresses, a lot of tricks, a lot of different ways you could
他们确实会追踪地址，有很多诡计，很多不同的方法可以做到。

1130
01:17:19,340 --> 01:17:25,520
do it. But you have to you have to pick one, right, either you invalidate the whole TLB
做吧。但你必须选择一个，对吧，要么你使整个TLB无效。

1131
01:17:25,520 --> 01:17:31,040
on each context switch, which is slow, but simple. Or you create you keep a process ID
在每次上下文切换时，这是慢但简单的。或者你可以保留一个进程ID。

1132
01:17:31,040 --> 01:17:36,760
in the TLB, that might slow down the hit time of the TLB. But you know, won't have all these
在TLB中，这可能会降低TLB的命中时间。但是你知道的，不会有所有这些。

1133
01:17:36,760 --> 01:17:42,440
misses when you contact switch. And then there's this is the last one, this is what I was talking
联系开关时会错过。然后还有最后一个，这就是我所说的。

1134
01:17:42,440 --> 01:17:47,540
about, it's possible for the OS to change the page tables on you, right, it does it
关于这个问题，操作系统有可能在你的情况下改变页表，对吗？它确实会这样做。

1135
01:17:47,540 --> 01:17:52,120
all the time. And if you do, then you have to go and invalidate the TLB. So those are
一直以来。如果你这样做了，那么你就必须去使TLB失效。所以这些都是

1136
01:17:52,120 --> 01:17:57,620
those coherence misses that the TLB is really have to deal with. And this is a really big
那些一致性缺失是TLB真正需要处理的。而且这是一个非常大的问题。

1137
01:17:57,620 --> 01:18:03,560
design decision in operating systems, operating systems spend a lot of mental energy, trying
操作系统中的设计决策，操作系统会花费大量精力来尝试

1138
01:18:03,560 --> 01:18:11,400
to understand this and make this not happen too often. Okay, so um, yeah, so I'm going
理解这个并且让这种情况不再经常发生。好的，嗯，所以，是的，我要去。

1139
01:18:11,400 --> 01:18:18,020
to end it there. Because we're out of time. And I'll let the next lecture kind of do this,
结束到这里。因为我们时间不够了。我会让下一节课来继续这个话题。

1140
01:18:18,020 --> 01:18:23,260
this is a great slide to start the next lecture on anyways. So you guys will start with this
这是一个很好的幻灯片，可以用来开始下一堂课。所以你们将从这个开始。

1141
01:18:23,260 --> 01:18:29,000
overview. And then you can get into more interesting stuff around paging. And you know, people
概述。然后你可以深入研究一些关于分页的有趣内容。你知道的，人们

1142
01:18:29,000 --> 01:18:33,220
asked about what happens when software has to deal with the disk, all that stuff, you
问到当软件需要处理硬盘时会发生什么，所有那些东西，你想知道什么？

1143
01:18:33,220 --> 01:18:39,240
can look forward to that in the next lecture. So I'll end it there. I think we're out of
可以期待下一堂讲座中的内容。所以我就到这里结束了。我觉得我们已经讲完了。

1144
01:18:39,240 --> 01:18:44,500
time. And I'll stick around for a few minutes if anybody wants to ask questions, and then
时间。如果有人想问问题，我会再待几分钟，然后

1145
01:18:44,500 --> 01:19:14,440
I'll end off the recording. So thanks for listening.
我将结束录音。谢谢你的聆听。

1146
01:19:14,440 --> 01:19:24,400
Bye bye.
再见。

1147
01:19:24,400 --> 01:19:24,680
Transcribed by https://otter.ai
由https://otter.ai转录

1148
01:19:24,680 --> 01:19:25,680
Transcribed by https://otter.ai
由https://otter.ai转录

1149
01:19:25,680 --> 01:19:26,680
Transcribed by https://otter.ai
由https://otter.ai转录

1150
01:19:26,680 --> 01:19:52,680
[ Silence ]
[沉默]

