1
00:00:28,670 --> 00:00:29,980
Hello, everybody.

2
00:00:32,260 --> 00:00:33,890
Welcome to the 11th lecture. 

3
00:00:33,900 --> 00:00:36,310
So hopefully you hear me. 

4
00:00:38,620 --> 00:00:41,850
Today we are going to continue our discussion about scheduling. 

5
00:00:43,660 --> 00:00:46,660
We are going to learn a bit about fairness, real time,

6
00:00:47,350 --> 00:00:49,830
and making further progress, 

7
00:00:49,840 --> 00:00:50,990
avoiding starvation, 

8
00:00:51,870 --> 00:00:53,910
and do one or two case studies. 

9
00:00:56,120 --> 00:01:02,600
So one thing just to start with is us a question I got from some people

10
00:01:02,610 --> 00:01:04,080
also before the midterm. 

11
00:01:05,010 --> 00:01:09,630
It's about what is the operating system, 

12
00:01:09,640 --> 00:01:14,110
scheduling processes or threads? 

13
00:01:15,500 --> 00:01:17,530
The answer, obviously, is threats.

14
00:01:18,800 --> 00:01:21,030
A process has at least one threat. 

15
00:01:22,190 --> 00:01:24,660
When a process has exactly one thread, 

16
00:01:24,670 --> 00:01:27,260
then you can think about its interchangeable. 

17
00:01:28,310 --> 00:01:33,050
The scared the kernel will scared either a process or astray, you can say.

18
00:01:34,080 --> 00:01:35,180
But obviously, 

19
00:01:35,190 --> 00:01:36,220
when a thread, 

20
00:01:36,230 --> 00:01:38,380
aaa process has multiple threads, 

21
00:01:38,950 --> 00:01:39,850
kernel threads, 

22
00:01:40,360 --> 00:01:47,270
then the operating system will schedule independently each thread of the process. 

23
00:01:48,080 --> 00:01:48,510
Okay? 

24
00:01:48,970 --> 00:01:54,300
Now the one thing to keep in mind is that when you switch between the context, 

25
00:01:54,310 --> 00:01:56,180
switching between two threads, 

26
00:01:56,610 --> 00:01:59,210
if you remember which belong to the same process, 

27
00:01:59,750 --> 00:02:03,500
that's much quicker because they are living in the same address space, 

28
00:02:04,080 --> 00:02:07,130
you do not need to switch the address space. 

29
00:02:07,710 --> 00:02:08,040
However, 

30
00:02:08,050 --> 00:02:13,200
when you switch between two threads which are indifferent processes, 

31
00:02:13,530 --> 00:02:15,980
then you need also to switch the address space. 

32
00:02:16,370 --> 00:02:17,880
And that's much more expensive. 

33
00:02:18,290 --> 00:02:22,800
Think about one order of magnitude more expensive to switch to context, 

34
00:02:22,810 --> 00:02:24,900
switch between two stress in different processes, 

35
00:02:25,370 --> 00:02:28,060
then switching between two strides in the same process. 

36
00:02:30,910 --> 00:02:33,010
And also remember here that actually, 

37
00:02:33,020 --> 00:02:38,620
there is this multithreading or hyper simultaneous multithreading or hyperthreading, 

38
00:02:38,630 --> 00:02:44,260
that's kind of the harder level which allows you to run multiple threads

39
00:02:44,270 --> 00:02:45,820
on the same call. 

40
00:02:46,080 --> 00:02:49,680
But from the operating system and from the application, 

41
00:02:49,900 --> 00:02:52,650
the only difference is that is hyper threading. 

42
00:02:52,850 --> 00:02:54,410
You can run more threads, 

43
00:02:54,420 --> 00:02:55,690
kernel thread at the same time. 

44
00:02:56,100 --> 00:02:57,020
There's the only difference, 

45
00:02:58,690 --> 00:02:59,230
nothing more. 

46
00:03:00,680 --> 00:03:02,880
Now, we discussed last time,

47
00:03:02,890 --> 00:03:08,890
we did come first set of we ended up with this kind of discipline, 

48
00:03:08,900 --> 00:03:12,770
which is when we look at the best first compass, if you remember,

49
00:03:13,630 --> 00:03:17,230
we are starting with the smallest job first, 

50
00:03:17,830 --> 00:03:21,710
and then to minimize the waiting time and to minimize the completion time. 

51
00:03:22,520 --> 00:03:22,950
Okay. 

52
00:03:24,020 --> 00:03:27,110
Obviously, the question here is that for that,

53
00:03:27,120 --> 00:03:28,470
we need to know the future. 

54
00:03:28,940 --> 00:03:32,820
And if the future, 

55
00:03:32,830 --> 00:03:34,260
can we meet all the best? 

56
00:03:35,110 --> 00:03:36,240
First come first serve? 

57
00:03:36,810 --> 00:03:39,310
The answer is, obviously we all be said,

58
00:03:39,320 --> 00:03:40,430
what is a discipline? 

59
00:03:41,070 --> 00:03:46,380
And that is to run the first job at first. 

60
00:03:46,850 --> 00:03:47,250
Right? 

61
00:03:48,200 --> 00:03:50,640
So whatever job takes, 

62
00:03:50,650 --> 00:03:51,800
the least run. 

63
00:03:52,120 --> 00:03:54,270
It has priority over other jobs. 

64
00:03:55,180 --> 00:03:57,370
And there are two versions of that. 

65
00:03:58,090 --> 00:03:59,560
One, it's a preemp.

66
00:03:59,570 --> 00:04:01,600
It's non preemptive version and gone. 

67
00:04:01,610 --> 00:04:03,400
And the other one is preemptive version. 

68
00:04:04,340 --> 00:04:08,100
As and I implies for the non preemptive version, 

69
00:04:08,110 --> 00:04:10,860
you run each job all the way to completion. 

70
00:04:11,420 --> 00:04:12,850
In the preemptive version, 

71
00:04:12,860 --> 00:04:15,650
you are going to comprehend the existing jobs. 

72
00:04:15,820 --> 00:04:17,610
For instance, if any existing jobs,

73
00:04:17,950 --> 00:04:19,580
there's still 10 seconds to run. 

74
00:04:19,590 --> 00:04:20,980
And now a new job arrives, 

75
00:04:20,990 --> 00:04:22,620
which is only 1 second to run. 

76
00:04:22,630 --> 00:04:27,350
The new job is going to preempt the existing job because it has

77
00:04:27,360 --> 00:04:30,520
only 1 second to finish while the preview while

78
00:04:30,530 --> 00:04:33,040
the existing joke still has 10 seconds to finish. 

79
00:04:33,690 --> 00:04:34,150
Okay. 

80
00:04:34,570 --> 00:04:36,540
This is about shortest remaining time. 

81
00:04:36,550 --> 00:04:36,870
First, 

82
00:04:37,980 --> 00:04:40,410
this is a preemptive version of shortage of us. 

83
00:04:46,050 --> 00:04:47,180
So remember about that? 

84
00:04:47,190 --> 00:04:48,260
So this is optimal. 

85
00:04:48,270 --> 00:04:53,210
And you can show that is optimal from the point of view of reduction, 

86
00:04:53,220 --> 00:04:55,600
reducing or minimizing the completion time. 

87
00:04:59,990 --> 00:05:02,080
So keeping keep in mind, 

88
00:05:02,090 --> 00:05:04,180
this is an optimal scheduling discipline. 

89
00:05:04,930 --> 00:05:05,300
Now, 

90
00:05:06,560 --> 00:05:08,680
so it's, 

91
00:05:13,030 --> 00:05:19,490
so one question here is that when you have shortest remaining time, first,

92
00:05:20,160 --> 00:05:23,580
if you want to compare with his first come first set up, 

93
00:05:24,020 --> 00:05:25,050
the one question is, 

94
00:05:25,060 --> 00:05:26,930
what if all jobs have the same length? 

95
00:05:26,940 --> 00:05:28,490
Because it's all jobs at the same length? 

96
00:05:28,500 --> 00:05:31,170
What you are going to do all of them are going to take the same time. 

97
00:05:32,130 --> 00:05:35,020
In this case, there is no difference between them, right?

98
00:05:35,030 --> 00:05:38,160
Because it doesn't matter in which order you are going to run, 

99
00:05:38,170 --> 00:05:40,140
because you need to break the ties, 

100
00:05:40,480 --> 00:05:43,350
because they all have the same length in some arbitrary fashion. 

101
00:05:43,360 --> 00:05:47,420
And first come first service one of these ways to break the ties. 

102
00:05:48,570 --> 00:05:50,580
And you are going to get the same results. 

103
00:05:52,470 --> 00:05:54,420
Obviously, if the jobs are varying length,

104
00:05:54,840 --> 00:05:57,680
then with the shortest stop short, 

105
00:05:57,690 --> 00:06:03,500
the remaining time first is going to prioritize, obviously, the short jobs.

106
00:06:03,880 --> 00:06:08,360
And they are not going to go to to start to be stuck behind the long ones. 

107
00:06:08,370 --> 00:06:11,650
Remember that the first come, first set, they didn't have,

108
00:06:12,100 --> 00:06:19,170
you might not have a good average response time when you have a big job, 

109
00:06:19,180 --> 00:06:23,450
and then as a small jobs are just stuck behind the big job, 

110
00:06:23,460 --> 00:06:27,810
because all the small jobs are going to inherit the completion time, 

111
00:06:27,820 --> 00:06:30,510
the running time of the big job, 

112
00:06:30,520 --> 00:06:31,950
because I have to wait after it. 

113
00:06:34,930 --> 00:06:38,880
Here is a simple example to illustrate the benefit of the shortest

114
00:06:38,890 --> 00:06:39,920
remaining time. 

115
00:06:39,930 --> 00:06:40,320
First. 

116
00:06:41,010 --> 00:06:42,760
The shortest reminding time, 

117
00:06:42,770 --> 00:06:44,080
remaining time first. 

118
00:06:44,650 --> 00:06:50,500
It's a preemptive version of shorter job first. 

119
00:06:51,190 --> 00:06:52,640
And here you have two jobs, 

120
00:06:53,400 --> 00:06:55,860
a and b they are cpu bound, 

121
00:06:55,870 --> 00:06:58,260
meaning that they use only the cpu say, 

122
00:06:58,270 --> 00:07:00,020
run for a week or for a long time. 

123
00:07:00,630 --> 00:07:02,470
And then you have another job see, 

124
00:07:02,860 --> 00:07:04,180
which is io bound. 

125
00:07:05,620 --> 00:07:11,030
This means that you do an eye operation in one will take so many seconds

126
00:07:11,040 --> 00:07:11,990
to do eye operation, 

127
00:07:12,000 --> 00:07:12,390
like, say,

128
00:07:12,400 --> 00:07:14,610
you read or write to the list, 

129
00:07:14,620 --> 00:07:19,070
but then I you wait for 9 million seconds for the operation to complete. 

130
00:07:20,310 --> 00:07:20,790
Okay? 

131
00:07:21,460 --> 00:07:24,820
If you run one of the jobs at a time, 

132
00:07:25,240 --> 00:07:32,730
then job a or b will use 100% of the cpu and 0% of the io of the disk. 

133
00:07:34,270 --> 00:07:36,220
If you run c at the time, 

134
00:07:37,980 --> 00:07:42,110
c will use10% of the cpu and 90% of the risk. 

135
00:07:43,090 --> 00:07:46,360
So what will happen with first time for a setup? 

136
00:07:46,680 --> 00:07:47,580
With first fargo? 

137
00:07:47,590 --> 00:07:49,100
First come, first serve.

138
00:07:49,330 --> 00:07:52,950
Once a our big is scheduled, 

139
00:07:52,960 --> 00:07:56,230
then it's going to run the story. 

140
00:07:57,000 --> 00:08:00,840
Going to hold the cpu for2 weeks together. 

141
00:08:02,820 --> 00:08:05,730
They are going to get in because even if she starts to love me, 

142
00:08:05,740 --> 00:08:07,050
as starts to learn, 

143
00:08:07,060 --> 00:08:08,610
starts to run. 

144
00:08:09,090 --> 00:08:13,700
After 1 mini seconds is going to give up the cpu because it has to wait

145
00:08:14,080 --> 00:08:16,380
for to get

146
00:08:19,840 --> 00:08:21,240
the eye operation complete. 

147
00:08:23,030 --> 00:08:26,950
Now, what about a round robin or short as remaining time?

148
00:08:26,960 --> 00:08:28,430
First in this particular case? 

149
00:08:29,330 --> 00:08:30,360
Let's see what happens. 

150
00:08:32,160 --> 00:08:35,800
This is round robin and assume the round robin. 

151
00:08:35,810 --> 00:08:39,410
The time slice is 100 million seconds, okay?

152
00:08:39,730 --> 00:08:44,140
So you execute in round robin every job. 

153
00:08:44,710 --> 00:08:49,760
So let's start with c it's again and say the time slice is

154
00:08:49,770 --> 00:08:51,000
100 million seconds again. 

155
00:08:51,680 --> 00:08:58,590
So you start to see c runs for 1 millisecond and then gives up yell the cpu

156
00:08:58,600 --> 00:09:01,350
because it needs to wait for the eye operation to complete. 

157
00:09:02,260 --> 00:09:05,070
Then you have to run a and then b and c again. 

158
00:09:06,210 --> 00:09:08,930
Now a and b because our cpu bounded, 

159
00:09:08,940 --> 00:09:11,250
they are going to take their entire time quanta. 

160
00:09:11,260 --> 00:09:12,490
That is 100 reset. 

161
00:09:13,160 --> 00:09:13,570
Right? 

162
00:09:14,010 --> 00:09:15,700
In this case, a discretization,

163
00:09:15,710 --> 00:09:17,060
if you look about, 

164
00:09:18,100 --> 00:09:19,780
is like from around, 

165
00:09:19,790 --> 00:09:28,790
when you schedule caabc then it takes to all of them to complete takes 200, 

166
00:09:29,220 --> 00:09:30,390
1 million seconds, 

167
00:09:31,070 --> 00:09:36,330
100 for a 100 for b and one for c and out of this time, 

168
00:09:36,340 --> 00:09:38,770
because you have the only one eye operation, 

169
00:09:38,780 --> 00:09:43,100
because the schedule c only once the eye operation kept takes 9 millisecond. 

170
00:09:43,760 --> 00:09:46,070
The discretization is 9 over 201, 

171
00:09:46,080 --> 00:09:48,100
which is.5 years ago, 

172
00:09:48,110 --> 00:09:49,260
4.5%. 

173
00:09:51,510 --> 00:09:52,830
Very little bit. 

174
00:09:53,940 --> 00:09:55,090
Now let's say you do that. 

175
00:09:55,100 --> 00:09:56,450
Our robin of 1 millisecond. 

176
00:09:56,460 --> 00:09:59,850
If you do round robin of about 1 millisecond, what do you go?

177
00:10:00,830 --> 00:10:01,340
What happens? 

178
00:10:01,350 --> 00:10:02,060
Your schedule? 

179
00:10:02,070 --> 00:10:04,060
C first, it takes 1 millisecond.

180
00:10:04,810 --> 00:10:07,480
Then c will have to wait for 9. 

181
00:10:07,490 --> 00:10:12,270
Millisecond is going to be in the waiting queue to wait for the operations

182
00:10:12,280 --> 00:10:12,850
to conflict. 

183
00:10:13,090 --> 00:10:13,370
Right? 

184
00:10:13,740 --> 00:10:15,170
During these 9 million seconds, 

185
00:10:15,180 --> 00:10:19,680
you are going to ultimate between a and b each of them for 1 million seconds, 

186
00:10:19,690 --> 00:10:22,340
because they are ready to always run, 

187
00:10:22,350 --> 00:10:24,300
because they are only cpu bounded, right?

188
00:10:25,520 --> 00:10:26,790
What you get here, 

189
00:10:27,080 --> 00:10:29,710
the discretization is 90%, right?

190
00:10:29,720 --> 00:10:34,570
Because see, it's already once an io completes see,

191
00:10:34,580 --> 00:10:38,530
it's ready to launch the next time. 

192
00:10:38,940 --> 00:10:39,230
Right? 

193
00:10:39,630 --> 00:10:41,540
The problem here is, if you see it,

194
00:10:42,450 --> 00:10:44,840
this is great maximize the discretization, 

195
00:10:44,850 --> 00:10:46,440
but in this particular case, 

196
00:10:46,450 --> 00:10:48,770
you have a loss of context switches, right?

197
00:10:48,780 --> 00:10:51,610
Because between a and b you have a lot of contact switches. 

198
00:10:52,320 --> 00:10:54,630
And at every one, the second.

199
00:10:56,500 --> 00:10:58,540
Now what happens is the shortest time first, 

200
00:10:58,890 --> 00:11:00,280
the shortest time first, 

201
00:11:00,290 --> 00:11:01,330
remaining time first. 

202
00:11:01,340 --> 00:11:03,080
So shortest remaining time first. 

203
00:11:03,430 --> 00:11:04,400
Let's see what happens. 

204
00:11:04,910 --> 00:11:06,240
First, exactly see.

205
00:11:07,880 --> 00:11:09,730
Like in the previous two cases, 

206
00:11:10,220 --> 00:11:11,490
it takes 1 millisecond, 

207
00:11:11,810 --> 00:11:18,300
and then is going to wait for9 million seconds for the eye of the complete. 

208
00:11:18,860 --> 00:11:19,250
Right? 

209
00:11:21,140 --> 00:11:23,050
See, it's on the way to you.

210
00:11:23,060 --> 00:11:28,490
So now you need to schedule between a and b let's say you schedule a you

211
00:11:28,500 --> 00:11:32,440
are going to schedule a until c becomes, 

212
00:11:32,770 --> 00:11:34,930
again, ready for execute to execute.

213
00:11:35,160 --> 00:11:38,830
And he will become ready to execute when his io has completed. 

214
00:11:38,840 --> 00:11:40,630
So after 9 million seconds, 

215
00:11:41,590 --> 00:11:43,230
in the first 90 seconds, 

216
00:11:43,490 --> 00:11:47,130
you run a and now c is ready to execute, 

217
00:11:47,140 --> 00:11:49,010
and c takes only 1 millisecond. 

218
00:11:49,480 --> 00:11:53,750
The remaining time to finish first for seats, 

219
00:11:53,760 --> 00:12:00,980
1 millisecond while for a it's 1 week minus9 millisecond. 

220
00:12:02,000 --> 00:12:04,160
So we are going to schedule c see it again, 

221
00:12:04,170 --> 00:12:05,920
takes 1 millisecond to go to sleep, 

222
00:12:06,220 --> 00:12:09,740
because it's just like for waiting for the eye operation to complete. 

223
00:12:10,010 --> 00:12:14,770
And now you have a and ba remaining time. 

224
00:12:15,130 --> 00:12:16,840
It's 1 week-90 seconds, 

225
00:12:16,850 --> 00:12:20,880
the remaining time for b we didn't run at all b it's 1 week. 

226
00:12:22,540 --> 00:12:25,370
A is 1 week-90 seconds, b is 1 week.

227
00:12:26,230 --> 00:12:29,950
A will take shorter to complete to terminate. 

228
00:12:30,680 --> 00:12:32,470
Therefore, you are going to schedule a gaming,

229
00:12:32,480 --> 00:12:33,630
so you started to do it. 

230
00:12:34,060 --> 00:12:40,210
You do cacaca until a finishes this utilization 90%, 

231
00:12:40,730 --> 00:12:41,980
and much fewer context edges. 

232
00:12:42,680 --> 00:12:42,920
Right? 

233
00:12:44,590 --> 00:12:45,250
Any questions? 

234
00:12:45,260 --> 00:12:45,890
Please ask? 

235
00:12:46,340 --> 00:12:47,530
Let's make it, again.

236
00:12:47,820 --> 00:12:48,640
More interactive. 

237
00:12:51,230 --> 00:12:53,740
It's pretty hard to just stare at the screen. 

238
00:12:58,920 --> 00:12:59,950
Anyway, now,

239
00:12:59,960 --> 00:13:01,590
what is the problem with shortest time? 

240
00:13:01,600 --> 00:13:01,950
First? 

241
00:13:01,960 --> 00:13:03,350
As short as yours are remaining? 

242
00:13:03,360 --> 00:13:03,790
The time? 

243
00:13:04,490 --> 00:13:07,090
First is starvation, what does it mean?

244
00:13:07,100 --> 00:13:07,320
Starvation? 

245
00:13:07,760 --> 00:13:12,040
Can someone tell me what starvation means and why we are going to have starvation? 

246
00:13:12,050 --> 00:13:12,640
In this case? 

247
00:13:26,330 --> 00:13:32,040
Never getting to run b never is scheduled in the previous example. 

248
00:13:32,050 --> 00:13:32,760
Actually. 

249
00:13:33,140 --> 00:13:35,160
After you finish a you are going to eventually run. 

250
00:13:35,170 --> 00:13:37,440
So we will wait a long time, 

251
00:13:37,450 --> 00:13:40,310
but starvation means that it may never be, 

252
00:13:40,570 --> 00:13:42,310
you may never run as a joke. 

253
00:13:51,670 --> 00:13:52,700
Any other answer? 

254
00:13:52,990 --> 00:13:56,070
So it's against starvation means that the job industry remains a system

255
00:13:56,270 --> 00:13:58,440
without ever being run executive. 

256
00:13:59,920 --> 00:14:00,790
When can this happen? 

257
00:14:06,780 --> 00:14:07,300
That's great. 

258
00:14:08,050 --> 00:14:09,530
So allison, 

259
00:14:10,320 --> 00:14:13,800
so if you have a stream of short jobs, 

260
00:14:14,410 --> 00:14:16,450
you always get new, short jobs,

261
00:14:17,000 --> 00:14:20,760
then the long job may never be scheduled. 

262
00:14:22,670 --> 00:14:23,790
That's exactly what happens. 

263
00:14:29,660 --> 00:14:35,110
The other problem with this shortest remaining time first is that you

264
00:14:35,120 --> 00:14:36,150
need to predict the future. 

265
00:14:36,160 --> 00:14:40,230
You need to know how long a job is going to take. 

266
00:14:40,740 --> 00:14:44,230
There was a question or two last lectures about this. 

267
00:14:48,130 --> 00:14:50,360
There are some ways none of them is perfect. 

268
00:14:51,170 --> 00:14:54,440
One way is to rely on the users and as the users, 

269
00:14:54,450 --> 00:14:56,920
how long will take the job or the job will take. 

270
00:14:57,880 --> 00:15:00,090
But with this has certain problems. 

271
00:15:00,100 --> 00:15:01,200
First of all, 

272
00:15:02,390 --> 00:15:03,730
you assume the user now, 

273
00:15:03,740 --> 00:15:05,080
which is not always true, 

274
00:15:05,670 --> 00:15:07,030
or which is rarely true. 

275
00:15:07,690 --> 00:15:12,880
And also you open yourself to an attack in the sense that a user, 

276
00:15:13,350 --> 00:15:18,220
because if the user now that the system using the shortest remaining time first, 

277
00:15:18,510 --> 00:15:19,800
will declare a very short time, 

278
00:15:19,810 --> 00:15:21,480
even if the job will take long. 

279
00:15:21,730 --> 00:15:23,120
Because in this way, 

280
00:15:24,010 --> 00:15:26,470
she can ensure that the job will be scattered. 

281
00:15:29,850 --> 00:15:33,120
The other thing which is not here is basically to keep the history. 

282
00:15:33,130 --> 00:15:34,520
If you run a job repeatedly, 

283
00:15:34,530 --> 00:15:35,800
you look at the history. 

284
00:15:36,270 --> 00:15:43,060
If you see how long you basically assume that the past running time is

285
00:15:43,070 --> 00:15:46,180
a good predictor for the future running time for the same job. 

286
00:15:46,190 --> 00:15:48,260
And we are going to use that prediction. 

287
00:15:50,490 --> 00:15:52,580
But anyway, so this is hard.

288
00:15:52,880 --> 00:15:57,420
However, shortest running time first is still a very important discipline.

289
00:15:57,690 --> 00:15:58,660
For one reason, 

290
00:15:59,370 --> 00:16:00,920
it represents a yardstick. 

291
00:16:00,930 --> 00:16:04,090
It's a baseline for measuring other policies. 

292
00:16:04,310 --> 00:16:08,780
When it comes to minimize the average response line, 

293
00:16:10,580 --> 00:16:11,250
it's optimal. 

294
00:16:11,260 --> 00:16:12,290
You cannot do it better. 

295
00:16:13,510 --> 00:16:16,780
If you are looking, if you are designing a new scheduler, one of them,

296
00:16:16,790 --> 00:16:18,700
at least the average response time, 

297
00:16:19,040 --> 00:16:21,470
you are going to compare the average response time

298
00:16:21,480 --> 00:16:25,910
of that new discipline or scheduling discipline through your design, 

299
00:16:26,340 --> 00:16:27,820
Against the shortest, 

300
00:16:28,210 --> 00:16:29,390
a remaining time first. 

301
00:16:29,740 --> 00:16:31,610
The closer you are, the better you are,

302
00:16:33,730 --> 00:16:35,640
in summary, for shortest remaining time.

303
00:16:35,650 --> 00:16:36,120
First. 

304
00:16:36,760 --> 00:16:40,230
It's optimal with respect to a very response time, 

305
00:16:40,240 --> 00:16:42,030
but it can be hard to predict. 

306
00:16:43,090 --> 00:16:44,040
It brings the future. 

307
00:16:44,050 --> 00:16:45,480
You need to bring the future. 

308
00:16:45,490 --> 00:16:46,440
And this is hard. 

309
00:16:46,650 --> 00:16:49,460
And can be unfair. 

310
00:16:49,470 --> 00:16:51,140
Here means also starvation. 

311
00:16:51,370 --> 00:16:54,570
The long jobs not may never be scheduled. 

312
00:17:01,480 --> 00:17:04,670
This is what I said in the earliest. 

313
00:17:04,680 --> 00:17:06,670
This is one way to implement what I said. 

314
00:17:07,870 --> 00:17:09,060
In the previous slide, 

315
00:17:09,070 --> 00:17:12,500
that one way is to predict is based on the past behavior. 

316
00:17:12,510 --> 00:17:12,740
Right? 

317
00:17:12,750 --> 00:17:18,300
So you look at is that how long a particular job or process the first time

318
00:17:18,550 --> 00:17:20,330
is the previous first time? 

319
00:17:20,340 --> 00:17:27,360
And you use that as aa prediction for the future times and for the future. 

320
00:17:27,370 --> 00:17:31,610
And one way is to do this exponentially averaging in which you

321
00:17:31,620 --> 00:17:35,010
are going to put away against the

322
00:17:35,020 --> 00:17:38,970
duration of the last time the job runs, 

323
00:17:39,370 --> 00:17:47,260
and then discount to one minus alpha

324
00:17:47,270 --> 00:17:51,780
for the existing prediction. 

325
00:17:52,400 --> 00:17:54,030
You have an existing prediction. 

326
00:17:55,640 --> 00:17:58,670
You can multiply that pre existing prediction with a way. 

327
00:17:59,210 --> 00:18:02,000
Then you add to one minus weight, 

328
00:18:03,170 --> 00:18:06,820
the last running time of the job. 

329
00:18:08,650 --> 00:18:09,720
At one extreme, 

330
00:18:09,730 --> 00:18:11,560
if you wait with zero, 

331
00:18:14,140 --> 00:18:15,910
the previous prediction, 

332
00:18:16,120 --> 00:18:20,470
this means that you don't care about the past execution, 

333
00:18:20,480 --> 00:18:24,190
but the last one because the weight will be one for the last execution. 

334
00:18:24,890 --> 00:18:28,440
And if you have a small weight for the last execution, 

335
00:18:28,710 --> 00:18:31,060
this means that you are going to put a lot of weight

336
00:18:31,380 --> 00:18:34,700
on the previous equations before the last one. 

337
00:18:42,780 --> 00:18:44,090
What about the fairness? 

338
00:18:44,500 --> 00:18:48,000
And this is a very important aspect they are going to talk about. 

339
00:18:48,250 --> 00:18:50,450
We discuss about first come first serve, 

340
00:18:50,460 --> 00:18:51,530
not really fair. 

341
00:18:51,540 --> 00:18:55,090
We discuss about shortage of first not really necessary fair. 

342
00:18:56,100 --> 00:18:58,820
We discuss about robin actually that's kind of fair. 

343
00:19:03,490 --> 00:19:08,070
And now, 

344
00:19:09,020 --> 00:19:12,850
keep in mind that this kind of fairness is another very important metric. 

345
00:19:13,120 --> 00:19:15,720
We are going to use to characterize the schedule. 

346
00:19:18,850 --> 00:19:20,500
And fundamentally, 

347
00:19:20,510 --> 00:19:22,790
there is a strict, 

348
00:19:23,510 --> 00:19:27,750
it's a hard trade off between the average response time and the fairness. 

349
00:19:28,770 --> 00:19:29,160
Right? 

350
00:19:29,670 --> 00:19:30,890
If you remember, 

351
00:19:30,900 --> 00:19:34,490
we had last lecture, 

352
00:19:34,500 --> 00:19:38,450
we had this example and between the round robin, which is fair,

353
00:19:38,460 --> 00:19:40,500
because during one round, 

354
00:19:40,510 --> 00:19:45,850
you schedule every process or every job. 

355
00:19:48,310 --> 00:19:49,420
First come, first serve.

356
00:19:50,140 --> 00:19:55,200
If you remember, you are looking at equal a length of jobs.

357
00:19:56,390 --> 00:20:00,580
And because if you really want to be fair, 

358
00:20:00,590 --> 00:20:02,540
everyone will finish at the same time. 

359
00:20:02,550 --> 00:20:04,420
So everyone will be like, 

360
00:20:05,140 --> 00:20:05,540
right? 

361
00:20:05,920 --> 00:20:09,070
Heard the average response time while if you are not fair, 

362
00:20:09,810 --> 00:20:15,360
if you run everyone at comfortable at every job to completion, 

363
00:20:15,560 --> 00:20:18,500
then the one that you get first are going to finish

364
00:20:18,510 --> 00:20:20,180
much earlier than the last one. 

365
00:20:20,530 --> 00:20:20,890
Right? 

366
00:20:21,480 --> 00:20:24,700
So you're going to get better response to keep in mind. 

367
00:20:24,710 --> 00:20:32,510
The fairness may in general hurt the response to how do you and basically also

368
00:20:32,520 --> 00:20:37,270
have other scheduling discipline like we are going to learn about fixed priority. 

369
00:20:37,720 --> 00:20:40,690
The fixed priority is also fundamental fair. 

370
00:20:40,970 --> 00:20:43,690
With a priority, basically assign different jobs,

371
00:20:43,700 --> 00:20:45,010
different priorities, 

372
00:20:45,890 --> 00:20:49,280
because you deem that some jobs are more important than the others. 

373
00:20:49,290 --> 00:20:50,000
And by the way, 

374
00:20:50,010 --> 00:20:53,120
whenever you say something is more important than the other, 

375
00:20:53,370 --> 00:20:55,190
basically, you give up on the fairness.

376
00:20:55,800 --> 00:20:56,790
It's at some level. 

377
00:20:57,830 --> 00:20:59,230
So how do you implement fairness? 

378
00:21:01,100 --> 00:21:03,150
One is around robin. 

379
00:21:05,330 --> 00:21:12,670
But and but the fundamental thing is that to implement fairness, you need,

380
00:21:12,950 --> 00:21:13,620
in some sense, 

381
00:21:13,630 --> 00:21:18,260
to divide to visualize the cpu you need to divine devise acpu and give

382
00:21:18,270 --> 00:21:21,310
each job a fraction of the cpu

383
00:21:27,710 --> 00:21:28,900
and now, 

384
00:21:29,210 --> 00:21:30,710
let's talk a little bit about units. 

385
00:21:32,850 --> 00:21:33,840
In unix, 

386
00:21:36,550 --> 00:21:40,740
it's using an original unit is using priority scheduling. 

387
00:21:41,590 --> 00:21:43,330
So you have a bunch of priorities, 

388
00:21:44,680 --> 00:21:46,790
as if you remember from last time, 

389
00:21:46,800 --> 00:21:52,040
and the jobs and with the highest priority are going to run first. 

390
00:21:52,610 --> 00:21:55,770
And jobs is a lower priority can run. 

391
00:21:56,050 --> 00:22:00,360
Only if there are no other jobs is higher priority which are ready to run. 

392
00:22:02,420 --> 00:22:03,460
So this is a call. 

393
00:22:03,760 --> 00:22:06,630
But now how do you are going to get some fairness? 

394
00:22:06,930 --> 00:22:07,300
Right? 

395
00:22:07,820 --> 00:22:12,560
There are I many proposals, 

396
00:22:13,620 --> 00:22:15,880
one way to implement. 

397
00:22:16,250 --> 00:22:17,360
It's not very scheduled. 

398
00:22:18,150 --> 00:22:18,560
Okay? 

399
00:22:19,320 --> 00:22:20,350
So this one, 

400
00:22:20,360 --> 00:22:23,270
and it's a very nice analogy. 

401
00:22:23,690 --> 00:22:25,160
It's basically the lottery scheduling. 

402
00:22:25,170 --> 00:22:28,310
You give each job some number of lottery tickets. 

403
00:22:29,680 --> 00:22:30,880
And each time, 

404
00:22:31,240 --> 00:22:33,480
each time slice, you randomly pick a winning ticket.

405
00:22:34,110 --> 00:22:34,520
Right? 

406
00:22:34,980 --> 00:22:35,690
On average, 

407
00:22:35,700 --> 00:22:41,810
the cpu time is proportionally allocated to the number of tickets given

408
00:22:41,820 --> 00:22:42,450
to a job. 

409
00:22:45,340 --> 00:22:48,710
Now, how you can assign the dockets, right?

410
00:22:49,190 --> 00:22:50,340
How you are going to. 

411
00:22:50,350 --> 00:22:53,980
And it turns out that the nice thing about this lottery scheduling, 

412
00:22:54,430 --> 00:23:03,490
you can approximate some of these other disciplines. 

413
00:23:05,560 --> 00:23:06,590
If you want, 

414
00:23:07,130 --> 00:23:08,560
or you can use to implement, 

415
00:23:09,190 --> 00:23:12,040
like, if you want to implement shortest running time first,

416
00:23:12,450 --> 00:23:15,610
you can give those are small jobs, 

417
00:23:15,620 --> 00:23:18,490
a much larger number of tickets. 

418
00:23:19,130 --> 00:23:19,330
Right? 

419
00:23:19,540 --> 00:23:21,170
The long jobs get fewer tickets. 

420
00:23:22,120 --> 00:23:22,460
Now, 

421
00:23:23,040 --> 00:23:25,330
the nice thing it's also can avoid starvation. 

422
00:23:27,060 --> 00:23:29,500
If I give to each job, 

423
00:23:30,470 --> 00:23:31,680
at least one picket, 

424
00:23:32,420 --> 00:23:32,670
right? 

425
00:23:32,680 --> 00:23:33,550
At least one picket, 

426
00:23:34,320 --> 00:23:38,640
then that job is not going to be stuck forever, 

427
00:23:39,670 --> 00:23:44,730
because it will be at some. that is the cat will be selected. 

428
00:23:45,420 --> 00:23:46,640
And therefore, it will be scattered.

429
00:23:51,680 --> 00:23:54,550
This is one advantage of our state priorities, right?

430
00:23:55,010 --> 00:23:57,200
Again, you restate priorities.

431
00:23:57,550 --> 00:23:58,560
If a job, 

432
00:23:59,050 --> 00:24:07,350
a if you are aaa job cannot run unless there is no other job ready to execute, 

433
00:24:07,780 --> 00:24:08,850
which has high approach. 

434
00:24:10,980 --> 00:24:15,350
With this one, we say the jobs in the heart already have more tickets,

435
00:24:15,660 --> 00:24:17,250
but the job is a low priority. 

436
00:24:17,510 --> 00:24:18,610
Have at least on weekend. 

437
00:24:20,010 --> 00:24:20,880
Now I will be stuck. 

438
00:24:25,580 --> 00:24:25,690
Here. 

439
00:24:25,700 --> 00:24:26,410
It's an example, 

440
00:24:28,220 --> 00:24:29,300
lottery scheduling. 

441
00:24:29,310 --> 00:24:32,460
So assume that you have short jobs and long jobs, 

442
00:24:33,060 --> 00:24:36,870
and you have a job, 

443
00:24:38,230 --> 00:24:39,640
get ten tickets, 

444
00:24:39,650 --> 00:24:41,720
and long job get one ticket. 

445
00:24:42,440 --> 00:24:42,820
Right? 

446
00:24:44,540 --> 00:24:49,130
If a short job gets ten tickets and a long job gets one ticket, 

447
00:24:49,550 --> 00:24:59,030
then the cpu get given to the short jobs is 91%, right?

448
00:24:59,650 --> 00:25:01,080
The other one is 9%. 

449
00:25:01,800 --> 00:25:02,880
Because in total, 

450
00:25:02,890 --> 00:25:04,880
you have 11 tickets in the system, 

451
00:25:05,580 --> 00:25:07,010
then for the short jobs, 

452
00:25:07,520 --> 00:25:08,680
one for the long jobs. 

453
00:25:10,370 --> 00:25:20,350
If you if you are going to give you have two long jobs, 

454
00:25:23,520 --> 00:25:27,050
and you zero short jobs, 

455
00:25:28,220 --> 00:25:30,180
you are going to divide, 

456
00:25:30,450 --> 00:25:32,550
because each long job gets on tickets, 

457
00:25:32,560 --> 00:25:34,270
you have only two tickets in the system. 

458
00:25:34,600 --> 00:25:36,390
Each of the long jobs will get 50%. 

459
00:25:36,400 --> 00:25:38,390
If you have two short jobs, 

460
00:25:38,400 --> 00:25:40,310
you have 50%, each of short jobs.

461
00:25:40,320 --> 00:25:41,750
You don't have any long jobs. 

462
00:25:42,180 --> 00:25:43,540
You have ten, short, long,

463
00:25:43,550 --> 00:25:45,460
short jobs and long, long jobs.

464
00:25:45,960 --> 00:25:52,780
You have now101 tickets in the system because each short job will have ten tickets. 

465
00:25:54,310 --> 00:25:57,680
Therefore, the short jobs get,

466
00:25:59,030 --> 00:26:00,830
they should each issue jobs, 

467
00:26:00,840 --> 00:26:03,670
each issue job get 9.9%, 

468
00:26:03,970 --> 00:26:05,920
all short jobs will get 99%. 

469
00:26:06,910 --> 00:26:11,890
The a as a long job will get on% and so forth. 

470
00:26:13,050 --> 00:26:15,000
Let me see if there is a question. 

471
00:26:18,670 --> 00:26:20,900
Since the scheduling is probabilistic, 

472
00:26:20,910 --> 00:26:25,860
isn't there still the possibility that the long job gets started

473
00:26:25,870 --> 00:26:27,100
for quite a while? 

474
00:26:29,440 --> 00:26:30,120
That's correct. 

475
00:26:30,890 --> 00:26:33,880
The long job can still wait for a while, 

476
00:26:34,400 --> 00:26:41,030
but eventually is going to be selected while in, 

477
00:26:44,150 --> 00:26:45,270
say, for instance,

478
00:26:45,280 --> 00:26:52,020
with shorter job first or with for a strict priority scheduling, 

479
00:26:53,320 --> 00:26:56,080
a job might never ever be scheduled. 

480
00:26:57,040 --> 00:27:04,500
If there are always enough lower priority jobs in the system, 

481
00:27:04,510 --> 00:27:05,700
very good question. 

482
00:27:10,160 --> 00:27:10,530
Okay. 

483
00:27:13,730 --> 00:27:16,600
What if too many short jobs are in the system to give reason

484
00:27:16,610 --> 00:27:17,560
of the response time? 

485
00:27:18,560 --> 00:27:21,590
You can take a long time. 

486
00:27:21,600 --> 00:27:23,980
So it can be hard to make progress, right?

487
00:27:23,990 --> 00:27:25,300
Because there are too many jobs. 

488
00:27:25,810 --> 00:27:29,790
So it takes too long to get your thought. 

489
00:27:32,950 --> 00:27:38,480
11answer here is that kick some users out of the system. 

490
00:27:44,500 --> 00:27:44,980
Now, 

491
00:27:45,500 --> 00:27:47,460
let's take a step back and let's say, 

492
00:27:47,470 --> 00:27:53,190
what are the kind of jobs you are expecting to run on to your computer? 

493
00:27:54,090 --> 00:27:56,190
And typically, there is a mix of jobs.

494
00:28:00,400 --> 00:28:03,070
One of them will have the short burst time, 

495
00:28:03,820 --> 00:28:05,840
and some of them longer burst times. 

496
00:28:06,710 --> 00:28:09,170
Let's see, think about what are this kind of job?

497
00:28:09,180 --> 00:28:10,170
What are the possible? 

498
00:28:11,310 --> 00:28:12,800
Some jobs are interactive jobs, 

499
00:28:13,450 --> 00:28:13,740
right? 

500
00:28:14,640 --> 00:28:15,360
These are, 

501
00:28:17,890 --> 00:28:20,360
it's editors, 

502
00:28:21,910 --> 00:28:25,030
your chat application. 

503
00:28:25,530 --> 00:28:27,920
You're interacting with the browser. 

504
00:28:28,910 --> 00:28:30,440
And it's not a short burst, right?

505
00:28:30,450 --> 00:28:32,840
It's interactive like the short burst. 

506
00:28:33,400 --> 00:28:37,100
They have to respond quickly into the user interaction. 

507
00:28:40,470 --> 00:28:45,780
Then there are other ones which are io it's also io not necessarily the users, 

508
00:28:45,790 --> 00:28:50,590
but they are waiting for networking to get the data from the network

509
00:28:51,180 --> 00:28:52,670
or for an eye or to complete. 

510
00:28:53,250 --> 00:28:53,610
Right? 

511
00:28:55,520 --> 00:29:00,310
There are others which are long run. 

512
00:29:00,680 --> 00:29:02,030
Like, for instance,

513
00:29:02,510 --> 00:29:03,510
one example, 

514
00:29:03,520 --> 00:29:05,750
would be a compiler, 

515
00:29:06,770 --> 00:29:07,800
or one example. 

516
00:29:07,810 --> 00:29:08,520
You do training, 

517
00:29:09,200 --> 00:29:09,760
machine learning. 

518
00:29:12,560 --> 00:29:17,790
And you'd expect here that if something is interactive, 

519
00:29:17,800 --> 00:29:19,630
it has to get the higher priority, 

520
00:29:20,480 --> 00:29:23,990
because he needs to provide the user good user experience and the one which

521
00:29:24,000 --> 00:29:26,470
are not in long running jobs. 

522
00:29:26,880 --> 00:29:29,820
It's okay that they are not interactive because they are running in the background. 

523
00:29:30,420 --> 00:29:30,630
Right? 

524
00:29:30,640 --> 00:29:36,570
It doesn't matter if a training neural network model is going to take

525
00:29:36,940 --> 00:29:39,110
5 hours or 5 hours and 5 minutes. 

526
00:29:42,280 --> 00:29:48,780
These are not will not realize. 

527
00:29:49,300 --> 00:29:49,700
Okay. 

528
00:29:50,560 --> 00:29:52,230
So again, in general,

529
00:29:52,240 --> 00:29:54,270
it's hard to characterize all the application. 

530
00:29:54,700 --> 00:29:55,100
But, 

531
00:29:55,950 --> 00:30:01,040
again, you can classify broadly in interactive applications.

532
00:30:01,050 --> 00:30:04,800
They have typically have short bars and long running applications, 

533
00:30:04,810 --> 00:30:07,150
which have obviously long reversed. 

534
00:30:09,600 --> 00:30:19,030
So in recognizing that this is how early implement the scheduler, 

535
00:30:19,520 --> 00:30:21,610
this is multilevel feedback schedule. 

536
00:30:23,410 --> 00:30:27,120
The mind never scheduling is like it has a bunch of cures, 

537
00:30:29,170 --> 00:30:31,550
and each queue has a different priority, 

538
00:30:33,110 --> 00:30:35,570
the different time quant, let me guess.

539
00:30:38,320 --> 00:30:45,460
So the cure at the top has a highest priority, 

540
00:30:45,470 --> 00:30:46,960
and there were a task. 

541
00:30:47,300 --> 00:30:50,840
It's the process is in cue first. 

542
00:30:52,300 --> 00:30:55,180
And the same time quanta says 8 million seconds. 

543
00:30:56,810 --> 00:31:04,120
And if a job spends

544
00:31:05,000 --> 00:31:08,820
too much time on at some level, 

545
00:31:09,660 --> 00:31:13,160
is demoted to the next level. 

546
00:31:13,770 --> 00:31:15,450
In this case, there's an execute,

547
00:31:16,030 --> 00:31:22,850
which is quantum of 16 millisecond. 

548
00:31:24,670 --> 00:31:27,420
If you spend too much at this level, 

549
00:31:27,430 --> 00:31:31,280
you are demoted to the next cure, 

550
00:31:31,290 --> 00:31:33,810
which is first conference set. 

551
00:31:34,560 --> 00:31:35,750
So the first two, 

552
00:31:37,490 --> 00:31:40,680
can each of these levels can use a different schedule and be separate? 

553
00:31:42,390 --> 00:31:43,630
The first two, in this case,

554
00:31:43,640 --> 00:31:45,830
can use round robin. 

555
00:31:46,170 --> 00:31:47,600
The last time first come, first set.

556
00:31:49,770 --> 00:31:50,070
Basically, 

557
00:31:50,080 --> 00:31:56,660
what does this mean is that if you have an interactive job which are small bursts, 

558
00:31:58,310 --> 00:31:59,950
that will be first endured. 

559
00:32:01,060 --> 00:32:02,080
At the first level, 

560
00:32:02,590 --> 00:32:03,770
as a highest priority, 

561
00:32:03,780 --> 00:32:05,250
it will be scheduled quickly. 

562
00:32:06,590 --> 00:32:07,860
If it's a small burst, 

563
00:32:09,480 --> 00:32:12,720
then it relinquishes a cpu, goes to sleep.

564
00:32:14,480 --> 00:32:17,920
So it will always remain at the first level. 

565
00:32:19,580 --> 00:32:21,180
Now consider a long job. 

566
00:32:22,700 --> 00:32:24,650
Come like training a neural level. 

567
00:32:25,510 --> 00:32:28,560
It starts at the first level. 

568
00:32:29,880 --> 00:32:31,140
And after a while, 

569
00:32:31,450 --> 00:32:34,200
say, after several seconds,

570
00:32:34,780 --> 00:32:35,760
is still running. 

571
00:32:37,700 --> 00:32:38,080
Right? 

572
00:32:40,630 --> 00:32:44,040
It's going to be in the mounted to the second level. 

573
00:32:46,400 --> 00:32:49,580
And the second level, if he stays and continuously running for,

574
00:32:51,020 --> 00:32:54,420
say, i'm just making up like for another 1 hour,

575
00:32:54,430 --> 00:32:58,180
then it's pushed to the lower level. 

576
00:33:00,460 --> 00:33:02,300
So you can see that in this way, 

577
00:33:02,820 --> 00:33:04,710
the jobs takes a long time. 

578
00:33:04,720 --> 00:33:10,530
They are going to fall through this kind of different levels to the bottom level. 

579
00:33:11,140 --> 00:33:12,430
And you'll have lower products. 

580
00:33:13,560 --> 00:33:15,320
These are very nice mechanics, 

581
00:33:15,330 --> 00:33:16,880
but adaptive mechanisms, 

582
00:33:17,300 --> 00:33:23,940
but in which that jobs with short bursts remains the high priority, 

583
00:33:23,950 --> 00:33:24,660
high levels. 

584
00:33:25,090 --> 00:33:26,430
And the one is lower, 

585
00:33:27,250 --> 00:33:31,620
which takes a long time they are going to be demoted

586
00:33:31,930 --> 00:33:35,420
naturally to the levels with a lot of birds. 

587
00:33:39,220 --> 00:33:39,580
Okay? 

588
00:33:42,410 --> 00:33:43,800
The results really here, 

589
00:33:43,810 --> 00:33:46,960
you can think you approximate the shortest remaining time. 

590
00:33:46,970 --> 00:33:47,480
First. 

591
00:33:48,250 --> 00:33:50,410
Again, if the job is small enough,

592
00:33:50,920 --> 00:33:54,190
you always got executed with the highest product. 

593
00:34:00,710 --> 00:34:02,190
Again, between the queues,

594
00:34:02,200 --> 00:34:03,710
you have fixed priorities. 

595
00:34:04,470 --> 00:34:11,080
And then you can have different time quanta, 

596
00:34:11,090 --> 00:34:15,050
like we saw in these examples between different cures. 

597
00:34:23,160 --> 00:34:24,510
Here is a question. 

598
00:34:25,690 --> 00:34:28,080
This was probably about lottery scheduling, sorry,

599
00:34:28,090 --> 00:34:30,900
for not saying it bit short job. 

600
00:34:31,320 --> 00:34:33,880
These are short job and long job run simultaneous. 

601
00:34:35,480 --> 00:34:39,980
In that case, we assume they don't run to completion.

602
00:34:40,590 --> 00:34:42,780
We assume a lottery scheduling, 

603
00:34:42,790 --> 00:34:44,900
assume a preemptive scheduling. 

604
00:34:46,310 --> 00:34:48,460
This is a preemptive scheduling discipline. 

605
00:34:49,470 --> 00:34:53,240
So you're basically each time qanta is, again,

606
00:34:53,250 --> 00:34:55,920
you run a lottery and your work. 

607
00:34:57,550 --> 00:34:59,630
Cpu to the winning ticket, 

608
00:35:00,240 --> 00:35:01,750
to the process with the winning ticket. 

609
00:35:02,660 --> 00:35:03,880
So from that perspective, 

610
00:35:04,330 --> 00:35:08,020
they are interviewed That the short jobs and long run, 

611
00:35:08,030 --> 00:35:09,870
long jobs are intended. 

612
00:35:23,940 --> 00:35:25,020
Now, obviously,

613
00:35:25,030 --> 00:35:26,300
if the scheduler, 

614
00:35:26,310 --> 00:35:28,860
you can actually fool the scheduler. 

615
00:35:30,980 --> 00:35:32,010
For instance, 

616
00:35:32,310 --> 00:35:33,420
if I want, 

617
00:35:34,250 --> 00:35:37,630
what can I do for my job to remain as a high priority? 

618
00:35:37,640 --> 00:35:42,000
Well, i'm going to insert some io operations from time to time,

619
00:35:42,700 --> 00:35:50,800
because io operations put the process of the job to split to sleep. 

620
00:35:51,250 --> 00:35:58,120
And there are 40 to remain at the high in the double level tears. 

621
00:36:05,570 --> 00:36:11,200
And that I actually run games in which it is all the law. 

622
00:36:11,210 --> 00:36:13,360
It's an old head program game. 

623
00:36:13,850 --> 00:36:15,880
You try to play against computer. 

624
00:36:17,940 --> 00:36:22,730
The key is to do computation at a higher priority than the company competitor. 

625
00:36:25,940 --> 00:36:26,370
So I see, 

626
00:36:28,600 --> 00:36:29,950
again, the way you do it,

627
00:36:29,960 --> 00:36:31,470
the way you are doing it, 

628
00:36:32,240 --> 00:36:37,070
some of these game developers just put a bunch of print depths, 

629
00:36:37,300 --> 00:36:38,410
because the print depths, again,

630
00:36:38,420 --> 00:36:41,740
you have io the thread is put us to sleep. 

631
00:36:42,270 --> 00:36:45,790
When you come back, it's going to go with a high priority queue.

632
00:36:45,800 --> 00:36:47,510
While if you don't have to go to sleep, 

633
00:36:47,810 --> 00:36:51,280
you are going to fall through the levels to the bottom level, 

634
00:36:51,290 --> 00:36:53,710
and you are going to be with a lot. 

635
00:36:55,770 --> 00:36:55,980
Right? 

636
00:36:56,210 --> 00:36:56,860
So it's fine. 

637
00:36:58,960 --> 00:37:00,080
Multicore scheduling. 

638
00:37:01,350 --> 00:37:02,300
You have multiple core. 

639
00:37:02,310 --> 00:37:04,180
Now, all the processors have multiple cores.

640
00:37:04,190 --> 00:37:06,100
Your mac has multiple cores, 

641
00:37:06,110 --> 00:37:07,420
your pc has multiple cores, 

642
00:37:07,430 --> 00:37:09,100
your phones have multiple cores. 

643
00:37:09,660 --> 00:37:10,060
Algorithm. 

644
00:37:10,070 --> 00:37:11,900
Italy is not a huge difference now, 

645
00:37:13,320 --> 00:37:14,620
but implementation way, 

646
00:37:15,150 --> 00:37:17,460
why is there are some things you need to keep in mind. 

647
00:37:18,150 --> 00:37:21,330
And one thing to keep in mind is a cash coherence. 

648
00:37:22,100 --> 00:37:25,170
Every court has its own cash. 

649
00:37:25,920 --> 00:37:29,910
Therefore, you want to have this affinity scheduling.

650
00:37:30,210 --> 00:37:38,440
You want to schedule a thread on the same cpu when it doesn't come. 

651
00:37:39,090 --> 00:37:39,330
Speak. 

652
00:37:39,340 --> 00:37:39,730
Why? 

653
00:37:39,740 --> 00:37:41,450
Because if you do so, 

654
00:37:41,990 --> 00:37:42,980
that thread, 

655
00:37:44,230 --> 00:37:46,140
you can leverage the date of the set, 

656
00:37:46,150 --> 00:37:48,860
which is still in the local cache of the same superior. 

657
00:37:49,150 --> 00:37:54,510
If you schedule the thread on a different cpu then that cash will not have

658
00:37:54,520 --> 00:37:55,200
any date out. 

659
00:37:55,210 --> 00:37:55,660
That's right. 

660
00:37:59,190 --> 00:38:00,900
Speed, lock and multiprocessor.

661
00:38:03,310 --> 00:38:04,380
Let me guess. 

662
00:38:08,650 --> 00:38:11,910
It turns out that the one way, 

663
00:38:11,920 --> 00:38:13,790
actually to, 

664
00:38:15,900 --> 00:38:17,990
especially for multiprocessors, 

665
00:38:20,300 --> 00:38:24,530
there are two reasons or you use as spin locks. 

666
00:38:25,670 --> 00:38:29,180
The spin lock is just waiting for some condition to become true, 

667
00:38:29,190 --> 00:38:32,680
and you can do the test and set on a particular value, right?

668
00:38:33,010 --> 00:38:36,450
It's like think about acquiring the law, right?

669
00:38:37,300 --> 00:38:40,010
There are two cages to use a spin lock, one.

670
00:38:40,460 --> 00:38:44,170
It's typically when you have multiple strides to execute at the same time, 

671
00:38:44,180 --> 00:38:44,810
like, for instance,

672
00:38:44,820 --> 00:38:47,090
you have two strategies communicate between each other, 

673
00:38:47,360 --> 00:38:48,970
you have to run them at the same time. 

674
00:38:49,520 --> 00:38:50,640
So you want, 

675
00:38:50,650 --> 00:38:55,990
then the threats to wait for each other to be scheduled at the same time. 

676
00:38:56,640 --> 00:38:58,190
If I said it's scheduled. 

677
00:38:58,760 --> 00:39:00,430
First, the second thread,

678
00:39:01,360 --> 00:39:04,270
it has to wait for the second set to be scheduled, in order to say,

679
00:39:04,280 --> 00:39:04,790
for instance, 

680
00:39:04,800 --> 00:39:05,870
to start the communication. 

681
00:39:07,140 --> 00:39:09,210
You use, typically for that test and set.

682
00:39:09,220 --> 00:39:11,330
Now, the problem is this test and set.

683
00:39:12,050 --> 00:39:14,380
If this test and set is done on, 

684
00:39:14,970 --> 00:39:18,750
you have different threads on different course. 

685
00:39:19,190 --> 00:39:25,560
The piston said you are going to involve aaa right? 

686
00:39:25,880 --> 00:39:27,530
If you remember the test and set, 

687
00:39:27,810 --> 00:39:30,230
it takes a value from the other is savage. 

688
00:39:31,010 --> 00:39:34,940
And then set that value to one, 

689
00:39:34,950 --> 00:39:39,740
irrespective of what was the value before and write it back in the memory, 

690
00:39:40,750 --> 00:39:43,030
and then return the original value. 

691
00:39:44,740 --> 00:39:46,930
This is what is less than said, if you remember.

692
00:39:47,460 --> 00:39:51,370
But if I am going to write and another test and set is going to read

693
00:39:51,380 --> 00:39:53,210
from a different processor, 

694
00:39:53,630 --> 00:39:58,060
then you are going to the value has to go through the main memory

695
00:39:58,070 --> 00:39:59,860
and then go back between. 

696
00:40:00,160 --> 00:40:05,030
It is going to go to me to go to the other process. 

697
00:40:05,040 --> 00:40:07,230
You can understand that any of these investments, 

698
00:40:07,880 --> 00:40:12,550
if two sides of the good test and set and they run on different cp us, 

699
00:40:12,830 --> 00:40:14,770
then you are going to ping pong, 

700
00:40:14,780 --> 00:40:18,070
the value between each other without doing anything. 

701
00:40:21,570 --> 00:40:23,180
And another way to do it, 

702
00:40:23,190 --> 00:40:27,150
if you need to do that is to do this test and set. 

703
00:40:27,560 --> 00:40:30,850
Basically, instead of doing having in the wildest and set,

704
00:40:31,240 --> 00:40:32,640
in the while you have the value, 

705
00:40:32,650 --> 00:40:33,880
just look at the value. 

706
00:40:34,410 --> 00:40:36,630
You look for the value, for the inquiry,

707
00:40:36,640 --> 00:40:41,380
look for the value to become zero. 

708
00:40:42,730 --> 00:40:46,580
Then this is going to just do a read. 

709
00:40:47,100 --> 00:40:49,570
So you read local value always. 

710
00:40:52,650 --> 00:40:57,000
Then you are going to do again a while at best and said, 

711
00:40:57,310 --> 00:40:58,650
if the value is zero. 

712
00:40:58,660 --> 00:41:02,400
And the reason it is a second test and set is because the race condition, 

713
00:41:02,630 --> 00:41:03,820
because you don't want, 

714
00:41:04,200 --> 00:41:08,320
because you want to acquire the lock in this case, 

715
00:41:08,330 --> 00:41:10,880
or which means to set the value to one. 

716
00:41:11,200 --> 00:41:15,270
You don't know the race condition is that two threads executing

717
00:41:15,280 --> 00:41:16,990
test and set at the same time, 

718
00:41:17,230 --> 00:41:18,660
they receive the value zero, 

719
00:41:18,670 --> 00:41:20,580
and then they both of them, 

720
00:41:20,810 --> 00:41:22,110
they are going to settle one. 

721
00:41:22,570 --> 00:41:23,680
In order to avoid that, 

722
00:41:23,690 --> 00:41:26,160
you do a test and set again to the value. 

723
00:41:26,680 --> 00:41:32,000
You have only one will succeed because test and said is going to be atom. 

724
00:41:33,290 --> 00:41:36,480
But again, the main.here is that you avoid a right,

725
00:41:36,890 --> 00:41:38,100
because you avoid the right, 

726
00:41:38,110 --> 00:41:40,350
you are going to go through the main memory, 

727
00:41:40,360 --> 00:41:45,300
and you are going to go to avoid a lot of context, 

728
00:41:45,310 --> 00:41:50,030
which is this. 

729
00:41:50,620 --> 00:41:51,650
That's a great question. 

730
00:41:53,230 --> 00:41:55,670
Is this an issue of correctness of all efficient? 

731
00:41:55,680 --> 00:41:57,700
This is a progression from outside. 

732
00:42:00,950 --> 00:42:02,140
It's about it. 

733
00:42:02,350 --> 00:42:03,580
This is about efficiency. 

734
00:42:03,840 --> 00:42:04,890
It's not about correctness. 

735
00:42:05,210 --> 00:42:07,240
Both codes are correct. 

736
00:42:07,800 --> 00:42:11,030
Both using both test and set and test and set are core. 

737
00:42:11,480 --> 00:42:12,700
It's only about the patients. 

738
00:42:19,790 --> 00:42:20,180
Good. 

739
00:42:25,820 --> 00:42:33,950
This is exactly why when these are used this spin locks and spin waiting. 

740
00:42:35,160 --> 00:42:36,430
When multiple threads, again,

741
00:42:36,440 --> 00:42:37,750
like ii just mentioned, 

742
00:42:37,760 --> 00:42:39,470
work together on a multiple floor, 

743
00:42:39,480 --> 00:42:41,030
try to schedule them together. 

744
00:42:41,230 --> 00:42:43,360
This is also called gang gang scheduling. 

745
00:42:44,330 --> 00:42:47,240
There are other ways to do it instead of using spin lock. 

746
00:42:47,250 --> 00:42:51,750
Another way is basically to tell the os to tell the application. 

747
00:42:51,920 --> 00:42:56,350
Iiii could schedule only three of your threads, and you take care,

748
00:42:57,920 --> 00:43:01,030
you should that you have three slides with running parallel. 

749
00:43:01,410 --> 00:43:04,900
So you can figure the way you run the program, 

750
00:43:05,440 --> 00:43:08,270
knowing that you have only three slides which are running in power. 

751
00:43:08,760 --> 00:43:08,880
Right? 

752
00:43:09,290 --> 00:43:10,480
By the way, 

753
00:43:12,090 --> 00:43:13,680
there is another reason. 

754
00:43:15,070 --> 00:43:18,890
There is another example in which you do this been a spin locks. 

755
00:43:19,400 --> 00:43:25,280
And the reason is that if you expect that you have an eye operation, 

756
00:43:25,550 --> 00:43:27,720
which we expect to finish very quickly, 

757
00:43:30,190 --> 00:43:36,020
so this is to avoid the context switch. 

758
00:43:36,590 --> 00:43:38,740
So say a context switch, it takes 1 millisecond,

759
00:43:39,940 --> 00:43:41,110
but you are a program, 

760
00:43:41,120 --> 00:43:44,300
and you do an operation which takes 0.1 millisecond. 

761
00:43:45,210 --> 00:43:53,030
So you do not want to be just suspending a delinquent acpu and also is

762
00:43:53,040 --> 00:43:54,830
not very effective for the system, 

763
00:43:55,110 --> 00:43:58,470
because it takes 1 million seconds to which is wasted time

764
00:43:58,480 --> 00:44:00,390
to contact switching to another strike. 

765
00:44:01,280 --> 00:44:02,890
Instead, you just do us.

766
00:44:03,530 --> 00:44:05,000
You are waiting, busy,

767
00:44:05,010 --> 00:44:08,010
waiting for the for the eye operation to complete. 

768
00:44:08,020 --> 00:44:11,650
And then you write only for 0.1 millisecond and then continue. 

769
00:44:12,120 --> 00:44:12,520
Right? 

770
00:44:12,720 --> 00:44:13,710
No contact switching. 

771
00:44:14,040 --> 00:44:16,230
You spend wasted 10.10 millisecond, 

772
00:44:16,240 --> 00:44:17,630
but it's shorter than 1 millisecond. 

773
00:44:17,640 --> 00:44:18,590
It's a contact switching. 

774
00:44:19,010 --> 00:44:22,380
You are going to get much better response time because you

775
00:44:22,390 --> 00:44:25,180
are continue to run instead of waiting to be scheduled again. 

776
00:44:27,490 --> 00:44:30,120
Announcements, congrats for finishing with them on.

777
00:44:30,440 --> 00:44:32,950
We started to grade it will take a little bit of time. 

778
00:44:33,240 --> 00:44:37,070
We'll let you know for sure that is the ada to give your grading on monday, 

779
00:44:37,080 --> 00:44:40,960
hopefully will be very close to monday after monday. 

780
00:44:41,830 --> 00:44:44,340
Homework two is due on monday. 

781
00:44:44,870 --> 00:44:49,530
And project one code and final reporting member is due on wednesday next week. 

782
00:44:51,040 --> 00:44:51,480
Now. 

783
00:44:51,770 --> 00:44:54,440
Ii understand that things are difficult, right?

784
00:44:54,450 --> 00:44:58,630
It's like we are still in this kind of remote instruction. 

785
00:44:58,640 --> 00:45:01,990
It's you still have a tough time, 

786
00:45:02,000 --> 00:45:03,630
maybe home and so forth, 

787
00:45:04,390 --> 00:45:06,580
and make making things work. 

788
00:45:07,170 --> 00:45:08,840
You are stressed. 

789
00:45:08,850 --> 00:45:14,400
So make sure that your da understand any issue that you may be having

790
00:45:14,410 --> 00:45:15,180
because of that, 

791
00:45:15,190 --> 00:45:17,610
or and also is a group. 

792
00:45:18,140 --> 00:45:19,630
And if you, 

793
00:45:19,910 --> 00:45:21,400
if you want to escalate, 

794
00:45:22,290 --> 00:45:23,960
i'll be happy to meet with a group, 

795
00:45:23,970 --> 00:45:25,240
just send emails, 

796
00:45:25,540 --> 00:45:26,110
an email, 

797
00:45:26,120 --> 00:45:32,110
and i'll be happy to meet with you and provide some best practices

798
00:45:32,120 --> 00:45:33,010
and some advice. 

799
00:45:41,300 --> 00:45:44,860
So next, let's talk about real time scheduling.

800
00:45:46,430 --> 00:45:47,740
Real time scheduling, 

801
00:45:47,750 --> 00:45:50,830
think about you, 

802
00:45:51,260 --> 00:45:58,990
your the programs which runs on your car, 

803
00:45:59,700 --> 00:46:02,180
like abs anti blocking, 

804
00:46:02,190 --> 00:46:05,250
whatever for breaks. 

805
00:46:06,030 --> 00:46:10,200
You have in your car, you have probably of processors,

806
00:46:10,980 --> 00:46:12,440
tens hundreds of programs run. 

807
00:46:13,040 --> 00:46:13,530
Okay? 

808
00:46:14,530 --> 00:46:15,800
Or think about self driving. 

809
00:46:17,550 --> 00:46:22,260
You really want their predictable performance. 

810
00:46:23,300 --> 00:46:27,150
You run sinks to finish by a certain time, 

811
00:46:28,490 --> 00:46:33,720
like our steering or it's out in a self driving car. 

812
00:46:33,990 --> 00:46:35,160
You need to steer in time, right?

813
00:46:35,170 --> 00:46:37,060
If it doesn't steer in time, you have an accident.

814
00:46:39,390 --> 00:46:40,520
So therefore, 

815
00:46:40,530 --> 00:46:42,280
these are the core the power plant. 

816
00:46:46,050 --> 00:46:51,210
Think about landing and taking off for airplanes, 

817
00:46:51,220 --> 00:46:53,050
which is done automatically. 

818
00:46:54,080 --> 00:46:55,400
For all of these use cases, 

819
00:46:55,410 --> 00:46:56,720
you need to have programs. 

820
00:46:57,110 --> 00:46:57,590
For sure, 

821
00:46:58,840 --> 00:47:00,230
you don't get starvation, 

822
00:47:01,090 --> 00:47:01,480
right? 

823
00:47:02,120 --> 00:47:04,630
And you can predict these are predictable. 

824
00:47:05,580 --> 00:47:07,170
Now, the real time is, again,

825
00:47:07,180 --> 00:47:12,580
is predictable predictability about things happening by a certain time. 

826
00:47:13,850 --> 00:47:16,090
It's not about being fast. 

827
00:47:19,900 --> 00:47:22,610
And there are multiple classes about real time. 

828
00:47:22,840 --> 00:47:24,590
In real time, it's again, a big area.

829
00:47:24,600 --> 00:47:27,470
There are conferences only dedicated real time. 

830
00:47:29,670 --> 00:47:31,180
It's about meetings, the deadlines, right?

831
00:47:31,190 --> 00:47:34,140
You have some deadlines by some task is to finish. 

832
00:47:35,610 --> 00:47:38,200
And in these areas, 

833
00:47:38,210 --> 00:47:39,440
there are different categories. 

834
00:47:39,450 --> 00:47:42,080
There are soft real deadlines, 

835
00:47:42,090 --> 00:47:43,320
hard real time deadlines. 

836
00:47:43,330 --> 00:47:44,680
You need to meet all the deadlines. 

837
00:47:45,640 --> 00:47:47,430
Several times, best effort.

838
00:47:47,880 --> 00:47:48,950
Try to be your best to meet. 

839
00:47:48,960 --> 00:47:49,390
Most of them. 

840
00:47:50,260 --> 00:47:52,910
Depends on the application that you expect. 

841
00:47:52,920 --> 00:47:54,030
There are a lot of algorithms, 

842
00:47:54,040 --> 00:47:56,190
and the algorithms scaling algorithms are quite different. 

843
00:47:58,400 --> 00:48:01,750
And we are going to look at only one, which is very simple,

844
00:48:01,760 --> 00:48:03,230
which is early deadline first. 

845
00:48:04,690 --> 00:48:06,480
By the way, another,

846
00:48:06,490 --> 00:48:08,560
for an example of a soft real time, 

847
00:48:08,810 --> 00:48:09,920
is for multimedia, 

848
00:48:09,930 --> 00:48:15,960
for your playing back video or the voice over when you chat over your over phone. 

849
00:48:16,390 --> 00:48:16,780
Right? 

850
00:48:18,050 --> 00:48:21,420
It's great to have hard deadlines. 

851
00:48:21,710 --> 00:48:22,970
Your message, 

852
00:48:23,300 --> 00:48:25,770
what you are saying to arrive to the other and say

853
00:48:25,780 --> 00:48:28,170
within 15 minutes seconds never later. 

854
00:48:28,490 --> 00:48:29,730
But if it's alive, 

855
00:48:30,220 --> 00:48:31,410
it's a little bit longer. 

856
00:48:31,650 --> 00:48:32,160
It's okay. 

857
00:48:32,490 --> 00:48:33,790
The humans are going to adapt. 

858
00:48:39,110 --> 00:48:39,820
And here we are, 

859
00:48:40,870 --> 00:48:44,860
and we are going to talk about only ones are scheduling, this discipline,

860
00:48:44,870 --> 00:48:46,180
which is a leader line first. 

861
00:48:46,910 --> 00:48:48,050
But here is a model. 

862
00:48:48,570 --> 00:48:52,170
The model is that the task have deadlines. 

863
00:48:53,100 --> 00:48:57,420
This they declare about the computation time is now. 

864
00:48:58,220 --> 00:49:00,450
So here we are talking about sinks, 

865
00:49:00,970 --> 00:49:02,880
getting repeatedly being done. 

866
00:49:05,810 --> 00:49:09,360
You have pretty good idea about each when each task, 

867
00:49:09,370 --> 00:49:11,280
how long each task is going to take. 

868
00:49:11,970 --> 00:49:16,160
It's different from general case in which it's hard to predict the future. 

869
00:49:16,520 --> 00:49:18,030
Here, you have to predict the future,

870
00:49:18,040 --> 00:49:22,920
because how can you set up a deadline without knowing how much

871
00:49:22,930 --> 00:49:23,800
a conversation will take? 

872
00:49:24,280 --> 00:49:25,080
It's impossible. 

873
00:49:26,180 --> 00:49:30,900
So it's part of the game here that you are going to know how long a task

874
00:49:30,910 --> 00:49:31,940
is going to take. 

875
00:49:32,890 --> 00:49:33,360
Okay. 

876
00:49:34,300 --> 00:49:35,490
Now the question is, 

877
00:49:35,500 --> 00:49:36,690
you have multiple tasks. 

878
00:49:36,700 --> 00:49:40,570
Each of them, they have certain computation time and certain deadlines.

879
00:49:41,180 --> 00:49:47,740
The computer, the thing is that can all the task meets at that place.

880
00:49:48,050 --> 00:49:48,790
That's a good question. 

881
00:49:50,520 --> 00:49:50,800
Right? 

882
00:49:51,170 --> 00:49:53,760
Here is one of the example of scheduling. 

883
00:49:54,550 --> 00:49:56,260
Again, it's preemptive.

884
00:49:56,270 --> 00:49:59,680
You still have time quanta between these tasks. 

885
00:50:01,180 --> 00:50:03,190
And it turns out this other deadlines, 

886
00:50:03,800 --> 00:50:05,490
the up arrows. 

887
00:50:07,370 --> 00:50:09,890
The answer is apparatus is when the task, 

888
00:50:11,360 --> 00:50:13,730
even which triggers the computation arrives. 

889
00:50:14,380 --> 00:50:18,040
And the down arrows are the deadlines. 

890
00:50:18,900 --> 00:50:22,530
And here is an example in which this scheduling, 

891
00:50:22,540 --> 00:50:29,010
particular scheduling of these tasks is going to violate the deadlines for desktop. 

892
00:50:32,890 --> 00:50:33,320
Now, 

893
00:50:35,100 --> 00:50:35,970
I like I mentioned, 

894
00:50:35,980 --> 00:50:37,610
we are going to learn about one

895
00:50:37,620 --> 00:50:40,730
such a scheduling discipline and leader line first. 

896
00:50:42,090 --> 00:50:42,680
Difficult. 

897
00:50:42,690 --> 00:50:47,810
They assume that the task I is periodic is period pi meaning

898
00:50:47,820 --> 00:50:50,540
that and computation ci meaning

899
00:50:50,550 --> 00:50:53,830
that in each period, 

900
00:50:54,080 --> 00:50:58,500
you have to perform a computation for that task, 

901
00:50:59,760 --> 00:51:01,780
like, for instance,

902
00:51:01,790 --> 00:51:03,340
every 100 millisecond, 

903
00:51:03,670 --> 00:51:06,680
the task needs to perform a computation of 10 millisecond. 

904
00:51:07,610 --> 00:51:08,380
Example. 

905
00:51:08,840 --> 00:51:09,820
Think about, 

906
00:51:10,990 --> 00:51:14,430
It's again, something like a self driving car or anything in the car.

907
00:51:14,750 --> 00:51:19,640
You have sensors which are like video cameras and so forth, 

908
00:51:19,940 --> 00:51:26,360
which periodically take take a measurements, 

909
00:51:26,790 --> 00:51:30,660
maybe the state of the brake or the speed, 

910
00:51:31,070 --> 00:51:33,630
or obviously a video frame. 

911
00:51:34,120 --> 00:51:34,480
Right? 

912
00:51:35,280 --> 00:51:37,410
And these are periodic. 

913
00:51:37,860 --> 00:51:39,100
And they need to be processed. 

914
00:51:40,340 --> 00:51:42,330
Before the next measurement mistaken, 

915
00:51:42,340 --> 00:51:44,180
we need to process the previous measure. 

916
00:51:44,940 --> 00:51:46,360
But that's kind of my motivation. 

917
00:51:48,490 --> 00:51:51,730
And the early deadline first is very simple, 

918
00:51:52,190 --> 00:51:53,420
is basically saying, 

919
00:51:53,430 --> 00:51:54,740
like the name implies, 

920
00:51:55,080 --> 00:51:59,970
you always schedule the task whose deadline is the earliest. 

921
00:52:04,240 --> 00:52:04,750
That's it. 

922
00:52:05,180 --> 00:52:06,150
Let's take an example. 

923
00:52:06,800 --> 00:52:07,300
Okay. 

924
00:52:07,700 --> 00:52:10,350
So let's have three tasks. 

925
00:52:11,030 --> 00:52:12,300
And for each task, 

926
00:52:12,730 --> 00:52:17,670
the two numbers in parentages represent the period, 

927
00:52:18,160 --> 00:52:21,980
the first number, and how long it needs to come?

928
00:52:22,320 --> 00:52:24,270
It should take to compute in this period. 

929
00:52:25,670 --> 00:52:26,690
So for one, 

930
00:52:27,040 --> 00:52:28,960
means that every 4 time, you need say,

931
00:52:28,970 --> 00:52:30,760
for every set 4 seconds, 

932
00:52:32,250 --> 00:52:34,770
t one is requires 1 second of computation. 

933
00:52:34,780 --> 00:52:40,320
The two during 5 seconds requires 2 seconds of computation. 

934
00:52:40,860 --> 00:52:43,940
These three average 7 seconds requires 2 seconds of competition. 

935
00:52:44,700 --> 00:52:44,960
Right? 

936
00:52:45,750 --> 00:52:47,730
And these are the first deadlines, right?

937
00:52:47,740 --> 00:52:52,360
Because you need to finish to process in the current period

938
00:52:52,370 --> 00:52:54,660
before the next period starts. 

939
00:52:56,420 --> 00:53:02,030
41, the first deadline is Time for, sorry,

940
00:53:02,040 --> 00:53:04,550
42 is five, 4037.

941
00:53:06,420 --> 00:53:07,390
So there are four. 

942
00:53:07,700 --> 00:53:08,280
First, 

943
00:53:09,600 --> 00:53:15,970
you are going to schedule and say that i'm going to hear each one. 

944
00:53:16,920 --> 00:53:19,050
So first, you are going to schedule.

945
00:53:19,060 --> 00:53:19,490
You are. 

946
00:53:20,260 --> 00:53:20,680
Right? 

947
00:53:20,910 --> 00:53:21,100
Why? 

948
00:53:21,110 --> 00:53:22,850
Because the deadline the earliest. 

949
00:53:23,500 --> 00:53:23,650
Right? 

950
00:53:23,660 --> 00:53:24,170
You see, 

951
00:53:25,020 --> 00:53:28,240
is that for the other deadlines are at five and seven, 

952
00:53:29,450 --> 00:53:30,650
once you are done of that, 

953
00:53:30,900 --> 00:53:32,210
you are going to schedule p two. 

954
00:53:32,890 --> 00:53:36,720
And let's assume that we don't preempt here, for simplicity,

955
00:53:40,770 --> 00:53:46,680
because the two has earlier deadlines and these 35 versus seven to schedule

956
00:53:46,690 --> 00:53:47,040
that. 

957
00:53:47,050 --> 00:53:48,080
And finally, 

958
00:53:48,360 --> 00:53:52,030
you schedule pc now, 

959
00:53:52,040 --> 00:53:53,230
what are the next deadlines? 

960
00:53:53,240 --> 00:54:00,350
He said the next deadlines of t one is at time of eight. 

961
00:54:00,870 --> 00:54:02,790
The next line of the two is time ten, 

962
00:54:02,800 --> 00:54:06,070
and the next line of history is time14. 

963
00:54:07,190 --> 00:54:08,490
We are going to spend the first step, 

964
00:54:08,860 --> 00:54:09,980
which is the next deadline. 

965
00:54:13,970 --> 00:54:15,960
Again, duan is earlier strong.

966
00:54:17,490 --> 00:54:21,150
Then again, d two and against this.

967
00:54:21,510 --> 00:54:22,060
Again. 

968
00:54:22,110 --> 00:54:23,220
But again, 

969
00:54:23,230 --> 00:54:24,420
before going to this three, 

970
00:54:24,430 --> 00:54:25,620
let's look at the next at last. 

971
00:54:27,970 --> 00:54:32,410
The next deadline of t one is now 12. 

972
00:54:33,450 --> 00:54:35,960
The next deadline of t two is now 15. 

973
00:54:36,850 --> 00:54:38,880
The next deadline of these three, actually,

974
00:54:38,890 --> 00:54:39,920
the second deadline, 

975
00:54:40,500 --> 00:54:42,250
it's 14, 

976
00:54:43,210 --> 00:54:46,070
which is the earliest deadlines we need to consider now. 

977
00:54:47,180 --> 00:54:47,540
Right? 

978
00:54:48,470 --> 00:54:49,550
You are the next one. 

979
00:54:49,560 --> 00:54:51,850
It's 12. 

980
00:54:52,630 --> 00:54:55,170
They do 50 and 340. 

981
00:54:55,870 --> 00:54:56,820
Obviously still on. 

982
00:54:56,830 --> 00:55:01,660
They are going to schedule pr so now you see that you schedule

983
00:55:02,280 --> 00:55:04,650
for the first three periods of yuan, 

984
00:55:05,350 --> 00:55:06,540
while for these three, 

985
00:55:06,550 --> 00:55:07,820
you scattered for only one. 

986
00:55:10,540 --> 00:55:12,290
But now after a schedule 41, 

987
00:55:12,300 --> 00:55:16,060
you are going to consider pc because it's deadline. 

988
00:55:17,350 --> 00:55:18,410
It's earlier than people. 

989
00:55:19,200 --> 00:55:21,250
And then you continue. 

990
00:55:24,920 --> 00:55:27,380
Now, an interesting question here.

991
00:55:30,970 --> 00:55:31,560
It's, 

992
00:55:31,650 --> 00:55:37,690
let me just say it's how do you know that you can satisfy the algorithms

993
00:55:37,700 --> 00:55:41,510
can satisfy all the task deadlines? 

994
00:55:41,870 --> 00:55:44,140
As you can see, from the previous example, is not easy.

995
00:55:45,140 --> 00:55:49,850
The order that it changes as your progress. 

996
00:55:51,370 --> 00:55:51,910
Okay? 

997
00:55:52,450 --> 00:55:53,770
It's actually quite complicated. 

998
00:55:55,060 --> 00:55:58,740
Now, it turns out that is early deadline.

999
00:55:58,750 --> 00:56:00,740
First, there is a simple condition.

1000
00:56:00,750 --> 00:56:05,070
You can use to check whether you can satisfy early deadline first, 

1001
00:56:05,370 --> 00:56:08,040
satisfy the deadlines of all tasks, 

1002
00:56:09,720 --> 00:56:16,050
and that you sum up the computation of a period for all tasks. 

1003
00:56:16,060 --> 00:56:17,770
And if that is the lesson one, 

1004
00:56:18,520 --> 00:56:20,570
you the edf is feasible. 

1005
00:56:21,060 --> 00:56:21,680
It's working. 

1006
00:56:22,200 --> 00:56:28,070
In our case, it's 1 over 4 plus 2 over 5 plus 2 over 7 is less than one.

1007
00:56:28,320 --> 00:56:28,910
It's feasible. 

1008
00:56:30,020 --> 00:56:35,190
We've seen, at least from our simulation for the first,

1009
00:56:36,180 --> 00:56:37,810
whatever 30 seconds. 

1010
00:56:40,350 --> 00:56:42,530
This is very cool, because you see,

1011
00:56:42,540 --> 00:56:45,130
this is also optimal from the point of view optimization, 

1012
00:56:45,490 --> 00:56:52,290
because c over b for a task is how much is going to utilize from the cpu

1013
00:56:53,850 --> 00:56:55,030
if I want to utilize, 

1014
00:56:55,040 --> 00:56:56,430
I have like the first task, 

1015
00:56:56,810 --> 00:56:57,940
one time unit, 

1016
00:56:58,170 --> 00:56:59,950
1 second out of 4 seconds, 

1017
00:57:01,060 --> 00:57:04,860
the utilization that task alone is going to get 1 over 4 of the cpu

1018
00:57:04,870 --> 00:57:08,610
25% of the cpu so the sum of

1019
00:57:08,620 --> 00:57:12,000
these see over these cannot be greater than one, 

1020
00:57:13,700 --> 00:57:14,030
right? 

1021
00:57:15,430 --> 00:57:17,670
Because you cannot use more cp us than you have. 

1022
00:57:18,830 --> 00:57:19,510
This is a very good. 

1023
00:57:19,520 --> 00:57:21,510
That's how you are talking about salary, because it's very good.

1024
00:57:21,520 --> 00:57:22,310
It's also optimal. 

1025
00:57:28,320 --> 00:57:30,710
Now, things are more complicated,

1026
00:57:30,720 --> 00:57:33,830
and we touch a little bit about starvation. 

1027
00:57:35,720 --> 00:57:38,990
We are going to talk more during this lecture and the next lecture. 

1028
00:57:43,920 --> 00:57:47,760
One thing to make sure is that starvation is different from deadlock. 

1029
00:57:49,000 --> 00:57:53,130
Starvations means that you are a star, 

1030
00:57:53,140 --> 00:57:56,970
but eventually you are not, 

1031
00:57:58,670 --> 00:57:59,550
you can still run. 

1032
00:57:59,560 --> 00:58:00,510
Like we are talking. 

1033
00:58:00,520 --> 00:58:04,940
In the previous case, you are start and you can be started forever.

1034
00:58:05,740 --> 00:58:08,160
If there are prosperity scheduling. 

1035
00:58:08,460 --> 00:58:13,590
If there are always lower produce tasks or jobs in the system, 

1036
00:58:14,550 --> 00:58:17,480
but once that they are no longer, 

1037
00:58:17,790 --> 00:58:23,000
you are scared that look is a different in the sense that you get

1038
00:58:23,010 --> 00:58:25,880
to a point that you cannot resolve that. 

1039
00:58:26,160 --> 00:58:27,860
No matter what happens in the system, 

1040
00:58:29,010 --> 00:58:31,760
unless you kill the process, so you start the system.

1041
00:58:32,700 --> 00:58:32,980
Right? 

1042
00:58:33,650 --> 00:58:35,120
We'll talk more about the next time, 

1043
00:58:35,740 --> 00:58:38,690
but we also going to touch a little bit during this lecture. 

1044
00:58:40,720 --> 00:58:43,830
You have these causes of starvation, scaling police, like we said,

1045
00:58:43,840 --> 00:58:46,870
never runs a particular thread on the cpo and so forth. 

1046
00:58:51,000 --> 00:58:54,380
But we'll explore more about these problems. 

1047
00:58:57,720 --> 00:59:04,990
One way to avoid survey starvation is not one way. 

1048
00:59:05,000 --> 00:59:13,290
It's it's obviously one way to alleviate starvation. 

1049
00:59:13,730 --> 00:59:16,750
Is that if the cpu is always yours, 

1050
00:59:18,260 --> 00:59:19,370
if there is work to do, 

1051
00:59:20,440 --> 00:59:20,830
right? 

1052
00:59:21,340 --> 00:59:25,630
If you have a scheduler which doesn't use the cpu and keep the cpu idol, 

1053
00:59:25,970 --> 00:59:28,690
obviously, it's much higher chance that you are going to stop some threats.

1054
00:59:29,610 --> 00:59:33,390
The schedulers, which are always using cpu.

1055
00:59:33,960 --> 00:59:39,640
They don't leave the cpu idle while there is work to do while there are

1056
00:59:39,650 --> 00:59:41,690
ready processes in the system. 

1057
00:59:42,480 --> 00:59:45,830
Already threats they are called work on sale. 

1058
00:59:47,350 --> 00:59:54,330
They are scheduled which are not considering a schedule which are they

1059
00:59:54,340 --> 00:59:56,410
may maintain the cpu idle, 

1060
00:59:56,420 --> 00:59:58,730
even if there are processes in the system, 

1061
00:59:59,540 --> 01:00:01,520
which can are ready to execute. 

1062
01:00:02,210 --> 01:00:03,820
And obvious, like I said,

1063
01:00:04,410 --> 01:00:07,330
they can linear triviality to this to celebration. 

1064
01:00:09,170 --> 01:00:12,130
In this class, you'll assume that the schedulers were concerned.

1065
01:00:12,960 --> 01:00:15,520
We don't need to worry about hong kong were conserving, 

1066
01:00:15,530 --> 01:00:17,960
but just to keep for completeness, 

1067
01:00:17,970 --> 01:00:19,800
let you know that there are such catalysts. 

1068
01:00:28,080 --> 01:00:30,100
Here is another thing. 

1069
01:00:30,320 --> 01:00:33,030
There's another example of schedule as a few example of schedule, 

1070
01:00:33,040 --> 01:00:34,230
which leads to starvation. 

1071
01:00:34,240 --> 01:00:36,670
Again, you already knew now about some of them.

1072
01:00:37,010 --> 01:00:38,140
Here is a new one, 

1073
01:00:38,440 --> 01:00:41,300
is life for last in first out. 

1074
01:00:41,870 --> 01:00:45,660
It's as opposed to first team first out or first come first serve. 

1075
01:00:47,040 --> 01:00:51,370
This is going to serve the tasks which arrived, 

1076
01:00:51,380 --> 01:00:52,410
which are inserted, 

1077
01:00:52,420 --> 01:00:55,280
which arrived the latest first. 

1078
01:00:56,110 --> 01:00:56,510
Right? 

1079
01:00:57,500 --> 01:01:02,180
And this can be very unfair and obviously can cause starvation, 

1080
01:01:02,820 --> 01:01:05,710
because you can have new task always arriving. 

1081
01:01:05,720 --> 01:01:08,320
You are already all only going to schedule those. 

1082
01:01:12,690 --> 01:01:18,860
And when arrival rate exceeds the how much the number of task which you get, 

1083
01:01:18,870 --> 01:01:20,610
it's more than what you can process, 

1084
01:01:20,620 --> 01:01:22,890
obviously are going to start the whole task. 

1085
01:01:28,060 --> 01:01:30,420
54doesn't really have that problem. 

1086
01:01:31,030 --> 01:01:36,730
But anyway, this is just about what about first come, first set,

1087
01:01:36,740 --> 01:01:40,480
but it for five or first come first set is the same thing. 

1088
01:01:42,010 --> 01:01:44,130
They don't have as much of a problem, 

1089
01:01:45,940 --> 01:01:48,370
because eventually you are going to drain the cure. 

1090
01:01:49,660 --> 01:01:49,930
Right? 

1091
01:01:51,800 --> 01:01:52,240
Let me see. 

1092
01:01:52,250 --> 01:01:53,120
It's a question. 

1093
01:01:54,300 --> 01:01:57,420
Why would you ever want a non work on serving scheduler? 

1094
01:02:00,430 --> 01:02:02,420
A that's a good question. 

1095
01:02:02,430 --> 01:02:07,020
Why we always would like to. 

1096
01:02:07,030 --> 01:02:16,550
So there are there are schedulers which you want to be very predictable. 

1097
01:02:17,660 --> 01:02:18,530
There are scheduler. 

1098
01:02:18,540 --> 01:02:22,730
You want to happen certain things to happen exactly the right at the right time. 

1099
01:02:23,570 --> 01:02:24,800
You want, for instance,

1100
01:02:24,810 --> 01:02:28,600
to produce a result every 100 millisecond. 

1101
01:02:30,000 --> 01:02:31,390
In that particular case, 

1102
01:02:31,400 --> 01:02:37,970
even if you can process more and earlier, 

1103
01:02:37,980 --> 01:02:41,770
you are not going to process because you are going to produce a disaster. 

1104
01:02:44,090 --> 01:02:45,330
So that's kind of one. 

1105
01:02:50,070 --> 01:02:52,330
When you want to regularly, 

1106
01:02:52,340 --> 01:02:53,690
this is also a networking. 

1107
01:02:54,240 --> 01:02:54,760
You're not talking. 

1108
01:02:54,770 --> 01:02:56,360
You want to send one packet. 

1109
01:02:56,920 --> 01:03:01,610
Every say you have one packet, 

1110
01:03:01,620 --> 01:03:07,130
you are going to send one microsecond. 

1111
01:03:07,140 --> 01:03:08,250
Now you may ask, 

1112
01:03:08,730 --> 01:03:09,850
why do you want to do that? 

1113
01:03:10,090 --> 01:03:10,310
Right? 

1114
01:03:10,320 --> 01:03:10,670
Why? 

1115
01:03:11,460 --> 01:03:12,690
And in general, 

1116
01:03:13,240 --> 01:03:16,560
one reason you may want to do this to keep this kind of pace, 

1117
01:03:17,020 --> 01:03:22,870
because you don't want to overwhelm the next stage or the next processing stage, 

1118
01:03:22,880 --> 01:03:24,170
like, for instance, in networking.

1119
01:03:24,370 --> 01:03:28,310
If you send burst of packets instead of facing them, 

1120
01:03:28,830 --> 01:03:31,490
then you have a higher probability. 

1121
01:03:31,500 --> 01:03:34,540
You are going to go into overflow, 

1122
01:03:35,080 --> 01:03:40,130
to send more packets and downstream router can handle. 

1123
01:03:40,470 --> 01:03:41,780
Then I guess it'll be lost. 

1124
01:03:42,830 --> 01:03:45,210
So that's an example. 

1125
01:03:55,460 --> 01:03:57,050
It's again, the first come first serve.

1126
01:03:57,060 --> 01:04:00,210
The only problem you have is that you are going to have a very long job

1127
01:04:00,220 --> 01:04:01,090
with nobody else. 

1128
01:04:02,200 --> 01:04:04,710
Then you have to start for samoa while. 

1129
01:04:05,110 --> 01:04:08,620
But it's again, as long as over some time intervals,

1130
01:04:09,390 --> 01:04:10,510
the load of purpose, 

1131
01:04:10,520 --> 01:04:15,810
a system that the system has to process is lower than the capacitor of the system. 

1132
01:04:16,370 --> 01:04:24,210
Everyone's is going to run is the round robin from the starvation. 

1133
01:04:27,140 --> 01:04:35,040
If you have any processes and if you have aa time quantum

1134
01:04:35,050 --> 01:04:42,840
of then of q then your turn will come every n minus one times

1135
01:04:42,850 --> 01:04:43,840
few millisecond. 

1136
01:04:44,150 --> 01:04:44,720
What are you doing? 

1137
01:04:45,790 --> 01:04:49,550
So we see you don't have salvation. 

1138
01:04:53,240 --> 01:04:55,750
Now is priority scheduling from the salvation. 

1139
01:04:56,200 --> 01:04:58,070
It is we just discuss about that, right?

1140
01:04:59,010 --> 01:05:02,120
Again, early scheduling grants every job,

1141
01:05:02,170 --> 01:05:07,500
every first it has to finish all the jobs at the high priority level

1142
01:05:07,510 --> 01:05:10,230
before going to the next time. 

1143
01:05:11,850 --> 01:05:17,310
And now as what you say, 

1144
01:05:17,320 --> 01:05:22,840
what is the word it's like as a preview for the next lecture, 

1145
01:05:22,850 --> 01:05:23,760
for the deadlock? 

1146
01:05:25,000 --> 01:05:28,020
Let me give you one example about a deadlock. 

1147
01:05:28,750 --> 01:05:33,020
We alluded about this deadlock last lecture when we talk about priority inversion. 

1148
01:05:34,730 --> 01:05:36,000
This is what can happen. 

1149
01:05:41,960 --> 01:05:44,300
But again, that means you are stuck.

1150
01:05:46,300 --> 01:05:46,910
Can do anything. 

1151
01:05:46,920 --> 01:05:52,800
Even if you have no other job in the system, you are still stuck,

1152
01:05:52,810 --> 01:05:53,800
you cannot make progress. 

1153
01:05:54,810 --> 01:05:56,850
So say a job at priority one, 

1154
01:05:56,860 --> 01:05:58,490
lower priority acquire a lot. 

1155
01:06:03,080 --> 01:06:06,450
And now the job one is in critical section. 

1156
01:06:08,240 --> 01:06:10,890
But now jobs three comes, it's a hybrid,

1157
01:06:12,850 --> 01:06:17,130
and jobs three tries to acquire the lock held by job one. 

1158
01:06:20,040 --> 01:06:20,370
Right? 

1159
01:06:25,400 --> 01:06:27,680
But you cannot your block on a query. 

1160
01:06:31,440 --> 01:06:32,270
By the way, 

1161
01:06:33,220 --> 01:06:39,820
now, job three waits for the job one to finish to release a lock.

1162
01:06:40,410 --> 01:06:43,770
And job to one is not executive because jobs three has a higher product. 

1163
01:06:44,890 --> 01:06:45,650
That's kind of that. 

1164
01:06:48,600 --> 01:06:49,750
This is priority inversion, 

1165
01:06:52,070 --> 01:06:59,010
because you are waiting for a job with a lower priority to release a lock. 

1166
01:06:59,380 --> 01:07:01,020
And we cannot believe a lot because of you. 

1167
01:07:07,310 --> 01:07:09,370
And this is the definition of working version. 

1168
01:07:11,670 --> 01:07:14,300
This is another example is a live block. 

1169
01:07:15,290 --> 01:07:17,490
You have local choirs, local release,

1170
01:07:18,120 --> 01:07:19,210
the low priority. 

1171
01:07:19,620 --> 01:07:21,110
The high priority is, again,

1172
01:07:21,120 --> 01:07:22,610
try to achieve live long, 

1173
01:07:24,030 --> 01:07:25,710
always busy waiting. 

1174
01:07:29,530 --> 01:07:30,780
So what are the solutions? 

1175
01:07:31,120 --> 01:07:34,650
One solution is priority donation or inheritance. 

1176
01:07:35,830 --> 01:07:38,010
In this particular case, if job one,

1177
01:07:38,020 --> 01:07:39,850
which is not priority, holds a lock,

1178
01:07:40,660 --> 01:07:42,250
and jobs three wants to acquire it. 

1179
01:07:43,010 --> 01:07:44,370
What happens in this case? 

1180
01:07:44,800 --> 01:07:47,930
Job three, donate its priority to job one.

1181
01:07:48,630 --> 01:07:52,700
So job one while it is a critical section and while holding the lock, 

1182
01:07:53,180 --> 01:07:56,930
now it's going to be promoted to priority three to the highest priority. 

1183
01:07:57,720 --> 01:08:03,260
Now it's got times to run and to finish after he believes it goes back, 

1184
01:08:03,510 --> 01:08:04,790
job one and priority one, 

1185
01:08:04,800 --> 01:08:08,560
dollar priority on his previous priority and jobs three can acquire the law. 

1186
01:08:10,490 --> 01:08:12,480
And you're going to have in protective. 

1187
01:08:14,510 --> 01:08:14,800
Here. 

1188
01:08:14,810 --> 01:08:15,700
It's an example. 

1189
01:08:18,380 --> 01:08:19,810
This is not only theoretical. 

1190
01:08:20,300 --> 01:08:21,100
This is a marathon, 

1191
01:08:21,650 --> 01:08:22,720
but find a robber. 

1192
01:08:23,150 --> 01:08:24,930
And I have here for the fun, 

1193
01:08:25,370 --> 01:08:27,370
which is not necessarily like it with the lecture. 

1194
01:08:27,380 --> 01:08:31,070
This is in 97 or so many years ago. 

1195
01:08:31,460 --> 01:08:37,390
But it was a big event because it was the first one of these

1196
01:08:41,460 --> 01:08:42,060
satellites. 

1197
01:08:42,070 --> 01:08:47,620
And actually it has also actually landed on the planet since 76, 

1198
01:08:47,630 --> 01:08:49,670
so after 21 years, right?

1199
01:08:50,330 --> 01:08:52,510
And one thing it was fun. 

1200
01:08:52,790 --> 01:08:55,720
It was this kind of different delivery mechanics. 

1201
01:08:56,150 --> 01:08:58,400
Let me just see whether I have this one. 

1202
01:09:03,080 --> 01:09:11,990
So i'm guessed, okay,

1203
01:09:13,480 --> 01:09:14,680
do you see my screen? 

1204
01:09:14,690 --> 01:09:15,680
You don't see my screen. 

1205
01:09:18,510 --> 01:09:24,240
Let me just, i'm not sure how much you see it.

1206
01:09:28,950 --> 01:09:31,980
For some reason, I cannot let me see if I can do it.

1207
01:09:35,420 --> 01:09:36,420
Let's do this for now. 

1208
01:09:42,070 --> 01:09:43,900
It's a very interesting delivery mechanics. 

1209
01:09:44,470 --> 01:09:49,080
How is this lander delivered how he planned it on mars? 

1210
01:09:52,560 --> 01:09:54,720
It has like balloons, like airbags,

1211
01:09:55,050 --> 01:09:56,130
all over the place. 

1212
01:09:57,230 --> 01:10:00,960
And this is how is the house delivered? 

1213
01:10:03,430 --> 01:10:05,440
Very innovative, very, very cool.

1214
01:10:21,090 --> 01:10:22,470
So eventually stopped. 

1215
01:10:24,850 --> 01:10:27,090
But this is the one we are talking about. 

1216
01:10:28,600 --> 01:10:37,930
And now the problem is that a few days intermissions into the mission, 

1217
01:10:37,940 --> 01:10:39,650
multiple systems resets occur, 

1218
01:10:40,870 --> 01:10:44,430
and it was forced for the software. 

1219
01:10:46,350 --> 01:10:48,710
And the system appeared to reboot randomly, 

1220
01:10:49,520 --> 01:10:52,230
losing valuable time and making progress. 

1221
01:10:52,790 --> 01:10:57,300
What it turned out to be was priority inversion. 

1222
01:10:57,310 --> 01:10:59,470
It was his priority to high priority, 

1223
01:10:59,480 --> 01:11:01,330
which was a data distribution task. 

1224
01:11:02,530 --> 01:11:03,400
They need a lock. 

1225
01:11:03,990 --> 01:11:06,800
The problem is that the collector, the one,

1226
01:11:07,090 --> 01:11:10,780
another task, which was collecting samples, collecting data,

1227
01:11:11,400 --> 01:11:12,660
which was lower priority, 

1228
01:11:13,660 --> 01:11:14,610
was getting the lock. 

1229
01:11:16,430 --> 01:11:16,900
Now, 

1230
01:11:18,420 --> 01:11:19,450
the priority, 

1231
01:11:21,440 --> 01:11:23,350
the collector adds a log. 

1232
01:11:24,490 --> 01:11:30,610
And the data distribution task couldn't acquire the law. 

1233
01:11:31,340 --> 01:11:32,090
Now, what happens?

1234
01:11:32,100 --> 01:11:33,330
Typically in these systems? 

1235
01:11:33,710 --> 01:11:34,660
You have a watchdog. 

1236
01:11:35,780 --> 01:11:42,310
It's a the white dog is a process which looks whether there is forward progress. 

1237
01:11:42,780 --> 01:11:46,290
If there is no further progress and you have this, in this case, a backlog,

1238
01:11:46,720 --> 01:11:49,020
what is going to do is going to reboot the system. 

1239
01:11:53,380 --> 01:11:58,770
It turns out that the rose actually called for the priority donation

1240
01:11:59,450 --> 01:12:00,580
to avoid this problem, 

1241
01:12:01,200 --> 01:12:02,080
writing version. 

1242
01:12:02,920 --> 01:12:10,730
But it was turned off because

1243
01:12:10,740 --> 01:12:14,450
the developers thought it's still worried about the performance. 

1244
01:12:16,380 --> 01:12:19,850
In this case, the fix was to upload and feedback the code.

1245
01:12:22,040 --> 01:12:24,750
Again, what you are talking here is not only theoretical.

1246
01:12:24,990 --> 01:12:25,460
It happens. 

1247
01:12:28,660 --> 01:12:29,880
Let's talk about others. 

1248
01:12:29,930 --> 01:12:34,680
It's shortest time first and multilevel feedback you from the starvation. 

1249
01:12:37,460 --> 01:12:38,300
They are right. 

1250
01:12:39,440 --> 01:12:41,330
Like we discussed shortest time first. 

1251
01:12:42,400 --> 01:12:45,000
The long job can be started in the favor of short runs. 

1252
01:12:45,010 --> 01:12:47,800
If you have always short jobs arriving, 

1253
01:12:48,360 --> 01:12:57,110
they are going to start the long jobs with multilevel feet queue fit by queue. 

1254
01:12:57,860 --> 01:13:01,180
It's an approximation assured that remaining time first. 

1255
01:13:01,640 --> 01:13:03,030
So it suffers from the same problem. 

1256
01:13:05,710 --> 01:13:07,180
Again, in some sense,

1257
01:13:07,650 --> 01:13:10,520
the case, the cause for starvation, it's always a priority,

1258
01:13:10,530 --> 01:13:12,120
whether it's a fixed priority, 

1259
01:13:12,130 --> 01:13:13,720
or whether it's implicit, 

1260
01:13:14,400 --> 01:13:16,600
explicit fixed priority or implicit priority, 

1261
01:13:16,610 --> 01:13:18,950
like the length of a job. 

1262
01:13:21,250 --> 01:13:26,400
So you have this kind of a priority which is encoded in the schedulers, 

1263
01:13:26,410 --> 01:13:27,840
how schedule make the decision? 

1264
01:13:28,800 --> 01:13:34,620
It should be a raise a flag that it you may then end up with starvation. 

1265
01:13:39,160 --> 01:13:40,990
Again, our job, remember,

1266
01:13:41,000 --> 01:13:45,860
is the server mix of CPU bound and io bound and interactive jobs effectively. 

1267
01:13:47,230 --> 01:13:51,780
Here you want to have interactive jobs to be interactive, 

1268
01:13:51,790 --> 01:13:55,930
be very quick response time, 

1269
01:13:55,940 --> 01:13:57,170
verify the response time. 

1270
01:13:57,690 --> 01:14:02,000
We need to give I abound the jobs enough CPU so that they are going to do

1271
01:14:02,010 --> 01:14:02,640
their work. 

1272
01:14:03,450 --> 01:14:05,730
Ideally want them to be our bound, right?

1273
01:14:10,210 --> 01:14:12,560
And then the CPU bound ones, 

1274
01:14:12,570 --> 01:14:16,210
you want to still let them running to eventually finish. 

1275
01:14:18,640 --> 01:14:19,000
Now, 

1276
01:14:21,210 --> 01:14:22,680
the scheduling discipline, 

1277
01:14:23,210 --> 01:14:27,410
it's also we are going to learn and we learned. 

1278
01:14:28,860 --> 01:14:34,660
It's also a reflection of the changes in the landscape of computers

1279
01:14:35,710 --> 01:14:37,120
for big mainframes, 

1280
01:14:37,130 --> 01:14:39,320
where you have a lot of users using them. 

1281
01:14:39,880 --> 01:14:40,790
To b C's, 

1282
01:14:40,800 --> 01:14:45,950
you have one user over and maybe one program earlier on a single machine

1283
01:14:45,960 --> 01:14:49,770
to multiple programs on a single machine, 

1284
01:14:49,780 --> 01:14:51,090
but only one users. 

1285
01:14:51,610 --> 01:14:53,760
And to even internet of things, 

1286
01:14:53,770 --> 01:14:58,600
which the things are sitting there just to get some Information from the environment. 

1287
01:14:59,650 --> 01:14:59,930
Right? 

1288
01:15:01,170 --> 01:15:04,560
So priority by scheduling is rooted in times sharing. 

1289
01:15:04,960 --> 01:15:07,290
When you have fewer resources, 

1290
01:15:07,970 --> 01:15:13,070
lot of things running on the same competing for the resources. 

1291
01:15:13,910 --> 01:15:16,730
And that's why. 

1292
01:15:17,000 --> 01:15:19,950
But and then they LED to starvation. 

1293
01:15:20,480 --> 01:15:22,970
People try to resolve the starvation, 

1294
01:15:23,390 --> 01:15:24,950
try to develop new scheduling, 

1295
01:15:24,960 --> 01:15:26,230
which are more fair, 

1296
01:15:28,320 --> 01:15:29,190
and things like that. 

1297
01:15:31,120 --> 01:15:38,620
And one question here is that this is

1298
01:15:39,510 --> 01:15:44,390
desperate providing some jobs necessarily start those that aren't prioritized. 

1299
01:15:47,660 --> 01:15:54,740
Not three priorities in certain cases, like we've seen, absolutely.

1300
01:15:55,260 --> 01:15:59,010
It turns out that people have a bunch of holistics to reduce that miss, 

1301
01:15:59,020 --> 01:15:59,650
reduce, 

1302
01:15:59,660 --> 01:16:01,130
alleviate starvation. 

1303
01:16:03,630 --> 01:16:05,670
There are a few ways to do it. 

1304
01:16:06,540 --> 01:16:07,770
Multilevel feedback, 

1305
01:16:07,860 --> 01:16:08,970
if you remember, 

1306
01:16:09,310 --> 01:16:14,770
tries to reduce the starvation by having CPU bounded jobs, 

1307
01:16:15,660 --> 01:16:17,810
falling that the one which keeps along to, 

1308
01:16:17,820 --> 01:16:20,580
it takes a long time to admit, 

1309
01:16:20,590 --> 01:16:21,980
to be deprived, 

1310
01:16:22,230 --> 01:16:24,650
to go to a lower priority in time. 

1311
01:16:26,040 --> 01:16:29,360
The other things are the mechanics like the mechanics, 

1312
01:16:29,370 --> 01:16:33,310
which are API exposed to the users to being nice. 

1313
01:16:33,660 --> 01:16:34,010
Right? 

1314
01:16:35,260 --> 01:16:39,450
So basically, and if you want it to be nice and is this a unique command,

1315
01:16:39,800 --> 01:16:42,680
you can be prioritize your task, 

1316
01:16:42,690 --> 01:16:44,000
your program. 

1317
01:16:44,440 --> 01:16:48,230
So other people will work and run their programs. 

1318
01:16:50,170 --> 01:16:52,880
The nice value ranged from-20 to 19, 

1319
01:16:52,890 --> 01:16:55,800
negative values are not nice. 

1320
01:16:56,400 --> 01:17:00,830
The things is that for in this particular, 

1321
01:17:03,940 --> 01:17:04,970
in this particular case, 

1322
01:17:04,980 --> 01:17:10,990
you can think about for unique sum systems, like unique.

1323
01:17:11,000 --> 01:17:12,550
Suddenly, some version of UNIX,

1324
01:17:13,100 --> 01:17:16,290
the lower priorities are the lower properties. 

1325
01:17:16,300 --> 01:17:18,250
Values are higher priorities. 

1326
01:17:18,540 --> 01:17:20,210
So far in all our examples, 

1327
01:17:20,220 --> 01:17:23,890
you assume the higher priority values of priority three has a high priority. 

1328
01:17:24,300 --> 01:17:26,530
But in UNIX, 

1329
01:17:26,540 --> 01:17:28,850
at least some version of UNIX is the other around. 

1330
01:17:29,280 --> 01:17:33,990
The lower priority values of priority zero is the highest priority, 

1331
01:17:34,000 --> 01:17:35,830
and priority three is the lower price. 

1332
01:17:36,730 --> 01:17:38,360
Then in this case, 

1333
01:17:38,580 --> 01:17:42,740
so therefore, if you increase a nice value, you increase,

1334
01:17:42,750 --> 01:17:47,810
you basically decrease a priority of your increase a priority value, 

1335
01:17:47,820 --> 01:17:50,570
but it is a priority of your job. 

1336
01:17:51,640 --> 01:17:51,990
Okay? 

1337
01:17:54,580 --> 01:17:55,770
Let me stop here. 

1338
01:17:55,780 --> 01:17:58,010
And we are almost done with the lecture, 

1339
01:17:58,020 --> 01:17:59,810
but we are going to continue next time. 

1340
01:18:00,440 --> 01:18:02,830
It's the last lecture on scheduling. 

1341
01:18:03,440 --> 01:18:06,190
And we are going to look a little bit about Linux, 

1342
01:18:06,200 --> 01:18:07,750
how Linux is implemented. 

1343
01:18:08,690 --> 01:18:15,210
And then we are going to talk a little bit more about fairness with that. 

1344
01:18:15,220 --> 01:18:18,250
If there are any other questions, I could answer

1345
01:18:27,440 --> 01:18:27,990
the deadlock. 

1346
01:18:28,000 --> 01:18:31,790
There only happens that does deadlock only happens here on spin locks. 

1347
01:18:32,690 --> 01:18:34,640
In that particular example is yes. 

1348
01:18:37,910 --> 01:18:41,260
But interlock is a much more general concept like we will see you next time. 

1349
01:18:45,950 --> 01:18:46,180
No. 

1350
01:18:46,190 --> 01:18:46,900
Other questions. 

1351
01:18:46,910 --> 01:18:48,100
Thank you so much, sir.

1352
01:18:48,110 --> 01:18:49,900
And I am going to see you on Monday. 

1353
01:18:51,120 --> 01:18:53,290
Good luck with your homework and the project. 

1354
01:18:54,360 --> 01:18:54,670
Bye. 

