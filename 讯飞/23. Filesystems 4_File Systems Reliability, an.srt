1
00:00:10,170 --> 00:00:11,080
Hello, everyone.

2
00:00:11,130 --> 00:00:16,320
So today we are going to continue our discussion on a file system, 

3
00:00:16,750 --> 00:00:17,820
reliability. 

4
00:00:17,830 --> 00:00:24,540
And we are going to talk a little bit about transactions and start talking

5
00:00:24,550 --> 00:00:25,460
about networking. 

6
00:00:28,230 --> 00:00:30,180
If you remember, from last time,

7
00:00:30,310 --> 00:00:39,700
these are the three notions which are characterizing a system ability to function. 

8
00:00:40,990 --> 00:00:48,390
One is availability and refers to the system ability to respond to the

9
00:00:48,400 --> 00:00:51,190
request process and response to the requests. 

10
00:00:52,990 --> 00:01:00,540
Durability refers to the fact that is reflected the storage means it means that

11
00:01:01,380 --> 00:01:04,690
if you successfully start a piece of data, 

12
00:01:06,200 --> 00:01:10,780
you are going to be able to later retrieve the piece of data, 

13
00:01:10,790 --> 00:01:12,020
that piece of data. 

14
00:01:13,320 --> 00:01:18,040
He's not going to disappear or is going to be lost

15
00:01:18,050 --> 00:01:23,150
despite maybe some the storage device failures, 

16
00:01:25,030 --> 00:01:26,740
and then reliability. 

17
00:01:26,750 --> 00:01:30,030
It's puts the two together, 

18
00:01:30,640 --> 00:01:32,590
both availability and your ability, 

19
00:01:32,600 --> 00:01:41,470
and basically the ability of the system to perform the required function, 

20
00:01:45,070 --> 00:01:48,890
according to some specification during the space. 

21
00:01:49,220 --> 00:01:51,770
For instance, if you are going to send the request,

22
00:01:52,040 --> 00:01:55,800
you are going to get a response within a specified time period. 

23
00:01:57,880 --> 00:02:00,390
And obviously, that should be correct.

24
00:02:01,410 --> 00:02:05,840
Last time, we discussed little about a durability.

25
00:02:06,620 --> 00:02:08,570
Let's go again back. 

26
00:02:09,650 --> 00:02:14,820
And we discuss about this is basically a summary of the last few slides

27
00:02:15,690 --> 00:02:17,170
from the last lecture. 

28
00:02:18,150 --> 00:02:19,620
I know you could provide your ability. 

29
00:02:19,870 --> 00:02:23,540
It's again, the ability that once you start a piece of data,

30
00:02:23,550 --> 00:02:25,940
you can later retrieve that piece of data. 

31
00:02:26,650 --> 00:02:28,690
It's basically replicating the data. 

32
00:02:29,240 --> 00:02:29,580
Right? 

33
00:02:30,240 --> 00:02:32,080
And if you replicate the data, 

34
00:02:32,320 --> 00:02:38,690
then it provides you the ability to survive to one this failure. 

35
00:02:38,700 --> 00:02:40,790
Because if one this failed, 

36
00:02:41,060 --> 00:02:45,770
you still have the other these storing the epitope of the data. 

37
00:02:45,980 --> 00:02:47,130
The data is not lost. 

38
00:02:49,240 --> 00:02:50,070
We also discuss. 

39
00:02:50,080 --> 00:02:55,030
So what are the characteristics of this system of this red one where you

40
00:02:55,040 --> 00:02:58,300
replicate any piece of data on two different disks? 

41
00:02:59,680 --> 00:03:02,390
One is that when you write a date, a piece of data,

42
00:03:02,400 --> 00:03:03,990
you need to write on both disks. 

43
00:03:04,320 --> 00:03:08,670
Therefore, you sacrifice the bandwidth of the right,

44
00:03:08,680 --> 00:03:12,820
because each right now becomes two rights to different disks. 

45
00:03:14,240 --> 00:03:16,830
It's also, you need to wait for the slower,

46
00:03:16,840 --> 00:03:18,830
slow as this to do the right. 

47
00:03:19,900 --> 00:03:24,890
If you want to really optimize of how long this right latency, 

48
00:03:25,250 --> 00:03:27,580
you probably want to synchronize a disk. 

49
00:03:27,590 --> 00:03:29,060
So therefore, both rise,

50
00:03:29,070 --> 00:03:32,170
take the same amount of time, more or less.

51
00:03:33,970 --> 00:03:35,000
On the other hand, 

52
00:03:35,010 --> 00:03:37,920
for real things are a little bit different and are better. 

53
00:03:38,450 --> 00:03:41,050
Because now you have two replicas, and you need, when you read,

54
00:03:41,060 --> 00:03:43,210
you need us to get a piece of data. 

55
00:03:43,740 --> 00:03:45,980
So you can get from either disk. 

56
00:03:46,600 --> 00:03:51,940
So actually, you can improve or can even double the throughput.

57
00:03:52,550 --> 00:03:53,450
In this case, 

58
00:03:55,830 --> 00:03:56,830
finally, if you remember,

59
00:03:56,840 --> 00:03:57,870
when it is fair, 

60
00:03:57,880 --> 00:03:59,690
is what you are going to do. 

61
00:03:59,700 --> 00:04:01,510
You are going to buy another one, 

62
00:04:01,620 --> 00:04:06,810
and then you are going to copy all the data from the primary

63
00:04:06,820 --> 00:04:09,250
now from primary disk to the secondary, 

64
00:04:09,740 --> 00:04:10,610
to the new disk. 

65
00:04:10,620 --> 00:04:12,490
And now you have a game to a rebel class. 

66
00:04:13,940 --> 00:04:14,130
Now, 

67
00:04:14,140 --> 00:04:17,490
this assumes that while you're doing these recoveries

68
00:04:17,500 --> 00:04:19,330
of primary disk doesn't fail. 

69
00:04:20,030 --> 00:04:22,190
And that's something to keep in mind. 

70
00:04:25,040 --> 00:04:27,700
And actually, this is a problem, in general,

71
00:04:27,710 --> 00:04:36,250
because this is if you do this right one, 

72
00:04:36,260 --> 00:04:38,930
and you do you build the right one and your application, 

73
00:04:39,260 --> 00:04:44,760
presumably, what you want this to be from different batches of production.

74
00:04:45,600 --> 00:04:48,660
Because if you and this, 

75
00:04:48,670 --> 00:04:50,160
you need to be careful, right?

76
00:04:50,170 --> 00:04:51,400
Because when you buy this, 

77
00:04:51,410 --> 00:04:55,070
you buy all the disk at the same time to build this system. 

78
00:04:55,530 --> 00:05:00,530
But then if this guy from the same batches batch of production, 

79
00:05:00,810 --> 00:05:05,180
they tend to have the same failures and the same kind of failure pattern. 

80
00:05:05,560 --> 00:05:08,470
And then when one this fails is pretty likely than other, 

81
00:05:08,480 --> 00:05:10,500
is also from the same bachelor fail. 

82
00:05:11,180 --> 00:05:12,830
So you don't want to do that, 

83
00:05:13,430 --> 00:05:16,620
because you want to reduce apps as a minimum, 

84
00:05:16,630 --> 00:05:18,140
the risk that during the recovery, 

85
00:05:18,150 --> 00:05:19,340
another disposal. 

86
00:05:19,960 --> 00:05:24,010
So that's how you use different product batches or you receive and may be

87
00:05:24,020 --> 00:05:26,760
different disk manufacturers. 

88
00:05:30,730 --> 00:05:34,960
The problem with red wine is very expensive and so far so high overhead. 

89
00:05:35,570 --> 00:05:37,520
We discuss about this straight, right?

90
00:05:37,530 --> 00:05:40,570
Five and more your stripes, the data.

91
00:05:40,580 --> 00:05:42,170
So you have a parity block. 

92
00:05:43,380 --> 00:05:44,480
In this case, 

93
00:05:48,340 --> 00:05:54,440
you take the blocks out of, 

94
00:05:56,050 --> 00:05:57,960
you start successively, in this case,

95
00:05:57,970 --> 00:06:00,100
for blocks on four disks. 

96
00:06:00,110 --> 00:06:02,550
And then on the five disk here, 

97
00:06:02,850 --> 00:06:06,380
you are going to have computer parity block, 

98
00:06:11,310 --> 00:06:12,350
the parity block. 

99
00:06:12,650 --> 00:06:14,870
One way to compute its excellent, 

100
00:06:14,880 --> 00:06:16,470
like we discussed last time, 

101
00:06:17,730 --> 00:06:19,570
d zero here is d zero, 

102
00:06:20,170 --> 00:06:23,040
x or d one, x or d two x or d three.

103
00:06:24,430 --> 00:06:25,510
Here is an example. 

104
00:06:26,200 --> 00:06:27,210
If you want, 

105
00:06:27,220 --> 00:06:29,250
if one biscuits it's destroyed, 

106
00:06:29,610 --> 00:06:31,110
you can still recover. 

107
00:06:32,400 --> 00:06:33,640
This is an example. 

108
00:06:34,020 --> 00:06:35,090
Here is an example. 

109
00:06:35,100 --> 00:06:35,450
Here. 

110
00:06:35,460 --> 00:06:36,890
Each block is 1 bit, 

111
00:06:37,440 --> 00:06:38,750
let's say, d zero, it's zero,

112
00:06:38,760 --> 00:06:41,110
then d one 1, d 20,

113
00:06:41,120 --> 00:06:42,150
d 31. 

114
00:06:42,520 --> 00:06:44,050
If you do the x or here, 

115
00:06:44,060 --> 00:06:45,370
you are going to get zero. 

116
00:06:45,380 --> 00:06:49,870
This is a parity on the content of the parity block. 

117
00:06:50,540 --> 00:06:52,930
Now, suppose this to fail.

118
00:06:53,860 --> 00:06:55,730
If you do this to fail, 

119
00:06:55,950 --> 00:06:56,960
then what you do, 

120
00:06:56,970 --> 00:07:00,730
you are going to do the x or everything, 

121
00:07:02,230 --> 00:07:05,020
which is, including the parity block.

122
00:07:05,450 --> 00:07:08,330
And then you are going to get the content of the lost block. 

123
00:07:08,340 --> 00:07:10,960
So in this case, we do was zero.

124
00:07:11,340 --> 00:07:13,550
You get deal with the zero, 

125
00:07:14,100 --> 00:07:15,340
x or v one, 

126
00:07:15,630 --> 00:07:18,210
x or b three, x or p zero, the parity block.

127
00:07:18,220 --> 00:07:19,960
And you get zero, you recover.

128
00:07:27,030 --> 00:07:28,610
It's a great question. 

129
00:07:30,620 --> 00:07:32,910
Why do we start parody staggered? 

130
00:07:38,680 --> 00:07:40,190
Gilbert, he says,

131
00:07:40,200 --> 00:07:43,110
answer that if they are in the same row columns and we

132
00:07:43,120 --> 00:07:47,120
might have to trouble recovering if that specific route column got lost. 

133
00:07:52,300 --> 00:07:59,260
So basically, it's about load balancing the load when you have failures.

134
00:07:59,270 --> 00:07:59,620
Right? 

135
00:07:59,630 --> 00:08:02,140
For instance, if the parity block fails,

136
00:08:02,510 --> 00:08:04,240
then both the readers, 

137
00:08:04,910 --> 00:08:06,550
the disposal parity block fails. 

138
00:08:06,880 --> 00:08:08,840
At least the reels will not be affected, 

139
00:08:09,720 --> 00:08:12,200
because all the blocks are there, right?

140
00:08:13,520 --> 00:08:15,670
The data blocks in the background, 

141
00:08:15,680 --> 00:08:17,590
you are going to reconstruct the parity block. 

142
00:08:19,670 --> 00:08:21,760
So that's 111 reason. 

143
00:08:22,090 --> 00:08:22,300
Right? 

144
00:08:23,310 --> 00:08:23,980
It's a game. 

145
00:08:23,990 --> 00:08:28,180
It's like, if you put all the parity blocks on a disk,

146
00:08:28,930 --> 00:08:33,610
then if any other disks goes away, 

147
00:08:33,620 --> 00:08:38,220
then all the reads have to reconstruct using the parity block. 

148
00:08:38,480 --> 00:08:39,400
So it's expensive. 

149
00:08:41,590 --> 00:08:43,770
All there is for the data, from the failures.

150
00:08:44,780 --> 00:08:48,070
If the parity blocks are staggered, 

151
00:08:48,510 --> 00:08:49,690
then again, 

152
00:08:49,700 --> 00:08:52,090
when the disk is a parity, 

153
00:08:53,250 --> 00:08:58,930
when you access the data whose parity block was on a failed disk, 

154
00:08:59,650 --> 00:09:01,980
you don't need to do anything because the data is available. 

155
00:09:10,910 --> 00:09:13,580
This is I the same solution, 

156
00:09:16,190 --> 00:09:18,030
in principle, is going to recover.

157
00:09:18,040 --> 00:09:18,510
Also. 

158
00:09:18,520 --> 00:09:19,310
What is the internet? 

159
00:09:19,320 --> 00:09:19,750
Right? 

160
00:09:19,760 --> 00:09:21,530
It's like, not there.

161
00:09:21,540 --> 00:09:25,950
It doesn't need to be in the same data center or in the same rack. 

162
00:09:29,350 --> 00:09:32,140
And then it's, again,

163
00:09:32,150 --> 00:09:33,380
this straight five. 

164
00:09:34,150 --> 00:09:40,570
It's provides your ability in the presence of one this failure. 

165
00:09:41,460 --> 00:09:43,610
What if you want to have more these failures? 

166
00:09:44,130 --> 00:09:46,630
There are, as a version of ride back,

167
00:09:46,640 --> 00:09:48,450
ride x instead of parity blocks, 

168
00:09:48,460 --> 00:09:49,750
there is your asian code. 

169
00:09:51,580 --> 00:09:52,230
For instance, 

170
00:09:52,240 --> 00:09:56,730
rate six allowed to disk and replicate to fail in the replication, 

171
00:09:57,330 --> 00:09:58,040
strive to fail. 

172
00:09:58,540 --> 00:10:02,010
Many of these are the three solomon codes of the radio codes. 

173
00:10:02,690 --> 00:10:04,800
In this case, you have m data fragments.

174
00:10:05,390 --> 00:10:06,730
You can think about blocks, 

175
00:10:06,940 --> 00:10:10,820
and you generate n minus m extra fragments. 

176
00:10:11,070 --> 00:10:15,010
Now, to start m blocks of m fragments of data or blocks of data,

177
00:10:15,260 --> 00:10:19,800
you are going to need and blocks out of which n minus rm

178
00:10:19,810 --> 00:10:21,200
are newly generated blocks. 

179
00:10:21,830 --> 00:10:23,920
This can generate n minus m failures. 

180
00:10:23,930 --> 00:10:25,120
So basically, you can,

181
00:10:26,040 --> 00:10:28,430
if, as long as you have,

182
00:10:28,800 --> 00:10:31,960
m in, the m disks are still up,

183
00:10:32,490 --> 00:10:36,750
then you can reconstruct nemd scout of n are up. 

184
00:10:37,120 --> 00:10:42,260
You can reconstruct all the pieces of it, right?

185
00:10:44,490 --> 00:10:44,930
It's again. 

186
00:10:44,940 --> 00:10:46,090
So like, for instance,

187
00:10:46,100 --> 00:10:49,820
if you want really to have extremely, 

188
00:10:51,080 --> 00:10:52,750
something extremely resilient, 

189
00:10:53,440 --> 00:10:56,350
extremely durable, you can have, like, in this example,

190
00:10:56,360 --> 00:11:01,520
you can have m is for fragments or blocks and in 16. 

191
00:11:01,980 --> 00:11:04,550
So then you are going, 

192
00:11:04,910 --> 00:11:06,470
the overhead is quite high. 

193
00:11:07,880 --> 00:11:10,310
And by this system will be extremely durable. 

194
00:11:12,260 --> 00:11:13,450
And like mentioning, 

195
00:11:13,460 --> 00:11:15,900
you can have the device. 

196
00:11:16,210 --> 00:11:19,720
All the disk drives in the same a room, 

197
00:11:19,730 --> 00:11:21,600
or you can have them across the internet. 

198
00:11:21,610 --> 00:11:23,680
And obviously, when they are across the internet,

199
00:11:24,020 --> 00:11:32,530
you are going to have a much more durable system because the correlation

200
00:11:32,540 --> 00:11:33,570
of failure is lower, 

201
00:11:33,580 --> 00:11:33,850
right? 

202
00:11:33,860 --> 00:11:35,610
If all the discard in the same room, 

203
00:11:35,620 --> 00:11:40,040
if you have an earthquake or you have a fire, 

204
00:11:40,330 --> 00:11:41,640
or that this may be destroyed. 

205
00:11:44,630 --> 00:11:49,600
Here a a it's a very interesting aspect. 

206
00:11:49,940 --> 00:11:53,630
And at the high level, 

207
00:11:55,690 --> 00:11:58,080
so one is so say you want to do, 

208
00:11:58,090 --> 00:12:01,730
you are prepared to pay an overhead here. 

209
00:12:01,740 --> 00:12:02,930
In this example, 

210
00:12:02,940 --> 00:12:07,520
you say an overhead of forex. 

211
00:12:07,530 --> 00:12:09,680
So for each piece of data, 

212
00:12:10,000 --> 00:12:14,460
I am not going to require 4 time storage. 

213
00:12:14,470 --> 00:12:18,390
Like if I start one gigabyte of data, 

214
00:12:18,730 --> 00:12:20,930
I am going to use four gigabytes of storage. 

215
00:12:22,810 --> 00:12:25,300
And one thing is to have for a wise replication, 

216
00:12:25,620 --> 00:12:26,850
each piece of data, 

217
00:12:28,250 --> 00:12:30,290
I am going to replicate on four different pieces. 

218
00:12:31,600 --> 00:12:34,410
And then you compute here, 

219
00:12:34,420 --> 00:12:36,570
this is fraction block loss per year. 

220
00:12:37,370 --> 00:12:40,120
This is on the y axis, 

221
00:12:40,130 --> 00:12:41,720
the x axis, 

222
00:12:41,730 --> 00:12:43,360
the repair time of algorithm, 

223
00:12:43,370 --> 00:12:51,360
or but then in your computer probably is that you lose all the data, right?

224
00:12:52,670 --> 00:12:56,890
This means all 4 days start going to fail before you have a chance to rebel. 

225
00:13:00,780 --> 00:13:04,260
Now, the other way you can do it is the following thing.

226
00:13:04,270 --> 00:13:05,820
And that's why it's called fragments. 

227
00:13:05,830 --> 00:13:06,260
I'm saying, 

228
00:13:06,840 --> 00:13:14,370
i'm taking a block and instead of replicating four time for on four beasts, 

229
00:13:15,210 --> 00:13:19,170
I am going to take assume that I have, 

230
00:13:19,660 --> 00:13:21,870
say, 64 disk,

231
00:13:21,880 --> 00:13:25,440
smaller disks that are the total story is the same. 

232
00:13:27,080 --> 00:13:28,900
But then i'm taking a block, 

233
00:13:29,260 --> 00:13:32,750
and i'm going to divide it into 6, 16 fragments.

234
00:13:33,870 --> 00:13:36,220
And for each fragment, I am going.

235
00:13:37,130 --> 00:13:38,920
And then for the 16 fragments, 

236
00:13:38,930 --> 00:13:41,320
and i'm going to compute using gradient codes. 

237
00:13:44,290 --> 00:13:46,450
Another 64-16, 

238
00:13:46,460 --> 00:13:48,400
48 fragment, right?

239
00:13:48,700 --> 00:13:50,140
The overhead is the same. 

240
00:13:51,070 --> 00:13:52,630
But now I have a lot of more fuel, 

241
00:13:52,640 --> 00:13:54,150
a lot of more fragments. 

242
00:13:55,410 --> 00:13:57,400
And in this particular case, 

243
00:13:57,410 --> 00:14:00,700
this will be a much more durable system. 

244
00:14:02,820 --> 00:14:04,490
Let me say a little bit about this plot. 

245
00:14:04,500 --> 00:14:05,690
Now, on the x axis,

246
00:14:05,700 --> 00:14:10,750
you have repair time on the y axis. 

247
00:14:11,100 --> 00:14:14,830
Here you are going to have probability of block failure period. 

248
00:14:17,910 --> 00:14:22,060
This basically says that, as you expect,

249
00:14:22,070 --> 00:14:24,940
and different lines are for the number of fragments, 

250
00:14:25,910 --> 00:14:27,530
for 8, 16, 72,

251
00:14:27,540 --> 00:14:29,430
64 for four fragments. 

252
00:14:29,840 --> 00:14:34,300
Is basically you have a replication on, 

253
00:14:35,090 --> 00:14:36,310
basically, on for,

254
00:14:36,320 --> 00:14:40,640
as you can see this way on for the or for devices. 

255
00:14:41,570 --> 00:14:45,240
Obviously, you can expect that the repair time increases,

256
00:14:47,170 --> 00:14:53,340
then the probability of failure will increase, 

257
00:14:55,070 --> 00:14:55,460
right? 

258
00:14:55,850 --> 00:14:59,510
Because if it takes one day to repair, 

259
00:14:59,520 --> 00:15:03,110
that is a chance that other bees will fail within one day, 

260
00:15:03,210 --> 00:15:06,760
is much smaller than if the repair takes 6 months. 

261
00:15:07,200 --> 00:15:09,760
Then now you have seen 6 months have already, obviously,

262
00:15:09,770 --> 00:15:12,100
the point that is to fail is much higher. 

263
00:15:17,430 --> 00:15:18,650
But this, basically,

264
00:15:22,900 --> 00:15:24,690
again, this is simple probability.

265
00:15:26,450 --> 00:15:31,680
This basically tells you that the probability to have, 

266
00:15:32,000 --> 00:15:37,840
say, in this case to have for this,

267
00:15:37,850 --> 00:15:40,160
so for this to fail, 

268
00:15:40,170 --> 00:15:44,210
so you lose all the copies is much higher. 

269
00:15:44,480 --> 00:15:48,600
Then they probably to have all for this to fail to have. 

270
00:15:49,270 --> 00:15:52,820
In this case, 49 of these of 64,

271
00:15:52,830 --> 00:15:59,630
these two facts. 

272
00:16:05,690 --> 00:16:08,440
Michael asked this question in practice, are error codes.

273
00:16:08,450 --> 00:16:12,080
I the parity codes ever used instead of eraser codes. 

274
00:16:15,340 --> 00:16:17,490
If you have only to tolerate a failure, 

275
00:16:17,500 --> 00:16:21,210
I think you are still going to use the priority codes. 

276
00:16:22,480 --> 00:16:23,550
It's just easier, 

277
00:16:23,560 --> 00:16:25,900
or you are going to use replication. 

278
00:16:28,040 --> 00:16:29,230
The other one. 

279
00:16:32,110 --> 00:16:34,970
But in general, you do is erasure codes and erasure codes.

280
00:16:34,980 --> 00:16:37,570
Actually, they are using all these distributed file systems,

281
00:16:37,950 --> 00:16:41,220
also like how to distribute file systems that are version, 

282
00:16:41,230 --> 00:16:42,860
which are using erasal codes. 

283
00:16:43,460 --> 00:16:48,180
They actually exactly to improve reliability. 

284
00:16:49,600 --> 00:16:50,960
But I will ask a question, 

285
00:16:50,970 --> 00:16:53,320
what does it mean to repair for 6 months? 

286
00:16:54,980 --> 00:17:00,530
So think about this is depends of how difficult is to repair, 

287
00:17:00,540 --> 00:17:02,210
but in the past, 

288
00:17:03,970 --> 00:17:05,640
you have the discounts, 

289
00:17:05,650 --> 00:17:08,020
and you lost some disks. 

290
00:17:08,030 --> 00:17:09,940
So now you need to order those disks. 

291
00:17:12,020 --> 00:17:13,130
The delivery, 

292
00:17:13,460 --> 00:17:14,850
it may take 3 months, right?

293
00:17:14,860 --> 00:17:18,090
Because in your order to be approved, 

294
00:17:18,460 --> 00:17:21,900
if you are at a company and all of these things, right?

295
00:17:21,910 --> 00:17:24,940
And then your disk have to be shipped. 

296
00:17:27,660 --> 00:17:31,050
Maybe you have all the disk and your similar disk, 

297
00:17:31,060 --> 00:17:32,610
so it just takes time. 

298
00:17:33,530 --> 00:17:34,880
The time is a mean, 

299
00:17:34,890 --> 00:17:37,120
repair time is a time it takes. 

300
00:17:37,680 --> 00:17:39,950
If you lost some cop, 

301
00:17:39,960 --> 00:17:43,380
you lost some copies to recover these copies. 

302
00:17:43,680 --> 00:17:44,830
Because and for that, 

303
00:17:44,840 --> 00:17:49,690
you may need to buy additional hardware to replace the one which has failed. 

304
00:17:55,410 --> 00:17:55,930
Make sense? 

305
00:18:01,530 --> 00:18:08,430
Here it's an example about using and studying the fragments over over the internet. 

306
00:18:13,490 --> 00:18:14,010
So again, 

307
00:18:14,020 --> 00:18:17,490
just wanted to make sure here to go back that what we are saying here is

308
00:18:17,500 --> 00:18:18,850
when you do that application, 

309
00:18:19,210 --> 00:18:20,300
again, you have one block,

310
00:18:20,310 --> 00:18:22,190
so say one block is one kilobyte. 

311
00:18:22,500 --> 00:18:23,410
You replicate. 

312
00:18:23,860 --> 00:18:26,600
You have4 copies, one kilobyte,

313
00:18:26,610 --> 00:18:28,120
only on different amounts. 

314
00:18:29,420 --> 00:18:30,940
When you lose a fragmentation, here,

315
00:18:30,950 --> 00:18:32,180
you take one kilobyte, 

316
00:18:32,190 --> 00:18:37,580
and the divide is out blocked divided in 16 fragments. 

317
00:18:38,720 --> 00:18:42,020
For 16 fragments, you are going to have what?

318
00:18:42,030 --> 00:18:43,500
It's to power. 

319
00:18:45,110 --> 00:18:48,640
It's one kilobyte divided by 16, 

320
00:18:49,600 --> 00:18:49,900
right? 

321
00:18:50,440 --> 00:18:52,410
And I believe it's what 128, 

322
00:18:52,420 --> 00:18:54,380
something like that bytes. 

323
00:18:55,180 --> 00:18:56,490
Now you have this kind of. 

324
00:18:59,390 --> 00:19:01,240
It's now you have, 

325
00:19:01,870 --> 00:19:04,020
sorry, you have 64, right?

326
00:19:04,030 --> 00:19:05,460
16×64. 

327
00:19:14,470 --> 00:19:14,870
Yep. 

328
00:19:15,840 --> 00:19:20,550
So divided one kilobyte is 16 fragments. 

329
00:19:20,560 --> 00:19:27,900
And then you are going to each fragment now is going to have 64 bytes. 

330
00:19:28,780 --> 00:19:32,210
Now you are going to generate another 48 fragments. 

331
00:19:32,220 --> 00:19:36,450
Each of them are 64 bytes using greater products. 

332
00:19:38,240 --> 00:19:42,070
Now, in order to read the data,

333
00:19:42,080 --> 00:19:44,350
you need to read 16 fragments. 

334
00:19:44,740 --> 00:19:46,020
Any of these 64 drag, 

335
00:19:46,030 --> 00:19:48,880
any 16 fragments out of 64 fragments will do it. 

336
00:19:49,660 --> 00:19:52,090
And you can construct and construct the original block. 

337
00:19:53,690 --> 00:19:54,130
Make sense? 

338
00:19:55,850 --> 00:19:59,340
I need to make sure we are on the same page. 

339
00:20:02,650 --> 00:20:04,000
This is about your ability. 

340
00:20:05,390 --> 00:20:07,830
But this is not enough the fact that the disk, 

341
00:20:07,840 --> 00:20:09,630
the data is still on the disk. 

342
00:20:10,850 --> 00:20:14,050
It doesn't mean that you can access it. 

343
00:20:15,020 --> 00:20:23,440
Also, it doesn't mean that you are also able to write the data on

344
00:20:23,450 --> 00:20:26,600
the disk in the first place. 

345
00:20:27,120 --> 00:20:27,590
Right? 

346
00:20:28,220 --> 00:20:30,320
So that's why we care about reliability. 

347
00:20:30,330 --> 00:20:32,440
Reality is looking at the end to end. 

348
00:20:32,450 --> 00:20:35,710
It is not doesn't care only what the data is on the disk, 

349
00:20:36,020 --> 00:20:40,610
but whether you can put the data on the disk and you can retrieve the data

350
00:20:40,620 --> 00:20:41,410
from the disk. 

351
00:20:43,070 --> 00:20:45,070
So next we are going to talk about reliability, 

352
00:20:46,490 --> 00:20:50,840
but let's talk about what can go wrong, right?

353
00:20:51,660 --> 00:20:53,600
Which is orthogonal to durability. 

354
00:20:55,180 --> 00:20:58,410
So say a disk loses power or you have a software crash. 

355
00:21:00,030 --> 00:21:02,190
Now you have a read operation or write operation. 

356
00:21:03,020 --> 00:21:05,440
What happens is that route operation, which is in progress,

357
00:21:07,470 --> 00:21:12,860
maybe can be lost, right?

358
00:21:14,960 --> 00:21:18,270
Or maybe it's interrupted in the middle. 

359
00:21:19,130 --> 00:21:23,250
You just wrote half a block, not the entire block.

360
00:21:25,170 --> 00:21:31,310
So raid doesn't protect against any of such failures, right?

361
00:21:32,000 --> 00:21:33,160
Raid basically says, 

362
00:21:33,570 --> 00:21:37,940
if you are successful to write data and you have so many replicas, 

363
00:21:39,310 --> 00:21:40,720
if you once you've done that, 

364
00:21:41,450 --> 00:21:42,970
I guarantee that you find the data. 

365
00:21:43,940 --> 00:21:44,880
When you come next time, 

366
00:21:46,050 --> 00:21:47,060
it'll be store. 

367
00:21:48,140 --> 00:21:48,430
Right? 

368
00:21:50,130 --> 00:21:51,520
So, yes,

369
00:21:51,530 --> 00:21:52,680
you need your ability. 

370
00:21:53,190 --> 00:21:54,640
But this is not the entire story. 

371
00:21:56,300 --> 00:21:59,560
So this is what we are going to talk next. 

372
00:22:00,070 --> 00:22:00,310
Right? 

373
00:22:03,490 --> 00:22:05,940
Why is this a bigger problem? 

374
00:22:06,330 --> 00:22:07,820
This is a bigger problem, 

375
00:22:08,310 --> 00:22:10,990
because when you write data on a disk, 

376
00:22:11,290 --> 00:22:13,550
when you write a block of data in a disk, 

377
00:22:14,750 --> 00:22:16,570
it's not only that piece of data. 

378
00:22:18,300 --> 00:22:19,100
You need maybe to, 

379
00:22:21,270 --> 00:22:24,680
you need to update the I note data, right?

380
00:22:24,690 --> 00:22:25,800
Because you have a new block. 

381
00:22:25,810 --> 00:22:26,120
Now, 

382
00:22:26,890 --> 00:22:28,380
maybe it's an indirect block. 

383
00:22:28,670 --> 00:22:30,230
The.up to the indirect block, 

384
00:22:30,600 --> 00:22:32,510
the indirect indirection pointer. 

385
00:22:34,040 --> 00:22:40,700
You need to update the bid map of the which files are now available, 

386
00:22:41,170 --> 00:22:43,460
sorry, which blocks are available.

387
00:22:44,400 --> 00:22:45,820
Availability bit, mark, right?

388
00:22:45,830 --> 00:22:47,740
If you write in a blog on a block, 

389
00:22:47,750 --> 00:22:49,180
that block is no longer available. 

390
00:22:49,190 --> 00:22:51,100
So I need to update a bit much. 

391
00:22:53,110 --> 00:22:56,030
So for each of these riots, 

392
00:22:56,040 --> 00:22:58,710
you need actually to touch and multiple. 

393
00:23:01,020 --> 00:23:05,260
You need to touch multiple pieces of information from the risk. 

394
00:23:06,390 --> 00:23:09,860
And if some of them made to the disk, 

395
00:23:09,870 --> 00:23:12,700
but some of them do not make the disk. 

396
00:23:12,710 --> 00:23:15,340
You are going to leave the disk in an inconsistent state. 

397
00:23:19,450 --> 00:23:20,590
So that's a problem, right?

398
00:23:20,600 --> 00:23:21,670
How do you do that? 

399
00:23:22,010 --> 00:23:25,900
Not only when you have this kind of multiple operations, 

400
00:23:25,910 --> 00:23:29,920
which means all to succeed in order for the right to succeed. 

401
00:23:34,140 --> 00:23:40,040
And by the so that's kind of the problem. 

402
00:23:40,610 --> 00:23:40,770
Right? 

403
00:23:40,780 --> 00:23:46,440
And you also there are other complication because if you want a concurrency

404
00:23:46,730 --> 00:23:48,400
for improving throughput, 

405
00:23:48,410 --> 00:23:54,330
so you want to to perform this operation in parallel and sing

406
00:23:54,540 --> 00:23:55,650
in sensing like that. 

407
00:23:58,220 --> 00:23:59,110
Make sure it makes sense. 

408
00:23:59,120 --> 00:24:00,110
Any questions? 

409
00:24:07,840 --> 00:24:10,630
What are the stress to threats to reliability? 

410
00:24:10,640 --> 00:24:13,390
Like we discuss its interrupted operation? 

411
00:24:14,330 --> 00:24:17,440
Crash of software crashes, 

412
00:24:18,410 --> 00:24:19,600
power failures. 

413
00:24:20,230 --> 00:24:22,440
And when this happens, 

414
00:24:22,810 --> 00:24:24,690
then you can get into trouble. 

415
00:24:25,010 --> 00:24:28,860
This is a classical canonical example about the bank transfer. 

416
00:24:29,700 --> 00:24:32,140
You transfer from one bank to another, 

417
00:24:32,150 --> 00:24:34,240
to from one account to another. 

418
00:24:34,470 --> 00:24:41,610
What happens if you have a failures after you withdraw the sum of money? 

419
00:24:41,890 --> 00:24:47,810
But before you have a chance to deposit the sum of money, 

420
00:24:48,500 --> 00:24:49,610
a in a different account, 

421
00:24:51,000 --> 00:24:53,140
then you lost that those fun if you are not careful. 

422
00:24:59,090 --> 00:25:04,290
It's also this one failure of nonvolatile storage, right?

423
00:25:04,820 --> 00:25:10,630
Storage media may cause previous store data to disappear or be corrupted, 

424
00:25:12,130 --> 00:25:14,480
like we are going to see. 

425
00:25:18,310 --> 00:25:22,560
Any questions about what problems you are trying to solve here? 

426
00:25:29,820 --> 00:25:30,970
You're trying to solve here. 

427
00:25:30,980 --> 00:25:34,930
The biggest problem is that when you are going to write the data on the disk, 

428
00:25:36,240 --> 00:25:42,800
the biggest problem you do not want in the presence of failures to leave

429
00:25:42,810 --> 00:25:44,040
the data on the disk

430
00:25:44,770 --> 00:25:46,380
in an inconsistent state. 

431
00:25:49,850 --> 00:25:50,520
That's a problem. 

432
00:25:54,920 --> 00:25:56,280
There are two ways to do it. 

433
00:25:56,290 --> 00:25:57,320
Two general ways. 

434
00:25:57,330 --> 00:25:57,960
One, 

435
00:25:58,480 --> 00:26:05,560
you are just careful in you carefully are ordered your

436
00:26:05,570 --> 00:26:11,370
operations such that if you have failures, 

437
00:26:12,110 --> 00:26:12,980
when you restart, 

438
00:26:14,080 --> 00:26:19,730
you can clean up the mess and leaves a disk in a consistent state. 

439
00:26:22,640 --> 00:26:28,720
That's why the other one is copy and write. 

440
00:26:29,750 --> 00:26:30,700
The copy on write. 

441
00:26:30,710 --> 00:26:33,700
You can think about the data you wrote is immutable. 

442
00:26:35,850 --> 00:26:38,800
When you try to modify some piece of data, 

443
00:26:40,240 --> 00:26:44,750
you basically create another copy, 

444
00:26:46,350 --> 00:26:47,620
and you modify the copies, 

445
00:26:47,630 --> 00:26:49,740
you don't modify the original so original. 

446
00:26:49,750 --> 00:26:50,660
It's always there. 

447
00:26:52,570 --> 00:26:55,080
When you are done, you are pointing to the modified copy,

448
00:26:55,090 --> 00:26:57,280
and maybe you can garbage for like the original. 

449
00:27:00,180 --> 00:27:00,610
Okay? 

450
00:27:04,560 --> 00:27:05,270
This is what it is. 

451
00:27:05,280 --> 00:27:06,470
So the left hand side, 

452
00:27:06,480 --> 00:27:09,070
the careful ordering of recovery is used, by fact,

453
00:27:10,010 --> 00:27:11,880
and fast file system, the unix,

454
00:27:13,870 --> 00:27:17,610
this is file system check. 

455
00:27:17,620 --> 00:27:18,650
It's a command iran. 

456
00:27:18,660 --> 00:27:20,490
When you reboot the system, 

457
00:27:21,860 --> 00:27:24,610
this command runs to clean up the disk. 

458
00:27:24,620 --> 00:27:25,690
If there are problems, 

459
00:27:27,590 --> 00:27:28,640
inconsistent data. 

460
00:27:29,440 --> 00:27:29,870
Really, 

461
00:27:29,880 --> 00:27:33,350
you are carefully about the order in which are doing these operations, 

462
00:27:33,360 --> 00:27:33,790
right? 

463
00:27:34,190 --> 00:27:34,680
Like for instance, 

464
00:27:34,690 --> 00:27:37,560
you create a new file is you need to update the directory. 

465
00:27:38,210 --> 00:27:40,160
You need to update the 3 bit map, 

466
00:27:41,100 --> 00:27:43,970
the updates, I know to update the data book.

467
00:27:48,000 --> 00:27:49,590
So this is a careful ordering couple. 

468
00:27:51,900 --> 00:27:55,090
So at the high level is, again,

469
00:27:56,490 --> 00:27:57,700
problem I want to solve. 

470
00:27:58,570 --> 00:28:03,930
A failure shouldn't result in the data that this being inconsistent. 

471
00:28:07,760 --> 00:28:12,830
The solution you need to order carefully, 

472
00:28:13,780 --> 00:28:15,100
all the rise to the disk, 

473
00:28:16,540 --> 00:28:19,140
which are needed to store that. 

474
00:28:19,410 --> 00:28:27,610
But the piece of data such that when you are going to restart, 

475
00:28:27,620 --> 00:28:30,130
you have enough information. 

476
00:28:30,140 --> 00:28:35,250
So you can clean up the disk from any partial and wrong. 

477
00:28:39,150 --> 00:28:41,550
Information is also used at the application level, 

478
00:28:43,590 --> 00:28:45,970
say, editors like or emails.

479
00:28:49,290 --> 00:28:51,000
So let me ask you this question, 

480
00:28:51,270 --> 00:28:54,350
because this is the court to understand this technique. 

481
00:28:56,540 --> 00:29:03,360
I assume you need to store a piece of data and the directory entry point

482
00:29:03,370 --> 00:29:05,080
to the data or the pointer to the data, 

483
00:29:11,380 --> 00:29:13,730
and assume that each of this operation is atomic, 

484
00:29:13,740 --> 00:29:15,250
but there are two different rights, 

485
00:29:15,260 --> 00:29:18,410
one to update to put the data on the disk. 

486
00:29:18,420 --> 00:29:26,360
And the other one is to put to update the director. 

487
00:29:30,950 --> 00:29:32,900
Tell me now this a question is the following. 

488
00:29:34,260 --> 00:29:35,150
Which one you should write? 

489
00:29:35,160 --> 00:29:35,590
First? 

490
00:29:36,360 --> 00:29:37,490
The data of the point

491
00:29:48,230 --> 00:29:48,790
data, 

492
00:29:49,760 --> 00:29:50,990
why that's very good. 

493
00:29:51,770 --> 00:29:52,520
Why is the data? 

494
00:30:01,640 --> 00:30:02,360
It's exact. 

495
00:30:02,370 --> 00:30:03,840
You don't want the pointer. 

496
00:30:03,850 --> 00:30:06,190
The point is about the state. 

497
00:30:06,200 --> 00:30:07,950
I don't want dangling pointers. 

498
00:30:12,910 --> 00:30:13,400
Excellent. 

499
00:30:14,750 --> 00:30:15,110
Right? 

500
00:30:16,750 --> 00:30:20,110
And then say this is correct. 

501
00:30:20,800 --> 00:30:22,120
First, you write the data,

502
00:30:22,130 --> 00:30:23,360
and then you write the pointer. 

503
00:30:25,140 --> 00:30:26,540
Now say you have a failure. 

504
00:30:27,220 --> 00:30:29,630
You are successful to write the data, but not the pointer.

505
00:30:30,450 --> 00:30:31,100
What do you do? 

506
00:30:33,740 --> 00:30:35,150
When you restart the system? 

507
00:30:39,330 --> 00:30:40,850
Because now you have inconsistent state, 

508
00:30:48,340 --> 00:30:52,130
you need to garbage collection collect somehow. 

509
00:30:52,630 --> 00:30:55,620
Basically, you look at all the data on the disk,

510
00:30:56,600 --> 00:30:57,440
all the blocks. 

511
00:30:57,980 --> 00:31:01,020
And you see whether there is a pointer, 

512
00:31:01,030 --> 00:31:02,220
there is a directory entry, 

513
00:31:02,230 --> 00:31:03,420
in this case for them. 

514
00:31:04,860 --> 00:31:07,240
If it's not, you are garbage collecting it.

515
00:31:09,290 --> 00:31:16,690
This will appear like the right has failed in the first place didn't happen, 

516
00:31:18,790 --> 00:31:19,410
which is okay. 

517
00:31:27,730 --> 00:31:29,200
If we write beta, 

518
00:31:29,210 --> 00:31:30,840
but no pointer, 

519
00:31:33,170 --> 00:31:35,080
michael is asking if we write data, 

520
00:31:35,090 --> 00:31:38,560
but no pointer isn't that the same as writing mask at all? 

521
00:31:39,570 --> 00:31:40,240
It is. 

522
00:31:40,780 --> 00:31:45,560
But now that space may be used, 

523
00:31:45,570 --> 00:31:46,960
so you need to garbage collect. 

524
00:31:50,290 --> 00:31:52,640
Yeah, this assume that it's very good..

525
00:31:52,650 --> 00:31:55,760
It's assume that you also update the three maps. 

526
00:31:55,770 --> 00:31:58,800
That's why iiii make I simplify the example. 

527
00:31:59,830 --> 00:32:01,550
In general, you need to obey the three map.

528
00:32:01,560 --> 00:32:02,830
You need to obey the I node, like,

529
00:32:02,840 --> 00:32:06,080
what's your next? 

530
00:32:06,090 --> 00:32:06,290
Right? 

531
00:32:06,300 --> 00:32:09,920
But in this case, I assume that when you write a piece of data that block,

532
00:32:09,930 --> 00:32:11,280
it's our already allocated. 

533
00:32:12,060 --> 00:32:13,460
So therefore, you need to garbage fund.

534
00:32:17,100 --> 00:32:19,130
So now it's very easy for you to understand. 

535
00:32:20,430 --> 00:32:24,110
Here are the normal operations for berkeley, 

536
00:32:24,600 --> 00:32:26,590
for fast file system. 

537
00:32:26,960 --> 00:32:28,040
You allocate a data block, 

538
00:32:28,050 --> 00:32:29,120
you write a data block, 

539
00:32:29,130 --> 00:32:30,360
you allocate and I node, 

540
00:32:30,720 --> 00:32:33,420
your ici node, which is pointing to that data block.

541
00:32:33,930 --> 00:32:37,490
You update the big map of three blocks and I nodes, 

542
00:32:38,390 --> 00:32:40,690
and update the directory with a file name, 

543
00:32:41,320 --> 00:32:42,780
pointing to the I note number. 

544
00:32:44,420 --> 00:32:46,790
And then you update modified time for directory. 

545
00:32:46,800 --> 00:32:50,090
And what do you update the modified time for the director? 

546
00:32:50,650 --> 00:32:51,000
It's like, 

547
00:32:52,410 --> 00:32:52,750
right? 

548
00:32:53,120 --> 00:32:57,860
You start from the data and you go backwards all the way to the directory. 

549
00:32:59,870 --> 00:33:00,980
What do you do on recovery? 

550
00:33:00,990 --> 00:33:03,260
Like we discussed the scans, I know, table.

551
00:33:05,530 --> 00:33:07,460
And there is any only files, 

552
00:33:07,470 --> 00:33:08,940
not in any directory. 

553
00:33:09,420 --> 00:33:09,980
You delete it, 

554
00:33:11,650 --> 00:33:12,010
right? 

555
00:33:12,020 --> 00:33:15,360
Or maybe you put in lost and found directory. 

556
00:33:15,370 --> 00:33:16,000
If you have one, 

557
00:33:17,930 --> 00:33:24,540
then you compare the free block bit map against I naughty and to see

558
00:33:24,550 --> 00:33:25,820
whether they are consistent. 

559
00:33:28,330 --> 00:33:28,760
Right? 

560
00:33:29,090 --> 00:33:33,520
It's again, we just can't elect or they are missing from the big map.

561
00:33:34,130 --> 00:33:36,860
They are not reflected in the free map to garbage collector. 

562
00:33:41,610 --> 00:33:43,920
Then you scan directory for missing updated access. 

563
00:33:44,640 --> 00:33:46,430
Now, you do all of these things.

564
00:33:46,640 --> 00:33:50,330
Again, a it's a mode involving procedure,

565
00:33:50,340 --> 00:33:51,890
because you are here, 

566
00:33:51,900 --> 00:33:56,330
you have to write more pieces of data which are associated or linked

567
00:33:56,340 --> 00:33:59,070
with a data block when you write a data block. 

568
00:33:59,970 --> 00:34:00,770
But fundamentally, 

569
00:34:00,780 --> 00:34:06,270
the same idea like we discussed earlier on when you have only data block

570
00:34:06,280 --> 00:34:07,470
and a pointer to the data. 

571
00:34:09,020 --> 00:34:11,300
Obviously, the problem with this, and if you want to do it,

572
00:34:11,310 --> 00:34:13,740
is the time is proportional to the disk size, 

573
00:34:14,700 --> 00:34:16,310
because you need to look at all blocks. 

574
00:34:20,080 --> 00:34:20,760
Any questions? 

575
00:34:20,850 --> 00:34:23,230
This was the first solution. 

576
00:34:34,510 --> 00:34:36,670
How do you recover a failed recovery? 

577
00:34:37,760 --> 00:34:38,390
For the failure? 

578
00:34:38,400 --> 00:34:39,790
That's a great question. 

579
00:34:40,000 --> 00:34:41,070
For a failed recovery. 

580
00:34:41,080 --> 00:34:43,750
You make sure that when you are going to take the actions, 

581
00:34:44,400 --> 00:34:48,170
you are taking the same action that when you recover next, 

582
00:34:48,810 --> 00:34:52,130
you can still clear clean up everything. 

583
00:34:54,680 --> 00:34:55,150
Okay? 

584
00:34:56,600 --> 00:34:57,960
That's what it is. 

585
00:34:57,970 --> 00:35:00,930
You apply recursive with the same idea. 

586
00:35:07,700 --> 00:35:09,320
The second one is copy on the right. 

587
00:35:14,750 --> 00:35:16,770
This is also called cow. 

588
00:35:17,590 --> 00:35:23,520
And you fundamentally create a new version of the file. 

589
00:35:23,530 --> 00:35:25,200
This is a simple version. 

590
00:35:25,210 --> 00:35:31,260
The simple the simple implementation of this is that if i'm going to update

591
00:35:31,270 --> 00:35:32,100
a piece of beta, 

592
00:35:32,110 --> 00:35:34,060
if I want to update a piece of beta, 

593
00:35:34,390 --> 00:35:35,500
I don't update in place. 

594
00:35:35,510 --> 00:35:37,750
I create a copy, and I update the copy.

595
00:35:37,760 --> 00:35:39,500
And later I can believe the origin. 

596
00:35:45,690 --> 00:35:47,840
It seems expensive, 

597
00:35:47,850 --> 00:35:49,680
but the updates can be back. 

598
00:35:49,690 --> 00:35:50,880
If you have multiple updates, 

599
00:35:50,890 --> 00:35:52,000
you can do at the same time. 

600
00:35:57,130 --> 00:35:59,640
Which, so you remember,

601
00:35:59,650 --> 00:36:01,720
if you send a batch of rice to the beast, 

602
00:36:02,120 --> 00:36:03,290
the disk can be smart. 

603
00:36:03,300 --> 00:36:05,610
This controller can be smart to reorder them. 

604
00:36:05,890 --> 00:36:09,460
So to minimize the c latency and even the rotation latency, 

605
00:36:12,200 --> 00:36:13,430
this is a method. 

606
00:36:13,440 --> 00:36:15,310
This a is approach, 

607
00:36:15,770 --> 00:36:20,940
copy and write is taken by a few other systems. 

608
00:36:21,300 --> 00:36:22,840
Zfs is oracle. 

609
00:36:22,850 --> 00:36:23,360
Now, 

610
00:36:24,350 --> 00:36:30,370
There is also an open dfs and that appliance has its right anywhere file

611
00:36:30,380 --> 00:36:32,070
layout or waffle. 

612
00:36:32,600 --> 00:36:38,920
They use the same this technique. 

613
00:36:40,000 --> 00:36:47,270
And here how it is assume that you have the file is represented as a three

614
00:36:47,280 --> 00:36:47,950
of blocks. 

615
00:36:48,850 --> 00:36:49,300
Right? 

616
00:36:50,940 --> 00:36:52,650
You are just updating. 

617
00:36:55,140 --> 00:36:57,010
What is called here is a fringe block. 

618
00:36:57,020 --> 00:36:59,970
The block at the end, you started all you,

619
00:36:59,980 --> 00:37:06,110
and you are adding more blocks to this file structure. 

620
00:37:09,000 --> 00:37:14,230
Now, assume that you update these blocks on the right hand side,

621
00:37:14,910 --> 00:37:15,990
the one, which is,

622
00:37:16,320 --> 00:37:18,040
it's half blue. 

623
00:37:18,990 --> 00:37:19,350
Right? 

624
00:37:23,620 --> 00:37:25,090
What you do, actually,

625
00:37:25,100 --> 00:37:26,250
in this particular case, 

626
00:37:26,260 --> 00:37:29,410
you write in a new block, 

627
00:37:31,410 --> 00:37:31,990
a copy. 

628
00:37:32,390 --> 00:37:33,340
That's all you write. 

629
00:37:37,290 --> 00:37:38,380
You took this block, 

630
00:37:40,450 --> 00:37:41,460
you replicate it, 

631
00:37:42,210 --> 00:37:43,300
and your updates are bigger. 

632
00:37:44,920 --> 00:37:47,890
The regional block remains untouched. 

633
00:37:52,940 --> 00:38:00,260
So now what you do, you just basically generate a new bunch of pointers,

634
00:38:01,600 --> 00:38:02,520
a sub three. 

635
00:38:03,380 --> 00:38:11,360
And then you are going to connect these new notes in the new

636
00:38:11,370 --> 00:38:18,570
version of the tree to the corresponding existing tree

637
00:38:19,340 --> 00:38:19,820
notes. 

638
00:38:23,710 --> 00:38:24,100
Right? 

639
00:38:25,470 --> 00:38:26,040
Now, 

640
00:38:27,130 --> 00:38:31,500
if you are successful in updating all these pointers, 

641
00:38:33,010 --> 00:38:34,750
after you updated the data, 

642
00:38:36,740 --> 00:38:42,110
then the version of the tree and of the file moved from the old version

643
00:38:42,120 --> 00:38:42,790
to the new version. 

644
00:38:47,590 --> 00:38:49,380
Once you do that, you can do garbage,

645
00:38:49,390 --> 00:38:51,550
collect the rest. 

646
00:38:51,560 --> 00:38:53,670
You see all the blocks, 

647
00:38:53,680 --> 00:38:58,050
data blocks from the all version of the file, 

648
00:38:58,930 --> 00:39:03,990
as well as interior nodes in the tree, 

649
00:39:05,680 --> 00:39:09,590
again, which are not pointed by the new version.

650
00:39:11,220 --> 00:39:12,270
They've been garbage for that. 

651
00:39:14,520 --> 00:39:15,590
Any block, 

652
00:39:15,600 --> 00:39:16,950
any interior node, 

653
00:39:17,860 --> 00:39:21,360
to which there is no black arrow pointing. 

654
00:39:22,130 --> 00:39:23,500
This can be garbage collective. 

655
00:39:27,340 --> 00:39:28,540
And now you have a new version. 

656
00:39:32,860 --> 00:39:33,450
This, again,

657
00:39:33,460 --> 00:39:36,530
is like you are going to move from all version to the new version

658
00:39:36,540 --> 00:39:37,770
only in the last moment. 

659
00:39:38,250 --> 00:39:41,370
Once you update all the interior nouns of the tree, 

660
00:39:41,380 --> 00:39:46,330
and obviously the day you created the new, you update is a blog.

661
00:39:47,610 --> 00:39:48,470
After you copy it. 

662
00:39:51,960 --> 00:39:53,030
If you are not successful, 

663
00:39:53,040 --> 00:39:55,190
if you fail during this process, it's okay.

664
00:39:55,200 --> 00:39:56,190
You have the old version. 

665
00:39:56,200 --> 00:39:57,510
The old version is still consistent. 

666
00:39:59,300 --> 00:40:00,900
It only reflects a new update. 

667
00:40:01,840 --> 00:40:02,800
But again, that's okay.

668
00:40:02,810 --> 00:40:08,030
The main problem we try to solve here is to not leave the storage system

669
00:40:08,040 --> 00:40:08,730
in inconsistency. 

670
00:40:11,900 --> 00:40:12,750
Any questions? 

671
00:40:27,300 --> 00:40:32,290
Is this better or worse on ssd it seems like we are writing a lot more, 

672
00:40:33,510 --> 00:40:36,770
but don't have to erase as often. 

673
00:40:38,320 --> 00:40:41,240
Well, yeah, it's worse for us at this,

674
00:40:41,250 --> 00:40:44,040
because you are going to wear is this small. 

675
00:40:47,470 --> 00:40:49,530
And but again, 

676
00:40:49,540 --> 00:40:51,090
we have other solutions like we'll see. 

677
00:40:52,950 --> 00:40:54,360
But in general, this is worse.

678
00:40:57,250 --> 00:41:00,730
You still need to erase because you need to garbage for like, 

679
00:41:02,120 --> 00:41:03,810
garbage collection means you later. 

680
00:41:06,710 --> 00:41:07,580
But a great question. 

681
00:41:11,410 --> 00:41:12,050
This is, 

682
00:41:13,850 --> 00:41:14,900
like I mentioned to you, 

683
00:41:14,910 --> 00:41:18,100
the fs of the fs is variable size blocks. 

684
00:41:18,600 --> 00:41:19,910
It's a symmetric tree. 

685
00:41:20,120 --> 00:41:24,420
Basically, the tree you are building is symmetric of a certain depth.

686
00:41:24,430 --> 00:41:25,500
So basically, 

687
00:41:25,990 --> 00:41:32,190
it because you might be dislike how large or small is. 

688
00:41:33,020 --> 00:41:36,760
If the depths of the tree and what leave the need for you are at, 

689
00:41:37,360 --> 00:41:39,940
you can estimate that side of the triplet they are, correct.

690
00:41:40,710 --> 00:41:41,610
If it's balanced, right?

691
00:41:41,620 --> 00:41:42,370
If it is symmetric, 

692
00:41:43,520 --> 00:41:45,640
if it's not symmetric, then you cannot do that.

693
00:41:47,940 --> 00:41:50,650
You store the version number in the pointers. 

694
00:41:52,080 --> 00:41:54,430
The pointer to inspiration number belongs to, 

695
00:41:56,980 --> 00:41:58,090
like we saw before, 

696
00:41:58,100 --> 00:42:01,250
you can create a new version by adding new blocks and new pointers. 

697
00:42:06,140 --> 00:42:07,380
As a tree expand, 

698
00:42:07,390 --> 00:42:08,940
you are going to garbage for like, 

699
00:42:09,810 --> 00:42:13,660
the all day does all pointers to make room for the new date. 

700
00:42:22,170 --> 00:42:24,280
In this case, is you try to batch everything,

701
00:42:24,290 --> 00:42:26,790
you try to batch the rights, 

702
00:42:26,800 --> 00:42:36,040
you try to batch the updates to the free space and so forth. 

703
00:42:44,590 --> 00:42:49,230
Now, let's talk about more a general solutions,

704
00:42:50,580 --> 00:42:53,930
one solution, which are going to talk also next time.

705
00:42:53,940 --> 00:42:55,290
Now it's just briefly, 

706
00:42:55,980 --> 00:42:56,940
is transaction. 

707
00:42:58,470 --> 00:42:59,580
Fundamentally, 

708
00:43:00,910 --> 00:43:02,540
what do you want here is remember, 

709
00:43:03,730 --> 00:43:07,970
we want to avoid to have to remain in an inconsistent state

710
00:43:09,070 --> 00:43:10,880
and the remaining an inconsistent state, 

711
00:43:11,940 --> 00:43:14,270
because they have multiple related updates. 

712
00:43:15,360 --> 00:43:17,590
If only part of the updates happen, 

713
00:43:18,090 --> 00:43:19,450
then you have in western state. 

714
00:43:21,120 --> 00:43:23,090
So we had this problem before. 

715
00:43:23,980 --> 00:43:25,080
If you remember, 

716
00:43:25,640 --> 00:43:27,990
and we talk about critical section, 

717
00:43:28,000 --> 00:43:30,070
we talk about that when I talk about atoms. 

718
00:43:31,320 --> 00:43:31,720
Right? 

719
00:43:31,990 --> 00:43:33,140
With atomic operation, 

720
00:43:33,150 --> 00:43:35,900
we want all of the operation to happen or none of sort. 

721
00:43:37,070 --> 00:43:40,350
The same idea is this transaction for the storage system. 

722
00:43:40,360 --> 00:43:43,160
This is called in some transactions. 

723
00:43:43,990 --> 00:43:47,500
There are more than atomic operation because they also required durability

724
00:43:48,840 --> 00:43:50,410
and other properties. 

725
00:43:50,780 --> 00:43:55,930
But the idea is the same a transaction contained multiple operations, 

726
00:43:57,480 --> 00:43:59,110
and the semantics should be, 

727
00:44:00,260 --> 00:44:05,970
these are all the operation in a transaction are going to happen to be successful, 

728
00:44:06,800 --> 00:44:08,670
or none of them will happen. 

729
00:44:15,470 --> 00:44:18,300
If you're a failure in the middle of the transaction, 

730
00:44:18,760 --> 00:44:24,500
then it looks like none of the updates is the transaction ever happened. 

731
00:44:24,920 --> 00:44:26,200
The entire transaction failed. 

732
00:44:27,430 --> 00:44:27,920
Okay? 

733
00:44:30,560 --> 00:44:34,530
We discuss about this and it's again, 

734
00:44:34,540 --> 00:44:38,970
closely related to its critical section and with the concept

735
00:44:38,980 --> 00:44:40,610
of atomic update for member. 

736
00:44:47,930 --> 00:44:49,130
In some sense, 

737
00:44:51,860 --> 00:44:55,010
the file for fast file system, 

738
00:44:55,560 --> 00:45:01,700
the witch approach to carefully ordering the sequence of updates, 

739
00:45:02,260 --> 00:45:07,850
and then recover from inconsistent state. 

740
00:45:08,740 --> 00:45:16,840
When you restart a it's a primitive form of implementing this idea. 

741
00:45:25,340 --> 00:45:31,640
Again, we discussed that just to draw home the.,

742
00:45:31,650 --> 00:45:35,620
a transaction is a bunch of operations, 

743
00:45:36,460 --> 00:45:40,260
which state a system from a consistent state to another consistent state. 

744
00:45:43,250 --> 00:45:44,450
And therefore, 

745
00:45:45,830 --> 00:45:48,700
we want all the operation in the transaction to happen, 

746
00:45:48,710 --> 00:45:49,700
or none of them to happen. 

747
00:45:50,740 --> 00:45:51,960
If none of them will happen, 

748
00:45:51,970 --> 00:45:54,710
you remain in the previous state, which is consistent, by definition,

749
00:45:54,720 --> 00:45:55,710
if all will happen, 

750
00:45:56,760 --> 00:45:58,390
you are going to move to a new state, 

751
00:45:59,500 --> 00:46:00,780
which is, again, will be consistent.

752
00:46:06,400 --> 00:46:07,120
So in one way, 

753
00:46:07,130 --> 00:46:11,860
transaction extends the concept of atomic updates

754
00:46:12,150 --> 00:46:14,610
to multiple data structures for a

755
00:46:14,620 --> 00:46:17,610
memory to persistent storage. 

756
00:46:21,390 --> 00:46:23,940
What is the typical structure of the transaction? 

757
00:46:24,350 --> 00:46:26,030
You have a begin transaction, 

758
00:46:26,040 --> 00:46:27,070
you have a for me, 

759
00:46:27,080 --> 00:46:29,310
transaction or end of the transaction. 

760
00:46:29,780 --> 00:46:31,900
And then you do a bunch of operations. 

761
00:46:33,060 --> 00:46:35,380
If you fail during these operations, 

762
00:46:35,820 --> 00:46:40,920
you are going to roll back to undo the effect of the operation have succeeded. 

763
00:46:43,780 --> 00:46:47,500
So this way, you are guaranteed that if you fail during a transaction,

764
00:46:47,840 --> 00:46:49,490
then all the operation will be undued. 

765
00:46:50,360 --> 00:46:51,910
From an external observer. 

766
00:46:51,920 --> 00:46:53,860
It appears that the transaction, 

767
00:46:53,870 --> 00:46:55,810
nothing from the transaction happened. 

768
00:47:00,020 --> 00:47:00,480
Okay? 

769
00:47:01,860 --> 00:47:07,970
These are examples in which are going to transfer $100 from alice account

770
00:47:08,300 --> 00:47:11,490
to bob accounts. 

771
00:47:13,250 --> 00:47:17,810
There are a bunch of operations here to update the account of alice and bob

772
00:47:17,820 --> 00:47:19,370
went to account the branch, 

773
00:47:19,380 --> 00:47:20,370
how many money, 

774
00:47:20,380 --> 00:47:22,170
how much monies are in the branch? 

775
00:47:22,540 --> 00:47:25,980
Assuming that alice and bob are in different, 

776
00:47:25,990 --> 00:47:28,940
their accounts are in different branches of the same bank. 

777
00:47:30,380 --> 00:47:31,930
There are four operations. 

778
00:47:32,550 --> 00:47:37,060
All of them should happen in a transaction to be able. 

779
00:47:41,760 --> 00:47:42,870
This is what you do. 

780
00:47:42,880 --> 00:47:47,590
You have these operations here is on the exercises at that time. 

781
00:47:48,750 --> 00:47:49,980
This is how it appears. 

782
00:47:49,990 --> 00:47:54,420
And then there are these operations that can be interleaved this operation

783
00:47:54,430 --> 00:47:55,740
from other transactions. 

784
00:47:55,750 --> 00:47:57,220
So there are transaction, actually,

785
00:47:57,230 --> 00:47:59,100
like we are going to see next time, 

786
00:47:59,470 --> 00:48:00,530
can overlap. 

787
00:48:01,520 --> 00:48:04,340
And then you have starter transaction and commit

788
00:48:12,000 --> 00:48:12,440
transaction. 

789
00:48:14,850 --> 00:48:15,650
Any questions? 

790
00:48:23,890 --> 00:48:27,860
Let's see how transactions are used for file systems. 

791
00:48:28,710 --> 00:48:31,390
You can see a little bit about how they could be used. 

792
00:48:35,450 --> 00:48:38,650
Basically, the chain changes are treated as transactions.

793
00:48:39,550 --> 00:48:41,720
And there are 2 kinds of file systems here, 

794
00:48:41,730 --> 00:48:42,920
2 types of file system, 

795
00:48:44,170 --> 00:48:45,890
log structure and journal. 

796
00:48:47,810 --> 00:48:49,510
In a log structure, 

797
00:48:49,520 --> 00:48:51,150
the data stays in the log. 

798
00:48:52,760 --> 00:48:55,440
And locks are updated using transactions. 

799
00:48:57,310 --> 00:48:59,110
In a journal file system. 

800
00:49:00,190 --> 00:49:02,200
Log is used only for recovery. 

801
00:49:03,730 --> 00:49:08,710
The data is still in the traditional data format on the disk. 

802
00:49:12,300 --> 00:49:16,760
We are going to look to journal file system in the next couple of slides. 

803
00:49:21,260 --> 00:49:22,490
It's the same idea. 

804
00:49:22,500 --> 00:49:27,090
A little bit always like is that you don't modify data structure on the disk, 

805
00:49:27,100 --> 00:49:28,700
direct this idea, 

806
00:49:30,120 --> 00:49:32,680
you will put them on the changes on the log. 

807
00:49:34,840 --> 00:49:36,820
And only after you are done, 

808
00:49:37,600 --> 00:49:40,660
we saw to speak, the transaction is all the changes.

809
00:49:41,070 --> 00:49:42,800
You push the changes to the risk. 

810
00:49:44,260 --> 00:49:47,610
It turns out that as long as long as along is persistent, 

811
00:49:48,660 --> 00:49:50,220
even if you have failures, 

812
00:49:50,950 --> 00:49:52,170
you can always recover. 

813
00:49:53,070 --> 00:49:54,660
We'll see how to say that on the show of amygdav. 

814
00:49:56,550 --> 00:49:57,020
Okay. 

815
00:50:01,190 --> 00:50:02,740
This is exactly what I said. 

816
00:50:03,360 --> 00:50:04,050
You're right. 

817
00:50:04,250 --> 00:50:06,740
The updates of the as a transaction, 

818
00:50:06,750 --> 00:50:09,530
the related updates as a transaction in the law. 

819
00:50:11,380 --> 00:50:13,480
Once the transaction is committed in the log, 

820
00:50:14,130 --> 00:50:19,330
you can now start applying those operation in the transaction on the storage. 

821
00:50:21,890 --> 00:50:24,700
If you, if you fail in between, it's okay,

822
00:50:24,710 --> 00:50:26,250
because when you come back, 

823
00:50:26,260 --> 00:50:31,610
you have enough information to continue to update the disk. 

824
00:50:33,120 --> 00:50:34,060
The data on the disk. 

825
00:50:37,820 --> 00:50:39,580
Once along all the operate, 

826
00:50:39,590 --> 00:50:46,270
all the updates in a transaction are successfully applied to the disk. 

827
00:50:46,980 --> 00:50:48,180
You are going to remove the log. 

828
00:50:51,100 --> 00:50:56,390
So this is linux use journal file system, 

829
00:50:56,970 --> 00:51:01,450
and basically took of ffs like file system and apply jam. 

830
00:51:05,510 --> 00:51:06,900
There are many systems. 

831
00:51:06,910 --> 00:51:08,340
There is a journaling file system. 

832
00:51:11,450 --> 00:51:11,810
Okay. 

833
00:51:11,820 --> 00:51:19,110
So let's it before to see to get a sense about how journaling is working. 

834
00:51:19,390 --> 00:51:20,740
Let's look, again,

835
00:51:20,930 --> 00:51:27,870
what are the typical updates you need to do when you are going to write

836
00:51:27,880 --> 00:51:28,950
data on the disk. 

837
00:51:31,320 --> 00:51:33,130
For now, there is no journal.

838
00:51:35,140 --> 00:51:37,740
So you need to do what you need to find a free block. 

839
00:51:37,970 --> 00:51:40,130
The yellow block, there is a free block.

840
00:51:40,140 --> 00:51:40,420
Good. 

841
00:51:41,320 --> 00:51:43,090
You need to find a free entry. 

842
00:51:43,100 --> 00:51:43,970
I know the entry. 

843
00:51:46,400 --> 00:51:49,460
You need to find where you are going to insert. 

844
00:51:50,120 --> 00:51:57,770
And the in the file directory where you are going to insert the entry, 

845
00:51:57,780 --> 00:52:01,080
which associate the file with the I node, 

846
00:52:01,660 --> 00:52:02,580
file language, I know.

847
00:52:04,590 --> 00:52:06,060
And then once you're update, 

848
00:52:06,510 --> 00:52:11,030
you find all these free available spaces. 

849
00:52:11,740 --> 00:52:12,540
You start to write, 

850
00:52:13,690 --> 00:52:19,240
you write the in the free map space. 

851
00:52:19,250 --> 00:52:25,170
You say you mark that you allocate the data, you're right.

852
00:52:25,180 --> 00:52:30,740
And I note entry to point is a block you're out and derive

853
00:52:30,750 --> 00:52:33,620
that the director directory entry to point to the item. 

854
00:52:34,010 --> 00:52:34,650
This article. 

855
00:52:35,260 --> 00:52:35,580
Right? 

856
00:52:37,180 --> 00:52:39,830
And remember, if something happens, wrong happens,

857
00:52:40,410 --> 00:52:43,370
it can leave the disk in the inconsistent state. 

858
00:52:45,890 --> 00:52:48,680
Now, let's see how we address this problem in journal.

859
00:52:50,720 --> 00:52:51,840
A german is locked. 

860
00:52:51,850 --> 00:52:53,040
So instead or when, 

861
00:52:53,050 --> 00:52:55,000
instead of writing directly to the disk, 

862
00:52:55,830 --> 00:52:57,470
you start you write to the lock. 

863
00:52:59,530 --> 00:53:00,610
It's not volatile. 

864
00:53:00,620 --> 00:53:02,130
It's on flash or on the disk. 

865
00:53:04,610 --> 00:53:11,410
What do you find the free data block? 

866
00:53:14,670 --> 00:53:16,910
Again, like these are the operations, right?

867
00:53:17,680 --> 00:53:20,280
Find free data block, find 39 or 90,

868
00:53:20,630 --> 00:53:27,970
find a directory and insertion pointing directory for adding the directory

869
00:53:27,980 --> 00:53:31,780
entry to map the file name to the island. 

870
00:53:33,640 --> 00:53:34,390
It's what you do. 

871
00:53:35,010 --> 00:53:36,170
You start the transaction, 

872
00:53:38,360 --> 00:53:39,680
and you write this operation. 

873
00:53:41,760 --> 00:53:42,270
Now, 

874
00:53:42,820 --> 00:53:46,730
you don't write directly to update the free space map. 

875
00:53:47,870 --> 00:53:49,670
You put the operation to the updates, 

876
00:53:49,680 --> 00:53:51,230
a free space map in the law. 

877
00:53:54,780 --> 00:54:01,470
You don't write the you don't update the iron ore table to point

878
00:54:01,480 --> 00:54:02,630
to the new block. 

879
00:54:03,540 --> 00:54:07,130
You write that operation in the lock, 

880
00:54:08,610 --> 00:54:09,080
the same. 

881
00:54:09,770 --> 00:54:12,180
The operation to update the directory entry, 

882
00:54:12,190 --> 00:54:14,720
you are going to write in the log. 

883
00:54:15,860 --> 00:54:17,130
Now, you're committed.

884
00:54:20,390 --> 00:54:21,720
So all updates, 

885
00:54:24,320 --> 00:54:29,320
all operation to update information on the disks are in the lock. 

886
00:54:30,090 --> 00:54:33,890
Nothing happened so far on the disk. 

887
00:54:39,790 --> 00:54:42,310
And then once you are done, 

888
00:54:42,630 --> 00:54:45,470
you are going to go through all the operations, the logs.

889
00:54:45,910 --> 00:54:48,870
And you are going to update now, 

890
00:54:49,110 --> 00:54:51,180
the data or the information on the disk. 

891
00:54:54,210 --> 00:54:55,910
So you copy all the changes, 

892
00:54:56,800 --> 00:54:59,820
you advance a tale of the log. 

893
00:55:00,840 --> 00:55:01,410
And now, 

894
00:55:02,110 --> 00:55:08,820
when the tail goes over the commit or executed, all you,

895
00:55:08,830 --> 00:55:11,220
after you execute all the operations, 

896
00:55:11,230 --> 00:55:15,560
apply all the operation from the log on the file system. 

897
00:55:16,260 --> 00:55:17,370
You can discard that log, 

898
00:55:20,160 --> 00:55:21,190
that transaction in the log. 

899
00:55:34,680 --> 00:55:44,400
Let's say that I was only successful to write to the logs, 

900
00:55:46,930 --> 00:55:54,240
only this

901
00:55:55,840 --> 00:56:01,380
do the operation to get to the free space, 

902
00:56:02,880 --> 00:56:04,110
to modify the bit map, 

903
00:56:04,120 --> 00:56:05,440
to the space bit map, 

904
00:56:06,180 --> 00:56:10,300
and the pointer to the item. 

905
00:56:13,360 --> 00:56:14,370
In this case, 

906
00:56:14,880 --> 00:56:16,110
if I am coming back, 

907
00:56:17,480 --> 00:56:20,830
and I assume that after these operations are written in the law, 

908
00:56:21,850 --> 00:56:25,580
but before the transaction ended, I have a failure.

909
00:56:29,000 --> 00:56:30,470
At this point, in this case,

910
00:56:31,500 --> 00:56:32,610
if I come back, 

911
00:56:36,410 --> 00:56:41,600
like the only thing I need to do is to remove this operation to remove

912
00:56:41,610 --> 00:56:42,520
from the lock, 

913
00:56:43,010 --> 00:56:47,910
because it spines point still nothing has been applied on the disk. 

914
00:56:49,280 --> 00:56:50,880
You apply the changes on the disk, 

915
00:56:51,270 --> 00:56:56,420
only after the transaction is succeeded on the lock. 

916
00:56:57,990 --> 00:57:01,560
After the committee, 

917
00:57:01,570 --> 00:57:02,760
there are two questions here. 

918
00:57:06,160 --> 00:57:09,030
Can you have a fail when while writing the log? 

919
00:57:10,380 --> 00:57:11,020
Absolutely. 

920
00:57:11,780 --> 00:57:14,620
But then everything will be clean up. 

921
00:57:15,590 --> 00:57:18,400
Like, in this case, you can fail while you're writing on the log.

922
00:57:19,380 --> 00:57:20,410
When you come back, 

923
00:57:20,420 --> 00:57:22,410
you look at the incompetent transaction, 

924
00:57:22,960 --> 00:57:24,000
you clean them up, 

925
00:57:25,340 --> 00:57:29,180
Because that nothing from the transaction which has not finished for me, 

926
00:57:29,190 --> 00:57:29,460
did, 

927
00:57:30,080 --> 00:57:32,600
has been all applied to the disk. 

928
00:57:37,550 --> 00:57:39,790
What's a big difference between writing directly? 

929
00:57:39,800 --> 00:57:41,350
The big difference from writing, 

930
00:57:41,360 --> 00:57:45,660
between writing directly and writing is along is very simple, 

931
00:57:46,860 --> 00:57:47,260
right? 

932
00:57:47,760 --> 00:57:50,480
Is basically because I have a log and I have done, 

933
00:57:51,050 --> 00:58:00,680
then I can easy reconstruct the state to make it consistent in the file system. 

934
00:58:01,720 --> 00:58:03,040
Otherwise is more difficult. 

935
00:58:03,050 --> 00:58:03,760
Remember, 

936
00:58:04,260 --> 00:58:08,930
like with a files check for the fast file system, 

937
00:58:10,090 --> 00:58:13,720
in order to make the state consistent, 

938
00:58:14,270 --> 00:58:18,310
you need to go and to sequential look over the entire distance

939
00:58:18,320 --> 00:58:19,390
is extremely slow. 

940
00:58:31,300 --> 00:58:32,540
It's again here. 

941
00:58:32,930 --> 00:58:33,700
In the log, 

942
00:58:33,710 --> 00:58:39,680
we assume that we know that we know that arrive has been completed. 

943
00:58:39,970 --> 00:58:43,670
Assume that we know that the disk eventually will tell you. 

944
00:58:45,920 --> 00:58:47,200
If the disk doesn't tell you, 

945
00:58:47,210 --> 00:58:48,920
then you assume that it doesn't. 

946
00:59:00,490 --> 00:59:00,850
Yeah. 

947
00:59:00,860 --> 00:59:05,370
So the question here is that basically see how to ensure the sequentially? 

948
00:59:06,180 --> 00:59:06,640
Well, 

949
00:59:07,150 --> 00:59:10,990
you make sure that a controller for the log is not going to reorder the rights. 

950
00:59:13,180 --> 00:59:14,620
Faces an excellent question. 

951
00:59:14,920 --> 00:59:16,760
That is a very good question. 

952
00:59:19,170 --> 00:59:20,800
So resources how this happened, 

953
00:59:20,810 --> 00:59:22,570
if you and now, 

954
00:59:23,790 --> 00:59:29,070
we saw that what happened if you just a log was partially written. 

955
00:59:30,020 --> 00:59:34,440
When you come back, you just remove the entries from the partial logs.

956
00:59:35,380 --> 00:59:35,850
You are done. 

957
00:59:37,530 --> 00:59:45,380
But now let's assume that let's see what

958
00:59:45,390 --> 00:59:47,700
happens like what now we are. 

959
00:59:50,070 --> 00:59:52,430
We committed the log the transaction. 

960
00:59:53,450 --> 00:59:55,520
Now we need to apply all the operation. 

961
00:59:56,840 --> 00:59:58,950
In the log, we need to apply them to the risk.

962
01:00:03,260 --> 01:00:06,420
What do you start from? 

963
01:00:06,810 --> 01:00:08,080
That matching commit? 

964
01:00:14,440 --> 01:00:19,810
And then what you are going to do here, 

965
01:00:20,290 --> 01:00:25,160
it basically is against every of this operation is either important, 

966
01:00:26,080 --> 01:00:28,590
meaning that if you apply it multiple times, 

967
01:00:29,600 --> 01:00:31,230
you are going to get the same result, 

968
01:00:31,240 --> 01:00:33,350
because it just right, one, right?

969
01:00:33,360 --> 01:00:36,070
Is particularly identical that if you write the same value

970
01:00:36,500 --> 01:00:38,300
at the same location over and over again, 

971
01:00:38,310 --> 01:00:40,640
you are still going to get the same value. 

972
01:00:40,930 --> 01:00:42,780
No matter how many times throughout, 

973
01:00:46,010 --> 01:00:47,080
here is what happens, 

974
01:00:47,090 --> 01:00:49,010
here is about, again,

975
01:00:49,620 --> 01:00:54,030
if you are going to successfully apply all the operations to the disk, 

976
01:00:54,040 --> 01:00:54,960
you are done. 

977
01:00:55,530 --> 01:00:57,180
You can garbage for it like you've seen. 

978
01:00:58,020 --> 01:01:02,170
But now assume that you have a failure in the middle or you're applying

979
01:01:02,180 --> 01:01:04,690
the operation from the law to that is. 

980
01:01:06,790 --> 01:01:07,490
So what do you do? 

981
01:01:09,010 --> 01:01:09,560
Simple. 

982
01:01:10,370 --> 01:01:11,210
When you come back? 

983
01:01:11,930 --> 01:01:12,210
Again, 

984
01:01:12,220 --> 01:01:14,650
you go from the beginning and you applies all the operations

985
01:01:14,780 --> 01:01:16,490
because the operation are right important. 

986
01:01:16,500 --> 01:01:20,830
It doesn't matter how many times supplies eventually are going to finish. 

987
01:01:22,000 --> 01:01:22,370
Right? 

988
01:01:23,050 --> 01:01:26,550
And then you are going to garbage for like the transaction. 

989
01:01:37,660 --> 01:01:38,290
The question, 

990
01:01:38,300 --> 01:01:42,250
how does discard the log work again when the machine started writing

991
01:01:42,260 --> 01:01:44,910
the log disk that it's already updated? 

992
01:01:45,470 --> 01:01:46,170
Partially? 

993
01:01:46,770 --> 01:01:49,480
How do we undo the only part that is not permitted? 

994
01:01:50,050 --> 01:01:52,310
So maybe I was not, it's a great question.

995
01:01:52,320 --> 01:01:53,460
And we are not clear. 

996
01:01:54,400 --> 01:02:01,750
There is nothing you are going to update on the disk unless the transaction

997
01:02:03,150 --> 01:02:04,640
is being committed. 

998
01:02:06,600 --> 01:02:06,940
Nothing. 

999
01:02:08,680 --> 01:02:10,060
You see this operation? 

1000
01:02:10,500 --> 01:02:11,800
Let me just very clear. 

1001
01:02:13,120 --> 01:02:21,840
What's these green things? 

1002
01:02:24,140 --> 01:02:25,120
They are not modified. 

1003
01:02:25,130 --> 01:02:27,200
I just found this entries. 

1004
01:02:29,030 --> 01:02:29,480
Right? 

1005
01:02:30,490 --> 01:02:32,090
Nothing has been modified on the disk. 

1006
01:02:33,170 --> 01:02:34,750
You start only modifying, 

1007
01:02:35,440 --> 01:02:38,110
once you wrote, the transaction has permitted,

1008
01:02:38,120 --> 01:02:40,150
now you can start to go back. 

1009
01:02:41,000 --> 01:02:45,430
You apply all the changes in the transaction on the disk. 

1010
01:02:46,300 --> 01:02:48,620
Only now you update the data on the disk. 

1011
01:02:50,140 --> 01:02:50,740
Not before. 

1012
01:02:54,400 --> 01:02:55,460
Did answer your question? 

1013
01:02:55,470 --> 01:03:01,980
I owe you answer. 

1014
01:03:10,430 --> 01:03:11,340
Another question, 

1015
01:03:11,350 --> 01:03:14,660
can we even tell which portion of a committee log is finished? 

1016
01:03:15,650 --> 01:03:16,270
It's again, 

1017
01:03:17,180 --> 01:03:19,970
if you don't need to know, right?

1018
01:03:20,500 --> 01:03:22,650
If you don't know to know it is finished, 

1019
01:03:23,490 --> 01:03:27,480
because you are going to repeat from the beginning every time. 

1020
01:03:29,530 --> 01:03:30,520
When you go back, 

1021
01:03:31,310 --> 01:03:32,320
when you restart, 

1022
01:03:33,240 --> 01:03:36,290
you are going to redo all the operation from the lock. 

1023
01:03:38,730 --> 01:03:41,130
It doesn't matter whether I already done. 

1024
01:03:41,660 --> 01:03:42,460
Previously. 

1025
01:03:42,850 --> 01:03:43,770
I've done a few. 

1026
01:03:45,010 --> 01:03:46,950
So I have three operation in the blog, 

1027
01:03:47,440 --> 01:03:50,160
in the log to apply 1 to 3, 

1028
01:03:50,170 --> 01:03:52,790
I applied its operation one, and two.

1029
01:03:53,280 --> 01:03:54,130
Then I failed. 

1030
01:03:55,860 --> 01:03:59,100
When I come back, i'm starting again with 12, and 3.

1031
01:03:59,110 --> 01:04:03,220
And then hopefully I am successful to apply three, and then i'm done.

1032
01:04:05,140 --> 01:04:07,130
I can apply one and two again, 

1033
01:04:07,440 --> 01:04:08,930
because one and two are rights. 

1034
01:04:09,950 --> 01:04:10,780
They are immutable. 

1035
01:04:10,790 --> 01:04:11,900
They are going to write to, 

1036
01:04:11,910 --> 01:04:13,300
i'm going to write the same value. 

1037
01:04:14,760 --> 01:04:24,480
It's okay. 

1038
01:04:32,950 --> 01:04:34,650
Why go through all this trouble? 

1039
01:04:37,060 --> 01:04:44,260
Because it makes it easy to reason and be quite efficient to make

1040
01:04:44,270 --> 01:04:47,020
sure that the state on the disk is persistent. 

1041
01:04:47,030 --> 01:04:49,820
It's consistent in the presence of failure. 

1042
01:04:51,040 --> 01:04:52,160
Isn't it expensive? 

1043
01:04:54,560 --> 01:04:56,470
From one perspective, it's expensive,

1044
01:04:57,840 --> 01:05:00,410
because you are going to write twice, 

1045
01:05:01,430 --> 01:05:03,070
you may write the data, 

1046
01:05:03,520 --> 01:05:06,190
you are going to write on the blog on the log. 

1047
01:05:07,180 --> 01:05:10,290
And then you are going to write data on the list. 

1048
01:05:12,440 --> 01:05:13,190
However, 

1049
01:05:15,610 --> 01:05:18,480
the modern file system is for about this to mention, 

1050
01:05:21,030 --> 01:05:26,970
they have different optimization to do it. 

1051
01:05:28,650 --> 01:05:30,870
So you can have different optimization. 

1052
01:05:32,350 --> 01:05:33,500
Like, for instance, eventually,

1053
01:05:33,510 --> 01:05:35,100
the data you can write it directly. 

1054
01:05:35,740 --> 01:05:37,000
And if you fail, 

1055
01:05:37,390 --> 01:05:39,630
then you eventually recovered at the light of time. 

1056
01:05:41,900 --> 01:05:43,420
But there is one, actually,

1057
01:05:43,430 --> 01:05:44,920
I want to ask you, 

1058
01:05:44,930 --> 01:05:51,390
can you see one reason actually journaling file systems generally can be

1059
01:05:51,400 --> 01:05:52,430
good for performance. 

1060
01:06:02,160 --> 01:06:05,230
If I tell you that journaling can also help with the performance, 

1061
01:06:08,620 --> 01:06:11,780
why do you think that would be the case? 

1062
01:06:27,100 --> 01:06:27,840
How is the log

1063
01:06:43,640 --> 01:06:44,590
organized sequentially? 

1064
01:06:45,080 --> 01:06:45,550
Correct? 

1065
01:06:47,190 --> 01:06:50,820
We know the sequential rise are fast, 

1066
01:06:50,830 --> 01:06:52,740
so all the rise in the longer sequential, 

1067
01:06:52,750 --> 01:06:53,940
so they are very fast. 

1068
01:06:55,580 --> 01:06:56,300
And then later, 

1069
01:06:56,310 --> 01:07:03,110
you can actually batch the updates from the logs to the disk. 

1070
01:07:04,290 --> 01:07:06,740
So you can do them as efficient as you can. 

1071
01:07:09,990 --> 01:07:10,800
That's the reason. 

1072
01:07:15,110 --> 01:07:17,420
So it's not all bad when it comes to performance. 

1073
01:07:18,330 --> 01:07:19,700
Announcements projects three, 

1074
01:07:19,710 --> 01:07:21,540
design reviews this week. 

1075
01:07:23,890 --> 01:07:25,730
This is the last round of the dining bills. 

1076
01:07:25,740 --> 01:07:27,530
We are close to the end of the class. 

1077
01:07:29,520 --> 01:07:31,660
Hormone five is due monday, 

1078
01:07:32,380 --> 01:07:33,180
next monday. 

1079
01:07:34,310 --> 01:07:40,100
And we have

1080
01:07:44,340 --> 01:07:46,220
mid term grades were released. 

1081
01:07:47,840 --> 01:07:50,640
I think you did congratulations, you did very well.

1082
01:07:51,670 --> 01:07:53,960
The first exams, 

1083
01:07:53,970 --> 01:07:58,820
aminos around%50%. 

1084
01:07:58,830 --> 01:08:00,940
Now it's almost 60%. 

1085
01:08:02,050 --> 01:08:02,890
So great job. 

1086
01:08:06,990 --> 01:08:10,610
Now we have another a little bit more than 12 minutes, 

1087
01:08:12,310 --> 01:08:15,730
and we are going to swiss gears. 

1088
01:08:17,140 --> 01:08:20,580
So we are done with file system reliability, and it's file system.

1089
01:08:20,590 --> 01:08:21,260
In general. 

1090
01:08:22,320 --> 01:08:24,790
We are going to start talking about distributing systems. 

1091
01:08:28,070 --> 01:08:29,910
So we are talking about distributed systems, 

1092
01:08:31,660 --> 01:08:32,770
because they are everywhere, 

1093
01:08:34,140 --> 01:08:38,330
because we need to scale all these workloads. 

1094
01:08:40,430 --> 01:08:43,900
And they require a lot of machines, 

1095
01:08:43,910 --> 01:08:45,060
lot of resources, 

1096
01:08:46,750 --> 01:08:48,070
which many separate systems. 

1097
01:08:49,760 --> 01:08:55,160
Because any application today are using almost it has a backend, 

1098
01:08:56,920 --> 01:09:01,580
which is some somewhere in the cloud connecting europe, 

1099
01:09:01,910 --> 01:09:03,380
the front end of your application. 

1100
01:09:03,390 --> 01:09:07,350
You can answer your device with a back end is another disability system. 

1101
01:09:11,230 --> 01:09:12,770
So you have everybody in your car. 

1102
01:09:13,670 --> 01:09:19,280
There are5,100 microprocessors that are connected by a bus. 

1103
01:09:20,150 --> 01:09:21,390
That's also a distribution system. 

1104
01:09:25,450 --> 01:09:27,890
There are 2 kind of disability systems. 

1105
01:09:28,670 --> 01:09:29,740
One is centralized. 

1106
01:09:31,170 --> 01:09:35,250
And if you have a coordinator, a server,

1107
01:09:35,530 --> 01:09:35,970
for instance, 

1108
01:09:35,980 --> 01:09:42,570
all the machines are connected to one particular server is follows. 

1109
01:09:42,580 --> 01:09:44,770
A plan set up a model is on the left hand side, 

1110
01:09:44,780 --> 01:09:47,610
the right hand side is peer to peer model. 

1111
01:09:48,920 --> 01:09:50,470
The peer model is more. 

1112
01:09:50,480 --> 01:09:53,510
Everyone can every other now can communicate with every other. 

1113
01:09:53,520 --> 01:09:53,630
Now, 

1114
01:09:54,760 --> 01:09:59,010
the communication in moscow is less structured, 

1115
01:09:59,670 --> 01:10:00,430
is more general. 

1116
01:10:01,050 --> 01:10:03,900
The kind of client server is also implemented by some

1117
01:10:03,910 --> 01:10:07,570
of the distributed systems for framework, 

1118
01:10:07,580 --> 01:10:10,410
like hard look spark. 

1119
01:10:14,090 --> 01:10:14,920
This is, 

1120
01:10:21,940 --> 01:10:23,640
and like I mentioned, 

1121
01:10:23,650 --> 01:10:28,990
disability systems can be on the same car in the same you can have. 

1122
01:10:29,000 --> 01:10:37,720
And the context can be widely different. 

1123
01:10:38,350 --> 01:10:41,430
You can have a distributed system in your car, 

1124
01:10:41,950 --> 01:10:42,960
in a room, 

1125
01:10:43,730 --> 01:10:44,720
in your home, 

1126
01:10:45,320 --> 01:10:48,200
in your building data center or across the globe. 

1127
01:10:55,020 --> 01:10:57,050
There are many reasons, again,

1128
01:10:57,060 --> 01:10:58,370
for being distributed systems, 

1129
01:10:58,380 --> 01:11:01,130
some of them because the applications, the users,

1130
01:11:01,950 --> 01:11:03,390
you want to connect the users. 

1131
01:11:04,610 --> 01:11:06,440
And the users are different locations. 

1132
01:11:08,250 --> 01:11:09,250
Some of them, 

1133
01:11:09,260 --> 01:11:10,810
because like I mentioned, 

1134
01:11:11,900 --> 01:11:18,050
one server cannot do is not powerful enough to support all the workload

1135
01:11:19,470 --> 01:11:20,560
to perform all the workload. 

1136
01:11:24,430 --> 01:11:26,290
But there are also other reasons. 

1137
01:11:29,270 --> 01:11:30,390
Sometimes it's cheaper. 

1138
01:11:30,400 --> 01:11:36,590
And this was a truth like it used to be that if you aren't very powerful computers, 

1139
01:11:36,600 --> 01:11:37,870
you build supercomputers, 

1140
01:11:37,880 --> 01:11:40,070
you can still be able to play supercomputers. 

1141
01:11:40,890 --> 01:11:42,250
These are very expensive, 

1142
01:11:42,870 --> 01:11:44,730
takes year to build, to deliver.

1143
01:11:46,890 --> 01:11:49,010
And then with the rise of the internet, 

1144
01:11:50,480 --> 01:11:53,590
in particular, google drove the charge,

1145
01:11:53,600 --> 01:11:56,830
and that was based on some research which has done it directly network

1146
01:11:56,840 --> 01:11:57,590
of all stations. 

1147
01:11:58,670 --> 01:12:04,870
People started to replace supercomputers with a bunch of servers, 

1148
01:12:05,320 --> 01:12:06,590
commodity servers, 

1149
01:12:07,520 --> 01:12:10,340
by service, you can buy right?

1150
01:12:10,660 --> 01:12:12,030
Online or whatever, right?

1151
01:12:13,100 --> 01:12:15,130
And then you connect the servers. 

1152
01:12:15,140 --> 01:12:19,670
And now we have a much more powerful intelligence software on top, 

1153
01:12:20,710 --> 01:12:21,750
that on the aggregate, 

1154
01:12:21,760 --> 01:12:23,550
they can provide you a lot of power, 

1155
01:12:24,270 --> 01:12:27,420
computation, power, and storage space.

1156
01:12:31,530 --> 01:12:33,720
What is the promise of the security systems? 

1157
01:12:35,470 --> 01:12:37,090
One problem is higher availability. 

1158
01:12:37,460 --> 01:12:40,380
If one machine goes down, use another one,

1159
01:12:42,280 --> 01:12:42,710
right? 

1160
01:12:43,200 --> 01:12:44,870
Despite some failures, actually,

1161
01:12:44,880 --> 01:12:47,390
all the services in the cloud are pretty reliable. 

1162
01:12:47,880 --> 01:12:49,460
Your facebook, google and so forth.

1163
01:12:49,470 --> 01:12:50,700
They are pretty reliable, 

1164
01:12:50,710 --> 01:12:52,250
more reliable than your laptop. 

1165
01:12:54,140 --> 01:12:55,330
Better your ability. 

1166
01:12:56,080 --> 01:12:59,790
You can store like you saw the data in multiple location across the globe. 

1167
01:13:02,880 --> 01:13:04,070
And also, in principle,

1168
01:13:04,080 --> 01:13:05,110
modern security, 

1169
01:13:05,120 --> 01:13:06,990
because we have multiple pieces. 

1170
01:13:09,170 --> 01:13:11,200
You split your application, multiple pieces.

1171
01:13:11,450 --> 01:13:19,390
And now you need to protect only 1 piece in a I only 1 piece at a time

1172
01:13:19,730 --> 01:13:21,540
and securing 1 piece. 

1173
01:13:21,840 --> 01:13:25,140
Presumably, it's easier than securing the entire system.

1174
01:13:28,820 --> 01:13:29,680
However, 

1175
01:13:30,450 --> 01:13:31,960
you need to be very careful, 

1176
01:13:31,970 --> 01:13:35,200
and it's not easy to deliver on that promise. 

1177
01:13:37,830 --> 01:13:38,500
In general, 

1178
01:13:38,510 --> 01:13:42,060
there have been many systems beyond distributed systems which provides

1179
01:13:42,070 --> 01:13:42,980
worse of everything, 

1180
01:13:44,100 --> 01:13:45,260
worse availability, 

1181
01:13:45,270 --> 01:13:47,100
worse reliability, or security,

1182
01:13:47,110 --> 01:13:48,140
worse availability. 

1183
01:13:49,010 --> 01:13:50,240
This is leslie lambert. 

1184
01:13:50,570 --> 01:13:51,700
During our winner, 

1185
01:13:53,270 --> 01:13:55,550
you'll hear more about him before the class ends, 

1186
01:13:57,010 --> 01:13:58,960
but you are saving the healthiest quote. 

1187
01:14:00,170 --> 01:14:02,200
A it's like a funny coat. 

1188
01:14:02,800 --> 01:14:07,330
A distributed system is one in with a failure of a computer. 

1189
01:14:07,780 --> 01:14:09,950
You didn't even now existed, 

1190
01:14:10,660 --> 01:14:13,460
can render your own computer that you unusable. 

1191
01:14:17,430 --> 01:14:22,810
You can think about if you have your email and email server, right?

1192
01:14:23,820 --> 01:14:26,520
If your email client works on your computer, 

1193
01:14:26,910 --> 01:14:28,420
but the email server is down, 

1194
01:14:29,540 --> 01:14:32,050
your computer is pretty useless for email. 

1195
01:14:34,120 --> 01:14:35,300
What is reliability? 

1196
01:14:37,440 --> 01:14:39,760
If the data you are not careful of the data, 

1197
01:14:39,770 --> 01:14:41,680
and you don't know where the data is. 

1198
01:14:42,210 --> 01:14:46,730
If the day if the computer crashes of starting the data crashes, 

1199
01:14:46,740 --> 01:14:47,810
then you lost the data. 

1200
01:14:49,860 --> 01:14:50,730
What security? 

1201
01:14:50,740 --> 01:14:52,970
Because if you compromise a component, 

1202
01:14:52,980 --> 01:14:54,650
maybe you can compromise the entire system. 

1203
01:14:57,650 --> 01:14:59,770
Also, coordination is more difficult.

1204
01:15:00,900 --> 01:15:03,330
But I remember we have all these challenges to coordinate

1205
01:15:03,340 --> 01:15:05,450
on the same machine between different threads. 

1206
01:15:05,780 --> 01:15:07,140
Critical section deadlocks. 

1207
01:15:07,150 --> 01:15:11,110
Remember that now this is much more complicated because

1208
01:15:11,120 --> 01:15:12,550
not even on a single machine, 

1209
01:15:14,620 --> 01:15:15,810
it's across the network. 

1210
01:15:15,820 --> 01:15:17,950
And you remember, 

1211
01:15:17,960 --> 01:15:19,310
to address these challenges, 

1212
01:15:19,320 --> 01:15:22,590
we have this kind of very convenient primitives, 

1213
01:15:23,410 --> 01:15:28,700
like test and set or pmb well, 

1214
01:15:29,100 --> 01:15:32,540
these are atomic operation implement based on atomic operations, 

1215
01:15:33,680 --> 01:15:34,710
implemented in hardware. 

1216
01:15:35,910 --> 01:15:38,540
How you are going to implement this in a distributed system. 

1217
01:15:39,760 --> 01:15:43,150
When machines can be thousands of miles away. 

1218
01:15:46,490 --> 01:15:47,760
And fundamentally, 

1219
01:15:47,770 --> 01:15:49,240
the security is a trust. 

1220
01:15:49,250 --> 01:15:51,320
It's more difficult, 

1221
01:15:52,210 --> 01:15:56,050
because you need to be careful that even if a component of the system is compromised, 

1222
01:15:56,060 --> 01:15:59,770
then other parts of the system are not compromised. 

1223
01:16:02,040 --> 01:16:04,150
This is corollary to lump code. 

1224
01:16:04,160 --> 01:16:08,040
A disability system is one where you can do it, 

1225
01:16:08,050 --> 01:16:10,600
because some computer you didn't even now existed, 

1226
01:16:11,550 --> 01:16:14,400
is successfully coordinating an attack on my system, right?

1227
01:16:15,870 --> 01:16:17,630
It's again, in compromise part of the system.

1228
01:16:17,640 --> 01:16:19,230
You can bring that down the entire system. 

1229
01:16:19,240 --> 01:16:22,080
If you are not careful in designing these systems. 

1230
01:16:25,930 --> 01:16:28,800
Now, when you design a distributed system,

1231
01:16:29,330 --> 01:16:30,560
what are your goals? 

1232
01:16:30,570 --> 01:16:31,760
What are the requirements? 

1233
01:16:33,980 --> 01:16:39,630
And simply the requirements you want to have is to be as transparent as possible. 

1234
01:16:40,730 --> 01:16:43,690
It's to be almost maybe like your lap more or less. 

1235
01:16:45,320 --> 01:16:45,610
Right? 

1236
01:16:45,620 --> 01:16:47,170
You don't want to be aware about. 

1237
01:16:47,180 --> 01:16:48,690
There are so many machines. 

1238
01:16:49,100 --> 01:16:51,240
You get this transparency, like, for instance,

1239
01:16:51,630 --> 01:16:53,290
when you use your facebook application, 

1240
01:16:54,030 --> 01:16:57,740
do you know how many machines are involved in answering some

1241
01:16:57,750 --> 01:17:00,960
of your requests in sending the news, 

1242
01:17:00,970 --> 01:17:06,750
feed or messages, chat, widows.

1243
01:17:07,120 --> 01:17:07,830
No, you don't.

1244
01:17:08,660 --> 01:17:10,430
That's transparency, good transparency.

1245
01:17:12,500 --> 01:17:14,170
The transparency, as you can imagine,

1246
01:17:14,180 --> 01:17:16,210
has multiple dimension location. 

1247
01:17:16,850 --> 01:17:22,590
You don't know what your servers and servers handling your facebook account

1248
01:17:22,600 --> 01:17:26,550
up located migration. 

1249
01:17:26,810 --> 01:17:30,480
Sometimes you need to move the data from one place to another to scale

1250
01:17:30,490 --> 01:17:33,000
up the system that should be also transparent. 

1251
01:17:33,010 --> 01:17:35,240
You are not aware about the replication. 

1252
01:17:35,610 --> 01:17:38,220
You don't know in how many places your data is replicated. 

1253
01:17:39,840 --> 01:17:42,070
Concurrency, you yourself.

1254
01:17:42,450 --> 01:17:46,150
You cannot say you cannot tell how many other Facebook users

1255
01:17:46,160 --> 01:17:48,670
at the same time on the system. 

1256
01:17:49,450 --> 01:17:49,730
Still, 

1257
01:17:49,740 --> 01:17:56,600
your experience is the same whether there are 1,000 or 5,000 or 51 billion. 

1258
01:17:57,850 --> 01:18:00,200
That means that is Paris. 

1259
01:18:03,850 --> 01:18:06,040
You also want to be paralyzed. 

1260
01:18:06,050 --> 01:18:08,040
I if you want to have a big job, 

1261
01:18:08,050 --> 01:18:13,800
you want the system to somehow transparently split it, ideally,

1262
01:18:14,380 --> 01:18:19,270
and then execute multiple pieces if possible in parallel and different machines. 

1263
01:18:19,280 --> 01:18:23,820
So it is running fast and falter as for sure, 

1264
01:18:23,830 --> 01:18:24,900
like we discuss. 

1265
01:18:25,590 --> 01:18:26,660
If there are failures, 

1266
01:18:27,260 --> 01:18:28,940
you absolutely do not want. 

1267
01:18:29,450 --> 01:18:31,490
There's also to see these failures. 

1268
01:18:34,930 --> 01:18:40,050
So any of these things requires the nodes, 

1269
01:18:40,430 --> 01:18:45,130
do some computers to communicate between themselves. 

1270
01:18:46,920 --> 01:18:48,820
And this is what protocol exchanges. 

1271
01:18:50,480 --> 01:18:51,020
Okay? 

1272
01:18:51,990 --> 01:18:53,020
The protocol. 

1273
01:18:54,220 --> 01:18:57,610
It's an agreement about how to communicate. 

1274
01:18:58,530 --> 01:18:59,920
It has a syntax. 

1275
01:19:00,200 --> 01:19:01,720
We describe the comments, 

1276
01:19:02,490 --> 01:19:06,940
the syntax of the send message, for instance, receive message.

1277
01:19:08,340 --> 01:19:09,690
What are the type of fields? 

1278
01:19:10,790 --> 01:19:13,880
Name of the common as any semantics? 

1279
01:19:14,770 --> 01:19:16,310
When you send some packets? 

1280
01:19:16,980 --> 01:19:19,100
What really matter, what really happened,

1281
01:19:20,040 --> 01:19:21,310
what actions are taken? 

1282
01:19:23,770 --> 01:19:27,240
In general, this is description of a state machine,

1283
01:19:27,250 --> 01:19:28,530
a protocol. 

1284
01:19:28,540 --> 01:19:30,510
You receive a message. 

1285
01:19:31,370 --> 01:19:33,720
You are in a way state to wait for a message, 

1286
01:19:34,000 --> 01:19:34,830
to receive a message, 

1287
01:19:34,840 --> 01:19:37,770
and you go into a state to process a message and seem like that. 

1288
01:19:49,090 --> 01:19:50,920
We are on the Top of the hour. 

1289
01:19:50,930 --> 01:19:52,120
So to stop here, 

1290
01:19:52,990 --> 01:19:54,700
we are going to continue next time. 

1291
01:19:54,710 --> 01:19:55,300
And next time. 

1292
01:19:56,110 --> 01:19:57,980
It's going to be an exciting lecture. 

1293
01:19:57,990 --> 01:20:00,200
We are going to talk about protocols. 

1294
01:20:00,210 --> 01:20:05,040
You are going to talk the byzantine general problem, consensus problem,

1295
01:20:05,400 --> 01:20:11,480
and also going to talk about now about real transactions and to see

1296
01:20:11,490 --> 01:20:13,750
how they are implemented under the quote. 

1297
01:20:15,830 --> 01:20:18,030
Thank you and see you on Monday. 

1298
01:20:18,530 --> 01:20:20,120
Good luck with everything else. 

