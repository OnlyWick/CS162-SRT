1
00:00:12,620 --> 00:00:13,620
Hello, everyone.

2
00:00:14,930 --> 00:00:16,600
So today, during today's lecture,

3
00:00:16,610 --> 00:00:24,490
we are going to finish the discussion on the deadlocks and then continue

4
00:00:24,500 --> 00:00:29,920
to start to learn about the visual memory and address translation. 

5
00:00:33,210 --> 00:00:39,480
Last time, we spent quite a bit on deadlocks is a very important concept.

6
00:00:40,120 --> 00:00:41,820
And if you remember, 

7
00:00:41,830 --> 00:00:47,290
there are four requirements which needs to happen to have a deadlock. 

8
00:00:48,300 --> 00:00:50,200
The first in mutual explosion, 

9
00:00:50,910 --> 00:00:54,690
that means that only one thread at a time can use a particular resource. 

10
00:00:55,620 --> 00:00:57,110
The second is hot and white. 

11
00:00:58,030 --> 00:01:05,490
That is a thread holds a list on resource and is waiting to acquire additional

12
00:01:05,500 --> 00:01:08,390
resources which are held by other threads. 

13
00:01:09,010 --> 00:01:11,540
So this means that this thread cannot make progress, 

14
00:01:11,550 --> 00:01:14,260
because it means the other resources in order to make. 

15
00:01:14,930 --> 00:01:16,210
He needs a computation, 

16
00:01:16,410 --> 00:01:19,870
which, again, are owned by other threads.

17
00:01:21,000 --> 00:01:21,550
No preemptions. 

18
00:01:22,510 --> 00:01:28,450
Resources are released only voluntarily by a thread holding the resource. 

19
00:01:29,790 --> 00:01:32,780
You can a thread cannot be emptied another thread to get the resource

20
00:01:32,790 --> 00:01:33,980
to finish the computation. 

21
00:01:35,040 --> 00:01:37,240
Then in circular weights, you have a cycle,

22
00:01:38,850 --> 00:01:40,320
which is a cycle, 

23
00:01:40,330 --> 00:01:42,240
which is defined by the pattern that, 

24
00:01:42,670 --> 00:01:48,350
like aa thread is waiting for a resource that is held by another thread. 

25
00:01:48,530 --> 00:01:51,070
And that thread is waiting for every story that is held

26
00:01:51,080 --> 00:01:52,910
by another thread and so on. 

27
00:01:52,920 --> 00:01:54,870
And you're going until you get a cycle. 

28
00:01:57,170 --> 00:01:57,610
Okay? 

29
00:01:58,490 --> 00:01:58,950
Also, 

30
00:01:59,700 --> 00:02:00,430
last, 

31
00:02:01,570 --> 00:02:09,220
there are several techniques we listed last time to resolve a deadlock. 

32
00:02:11,230 --> 00:02:14,660
One of them, it's and to recover from the deadlock.

33
00:02:14,670 --> 00:02:15,580
So one, 

34
00:02:16,810 --> 00:02:21,750
some of the things we mentioned last time was to terminate the thread. 

35
00:02:23,290 --> 00:02:26,440
Therefore, you can terminate a thread which owns a resource.

36
00:02:26,960 --> 00:02:28,710
As there are other threads, 

37
00:02:29,040 --> 00:02:31,950
can acquire the resource that can finish their computation. 

38
00:02:36,120 --> 00:02:39,150
This you don't always want to do that. 

39
00:02:39,160 --> 00:02:39,950
In some cases. 

40
00:02:40,280 --> 00:02:41,190
It's pretty hard. 

41
00:02:41,700 --> 00:02:42,530
Like, for instance,

42
00:02:42,540 --> 00:02:49,250
you can kill a thread which is modifying some sensitive data or important data. 

43
00:02:49,490 --> 00:02:53,790
Then you can it like, for instance,

44
00:02:53,800 --> 00:02:56,760
are updating your bank balance, right?

45
00:02:57,070 --> 00:03:02,410
You don't want to do that because you may end up with garbage, 

46
00:03:05,470 --> 00:03:09,700
pre and resources without killing of a thread. 

47
00:03:10,330 --> 00:03:16,270
This means that the system is the ability to suspend a threat. 

48
00:03:16,730 --> 00:03:22,000
And then you can preempt that resource while that thread is suspended

49
00:03:22,010 --> 00:03:24,920
or is sleeping. 

50
00:03:25,960 --> 00:03:29,230
Another thread can get that resource and again, 

51
00:03:29,240 --> 00:03:30,550
complete the computation. 

52
00:03:30,940 --> 00:03:33,540
When the thread which are suspended ghost comes back, 

53
00:03:33,550 --> 00:03:37,020
hopefully there are enough resources for the threat of things of computation. 

54
00:03:38,720 --> 00:03:41,990
But all back, the actions, if you remember, in our example,

55
00:03:42,000 --> 00:03:45,350
is a bridge and you have two cars on an online bridge coming, 

56
00:03:46,420 --> 00:03:48,770
had to head in the middle of the bridge. 

57
00:03:48,780 --> 00:03:52,320
One way to resolve the problems are deadlocked is for one, 

58
00:03:52,330 --> 00:03:57,650
a car to back up. 

59
00:03:57,660 --> 00:04:01,160
And when you look at the operating system, 

60
00:04:01,170 --> 00:04:03,840
some of them use some of these options, right?

61
00:04:03,850 --> 00:04:05,000
It's like, for instance,

62
00:04:05,500 --> 00:04:06,930
one system, hanks,

63
00:04:07,190 --> 00:04:09,010
but I typically one system hanks, 

64
00:04:09,400 --> 00:04:11,060
and you can do anything about it. 

65
00:04:11,350 --> 00:04:13,120
In some cases, he said a lot bad luck.

66
00:04:14,230 --> 00:04:14,980
In many cases. 

67
00:04:14,990 --> 00:04:16,260
So how do you do it? 

68
00:04:16,270 --> 00:04:17,180
You report it. 

69
00:04:17,680 --> 00:04:17,990
Right? 

70
00:04:18,330 --> 00:04:19,200
So you get everything. 

71
00:04:21,060 --> 00:04:24,660
And preempting resources is the operating system is doing that. 

72
00:04:24,670 --> 00:04:26,540
As you now, threads are preempted,

73
00:04:26,550 --> 00:04:29,860
are put on the slip. 

74
00:04:31,030 --> 00:04:33,100
Ii put on the waiting queue. 

75
00:04:36,500 --> 00:04:37,730
We set a few examples. 

76
00:04:41,550 --> 00:04:47,730
So also we talk about another example. 

77
00:04:48,710 --> 00:04:50,100
Last time, another way.

78
00:04:50,110 --> 00:04:53,020
Obviously, you can solve the deadlock problem.

79
00:04:53,030 --> 00:04:54,500
You have infinite resources, right?

80
00:04:54,510 --> 00:04:58,490
If even the resources means that every thread at any given time has

81
00:04:58,500 --> 00:04:59,420
all the resources, 

82
00:04:59,430 --> 00:05:03,650
it needs to continue to progress and to finish its computation. 

83
00:05:05,620 --> 00:05:06,650
This is relevant. 

84
00:05:06,660 --> 00:05:11,050
Here is an example about the second part with the second part of the lecture. 

85
00:05:11,060 --> 00:05:14,270
And we are going to talk about virtual memory. 

86
00:05:14,880 --> 00:05:17,560
And because virtual memory, 

87
00:05:17,570 --> 00:05:21,170
it provides you a memory, 

88
00:05:21,180 --> 00:05:29,180
which is much larger than the physical memory at, 

89
00:05:30,810 --> 00:05:31,880
you can think about, like,

90
00:05:31,890 --> 00:05:33,400
for most applications, 

91
00:05:33,410 --> 00:05:36,520
the same like infinite space, like infinite memory.

92
00:05:38,940 --> 00:05:40,330
The one thing, though, is that,

93
00:05:40,340 --> 00:05:41,450
as we will see, 

94
00:05:41,460 --> 00:05:47,450
and there is a hood of the virtual memories or the virtual memory it's implemented. 

95
00:05:47,830 --> 00:05:52,020
You are going to load different parts of the virtual memory

96
00:05:52,720 --> 00:05:53,830
in the physical memory. 

97
00:05:53,840 --> 00:05:58,290
And then you are going to offload to move some of the parts of the

98
00:05:58,820 --> 00:06:02,330
of the virtual memory of the threads, 

99
00:06:02,640 --> 00:06:07,410
which are not running of the physical memory, 

100
00:06:07,420 --> 00:06:08,810
maybe put them on the disk. 

101
00:06:09,700 --> 00:06:12,230
And in doing so, you basically,

102
00:06:12,240 --> 00:06:14,390
the solution under the hood is to preempt. 

103
00:06:15,680 --> 00:06:15,970
Right? 

104
00:06:15,980 --> 00:06:19,280
You preempt the physical memory, 

105
00:06:19,690 --> 00:06:20,350
a storage, 

106
00:06:20,360 --> 00:06:25,040
which contains a virtual memory data from one thread with another, 

107
00:06:26,850 --> 00:06:30,040
a a with a virtual memory content of another thread. 

108
00:06:30,730 --> 00:06:31,820
We'll talk more about that. 

109
00:06:36,390 --> 00:06:37,160
It's something, 

110
00:06:37,610 --> 00:06:42,190
it's an isolation between the deadlock solutions and virtual memory. 

111
00:06:50,240 --> 00:06:56,310
The next is the next mechanics of us resolving the deadlock problem. 

112
00:06:57,130 --> 00:06:59,160
It's deadlock avoid us, 

113
00:07:00,140 --> 00:07:00,430
right? 

114
00:07:01,230 --> 00:07:05,190
And this is different from the deadlock prevention, 

115
00:07:05,200 --> 00:07:08,050
which we talked last time quite a bit. 

116
00:07:08,960 --> 00:07:09,870
Deadlock prevention. 

117
00:07:09,880 --> 00:07:17,210
If you remember, you design your program that you never run into deadlock,

118
00:07:19,770 --> 00:07:26,870
like all the resources are going to be acquired in the same order by everyone. 

119
00:07:26,880 --> 00:07:27,070
Right? 

120
00:07:27,080 --> 00:07:27,670
Thing like that. 

121
00:07:29,060 --> 00:07:29,500
Now, 

122
00:07:31,030 --> 00:07:39,300
deadlock avoidance is basically is that it's a more dynamic way to avoid, 

123
00:07:39,350 --> 00:07:39,780
sorry, 

124
00:07:40,190 --> 00:07:44,190
that lock avoidance is a more dynamic way to avoid deadlocks. 

125
00:07:45,190 --> 00:07:50,070
And this basically is your operating system. 

126
00:07:50,080 --> 00:07:50,990
In this case. 

127
00:07:51,300 --> 00:07:55,040
It checks at everyone you make every resource request, 

128
00:07:55,610 --> 00:07:58,590
whether it can result in a deadlock. 

129
00:08:01,960 --> 00:08:09,360
If the operating system convince itself that if if grant is request, 

130
00:08:09,950 --> 00:08:13,230
there is a way in which you don't, 

131
00:08:15,360 --> 00:08:17,550
you don't get into a deadlock state, 

132
00:08:18,000 --> 00:08:21,430
then he's granting the resource is a threat which asked for it. 

133
00:08:22,360 --> 00:08:23,680
Otherwise, it does not.

134
00:08:27,000 --> 00:08:28,410
Let me see the question here. 

135
00:08:31,940 --> 00:08:32,510
Sorry. 

136
00:08:35,090 --> 00:08:36,050
That's a great question. 

137
00:08:36,060 --> 00:08:37,930
The slides is my mistake. 

138
00:08:39,580 --> 00:08:42,930
On me. 

139
00:08:44,560 --> 00:08:46,760
Let me give me 30 seconds to upload them, 

140
00:08:46,770 --> 00:08:49,510
and they are going to be available in a few moments. 

141
00:08:57,780 --> 00:08:59,090
I apologize for that. 

142
00:09:36,340 --> 00:09:38,510
Okay, so I push them.

143
00:09:38,520 --> 00:09:43,020
So it's after a bit of time that are going to be available again. 

144
00:09:44,460 --> 00:09:46,910
Sorry, and thanks for flagging it up.

145
00:09:52,930 --> 00:09:58,080
So let's see how this in these examples like we gave. 

146
00:09:58,090 --> 00:09:59,770
This is a canonical example. 

147
00:09:59,780 --> 00:10:02,970
We used last time to illustrate the deadlock. 

148
00:10:03,770 --> 00:10:04,860
And here, if you remember,

149
00:10:04,870 --> 00:10:07,710
you have two threads and both threads, 

150
00:10:07,720 --> 00:10:10,430
a and b acquire resources, 

151
00:10:10,710 --> 00:10:16,180
or the lock yx and y but they acquire them in a different order. 

152
00:10:16,580 --> 00:10:23,720
Let's say, is that a acquire x and let's b acquire b it's a thread,

153
00:10:23,730 --> 00:10:27,500
b acquire y in this case, it's not working.

154
00:10:27,510 --> 00:10:35,270
You have that lock y because

155
00:10:35,280 --> 00:10:39,500
if a tries to acquire y we can no longer do that, 

156
00:10:39,510 --> 00:10:44,390
because b already holds y

157
00:10:50,830 --> 00:10:51,940
this doesn't work, 

158
00:10:51,950 --> 00:10:52,260
right? 

159
00:10:52,890 --> 00:10:54,160
This is what we want to avoid. 

160
00:10:54,370 --> 00:10:55,560
In this particular case, 

161
00:10:55,570 --> 00:11:02,060
a point here is that if you go back, 

162
00:11:05,320 --> 00:11:12,380
one is a system allocated x to a

163
00:11:13,630 --> 00:11:15,680
then he shouldn't. 

164
00:11:16,110 --> 00:11:20,960
When we ask for why he should not grant access to that resource, 

165
00:11:20,970 --> 00:11:23,960
you shouldn't grant that the resource why or the lock. 

166
00:11:25,850 --> 00:11:27,300
Because if you grant it, 

167
00:11:27,960 --> 00:11:32,070
now, there is a potential for that.

168
00:11:32,080 --> 00:11:32,230
Look. 

169
00:11:33,620 --> 00:11:34,050
Okay. 

170
00:11:35,780 --> 00:11:37,610
Now, intuitively, you see,

171
00:11:38,900 --> 00:11:46,380
if the operating system doesn't grant y to b then a

172
00:11:46,390 --> 00:11:51,170
has your opportunity to request y now, 

173
00:11:51,180 --> 00:11:58,800
the operating system can grant y to a a now has both x and y can complete this

174
00:11:58,810 --> 00:12:06,810
computation and then release boss x and y that's kind of what you want to

175
00:12:06,820 --> 00:12:07,110
happen. 

176
00:12:07,330 --> 00:12:10,830
And this is exactly what the deadlock avoidance is trying to do. 

177
00:12:13,260 --> 00:12:16,500
In three d is the deadlock avoidance. 

178
00:12:16,510 --> 00:12:18,330
You have two states, 

179
00:12:19,090 --> 00:12:21,440
a safe state, and a deadlock state.

180
00:12:24,640 --> 00:12:32,040
In the safe state means that there is a way to allocate the

181
00:12:32,050 --> 00:12:35,990
resources to the existing threads, 

182
00:12:36,000 --> 00:12:39,110
said that every thread is going to complete. 

183
00:12:41,120 --> 00:12:42,690
So there is no deadlock. 

184
00:12:44,420 --> 00:12:47,420
Deadlock means there is a deadlock in the system. 

185
00:12:47,790 --> 00:12:51,980
So the four requirements we talk about are all hot. 

186
00:12:54,410 --> 00:12:55,810
These are the two main states, 

187
00:12:55,820 --> 00:13:00,440
and then there is another unsafe state. 

188
00:13:00,880 --> 00:13:02,830
There is no deadlock yet, 

189
00:13:02,840 --> 00:13:05,190
but stress can record resources in a part, 

190
00:13:05,200 --> 00:13:09,290
in a pattern that unavoidable leads to deadlock. 

191
00:13:10,580 --> 00:13:11,970
So basically, right now,

192
00:13:11,980 --> 00:13:13,290
there is no deadlock, 

193
00:13:14,530 --> 00:13:15,650
but the deadlock is imminent. 

194
00:13:15,660 --> 00:13:17,330
You cannot do anything about it. 

195
00:13:18,650 --> 00:13:21,290
You are on the way to for the deadlock to happen. 

196
00:13:22,260 --> 00:13:23,450
So this is what i'm saying. 

197
00:13:26,690 --> 00:13:28,580
With a deadlock avoidance, 

198
00:13:29,110 --> 00:13:35,360
you just try to prevent the system from reaching an unsafe state. 

199
00:13:36,130 --> 00:13:37,760
Because if you reach an unsafe state, 

200
00:13:37,770 --> 00:13:39,920
eventually you are going to reach a deadlock state. 

201
00:13:44,530 --> 00:13:47,960
The main idea here is on a thread request, a resource,

202
00:13:48,630 --> 00:13:50,390
the operating system checks, 

203
00:13:51,150 --> 00:13:52,470
if it will result, 

204
00:13:53,060 --> 00:13:58,610
if granting that resource would lead to an unsafe state, 

205
00:14:04,490 --> 00:14:07,370
if it will not lead to an unsafe state, 

206
00:14:07,800 --> 00:14:09,740
is going to grant the resource. 

207
00:14:11,370 --> 00:14:12,350
If not, 

208
00:14:14,670 --> 00:14:18,670
it's not going to grant and is going to wait for the existing threats

209
00:14:20,330 --> 00:14:23,840
to finish and release some resources. 

210
00:14:25,730 --> 00:14:27,260
So like, again, look,

211
00:14:27,270 --> 00:14:29,400
and as a previous example, 

212
00:14:30,590 --> 00:14:32,700
I already mentioned to you the solution, 

213
00:14:32,710 --> 00:14:34,220
but let's do it again. 

214
00:14:35,510 --> 00:14:39,780
Thread a acquires x now, 

215
00:14:39,790 --> 00:14:42,470
thread b ask for why, 

216
00:14:43,320 --> 00:14:50,940
but we do not give y to b until a finishes. 

217
00:14:52,680 --> 00:14:57,950
Because if we give grant y to b it can be results in the book. 

218
00:15:02,590 --> 00:15:05,380
The classic algorithm for avoiding deadlock. 

219
00:15:05,650 --> 00:15:07,060
It's a banker algorithms. 

220
00:15:08,370 --> 00:15:11,390
And basically, 

221
00:15:11,400 --> 00:15:12,630
what you, 

222
00:15:13,960 --> 00:15:18,240
the idea here is that each thread, 

223
00:15:18,250 --> 00:15:22,480
it stays a maximum number of resources in india in advance, 

224
00:15:23,410 --> 00:15:23,850
right? 

225
00:15:24,560 --> 00:15:32,460
And allow a threat to proceed only if available resources

226
00:15:32,470 --> 00:15:37,580
in the system minus requested resources in the system is

227
00:15:37,590 --> 00:15:40,340
greater than the maximum number of resources

228
00:15:40,350 --> 00:15:41,700
required by a threat. 

229
00:15:43,050 --> 00:15:43,410
Right? 

230
00:15:44,790 --> 00:15:45,960
And this is important. 

231
00:15:45,970 --> 00:15:49,360
You need to stay up front how many resources you have. 

232
00:15:50,800 --> 00:15:52,160
Because if you don't, 

233
00:15:53,030 --> 00:15:54,990
the system doesn't have the information. 

234
00:15:55,000 --> 00:15:56,870
And at any given time in the future, 

235
00:15:58,200 --> 00:16:01,900
you being a thread, ask for more resources.

236
00:16:01,910 --> 00:16:03,300
All right. 

237
00:16:03,310 --> 00:16:06,780
So there is no way actually to protect the deadlock in this situation. 

238
00:16:09,230 --> 00:16:13,450
And so banker are going to allocate the resource dynamically, 

239
00:16:13,460 --> 00:16:16,090
so is looking at each request, resource request.

240
00:16:17,410 --> 00:16:22,860
And then you decide whether to grant a request, 

241
00:16:22,870 --> 00:16:24,340
a resource or not. 

242
00:16:26,930 --> 00:16:31,000
If the resulting state, 

243
00:16:31,010 --> 00:16:32,650
it remains a safe state. 

244
00:16:33,340 --> 00:16:38,760
That and the techniques is very simple. 

245
00:16:38,770 --> 00:16:41,000
You pretend that each request is granted. 

246
00:16:41,530 --> 00:16:43,420
Then you run the deadlock detection algorithm. 

247
00:16:43,740 --> 00:16:46,210
You remember the last time we are looking, 

248
00:16:47,190 --> 00:16:50,160
we learn about deadlock detection algorithm. 

249
00:16:52,040 --> 00:16:56,300
It's very simple in the deadlock detection algorithms you are looking was

250
00:16:56,990 --> 00:16:58,420
the requested

251
00:17:00,450 --> 00:17:02,600
resources by a particular thread. 

252
00:17:05,060 --> 00:17:06,490
It's can be satisfied. 

253
00:17:07,320 --> 00:17:09,880
So it's less than the resource available. 

254
00:17:11,350 --> 00:17:11,730
Right? 

255
00:17:12,700 --> 00:17:13,540
In this case, 

256
00:17:13,550 --> 00:17:21,540
we are looking at how many more resources a thread needs in the worst case, 

257
00:17:21,550 --> 00:17:23,480
which is a max node, 

258
00:17:23,930 --> 00:17:28,490
is a node in the graph. 

259
00:17:29,460 --> 00:17:31,690
That's why it's called not here. 

260
00:17:32,480 --> 00:17:36,460
But you can replace node with a thread, 

261
00:17:37,040 --> 00:17:42,070
but the maximum number of resources that the thread still needs is

262
00:17:42,080 --> 00:17:45,520
a maximum number of resources overall, 

263
00:17:45,530 --> 00:17:49,460
that thread me needs minus a number of resources, 

264
00:17:49,470 --> 00:17:51,860
the thread already else. 

265
00:17:53,120 --> 00:17:53,470
Okay? 

266
00:17:56,190 --> 00:17:57,700
Again, if you remember,

267
00:17:58,050 --> 00:18:01,380
this is the algorithms to detect the deadlock. 

268
00:18:02,450 --> 00:18:06,400
The only change you need to make here is that we are going to replace

269
00:18:06,990 --> 00:18:10,020
request number of request resources

270
00:18:12,340 --> 00:18:16,360
with the maximum number of resources, 

271
00:18:16,620 --> 00:18:18,210
that node or thread. 

272
00:18:18,510 --> 00:18:21,140
Can we still need in the worst case? 

273
00:18:25,670 --> 00:18:26,610
So that's what it is. 

274
00:18:27,800 --> 00:18:28,130
Right? 

275
00:18:31,290 --> 00:18:33,480
Just to look a little bit more of the code, 

276
00:18:34,680 --> 00:18:36,250
you put all notes, again,

277
00:18:36,260 --> 00:18:37,770
all threads in unfinished state. 

278
00:18:37,780 --> 00:18:39,420
You have available resources, 

279
00:18:39,430 --> 00:18:46,400
which is amount of the number of resources which are free in the system. 

280
00:18:47,810 --> 00:18:51,690
Then you are going to look at all nodes and finished, 

281
00:18:51,700 --> 00:18:53,620
which are still computing. 

282
00:18:54,980 --> 00:18:55,930
For each of them. 

283
00:18:55,940 --> 00:18:57,490
You are looking at that. 

284
00:18:59,390 --> 00:19:03,470
Can if the mark, 

285
00:19:03,480 --> 00:19:10,820
if the amount of resources that thread is going to require in to ask for, 

286
00:19:10,830 --> 00:19:11,940
in the worst case, 

287
00:19:12,220 --> 00:19:13,950
is less than the available resources. 

288
00:19:15,320 --> 00:19:17,400
And if is fine, 

289
00:19:17,410 --> 00:19:18,680
you remove from unfinished, 

290
00:19:18,960 --> 00:19:22,690
because we know that we allocate those resources to the thread will finish

291
00:19:22,700 --> 00:19:23,290
for sure. 

292
00:19:23,860 --> 00:19:24,320
Right? 

293
00:19:25,270 --> 00:19:27,310
And we'll never ask for more resources than that. 

294
00:19:29,080 --> 00:19:30,240
And then you iterate. 

295
00:19:33,840 --> 00:19:37,040
And it's until you are done. 

296
00:19:49,080 --> 00:19:51,550
Can you explain what a lock means? 

297
00:19:52,560 --> 00:19:55,310
A lock means allocate a lock. 

298
00:19:55,320 --> 00:19:58,990
A lock is the resources which are already allocated to a threat. 

299
00:19:59,000 --> 00:19:59,950
So say, 

300
00:20:00,660 --> 00:20:02,920
I have a thread. 

301
00:20:04,910 --> 00:20:06,390
So let me just go. 

302
00:20:06,900 --> 00:20:13,700
Let me guess nothing better than an example. 

303
00:20:17,630 --> 00:20:18,700
In this example, 

304
00:20:23,140 --> 00:20:23,940
both threads, 

305
00:20:25,360 --> 00:20:26,700
the max will be two, 

306
00:20:27,550 --> 00:20:30,350
because they require x and y right? 

307
00:20:31,960 --> 00:20:33,990
Or it's a vector, depends how you want to look at.

308
00:20:34,410 --> 00:20:35,300
But in this case, 

309
00:20:35,310 --> 00:20:41,140
we understand Both threads requires x and y this is the max initial. 

310
00:20:42,560 --> 00:20:47,330
Now, when the thread a gets x in this case,

311
00:20:48,830 --> 00:20:50,760
x is a lock in a lock. 

312
00:20:53,110 --> 00:20:59,430
Allocated vector is the number of resources which are already allocated

313
00:20:59,440 --> 00:20:59,990
with a threat. 

314
00:21:01,600 --> 00:21:05,720
Max is still x and y when you do max, max,

315
00:21:05,730 --> 00:21:08,940
x and y max minus a lock. 

316
00:21:08,950 --> 00:21:09,980
In this case, 

317
00:21:10,410 --> 00:21:16,420
you get what you get y because max is x and y are log, 

318
00:21:16,430 --> 00:21:21,710
is x you get y in this case, 

319
00:21:21,720 --> 00:21:22,750
in the worst case, 

320
00:21:23,320 --> 00:21:27,650
that's thread a still is going to ask for a while. 

321
00:21:31,740 --> 00:21:32,230
Okay? 

322
00:21:51,350 --> 00:21:52,780
Just, again, to summarize,

323
00:21:52,790 --> 00:21:56,780
keeping the system in a safe state means that there is this a sequence

324
00:21:57,620 --> 00:22:02,760
of in which your grand request to the threads, 

325
00:22:03,370 --> 00:22:04,370
which are unfinished, 

326
00:22:04,750 --> 00:22:08,530
so that all threads are going to finish. 

327
00:22:10,450 --> 00:22:12,210
So let's apply these algorithms

328
00:22:14,170 --> 00:22:19,880
to the dining philosophy philosopher problem or lawyers problem. 

329
00:22:24,990 --> 00:22:26,000
What is the deadlock here? 

330
00:22:26,010 --> 00:22:30,450
The deadlock here is that when each person picks a chopstick, 

331
00:22:30,650 --> 00:22:32,610
and they have only one chopsticks, they can,

332
00:22:32,620 --> 00:22:34,570
there is no other chopstick available, 

333
00:22:34,970 --> 00:22:36,160
no one can eat. 

334
00:22:38,650 --> 00:22:39,780
What is a safe state here? 

335
00:22:40,180 --> 00:22:45,390
Is that and when you can grant a request a chopstick, 

336
00:22:46,530 --> 00:22:49,710
you can grant one is that there is not the last chopstick, 

337
00:22:50,390 --> 00:22:53,940
because if we have still on chopstick, 

338
00:22:54,620 --> 00:22:58,030
we can give that chopstick to someone who has already on chopstick. 

339
00:22:58,570 --> 00:23:01,570
That person is going to finish eating. 

340
00:23:01,860 --> 00:23:03,380
And now you get two chopsticks. 

341
00:23:03,810 --> 00:23:08,110
So you can give the chopsticks to other people to eat. 

342
00:23:10,830 --> 00:23:11,150
Okay? 

343
00:23:12,140 --> 00:23:14,520
Or this is the last chopstick, 

344
00:23:14,860 --> 00:23:18,460
but you give to someone who already has a chopstick. 

345
00:23:19,680 --> 00:23:21,050
Because if you do so, 

346
00:23:21,410 --> 00:23:26,470
then that person you gave the second chopstick can finish eating. 

347
00:23:30,910 --> 00:23:31,910
What happens? 

348
00:23:32,590 --> 00:23:34,080
If you have that? 

349
00:23:34,090 --> 00:23:36,180
You generalize a problem with gay handed? 

350
00:23:37,230 --> 00:23:40,160
People like octopus, 

351
00:23:40,170 --> 00:23:43,400
think about like you have octopus which are dying. 

352
00:23:46,450 --> 00:23:48,520
You can generalize that. 

353
00:23:48,530 --> 00:23:49,920
So basically, 

354
00:23:49,930 --> 00:23:54,730
the last one and no one could have k is the second to last one, 

355
00:23:54,740 --> 00:23:56,730
and no one has k minus one, 

356
00:23:57,280 --> 00:23:57,970
and so forth. 

357
00:23:58,640 --> 00:23:59,080
Right? 

358
00:24:00,750 --> 00:24:02,390
Because otherwise, 

359
00:24:02,400 --> 00:24:04,440
if you allocate, 

360
00:24:05,440 --> 00:24:11,760
if you grant the chopstick by violating any of these conditions, 

361
00:24:13,070 --> 00:24:16,700
then you can end up in that lock. 

362
00:24:21,430 --> 00:24:22,280
So in summary, 

363
00:24:23,170 --> 00:24:25,010
there are four conditions, by the way,

364
00:24:25,020 --> 00:24:27,490
any questions about bankers algorithm? 

365
00:24:39,190 --> 00:24:40,390
There is a high level. 

366
00:24:40,400 --> 00:24:41,750
The idea is very simple. 

367
00:24:42,440 --> 00:24:46,440
Each thread is going to tell you in advance, 

368
00:24:46,990 --> 00:24:50,960
to say, in advance how many resources it needs.

369
00:24:53,040 --> 00:24:59,110
And then what you do is the operating system is going to grant a request

370
00:25:00,590 --> 00:25:01,390
to a resource. 

371
00:25:01,920 --> 00:25:03,750
If by granting that request, 

372
00:25:04,300 --> 00:25:05,430
you remain in safe state. 

373
00:25:06,870 --> 00:25:14,420
And in safe state means that there is a way to grant the request to the

374
00:25:14,430 --> 00:25:20,510
existing threads says that every thread is going to finish. 

375
00:25:27,010 --> 00:25:28,980
What is k minus stuff? 

376
00:25:32,450 --> 00:25:33,870
So here, 

377
00:25:34,320 --> 00:25:35,480
k minus two here, 

378
00:25:35,490 --> 00:25:38,040
you assume that instead of having two hands, 

379
00:25:39,070 --> 00:25:43,340
that person or entity will have k hands. 

380
00:25:44,440 --> 00:25:50,810
And in order to eat that octopus, 

381
00:25:50,820 --> 00:25:55,790
it needs or k chopsticks. 

382
00:26:00,060 --> 00:26:05,870
If you have one chopstick left, 

383
00:26:06,890 --> 00:26:08,760
someone else asked for the chopstick. 

384
00:26:09,810 --> 00:26:17,320
You do not give that chopstick to that person unless that

385
00:26:17,330 --> 00:26:23,690
person has k chopsticks and the same. 

386
00:26:24,200 --> 00:26:24,630
Next, 

387
00:26:25,560 --> 00:26:29,370
if you have two chopsticks which are not allocated, 

388
00:26:31,120 --> 00:26:35,040
you would not give that a chopstick to a person, 

389
00:26:35,050 --> 00:26:36,920
unless at least on as a person, 

390
00:26:37,760 --> 00:26:39,320
has k minus on chopsticks. 

391
00:26:41,590 --> 00:26:43,320
Because otherwise, 

392
00:26:44,130 --> 00:26:46,760
if you give the chopstick to another person, 

393
00:26:47,540 --> 00:26:50,130
none of the person has k minus on chopsticks, 

394
00:26:50,140 --> 00:26:52,370
they have k minus two or less. 

395
00:26:53,590 --> 00:26:55,470
Now you are in an unsafe state, 

396
00:26:57,020 --> 00:26:59,590
because you have only one chopstick left. 

397
00:27:00,230 --> 00:27:03,820
No one else has paid my more than k minus two chopsticks. 

398
00:27:04,720 --> 00:27:07,310
No matter to whom I am going to give the last chopstick. 

399
00:27:08,150 --> 00:27:09,320
No one else can it? 

400
00:27:10,340 --> 00:27:10,920
No one can it? 

401
00:27:16,240 --> 00:27:18,000
So there are four conditions for that. 

402
00:27:18,010 --> 00:27:18,960
Look to happen. 

403
00:27:19,330 --> 00:27:21,530
Mutual exclusion, hold on weight,

404
00:27:21,730 --> 00:27:23,440
no preemption, and circular weight.

405
00:27:24,830 --> 00:27:28,970
And there are several techniques to addressing the deadlock problem, 

406
00:27:29,710 --> 00:27:30,840
deadlock prevention. 

407
00:27:31,840 --> 00:27:35,280
You write your code in a way that it's not prone to the deadlock. 

408
00:27:36,130 --> 00:27:37,490
You set up some rules, 

409
00:27:39,130 --> 00:27:39,410
right? 

410
00:27:39,420 --> 00:27:42,400
So that if everyone respect these rules, 

411
00:27:43,170 --> 00:27:44,450
you cannot have that lock. 

412
00:27:44,670 --> 00:27:45,350
For instance, 

413
00:27:48,700 --> 00:27:50,090
deadlock, recovery.

414
00:27:50,410 --> 00:27:54,440
You let the deadlock happen and then figure out how to recover. 

415
00:27:54,900 --> 00:27:57,290
You can preempt a thread. 

416
00:27:57,820 --> 00:27:59,470
You can suspend a thread, 

417
00:28:01,150 --> 00:28:02,080
you can roll back, 

418
00:28:04,690 --> 00:28:05,970
deadlock, avoid us.

419
00:28:06,760 --> 00:28:08,090
This is what we just learned, 

420
00:28:08,100 --> 00:28:10,490
the bank of our banker algorithms, 

421
00:28:11,420 --> 00:28:12,780
which time you did, 

422
00:28:12,790 --> 00:28:14,830
you basically delay resource requests? 

423
00:28:16,170 --> 00:28:17,520
So that look doesn't happen. 

424
00:28:19,420 --> 00:28:20,440
And finally, 

425
00:28:21,310 --> 00:28:22,780
deadlock, then denial,

426
00:28:23,670 --> 00:28:26,890
he just ignores is deadlock because it may never happen. 

427
00:28:27,110 --> 00:28:28,710
What is happens so infrequently? 

428
00:28:28,720 --> 00:28:29,760
And when happens, 

429
00:28:30,350 --> 00:28:32,240
there is not a big issue. 

430
00:28:34,080 --> 00:28:36,830
Announce announcements. 

431
00:28:37,680 --> 00:28:40,710
Project one, congrats for completing your first project.

432
00:28:44,500 --> 00:28:49,210
We are planning to release the grades for your midterm by monday, 

433
00:28:49,220 --> 00:28:50,650
like I mentioned last time, 

434
00:28:51,550 --> 00:28:53,750
and project two will be released today. 

435
00:28:54,160 --> 00:28:56,220
So good luck for project two. 

436
00:29:00,640 --> 00:29:02,710
Now i'm going to switch gears, 

437
00:29:02,720 --> 00:29:09,190
and i'm going to talk about virtual memory. 

438
00:29:11,780 --> 00:29:17,590
We all started to remind everyone to recall about visualizing resources, 

439
00:29:17,600 --> 00:29:17,910
right? 

440
00:29:17,920 --> 00:29:20,350
Memory, just another resource which you visualize.

441
00:29:21,480 --> 00:29:22,480
But before then, 

442
00:29:22,490 --> 00:29:30,250
I let me stop and ask you whether you have any questions about what we've

443
00:29:30,260 --> 00:29:33,290
learned so far or any other question? 

444
00:29:44,070 --> 00:29:45,580
So it seems there are no questions. 

445
00:29:45,590 --> 00:29:47,100
So let's go ahead. 

446
00:29:49,320 --> 00:29:56,840
So remember that what do you want in the operating system? 

447
00:29:58,150 --> 00:30:00,390
Once to provide the application? 

448
00:30:01,000 --> 00:30:05,800
Is the illusion that each application has its own machine on its graphs. 

449
00:30:06,360 --> 00:30:07,730
It has its own resources, 

450
00:30:08,900 --> 00:30:14,370
but the physical machines have limited resources. 

451
00:30:16,200 --> 00:30:21,830
Therefore, you need to kind of visualize this virtual machine,

452
00:30:22,240 --> 00:30:23,350
this physical machine, 

453
00:30:24,080 --> 00:30:25,480
two different applications, 

454
00:30:25,490 --> 00:30:26,600
different processes, 

455
00:30:28,000 --> 00:30:32,170
which means that visualization means that you need, 

456
00:30:32,920 --> 00:30:36,650
if you have more application or more processes, 

457
00:30:36,660 --> 00:30:38,050
which is a common case, 

458
00:30:38,710 --> 00:30:41,120
then the physical resources, 

459
00:30:41,370 --> 00:30:44,990
the only way you can visualize the resources is to multiplexer. 

460
00:30:46,580 --> 00:30:49,370
You can multiply them in space or in time. 

461
00:30:50,420 --> 00:30:51,470
Right? 

462
00:30:53,360 --> 00:31:01,250
So one classic example about visualizing in time is cpu you multiply the

463
00:31:01,260 --> 00:31:03,610
cpu so that in time qanta, 

464
00:31:03,620 --> 00:31:05,260
so for each time qanta, 

465
00:31:05,270 --> 00:31:07,240
you let another process to run. 

466
00:31:08,410 --> 00:31:09,240
And therefore, 

467
00:31:09,250 --> 00:31:17,180
each process has illusion that it owns as acpu the a slower cpu than

468
00:31:17,190 --> 00:31:24,900
the physical cpu the second one is

469
00:31:24,950 --> 00:31:27,340
another important resource is memory. 

470
00:31:27,840 --> 00:31:30,900
This is what we are going to start learning about today, 

471
00:31:30,910 --> 00:31:32,300
how to visualize the memory. 

472
00:31:34,020 --> 00:31:41,820
And the other important one is a disk or storage nine. 

473
00:31:43,990 --> 00:31:45,410
Why memory is important? 

474
00:31:45,420 --> 00:31:47,050
Why do you want to visualize memory? 

475
00:31:49,140 --> 00:31:54,230
It's very important because the entire state of a process or application

476
00:31:55,540 --> 00:31:58,390
is stored or not entire state, 

477
00:31:58,400 --> 00:32:00,350
but most of the state or the active state, 

478
00:32:00,880 --> 00:32:03,870
the state which is used by the process on europe when it runs, 

479
00:32:04,770 --> 00:32:08,260
is stored in the memory and the registers. 

480
00:32:10,820 --> 00:32:11,370
Okay? 

481
00:32:13,560 --> 00:32:14,230
Therefore, 

482
00:32:15,080 --> 00:32:17,070
you cannot have two threads, 

483
00:32:17,080 --> 00:32:18,150
use the same memo, 

484
00:32:27,150 --> 00:32:28,740
always use the same memory, 

485
00:32:30,610 --> 00:32:32,090
because it's, again,

486
00:32:32,100 --> 00:32:35,800
like two different pieces of data cannot go by the same location. 

487
00:32:37,500 --> 00:32:46,770
And sometimes you don't want stress to have access to each other memory. 

488
00:32:47,060 --> 00:32:47,390
Right? 

489
00:32:48,230 --> 00:32:49,780
Here, you have memory protection.

490
00:32:50,530 --> 00:32:53,690
And remember, how do you provide memory protection?

491
00:32:54,070 --> 00:32:54,790
You provide them. 

492
00:32:54,800 --> 00:32:56,670
We are going to see the mechanics here. 

493
00:32:57,100 --> 00:32:58,780
But the abstraction is a process. 

494
00:32:59,320 --> 00:32:59,700
Right? 

495
00:33:00,340 --> 00:33:02,100
Each process in its own memory, 

496
00:33:02,610 --> 00:33:04,490
all the threading the same process, 

497
00:33:04,810 --> 00:33:05,900
shares our memory, 

498
00:33:07,150 --> 00:33:08,790
stressing the different processes, 

499
00:33:09,130 --> 00:33:14,810
cannot share the cannot access each other memory. 

500
00:33:21,910 --> 00:33:25,180
Now, going back and recalling the four fundamental lawyers concepts,

501
00:33:25,190 --> 00:33:27,500
we have thread with the execution context. 

502
00:33:31,910 --> 00:33:36,970
It represent the control state, 

503
00:33:38,170 --> 00:33:41,120
which is program counter registers, 

504
00:33:41,460 --> 00:33:44,340
everything which is needed to execute that threat, 

505
00:33:45,940 --> 00:33:47,340
then in the address space, 

506
00:33:48,330 --> 00:33:56,940
which is owns the entire memory accessible by the program for accessing in sweden, 

507
00:33:56,950 --> 00:33:57,300
right? 

508
00:34:00,300 --> 00:34:01,670
Then is a process, 

509
00:34:03,200 --> 00:34:05,590
which is an instance of a running program. 

510
00:34:06,120 --> 00:34:07,360
And the process, 

511
00:34:07,870 --> 00:34:11,910
its address space plus one more threads. 

512
00:34:12,850 --> 00:34:19,900
Then we have this dual mode operation between the system and user. 

513
00:34:21,060 --> 00:34:28,500
The system has the ability to access more resources than

514
00:34:29,090 --> 00:34:31,880
the user programs. 

515
00:34:39,020 --> 00:34:46,100
So let's talk then about visualized memory. 

516
00:34:48,210 --> 00:34:48,640
First, 

517
00:34:48,650 --> 00:34:56,220
let's start with the concept of address space and others translation. 

518
00:34:58,250 --> 00:35:07,960
An address space is a set of contiguous set of memory addresses, 

519
00:35:09,170 --> 00:35:13,670
which have seen by the process or the application. 

520
00:35:18,060 --> 00:35:22,190
Typically, the unit for memory is byte,

521
00:35:23,970 --> 00:35:27,470
and the size is expressed in power of two. 

522
00:35:29,700 --> 00:35:33,950
For instance, if you have to power 10 bytes,

523
00:35:33,960 --> 00:35:39,410
this means you have1,024 bytes, 

524
00:35:39,420 --> 00:35:45,280
which is one kilobyte is b capital b stands for byte. 

525
00:35:46,690 --> 00:35:48,660
A byte has 8 bits, 

526
00:35:52,740 --> 00:35:54,990
and then you have an address, 

527
00:35:56,750 --> 00:36:02,600
and the others choose to access individual bytes in this outer space. 

528
00:36:04,630 --> 00:36:10,640
Again, the number of bits in the address is basically, in this case,

529
00:36:10,650 --> 00:36:12,240
is k or ten, 

530
00:36:12,250 --> 00:36:13,360
in this example, 

531
00:36:14,630 --> 00:36:21,550
is the exponent right of two when you define compute the memory size. 

532
00:36:24,310 --> 00:36:25,520
And this should be very easy. 

533
00:36:25,890 --> 00:36:26,910
But I do remember, right?

534
00:36:26,920 --> 00:36:35,410
If you have and addresses how many bits you need to encode this analysis, 

535
00:36:36,760 --> 00:36:38,920
a bit has to value zero and one. 

536
00:36:39,440 --> 00:36:43,050
You need log of n in this case, 

537
00:36:43,060 --> 00:36:46,680
n is to k log base two of two. 

538
00:36:46,690 --> 00:36:51,690
K is k how many bits of others? 

539
00:36:52,090 --> 00:36:55,380
Each byte, but a bit of others,

540
00:36:57,420 --> 00:37:01,560
how many bits you need to address each byte in a 4 kilobyte page? 

541
00:37:05,680 --> 00:37:06,520
Is 12, right?

542
00:37:06,530 --> 00:37:08,840
Because two power 12 is four kilobytes. 

543
00:37:11,760 --> 00:37:14,690
And obviously, 

544
00:37:14,980 --> 00:37:17,490
if you have20 bits to address, 

545
00:37:17,500 --> 00:37:20,210
you can address 2.2 power 20. 

546
00:37:24,170 --> 00:37:25,190
But bytes, 

547
00:37:25,930 --> 00:37:27,010
you have 32 beats. 

548
00:37:27,020 --> 00:37:30,050
You can address the power of 32 bytes and so forth. 

549
00:37:33,490 --> 00:37:34,460
But this is what? 

550
00:37:34,720 --> 00:37:41,100
A process ca contiguous set of addresses, 

551
00:37:43,060 --> 00:37:44,530
typically one at each other. 

552
00:37:44,540 --> 00:37:46,570
As you have 1 byte, you can store 1 byte.

553
00:37:47,280 --> 00:37:48,520
1 byte is 8 bits. 

554
00:37:51,270 --> 00:37:58,880
And then the process uses this address

555
00:37:58,890 --> 00:38:02,260
space to store various information, 

556
00:38:03,040 --> 00:38:04,080
code and data. 

557
00:38:09,320 --> 00:38:11,300
And axis you will address. 

558
00:38:12,410 --> 00:38:15,250
Accessible addresses are all the addresses. 

559
00:38:15,260 --> 00:38:22,040
A process can read and write or write and the state associated with them. 

560
00:38:22,750 --> 00:38:24,740
What is stored as a particular others? 

561
00:38:29,790 --> 00:38:30,780
In some cases, 

562
00:38:30,790 --> 00:38:38,020
we are also measuring or give the size of a memory in awards. 

563
00:38:39,380 --> 00:38:45,530
And award typically has more than 1 bytes. 

564
00:38:47,050 --> 00:38:48,160
For instance, 

565
00:38:49,230 --> 00:38:51,430
a forward is 32 bits. 

566
00:38:54,970 --> 00:39:02,780
One question here is how many 32 beats numbers or 4 byte words you

567
00:39:02,790 --> 00:39:06,330
can feed in an address space of, 

568
00:39:06,910 --> 00:39:07,330
right? 

569
00:39:07,880 --> 00:39:08,940
We set it to beats, 

570
00:39:09,650 --> 00:39:10,070
right? 

571
00:39:12,570 --> 00:39:13,760
You have 72 beats, 

572
00:39:13,770 --> 00:39:14,880
so you have two powers, 

573
00:39:14,890 --> 00:39:17,020
32 bytes. 

574
00:39:18,310 --> 00:39:19,420
You need to divide by four, 

575
00:39:19,430 --> 00:39:20,980
because award is 4 bytes. 

576
00:39:20,990 --> 00:39:23,060
You get to power circuit, which is 1 billion.

577
00:39:30,480 --> 00:39:32,710
Now, we are going to learn more about that,

578
00:39:32,720 --> 00:39:38,890
but that's for you to know that when you read and write to an address, 

579
00:39:39,840 --> 00:39:42,190
there are many things can happen. 

580
00:39:43,910 --> 00:39:50,560
The most natural thing is that you read and write that particular piece of data, 

581
00:39:51,360 --> 00:39:54,160
which is associated with the address that we should read and write. 

582
00:39:56,830 --> 00:39:58,840
But other things could happen. 

583
00:40:01,390 --> 00:40:05,350
You can actually, when you write or to special designated addresses,

584
00:40:06,510 --> 00:40:08,860
or you read from special designated addresses, 

585
00:40:09,840 --> 00:40:14,690
you can read and write to some device like more like display. 

586
00:40:17,890 --> 00:40:19,600
And these are memory mapped, 

587
00:40:19,920 --> 00:40:23,890
io operations that we can, 

588
00:40:24,150 --> 00:40:28,790
cause a program to aboard when is a program or do second. 

589
00:40:30,580 --> 00:40:31,770
When this can happen, 

590
00:40:32,210 --> 00:40:33,530
when does programs at fault? 

591
00:40:37,320 --> 00:40:42,410
You should know by now you've done homeworks projects. 

592
00:40:43,090 --> 00:40:51,010
I'm sure that this is many of you had this unfortunate experience and map memory. 

593
00:40:53,940 --> 00:40:54,060
Yeah. 

594
00:40:54,070 --> 00:40:54,820
So basically, 

595
00:40:57,090 --> 00:41:04,630
if i'm going to try to access an address

596
00:41:05,750 --> 00:41:08,690
which I don't is not accessible to me, 

597
00:41:10,090 --> 00:41:13,480
i'm going to read from and write from address which is not accessible. 

598
00:41:18,370 --> 00:41:19,160
That's fine. 

599
00:41:19,170 --> 00:41:25,080
Or the some addresses owned by other

600
00:41:32,520 --> 00:41:32,580
processes. 

601
00:41:36,240 --> 00:41:37,270
As you are now, 

602
00:41:37,520 --> 00:41:40,390
in the address space, there are three parts, four particle,

603
00:41:40,400 --> 00:41:42,910
four important segments for each process. 

604
00:41:43,690 --> 00:41:46,130
You have the code segment which contains the code. 

605
00:41:47,340 --> 00:41:52,660
You are going to execute the stack segment, 

606
00:41:53,460 --> 00:41:58,920
which you now is used to push the return addresses when you call

607
00:41:58,930 --> 00:42:01,280
a function and also pass

608
00:42:01,290 --> 00:42:03,600
the arguments or to that function, 

609
00:42:05,330 --> 00:42:11,190
is a heap for dynamically allocating memory

610
00:42:12,810 --> 00:42:15,460
and its static data, 

611
00:42:16,850 --> 00:42:17,690
which is for what? 

612
00:42:18,930 --> 00:42:23,620
For a static data is implied like global variables. 

613
00:42:32,600 --> 00:42:35,260
You seen this picture many times, 

614
00:42:36,020 --> 00:42:37,900
apologize for showing you again. 

615
00:42:39,240 --> 00:42:44,220
But as if you remember the relation, this shows you again,

616
00:42:44,230 --> 00:42:46,780
the relation between a process and a threat, 

617
00:42:46,790 --> 00:42:52,990
a process can have multiple threads, 

618
00:42:55,460 --> 00:42:57,700
all threads in the same process, 

619
00:42:58,510 --> 00:43:00,010
share resources, 

620
00:43:00,860 --> 00:43:05,700
including most of the memory resources, 

621
00:43:07,070 --> 00:43:09,350
including heap, 

622
00:43:09,850 --> 00:43:10,490
static, 

623
00:43:11,530 --> 00:43:13,020
and co segments. 

624
00:43:14,280 --> 00:43:19,430
The only one segment they don't share is a stack. 

625
00:43:20,660 --> 00:43:21,900
And the registers obvious. 

626
00:43:22,990 --> 00:43:25,490
And the reason you don't share the stack, because again,

627
00:43:25,500 --> 00:43:29,380
the stack contains the state of the execution. 

628
00:43:30,040 --> 00:43:32,630
But if you call a function in the thread, 

629
00:43:33,840 --> 00:43:37,950
then you have to push the return On the stack. 

630
00:43:39,390 --> 00:43:44,080
So now that represent the execution state of that thread, 

631
00:43:46,120 --> 00:43:48,590
you can also have a single threaded process, 

632
00:43:48,600 --> 00:43:50,310
which has a single thread. 

633
00:43:53,190 --> 00:43:56,190
There are three important aspects of memory multiplex. 

634
00:43:57,930 --> 00:43:59,160
One is protection. 

635
00:44:00,940 --> 00:44:09,360
You prevent a process from accessing the data of another process. 

636
00:44:12,990 --> 00:44:20,780
The second one is translation is the ability to translate from a

637
00:44:21,070 --> 00:44:24,200
visual address space to a physical address space. 

638
00:44:24,640 --> 00:44:25,620
We'll learn about. 

639
00:44:28,930 --> 00:44:31,050
And when this translation occurs, 

640
00:44:31,460 --> 00:44:33,550
you are going to have these future others. 

641
00:44:37,560 --> 00:44:40,910
This can be used to avoid overlap or talk next, 

642
00:44:42,210 --> 00:44:47,080
provide a uniform view to the program to the process. 

643
00:44:49,870 --> 00:44:55,180
And also can be used to provide products. 

644
00:44:57,990 --> 00:44:59,750
And the control overlap. 

645
00:45:03,900 --> 00:45:09,850
Its separate state of the thread should not cause colliding physical memory. 

646
00:45:11,040 --> 00:45:12,230
This means that, again,

647
00:45:12,240 --> 00:45:21,510
we have only one physical memory in the same a a on a single machine. 

648
00:45:21,520 --> 00:45:23,670
So you have different processes, 

649
00:45:24,420 --> 00:45:25,420
different threads, 

650
00:45:26,330 --> 00:45:27,470
they shouldn't collect. 

651
00:45:27,810 --> 00:45:28,960
But I they shouldn't, 

652
00:45:33,550 --> 00:45:35,880
for instance, share the same, I don't know,

653
00:45:36,890 --> 00:45:38,060
share the same data segments. 

654
00:45:45,000 --> 00:45:53,430
An alternative view is to have to look at at what is the allowable process behavior, 

655
00:45:55,620 --> 00:45:56,030
right? 

656
00:45:56,420 --> 00:45:58,010
What do you allow process to go? 

657
00:46:04,360 --> 00:46:06,040
And this, 

658
00:46:06,050 --> 00:46:07,600
what is allowed to do? 

659
00:46:11,790 --> 00:46:13,940
It's regulated by the operating system. 

660
00:46:16,740 --> 00:46:18,490
The operating system, in one way,

661
00:46:18,500 --> 00:46:21,570
is interposing itself. 

662
00:46:21,580 --> 00:46:24,170
So to make sure that the processes are well behaved. 

663
00:46:25,910 --> 00:46:30,180
That's why and the processes don't do anything back. 

664
00:46:31,160 --> 00:46:38,530
The operating system is handling the eye operations on the behalf of the processes. 

665
00:46:40,670 --> 00:46:44,710
It makes sure that every process get access to the cpu, 

666
00:46:47,290 --> 00:46:48,560
like you'll see, 

667
00:46:49,140 --> 00:46:52,690
is going to make sure that each process, 

668
00:46:53,030 --> 00:46:58,200
it gets its own physical memory under the hood. 

669
00:46:58,990 --> 00:46:59,430
Okay? 

670
00:47:02,320 --> 00:47:04,270
The question is, how do you enforce that?

671
00:47:06,930 --> 00:47:08,820
In the previous two cases, 

672
00:47:09,010 --> 00:47:11,050
the operating system, 

673
00:47:12,550 --> 00:47:15,400
it's like this requires a context switch. 

674
00:47:16,380 --> 00:47:16,660
Right? 

675
00:47:16,670 --> 00:47:18,100
I operation. 

676
00:47:18,110 --> 00:47:20,210
You is a cisco. 

677
00:47:20,530 --> 00:47:26,190
It's a context switch for the cpu we share them to multiply the cpu

678
00:47:26,200 --> 00:47:28,590
between different processes or threads. 

679
00:47:28,910 --> 00:47:30,120
You need to do context switch, 

680
00:47:30,870 --> 00:47:31,190
right? 

681
00:47:31,780 --> 00:47:32,940
And context we can remember, 

682
00:47:34,390 --> 00:47:35,260
it's expensive. 

683
00:47:36,070 --> 00:47:37,530
It can be tens of thousand, 

684
00:47:37,540 --> 00:47:38,980
hundreds of thousands of instructions. 

685
00:47:40,750 --> 00:47:42,140
Now, the question here is,

686
00:47:42,550 --> 00:47:43,700
what about the memory? 

687
00:47:44,480 --> 00:47:45,880
It doesn't seem, there's a memory.

688
00:47:45,890 --> 00:47:47,000
You can do that. 

689
00:47:47,610 --> 00:47:49,140
Whenever you access to the memory, 

690
00:47:50,830 --> 00:47:52,640
it's too expensive. 

691
00:47:54,170 --> 00:48:00,040
You need to have another way to make this kind of translation to interpose, 

692
00:48:01,150 --> 00:48:03,980
to have this interposition layer between the virtual memory

693
00:48:03,990 --> 00:48:04,900
and the physical matter. 

694
00:48:07,930 --> 00:48:09,520
If there are exception cases, 

695
00:48:09,530 --> 00:48:10,880
like you'll see like page four, 

696
00:48:10,890 --> 00:48:16,130
you'll see that then you can give the control to the operating system. 

697
00:48:16,140 --> 00:48:18,720
You can have the opposite operating system, 

698
00:48:18,850 --> 00:48:20,010
interpose interposing itself. 

699
00:48:22,550 --> 00:48:24,180
We learn about that. 

700
00:48:27,280 --> 00:48:28,750
Again, this is a previous picture.

701
00:48:28,760 --> 00:48:29,710
You've seen. 

702
00:48:30,160 --> 00:48:31,710
One of the first lectures, 

703
00:48:34,820 --> 00:48:37,100
everything here in this big box. 

704
00:48:37,110 --> 00:48:39,980
It's harder in the operating system. 

705
00:48:39,990 --> 00:48:45,070
And it with this big box provides a visualization of the os

706
00:48:45,080 --> 00:48:48,540
and of the machine to the application. 

707
00:48:49,410 --> 00:48:51,570
That's all of the operating system. 

708
00:48:58,270 --> 00:49:04,300
And just to for big picture of what happens under the hood when you execute

709
00:49:04,310 --> 00:49:05,020
a program. 

710
00:49:05,680 --> 00:49:07,330
To remember, if you remember,

711
00:49:07,860 --> 00:49:09,020
your copy is a program. 

712
00:49:09,030 --> 00:49:14,820
It's on the disk that you copy the code in the memory, 

713
00:49:15,490 --> 00:49:16,700
and then you start executive. 

714
00:49:19,470 --> 00:49:21,660
Let's see what happens when you execute. 

715
00:49:21,670 --> 00:49:30,820
And here a it's a a snippet of assembly language. 

716
00:49:35,660 --> 00:49:37,850
And basically, what happens here?

717
00:49:37,860 --> 00:49:44,810
You allowed some from this address data one, 

718
00:49:45,680 --> 00:49:48,310
the data, which is there and register at one.

719
00:49:48,820 --> 00:49:50,640
And depending on the value, 

720
00:49:50,650 --> 00:49:55,800
you are going to jump to this address. 

721
00:49:56,540 --> 00:49:57,570
Otherwise, 

722
00:49:57,580 --> 00:50:00,980
you are going to decrement the value. 

723
00:50:01,420 --> 00:50:03,110
And then you are going to, look,

724
00:50:03,120 --> 00:50:06,430
you go to until it's not zero, 

725
00:50:06,440 --> 00:50:09,550
b and z means r one is not zero. 

726
00:50:09,860 --> 00:50:10,570
You go back. 

727
00:50:13,670 --> 00:50:15,780
Basically, as long as it's not,

728
00:50:16,340 --> 00:50:18,890
when it's zero, you jump out of you terminate.

729
00:50:25,780 --> 00:50:27,210
Basically, in this code,

730
00:50:27,220 --> 00:50:28,490
take a piece of data, 

731
00:50:29,710 --> 00:50:30,430
checks it. 

732
00:50:32,730 --> 00:50:37,490
And then you take advantage, 

733
00:50:38,660 --> 00:50:41,990
and then you go back. 

734
00:50:45,640 --> 00:50:48,020
So what is in memory for this program? 

735
00:50:48,030 --> 00:50:48,740
Or do you start? 

736
00:50:49,730 --> 00:50:51,310
So in memory, you have only beats.

737
00:50:55,760 --> 00:50:57,470
This is an example here. 

738
00:51:00,080 --> 00:51:03,310
And you have 2 columns for the physical address. 

739
00:51:04,140 --> 00:51:06,500
The column on the left are the addresses. 

740
00:51:08,720 --> 00:51:13,620
And the column on the right are the content is the content of the novels. 

741
00:51:17,060 --> 00:51:19,420
In this memory layout. 

742
00:51:20,630 --> 00:51:23,340
We are using 4 byte words. 

743
00:51:23,800 --> 00:51:24,780
How do you see that? 

744
00:51:26,080 --> 00:51:28,750
You see this number here on the right, 0000.

745
00:51:29,920 --> 00:51:32,990
You have 1234560cents, and20.

746
00:51:34,350 --> 00:51:36,060
You have eight characters. 

747
00:51:36,920 --> 00:51:38,640
Each of these characters, 

748
00:51:42,280 --> 00:51:44,110
a sorry, 

749
00:51:44,120 --> 00:51:45,510
represent4bits, 

750
00:51:46,360 --> 00:51:46,760
right? 

751
00:51:47,600 --> 00:51:49,230
It's a hexadecimal format. 

752
00:51:51,160 --> 00:51:57,800
It's from zero to f each of these is from zero to f we have eight of them, 

753
00:51:57,810 --> 00:52:01,430
8times for its 32bits. 

754
00:52:02,630 --> 00:52:04,260
They have 32 bits worth, 

755
00:52:04,530 --> 00:52:06,100
or for byte work. 

756
00:52:10,460 --> 00:52:17,980
The sink with a red are the addresses which also appears in the program. 

757
00:52:19,250 --> 00:52:20,580
You have three addresses, 

758
00:52:20,590 --> 00:52:21,620
four addresses. 

759
00:52:22,270 --> 00:52:25,010
One is the address for this data one. 

760
00:52:26,580 --> 00:52:27,720
This is red. 

761
00:52:29,130 --> 00:52:32,070
The blue one is check it, 

762
00:52:32,080 --> 00:52:35,890
address the green one. 

763
00:52:35,900 --> 00:52:37,130
It's a loop. 

764
00:52:40,440 --> 00:52:48,190
Others now, 

765
00:52:49,390 --> 00:52:50,390
tell me now, 

766
00:52:51,010 --> 00:52:52,050
I said that, 

767
00:52:52,750 --> 00:52:53,920
say, take with the red,

768
00:52:53,930 --> 00:52:57,390
I said that z zero zero, c zero,

769
00:52:57,800 --> 00:52:58,880
which is a program, 

770
00:52:58,890 --> 00:53:01,190
refers to this0300. 

771
00:53:03,340 --> 00:53:09,850
Can you figure out how these are connected and why they are connected? 

772
00:53:09,860 --> 00:53:11,530
Why basically the same thing? 

773
00:53:37,920 --> 00:53:38,870
So here it is. 

774
00:53:44,120 --> 00:53:51,550
If you address the memory at 32 beats boundaries, 

775
00:53:53,050 --> 00:53:55,320
so an address as the word granularity, 

776
00:53:56,230 --> 00:53:57,350
each order is 4bytes. 

777
00:54:00,360 --> 00:54:03,130
You need 4 times fewer addresses. 

778
00:54:06,390 --> 00:54:07,100
That's what it is. 

779
00:54:09,040 --> 00:54:10,710
That's basically what happens here. 

780
00:54:11,410 --> 00:54:11,620
Right? 

781
00:54:11,630 --> 00:54:14,510
When the program is going to, 

782
00:54:17,060 --> 00:54:18,940
look, you compile the program.

783
00:54:20,090 --> 00:54:21,700
And when you allocate the memory, 

784
00:54:22,680 --> 00:54:27,590
everything happens at forward for the 4bytes, 

785
00:54:27,600 --> 00:54:29,870
granite or 32 beats granite. 

786
00:54:31,970 --> 00:54:34,570
There are four as this granularity. 

787
00:54:34,580 --> 00:54:37,860
We need 4 times fewer so to speak, 

788
00:54:38,960 --> 00:54:41,100
addresses or beats. 

789
00:54:42,870 --> 00:54:44,020
This is what happens here. 

790
00:54:45,330 --> 00:54:49,360
00, c zero is0300,

791
00:54:49,690 --> 00:54:51,990
but is absurdity, rupees, granularity.

792
00:54:52,380 --> 00:54:56,470
Instead of at the 8 bit or background. 

793
00:54:58,890 --> 00:54:59,560
Indeed, 

794
00:55:00,600 --> 00:55:03,040
if you multiply c zero by4, 

795
00:55:04,280 --> 00:55:06,360
you get300. 

796
00:55:12,580 --> 00:55:13,580
Any questions here? 

797
00:55:28,750 --> 00:55:29,980
The same for the other one. 

798
00:55:29,990 --> 00:55:31,620
If you multiply grade zero, 

799
00:55:31,630 --> 00:55:33,540
you are going to get a00. 

800
00:55:33,550 --> 00:55:35,740
If you multiply 0to42×4, 

801
00:55:35,750 --> 00:55:38,020
you get0908. 

802
00:55:41,130 --> 00:55:47,620
Now, this is how these values are stored in the physical memories,

803
00:55:47,630 --> 00:55:49,700
another way in another representation. 

804
00:55:50,750 --> 00:55:51,200
Right? 

805
00:55:52,280 --> 00:55:55,210
You have the values in these boxes. 

806
00:55:55,780 --> 00:55:57,970
And the address is on the side. 

807
00:56:02,500 --> 00:56:03,810
Now, here is a question.

808
00:56:06,150 --> 00:56:07,830
Say i'm running this program, 

809
00:56:08,740 --> 00:56:10,870
and this program loads into physical memory. 

810
00:56:10,880 --> 00:56:13,210
And these addresses, right?

811
00:56:13,220 --> 00:56:14,730
Because these are the addresses, 

812
00:56:15,730 --> 00:56:20,070
maybe in the program on the disk. 

813
00:56:23,410 --> 00:56:25,100
If I run again this program, 

814
00:56:27,560 --> 00:56:28,270
what will happen? 

815
00:56:30,310 --> 00:56:34,620
But I if I run again this program, 

816
00:56:34,630 --> 00:56:40,700
I don't want to load to be loaded exactly in the same place, 

817
00:56:45,210 --> 00:56:50,060
because a different instance of the problem by different data. 

818
00:56:54,860 --> 00:56:57,070
So that's one of the problem we need to solve. 

819
00:56:58,520 --> 00:56:59,600
You need this translation. 

820
00:57:01,950 --> 00:57:03,640
So one way to do the translation. 

821
00:57:03,650 --> 00:57:08,170
So instead of I modify these addresses with this nuance, 

822
00:57:08,850 --> 00:57:09,560
now, 

823
00:57:10,300 --> 00:57:15,670
all these addresses will not overlap with a previous instance. 

824
00:57:15,680 --> 00:57:18,750
They are going to not overlap to be non overlapping. 

825
00:57:19,170 --> 00:57:23,590
And you are going to be able to load the second time you run

826
00:57:23,600 --> 00:57:27,520
the same program at a different address space. 

827
00:57:28,030 --> 00:57:32,350
So the two programs now they don't step on each other. 

828
00:57:41,160 --> 00:57:47,510
So there are many way to possible way to translate. 

829
00:57:47,520 --> 00:57:48,790
This is only one possibility. 

830
00:57:51,690 --> 00:57:58,340
So translation can happens at 2times the link time, 

831
00:58:01,290 --> 00:58:05,980
when or before in our execution time. 

832
00:58:06,670 --> 00:58:13,920
I it's compile time, link time, and execution time,

833
00:58:14,460 --> 00:58:16,700
but link or lower time. 

834
00:58:17,590 --> 00:58:19,310
So compile time, 

835
00:58:22,060 --> 00:58:22,820
it's very hard. 

836
00:58:23,330 --> 00:58:25,030
We are not going to talk much about it. 

837
00:58:25,910 --> 00:58:27,370
The link and low time. 

838
00:58:27,650 --> 00:58:30,040
It's we are going to talk briefly, 

839
00:58:30,050 --> 00:58:37,080
and then we are going to focus mostly when the translation happened and execution. 

840
00:58:37,090 --> 00:58:43,520
So before talking about link low time translation, 

841
00:58:43,890 --> 00:58:50,360
let's remind ourselves what is the lifetime of a program? 

842
00:58:52,140 --> 00:58:53,460
You start with the source, 

843
00:58:54,880 --> 00:58:57,620
you compile, you get the object modules,

844
00:58:58,600 --> 00:59:05,280
then you link response possible other modules and libraries, 

845
00:59:05,290 --> 00:59:09,340
and then you load it in the memory. 

846
00:59:10,000 --> 00:59:13,660
And in the process, you are going also to the link with some system,

847
00:59:13,960 --> 00:59:15,300
libraries and some libraries. 

848
00:59:15,310 --> 00:59:19,970
You can actually link them at the run time after you started executive. 

849
00:59:21,480 --> 00:59:21,910
Okay. 

850
00:59:23,420 --> 00:59:25,700
But here is our previous example. 

851
00:59:25,710 --> 00:59:27,660
Actually, what implicitly done?

852
00:59:29,710 --> 00:59:33,950
You modify the addresses before loading to memory. 

853
00:59:34,680 --> 00:59:37,630
This is linked load time when you modify the others. 

854
00:59:38,630 --> 00:59:39,020
Right? 

855
00:59:39,420 --> 00:59:40,460
Remember, here,

856
00:59:40,980 --> 00:59:42,520
we said this is our program, 

857
00:59:43,720 --> 00:59:44,040
right? 

858
00:59:45,820 --> 00:59:47,170
Maybe this is on the disk. 

859
00:59:49,260 --> 00:59:54,780
But when I am cooperating system is going to load this program in memory, 

860
00:59:55,160 --> 01:00:02,440
is going to override these addresses that is not going to overlap

861
01:00:02,450 --> 01:00:03,480
with other programs, 

862
01:00:03,490 --> 01:00:05,120
which are already in the physical amount. 

863
01:00:12,130 --> 01:00:13,160
So this is what happens. 

864
01:00:13,170 --> 01:00:13,800
Okay? 

865
01:00:21,570 --> 01:00:22,130
Make sense? 

866
01:00:22,140 --> 01:00:23,330
It's any questions? 

867
01:00:29,970 --> 01:00:33,130
Now, a little bit of history,

868
01:00:35,200 --> 01:00:35,860
again, 

869
01:00:36,650 --> 01:00:43,990
the earliest operating systems for personal computers were very simple. 

870
01:00:46,000 --> 01:00:47,760
You have only one other space, 

871
01:00:49,160 --> 01:00:53,110
and you have only one application and you got a given time. 

872
01:00:54,280 --> 01:01:00,290
The application was owning the entire physical address space. 

873
01:01:02,580 --> 01:01:05,340
You have the illusion of a dedicated machine, 

874
01:01:06,030 --> 01:01:14,330
because you have a dedicated machine. 

875
01:01:16,510 --> 01:01:17,780
How do you do this? 

876
01:01:18,560 --> 01:01:19,580
Now is the next step. 

877
01:01:20,760 --> 01:01:24,000
If you start to work to run multiple programs, 

878
01:01:24,980 --> 01:01:27,540
you want to run in the same computer. 

879
01:01:28,220 --> 01:01:31,760
It's again, if the operating system doesn't provide your support,

880
01:01:34,520 --> 01:01:36,040
like you see for translation, 

881
01:01:37,180 --> 01:01:39,410
the one way you can do it, 

882
01:01:39,420 --> 01:01:40,850
like we've just seen, 

883
01:01:42,830 --> 01:01:44,590
it's basically translation. 

884
01:01:44,600 --> 01:01:52,250
You translate the addresses of the program before you load it to avoid overlapping, 

885
01:01:52,590 --> 01:01:54,680
conflicting with another program. 

886
01:01:56,200 --> 01:02:01,350
This was a case for early version of the microsoft windows, three,

887
01:02:03,230 --> 01:02:05,980
the windows, the early version of the windows.

888
01:02:08,740 --> 01:02:09,780
With these things, 

889
01:02:09,790 --> 01:02:10,820
it's risky. 

890
01:02:10,830 --> 01:02:15,760
There is no protection to the buggy code and applicable all applications

891
01:02:15,770 --> 01:02:18,630
here have access to the entire memory. 

892
01:02:20,240 --> 01:02:25,160
One application can read and write the data from another application. 

893
01:02:26,580 --> 01:02:32,650
So it can also crash another application. 

894
01:02:32,660 --> 01:02:37,620
The next level is to provide protection is still one other space. 

895
01:02:38,460 --> 01:02:41,820
Still, the applications are going to be,

896
01:02:42,510 --> 01:02:47,260
the addresses will be overwritten when you went by the louder

897
01:02:48,630 --> 01:02:52,170
before loading the application, 

898
01:02:52,180 --> 01:02:53,610
the program to the memory. 

899
01:02:55,100 --> 01:02:56,860
But now you do have protection. 

900
01:02:57,950 --> 01:02:59,390
How do you have protections? 

901
01:03:00,860 --> 01:03:01,730
Base and bound? 

902
01:03:01,740 --> 01:03:04,190
Do you remember about this? 

903
01:03:04,200 --> 01:03:05,110
We talk about that. 

904
01:03:06,070 --> 01:03:09,030
You have a base and a bound and associated with each application. 

905
01:03:09,040 --> 01:03:18,330
And you make sure that when the applications is going to a access, 

906
01:03:18,340 --> 01:03:18,810
a memory, 

907
01:03:18,820 --> 01:03:21,970
that address is going to be between base and bound. 

908
01:03:24,260 --> 01:03:26,290
This was in 31 super computer, 

909
01:03:26,300 --> 01:03:27,850
one of the first super computer. 

910
01:03:31,070 --> 01:03:31,780
This is what we do. 

911
01:03:31,790 --> 01:03:36,230
If like we have address of the program here, 

912
01:03:36,240 --> 01:03:37,350
101. 

913
01:03:37,940 --> 01:03:43,280
The base you have base is 1000 is bound1100. 

914
01:03:43,780 --> 01:03:45,810
When you address, you are going to check.

915
01:03:47,630 --> 01:03:52,870
Sorry, you are going to check whether it's between100, and110.

916
01:03:53,760 --> 01:03:56,480
If it is, you can access a memory.

917
01:03:56,900 --> 01:03:57,990
Otherwise, 

918
01:03:58,790 --> 01:04:05,460
you are going to set for you protect and isolate programs. 

919
01:04:06,080 --> 01:04:10,980
But this is requires you to, again,

920
01:04:11,650 --> 01:04:15,660
override the addresses of the application before the program, 

921
01:04:15,670 --> 01:04:16,660
before you load it. 

922
01:04:17,060 --> 01:04:20,520
This is also called relocating louder, a louder,

923
01:04:20,530 --> 01:04:21,760
like that is doing that. 

924
01:04:21,770 --> 01:04:24,520
Rewriting is called relocating louder. 

925
01:04:29,370 --> 01:04:30,250
Can be very fast. 

926
01:04:30,580 --> 01:04:35,210
The basin bounds are going to be implemented in harbor. 

927
01:04:36,460 --> 01:04:39,230
And there is its only comparison, 

928
01:04:39,240 --> 01:04:42,030
no addition or nothing can done extremely fast. 

929
01:04:45,780 --> 01:04:46,300
Okay. 

930
01:04:47,120 --> 01:04:49,430
To summarize, we saw unit programming,

931
01:04:49,790 --> 01:04:52,510
no protection, one program at a given time,

932
01:04:52,760 --> 01:04:54,830
multiprogramming, no protection,

933
01:04:54,840 --> 01:04:59,680
but you have multiple programs at a given time in the same physical memory. 

934
01:05:00,100 --> 01:05:05,540
And you need relocating loader to make sure that the programs, 

935
01:05:05,550 --> 01:05:06,300
when you load them, 

936
01:05:06,590 --> 01:05:11,060
you overwrite their addresses so that they don't step on each other. 

937
01:05:11,730 --> 01:05:14,160
Finally, here we have, again,

938
01:05:14,170 --> 01:05:15,880
no protection, 

939
01:05:15,890 --> 01:05:17,200
one physical memory, 

940
01:05:17,210 --> 01:05:18,560
no visualization. 

941
01:05:18,940 --> 01:05:20,970
You have also base and bounds to, 

942
01:05:21,660 --> 01:05:22,410
sorry. 

943
01:05:23,860 --> 01:05:24,450
In this case, 

944
01:05:25,860 --> 01:05:31,200
again, you have only one address physical memory,

945
01:05:32,350 --> 01:05:33,900
only one other space, 

946
01:05:33,910 --> 01:05:36,020
which is shared by the applications. 

947
01:05:36,440 --> 01:05:39,880
But in this case, you provide protection by using base and bounds.

948
01:05:40,090 --> 01:05:41,400
This is provided in harvard. 

949
01:05:44,520 --> 01:05:45,620
So now, 

950
01:05:47,230 --> 01:05:47,790
it's a time. 

951
01:05:47,800 --> 01:05:49,110
This is a pretty complicated, 

952
01:05:49,120 --> 01:05:50,950
like relocating louder and so forth. 

953
01:05:50,960 --> 01:05:52,830
It's pretty complicated and it's pretty limited. 

954
01:05:54,190 --> 01:05:54,880
So next, 

955
01:05:55,340 --> 01:06:00,720
we are going to start discussing about the general address translation. 

956
01:06:01,700 --> 01:06:02,200
Okay? 

957
01:06:04,560 --> 01:06:07,790
The general address translation is happening this way. 

958
01:06:08,750 --> 01:06:09,980
You have the cpu. 

959
01:06:10,390 --> 01:06:13,910
Remember this because sometimes it's little confusion. 

960
01:06:15,770 --> 01:06:17,900
When the cpu issues an instruction. 

961
01:06:19,010 --> 01:06:19,660
In general, 

962
01:06:20,490 --> 01:06:24,330
the instructions contain virtual addresses. 

963
01:06:25,450 --> 01:06:29,130
So these virtual addresses are then mapped to the physical address. 

964
01:06:30,090 --> 01:06:31,500
And they are done, typically,

965
01:06:31,510 --> 01:06:35,110
by cheap or part of the processor, 

966
01:06:35,870 --> 01:06:40,050
which is called mmu memory management unit. 

967
01:06:42,690 --> 01:06:44,160
The programs, 

968
01:06:44,570 --> 01:06:48,530
because they are running on the CPU they see mutual address spaces. 

969
01:06:51,380 --> 01:06:51,790
Okay? 

970
01:06:52,670 --> 01:06:53,670
From the memory side, 

971
01:06:53,680 --> 01:06:55,270
you have only physical addresses. 

972
01:07:08,770 --> 01:07:10,040
In translation, 

973
01:07:10,050 --> 01:07:11,480
it's a generalized technique, 

974
01:07:11,820 --> 01:07:13,570
which helps you is many things. 

975
01:07:15,070 --> 01:07:16,540
But if you really want, 

976
01:07:16,910 --> 01:07:17,940
if you only want, 

977
01:07:19,150 --> 01:07:20,170
like I mentioned, 

978
01:07:20,490 --> 01:07:21,560
protections, 

979
01:07:22,460 --> 01:07:23,850
control, overlap,

980
01:07:24,380 --> 01:07:25,250
and sing like that. 

981
01:07:25,850 --> 01:07:29,870
But if you really want to implement only one of these things like protection, 

982
01:07:29,880 --> 01:07:31,610
like you've seen in the past, 

983
01:07:32,460 --> 01:07:39,400
things are easier while you're on protection, 

984
01:07:39,410 --> 01:07:43,190
because if task a cannot gain access to speed data, 

985
01:07:43,200 --> 01:07:45,950
no way for anr to adversely affect. 

986
01:07:50,150 --> 01:07:50,540
Now, 

987
01:07:51,190 --> 01:07:53,610
if you have the translation, 

988
01:07:54,790 --> 01:08:00,520
then every program can be linked or loaded into the same region of the users. 

989
01:08:02,800 --> 01:08:04,350
Again, you have two applications.

990
01:08:04,360 --> 01:08:05,230
In this case. 

991
01:08:06,460 --> 01:08:10,740
Both applications have different virtual addresses, 

992
01:08:12,460 --> 01:08:13,520
virtual address space, 

993
01:08:14,610 --> 01:08:16,470
because they have their own process. 

994
01:08:17,290 --> 01:08:21,760
And each process has its own address space, visual address.

995
01:08:23,690 --> 01:08:26,380
These boss applications, 

996
01:08:26,910 --> 01:08:30,980
they can see the same virtual memory. 

997
01:08:31,720 --> 01:08:33,440
Both of them, they see visual memory, say,

998
01:08:33,450 --> 01:08:41,230
from 000 to fff the trick here is that these two address spaces are

999
01:08:41,730 --> 01:08:49,430
going to be mapped to different locations in the physical memory by using translation. 

1000
01:08:51,040 --> 01:08:52,640
That's what the translation gives. 

1001
01:08:55,100 --> 01:08:57,920
Let's consider examples. 

1002
01:08:59,860 --> 01:09:02,380
It's a one way to do it. 

1003
01:09:02,390 --> 01:09:09,290
It's a very simple change of the previous

1004
01:09:13,890 --> 01:09:17,050
basin bound technique. 

1005
01:09:20,010 --> 01:09:21,100
Here is a difference. 

1006
01:09:21,110 --> 01:09:23,940
Let me just go back to make sure that it's different, right?

1007
01:09:24,360 --> 01:09:25,070
This is the difference. 

1008
01:09:25,080 --> 01:09:26,230
In this case, 

1009
01:09:27,020 --> 01:09:28,540
the base and bound, 

1010
01:09:29,790 --> 01:09:30,190
right? 

1011
01:09:30,730 --> 01:09:32,070
Are absolute addresses. 

1012
01:09:32,460 --> 01:09:35,040
And the program address is also absolute address. 

1013
01:09:35,380 --> 01:09:36,720
You have 1010, 

1014
01:09:37,310 --> 01:09:38,340
and absolute meaning. 

1015
01:09:38,650 --> 01:09:41,100
I am referring to physical addresses. 

1016
01:09:42,020 --> 01:09:46,130
You need to compare 1010 with the base and with a bound. 

1017
01:09:50,800 --> 01:09:52,170
With translation, 

1018
01:09:52,890 --> 01:09:55,680
the program address is not absolute, 

1019
01:09:55,690 --> 01:09:58,400
is the relative to the bound to the basis. 

1020
01:09:59,750 --> 01:10:01,420
Actually, the real address,

1021
01:10:01,650 --> 01:10:07,110
physical address is a program address plus the base. 

1022
01:10:10,520 --> 01:10:13,750
In this case, a program address is 0010.

1023
01:10:15,970 --> 01:10:17,880
Base address is 1000. 

1024
01:10:18,090 --> 01:10:19,920
If you add them up, it's 1010.

1025
01:10:22,990 --> 01:10:25,580
These addresses are translated on the flight. 

1026
01:10:26,230 --> 01:10:26,410
Right? 

1027
01:10:26,420 --> 01:10:27,290
Very convenient. 

1028
01:10:29,950 --> 01:10:30,880
So you still now, 

1029
01:10:31,990 --> 01:10:33,710
this program addresses, 

1030
01:10:34,450 --> 01:10:35,820
they don't need to be changed. 

1031
01:10:36,110 --> 01:10:39,310
The only thing I need to change in order to make sure that programs

1032
01:10:39,320 --> 01:10:42,230
are mapped into different address spaces. 

1033
01:10:43,990 --> 01:10:47,290
Physical address spaces is the just chains of these others. 

1034
01:10:48,430 --> 01:10:48,710
Right? 

1035
01:10:49,700 --> 01:10:50,160
Indeed, 

1036
01:10:50,850 --> 01:10:51,160
right? 

1037
01:10:53,770 --> 01:10:55,200
It's harder for location. 

1038
01:10:55,210 --> 01:10:59,280
It's also called, then basically,

1039
01:10:59,650 --> 01:11:01,880
a question here, can you touch the program?

1040
01:11:01,890 --> 01:11:11,730
Can you touch the os but if you are careful, 

1041
01:11:12,390 --> 01:11:14,480
we are not going. 

1042
01:11:14,490 --> 01:11:19,440
You cannot touch the os because the os will be outside the base address

1043
01:11:19,450 --> 01:11:22,090
and the bound address of any

1044
01:11:22,800 --> 01:11:24,820
up any user process. 

1045
01:11:26,580 --> 01:11:27,940
Can you touch other programs? 

1046
01:11:27,950 --> 01:11:29,140
Now, if you are careful,

1047
01:11:29,150 --> 01:11:30,420
that's how you provide protection. 

1048
01:11:33,030 --> 01:11:34,540
Again, it's a very simple idea.

1049
01:11:35,900 --> 01:11:37,090
Any questions about that? 

1050
01:11:37,100 --> 01:11:42,210
Do you see how now I no longer need to override the program analysis? 

1051
01:11:42,670 --> 01:11:44,310
When I load the program in memory, 

1052
01:11:44,320 --> 01:11:48,220
I just do that as a runner when the program I give. 

1053
01:11:51,980 --> 01:11:52,780
Any questions? 

1054
01:11:56,680 --> 01:11:56,980
Okay. 

1055
01:11:59,420 --> 01:12:03,890
What are the issues with this basin bound method? 

1056
01:12:06,270 --> 01:12:10,310
The issue here is about what is called is about fragmentation. 

1057
01:12:12,400 --> 01:12:13,870
And this is a very simple example, 

1058
01:12:14,880 --> 01:12:20,790
because each process requires different amount of data, 

1059
01:12:21,250 --> 01:12:23,550
the different amount of space, memory space.

1060
01:12:24,960 --> 01:12:26,070
They are not uniform, 

1061
01:12:29,320 --> 01:12:30,430
because they are not uniform, 

1062
01:12:30,440 --> 01:12:32,670
like in this case process to requires a lot. 

1063
01:12:33,790 --> 01:12:38,320
And you process to goes away. 

1064
01:12:38,330 --> 01:12:40,940
Another process nine comes, 

1065
01:12:41,280 --> 01:12:43,320
you are locates a memory spatial process, 

1066
01:12:43,330 --> 01:12:46,120
9+5 goes away. 

1067
01:12:46,600 --> 01:12:48,940
And now look at this situation, 

1068
01:12:49,400 --> 01:12:50,590
you have process 11, 

1069
01:12:50,600 --> 01:12:53,830
and you have enough physical memory for process 11. 

1070
01:12:54,830 --> 01:13:00,310
But the point that this physical memory is scattered and process 11 needs

1071
01:13:00,320 --> 01:13:03,290
a contiguous region of memory. 

1072
01:13:05,790 --> 01:13:06,580
That's a problem. 

1073
01:13:12,080 --> 01:13:13,190
How do you do it? 

1074
01:13:14,280 --> 01:13:15,420
What is your solution here? 

1075
01:13:17,180 --> 01:13:18,170
There are many solutions. 

1076
01:13:19,690 --> 01:13:21,690
But one simple solution is to have, 

1077
01:13:21,700 --> 01:13:27,030
instead of only one segment for each program, 

1078
01:13:28,360 --> 01:13:29,950
you can have different segments. 

1079
01:13:31,660 --> 01:13:33,570
Typically, you can have code segment,

1080
01:13:33,580 --> 01:13:36,860
data segments that had segment sub segment. 

1081
01:13:38,450 --> 01:13:39,840
You do this independently. 

1082
01:13:40,210 --> 01:13:42,040
This gives you a little bit more flexibility. 

1083
01:13:50,150 --> 01:13:54,480
Also, another problem is the solution I show you here,

1084
01:13:56,570 --> 01:13:58,720
the original solution, the ban,

1085
01:13:58,730 --> 01:14:05,260
the basin bound is that remember about threads and processes. 

1086
01:14:06,430 --> 01:14:09,030
You can have multiple threads in the same process. 

1087
01:14:10,390 --> 01:14:12,060
The site is the same process. 

1088
01:14:12,070 --> 01:14:12,980
Here is a code. 

1089
01:14:14,800 --> 01:14:16,270
But how you are going to do it here, 

1090
01:14:18,480 --> 01:14:18,770
right? 

1091
01:14:23,010 --> 01:14:23,540
Because right? 

1092
01:14:26,650 --> 01:14:29,920
And even like think about, actually,

1093
01:14:30,330 --> 01:14:34,790
you can think about maybe a better example than what I said is libraries. 

1094
01:14:36,140 --> 01:14:41,890
If you have common library system libraries with these libraries, 

1095
01:14:42,460 --> 01:14:44,370
they are used by multiple applications. 

1096
01:14:44,840 --> 01:14:51,760
So it makes no sense to allow the copy of the library for each application

1097
01:14:51,770 --> 01:14:53,760
set up against share system values. 

1098
01:14:54,940 --> 01:14:55,300
Right? 

1099
01:14:56,990 --> 01:14:57,620
How are you doing? 

1100
01:15:02,660 --> 01:15:03,170
Again, 

1101
01:15:04,320 --> 01:15:06,310
now we can alleviate this problem. 

1102
01:15:07,430 --> 01:15:10,780
Like I mentioned that instead of having one segment per process, 

1103
01:15:11,320 --> 01:15:12,760
you have multiple segments, 

1104
01:15:13,400 --> 01:15:13,680
right? 

1105
01:15:14,990 --> 01:15:18,310
But process a typical one, like I mentioned,

1106
01:15:18,320 --> 01:15:20,990
you have code data stacked heap segment. 

1107
01:15:21,700 --> 01:15:24,260
But in general, you can have a segment at one extreme.

1108
01:15:24,270 --> 01:15:25,980
You can have a segment for each function. 

1109
01:15:28,140 --> 01:15:28,490
Right? 

1110
01:15:30,660 --> 01:15:33,930
For a segment, you have a base and a bound or a limit.

1111
01:15:35,020 --> 01:15:37,090
Now, because the segments are smaller,

1112
01:15:37,100 --> 01:15:40,330
you have more flexibility how to place them in the physical, 

1113
01:15:41,370 --> 01:15:42,880
in the physical memory. 

1114
01:15:43,960 --> 01:15:47,410
Let me go back here in this process 11. 

1115
01:15:47,420 --> 01:15:48,890
If this process 11, 

1116
01:15:50,000 --> 01:15:54,540
maybe it had been consisted by from two segments. 

1117
01:15:56,210 --> 01:15:57,230
Then you'd have feet. 

1118
01:15:57,240 --> 01:15:58,430
You could have feet. 

1119
01:15:58,920 --> 01:16:00,540
Process one in physical memory, 

1120
01:16:00,550 --> 01:16:06,160
because maybe one segment of process one would have fit in one of these gaps, 

1121
01:16:06,170 --> 01:16:07,880
and the other one is the other gap. 

1122
01:16:10,470 --> 01:16:12,800
So that's how multiple segments can help. 

1123
01:16:20,120 --> 01:16:21,990
This is one version. 

1124
01:16:22,550 --> 01:16:23,900
You have then a map. 

1125
01:16:24,850 --> 01:16:27,070
How would you implement it? 

1126
01:16:27,080 --> 01:16:28,230
Now you need a map, 

1127
01:16:29,090 --> 01:16:30,280
a segment map, 

1128
01:16:30,950 --> 01:16:33,670
which needs to reside in the processor. 

1129
01:16:34,630 --> 01:16:36,910
And then how do you address it? 

1130
01:16:37,280 --> 01:16:38,790
How do we know we segment? 

1131
01:16:40,520 --> 01:16:41,060
We are in. 

1132
01:16:42,160 --> 01:16:46,770
So one way to do it is to divide the address space, 

1133
01:16:46,780 --> 01:16:49,510
a virtual address into two. 

1134
01:16:50,650 --> 01:16:58,470
The first beats of the asset advice are the most significant ones represent the

1135
01:16:58,480 --> 01:17:02,760
segment.to this segment map. 

1136
01:17:05,130 --> 01:17:09,530
And the second and the other part of the address is a quality of. 

1137
01:17:12,230 --> 01:17:16,150
So when the processor issues such virtual address, 

1138
01:17:18,350 --> 01:17:22,430
the processor take the first, 

1139
01:17:22,440 --> 01:17:26,260
the segment beats its indexes in the segment map, 

1140
01:17:27,070 --> 01:17:35,990
then it gets the base and the limit the offset is added to the base. 

1141
01:17:38,740 --> 01:17:40,750
And now this you have the physical address, 

1142
01:17:40,760 --> 01:17:46,700
and then you need also to compare the offset to the limit, 

1143
01:17:48,630 --> 01:17:48,830
right? 

1144
01:17:48,840 --> 01:17:50,550
To see that you are within the segment. 

1145
01:17:52,360 --> 01:17:53,390
If not, it's an error.

1146
01:17:55,750 --> 01:17:56,340
You are done. 

1147
01:18:01,910 --> 01:18:05,990
Now you can chunk the memory in as many chunks that you have

1148
01:18:06,000 --> 01:18:09,320
in this map map table. 

1149
01:18:13,190 --> 01:18:20,730
And this is what very early versions of intel 86

1150
01:18:21,900 --> 01:18:23,670
are implemented. 

1151
01:18:28,210 --> 01:18:28,990
86. 

1152
01:18:31,160 --> 01:18:32,550
We are going to stop here. 

1153
01:18:32,560 --> 01:18:33,550
We are at time. 

1154
01:18:34,690 --> 01:18:38,970
And we are going to continue our discussion on virtual memory. 

1155
01:18:39,560 --> 01:18:40,240
Next Monday. 

1156
01:18:41,800 --> 01:18:48,350
Until then, good luck with project two is good to start early.

1157
01:18:50,170 --> 01:18:52,000
I'll see you then on virtually. 

1158
01:18:52,010 --> 01:18:53,040
I'll see you on Monday. 

1159
01:18:53,050 --> 01:18:56,100
If you have any other questions, please, let me know.

