1
00:00:23,790 --> 00:00:24,550
Hello, everyone.

2
00:00:25,490 --> 00:00:29,520
So today we are going to continue our discussion about file systems. 

3
00:00:31,740 --> 00:00:32,410
In particular, 

4
00:00:32,420 --> 00:00:39,650
we are going to go through a few examples to see how some of the most popular

5
00:00:40,670 --> 00:00:44,790
file systems in the past have been implemented. 

6
00:00:46,330 --> 00:00:49,910
First, to to recall,

7
00:00:51,130 --> 00:00:58,580
these are the main data structures which are maintained in the by file system. 

8
00:00:59,290 --> 00:00:59,940
First of all, 

9
00:01:01,500 --> 00:01:03,970
we are going to have a directory structures, 

10
00:01:05,590 --> 00:01:07,660
which is it's an article. 

11
00:01:08,240 --> 00:01:13,250
And here you are going to use a file pass to locate a particular file

12
00:01:13,260 --> 00:01:15,210
in this directory structure. 

13
00:01:16,860 --> 00:01:19,010
And entering the indirectory structures, 

14
00:01:19,020 --> 00:01:22,180
associate the file with an eye number, 

15
00:01:22,190 --> 00:01:23,900
an eye number. 

16
00:01:23,910 --> 00:01:30,450
It's an index in index structure called file header structure. 

17
00:01:31,140 --> 00:01:36,560
And this index points to what is called an inode. 

18
00:01:37,420 --> 00:01:43,580
The I node contains all the information which is relevant to the file, 

19
00:01:43,590 --> 00:01:50,270
and which help the operating system to locate the data for that file

20
00:01:50,280 --> 00:01:51,440
on the disk. 

21
00:01:55,160 --> 00:01:58,490
The first case we are going to go over. 

22
00:01:58,500 --> 00:02:03,460
It's a fat stands for the final location table. 

23
00:02:03,940 --> 00:02:09,310
And this was the first file system

24
00:02:14,430 --> 00:02:16,150
employed by microsoft. 

25
00:02:16,400 --> 00:02:17,910
This operating system, 

26
00:02:17,920 --> 00:02:23,390
which is the first operating system released by microsoft all the way in 1977. 

27
00:02:24,900 --> 00:02:27,050
It's still quite used today. 

28
00:02:27,060 --> 00:02:30,950
I despise after what after 50, 

29
00:02:32,510 --> 00:02:35,680
50, 40 years of 44 years, right?

30
00:02:37,800 --> 00:02:40,150
And the fact, 

31
00:02:40,800 --> 00:02:41,110
look, 

32
00:02:41,830 --> 00:02:45,020
is aa file system is quite simple. 

33
00:02:45,030 --> 00:02:47,280
Let me just so first of all, 

34
00:02:47,290 --> 00:02:52,010
what you have here on the right, 

35
00:02:52,020 --> 00:02:54,250
it's a blocks on the disk, 

36
00:02:54,970 --> 00:02:59,000
and that these blocks and you have a file. 

37
00:02:59,440 --> 00:03:01,920
For each file, you have whether the block is.

38
00:03:02,410 --> 00:03:04,280
Each file has a bunch of blocks. 

39
00:03:08,490 --> 00:03:10,660
Like they say the 456, 

40
00:03:10,880 --> 00:03:15,230
31, this is where the disk are located.

41
00:03:17,090 --> 00:03:20,580
And then you need to maintaining the fat table, 

42
00:03:20,830 --> 00:03:22,710
a pointer or the item, 

43
00:03:22,720 --> 00:03:26,400
the offer to where the disk is locked, 

44
00:03:27,230 --> 00:03:28,500
the blocks are located. 

45
00:03:30,510 --> 00:03:34,330
Therefore, to the I number of,

46
00:03:35,980 --> 00:03:37,980
sorry, to the index of that block,

47
00:03:39,000 --> 00:03:39,870
that this block, 

48
00:03:40,600 --> 00:03:43,140
you can think about of an array of blocks, 

49
00:03:43,840 --> 00:03:46,630
each blocks has a identifier, 

50
00:03:46,640 --> 00:03:48,830
is typically it's a logical identifier, 

51
00:03:49,110 --> 00:03:50,420
which is mapped, then,

52
00:03:50,430 --> 00:03:52,260
on a physical identifier as it is. 

53
00:03:53,210 --> 00:04:01,790
And the fat maintains a mapping between the files and the list of blocks

54
00:04:01,800 --> 00:04:03,030
identify as logical, 

55
00:04:03,040 --> 00:04:03,830
identify as. 

56
00:04:05,910 --> 00:04:08,150
So how does fat maintain that? 

57
00:04:10,210 --> 00:04:10,780
It's, 

58
00:04:11,630 --> 00:04:18,660
again, this is maintained in I the I note it's indexed by the I number.

59
00:04:19,680 --> 00:04:22,520
Let's assume that the file number here is 31. 

60
00:04:23,660 --> 00:04:26,580
And the fact is just basically a linguist. 

61
00:04:27,650 --> 00:04:32,080
Each link, each entry in the linked list corresponds to a block of a file.

62
00:04:32,840 --> 00:04:36,660
And each entry will maintain the index of a block, 

63
00:04:37,380 --> 00:04:41,850
and then a pointer to the next entry, 

64
00:04:42,340 --> 00:04:43,880
which points to the next block. 

65
00:04:44,890 --> 00:04:45,310
Okay? 

66
00:04:46,570 --> 00:04:50,980
He has assumed that you are going to have in three, 

67
00:04:51,260 --> 00:04:53,730
a three blocks in this 501, and 2.

68
00:04:53,740 --> 00:04:57,840
You have three corresponding entries in the fat table. 

69
00:04:58,240 --> 00:05:03,350
And each entry will have an index to a corresponding block, 

70
00:05:03,360 --> 00:05:05,750
and then a pointer to the next entry. 

71
00:05:06,660 --> 00:05:13,020
It's the next entry in the in this

72
00:05:17,300 --> 00:05:18,650
to the next entry, 

73
00:05:18,660 --> 00:05:21,290
corresponding to the next block in the file. 

74
00:05:23,930 --> 00:05:24,560
Also, 

75
00:05:25,490 --> 00:05:29,760
when i'm opening a file and other important data, 

76
00:05:29,770 --> 00:05:33,080
I need is basically the offset. 

77
00:05:33,600 --> 00:05:36,900
So I what is the current position in the file? 

78
00:05:37,270 --> 00:05:43,350
The current position in the file here is given by a the first couple is

79
00:05:43,360 --> 00:05:46,180
a block in the file. 

80
00:05:46,190 --> 00:05:51,460
And the second and part of the double, 

81
00:05:52,490 --> 00:05:54,810
it's basically the offset within that block. 

82
00:06:01,630 --> 00:06:02,340
The question is, 

83
00:06:02,350 --> 00:06:06,540
what does x the second element of the two x double comes into the place? 

84
00:06:06,550 --> 00:06:09,950
Again, x it's offset within the block two.

85
00:06:09,960 --> 00:06:11,120
In this case. 

86
00:06:16,520 --> 00:06:22,860
That's why in order to access the data here for from block two, 

87
00:06:23,090 --> 00:06:24,720
you start from block zero, 

88
00:06:24,730 --> 00:06:28,680
then you have to follow the link list to block one, then to block two.

89
00:06:28,850 --> 00:06:29,680
Now it block two. 

90
00:06:29,690 --> 00:06:31,320
This is a block I care about. 

91
00:06:31,570 --> 00:06:33,280
Now I can read three block two. 

92
00:06:34,240 --> 00:06:37,190
Then i'm going to the offset x within the block two. 

93
00:06:42,500 --> 00:06:44,850
It's a very simple technique. 

94
00:06:45,540 --> 00:06:47,980
Now you read the block two in the memory, 

95
00:06:47,990 --> 00:06:51,140
and then you access offset x within that. 

96
00:06:56,140 --> 00:06:59,150
Again, it's the file,

97
00:06:59,160 --> 00:07:01,910
like it's a collection of blocks. 

98
00:07:02,300 --> 00:07:09,570
And each entry in this link listing the fat link list corresponds to a block. 

99
00:07:11,470 --> 00:07:19,250
And the file number is

100
00:07:19,260 --> 00:07:22,050
basically the file number for simplicity. 

101
00:07:22,450 --> 00:07:23,460
In the case, 

102
00:07:23,470 --> 00:07:24,750
of fact, 

103
00:07:25,180 --> 00:07:29,480
it's exactly the index of the roadblock. 

104
00:07:31,190 --> 00:07:33,300
In the file, in this case, 31.

105
00:07:33,310 --> 00:07:38,380
It's also the index of the roadblock on the disk. 

106
00:07:41,110 --> 00:07:41,780
Okay. 

107
00:07:42,190 --> 00:07:44,740
So what about, obviously,

108
00:07:45,360 --> 00:07:49,750
what about three blocks? 

109
00:07:51,690 --> 00:07:54,620
You need three blocks in order, obviously,

110
00:07:54,630 --> 00:07:56,310
to extend the file. 

111
00:07:56,320 --> 00:08:00,840
Remember that the file extends expands as you write more in the file. 

112
00:08:02,150 --> 00:08:04,940
So there are four or four new files you need to follow. 

113
00:08:04,950 --> 00:08:06,620
If you want to write the new files, 

114
00:08:06,630 --> 00:08:13,320
you need to to look to find the three blocks. 

115
00:08:13,330 --> 00:08:17,680
Typically, there are two ways to to manage these three blocks.

116
00:08:18,000 --> 00:08:20,240
One is to have a list of three blocks. 

117
00:08:21,330 --> 00:08:23,740
The other one, you can have a big map of it,

118
00:08:23,990 --> 00:08:26,130
333 blocks. 

119
00:08:26,450 --> 00:08:28,620
So basically, in this opinion case,

120
00:08:28,630 --> 00:08:29,980
you have for each block, 

121
00:08:29,990 --> 00:08:32,750
you have a bit1 or 01. 

122
00:08:32,760 --> 00:08:36,260
If it's that block is not free, 

123
00:08:36,270 --> 00:08:38,120
it's used by a file zero. 

124
00:08:38,130 --> 00:08:39,050
If it's free. 

125
00:08:40,140 --> 00:08:41,210
This is how you find it. 

126
00:08:42,240 --> 00:08:44,190
In this particular case, for instance,

127
00:08:44,400 --> 00:08:47,990
you are going to write if the file for now has only three blocks, 

128
00:08:48,380 --> 00:08:53,360
you want to write to more data. 

129
00:08:53,690 --> 00:08:54,600
Like in this case, 

130
00:08:54,610 --> 00:08:58,880
I want to write in 571 in block c this means the first block. 

131
00:08:59,330 --> 00:09:00,600
Then what happens? 

132
00:09:00,610 --> 00:09:03,280
Again, the file of the operating system,

133
00:09:03,290 --> 00:09:05,240
the file system expands the file, 

134
00:09:05,570 --> 00:09:08,200
and finds on bikes, 

135
00:09:08,210 --> 00:09:10,920
finding a new block in the empty list, 

136
00:09:11,320 --> 00:09:12,390
and then allocating that block. 

137
00:09:12,400 --> 00:09:14,820
And now that block is part of the file. 

138
00:09:15,170 --> 00:09:19,790
And it's also part of the linked list of all the blocks which belong

139
00:09:19,800 --> 00:09:24,620
to that file. 

140
00:09:28,240 --> 00:09:28,730
Now, 

141
00:09:29,430 --> 00:09:30,620
what is passed out? 

142
00:09:31,100 --> 00:09:33,350
So again, this is persistent storage.

143
00:09:33,360 --> 00:09:39,440
All these modifications needs to persist after I am going. 

144
00:09:39,450 --> 00:09:40,720
I write a file. 

145
00:09:40,960 --> 00:09:42,750
For instance, I modify the file,

146
00:09:42,760 --> 00:09:45,190
and then I close the application, because next time,

147
00:09:45,200 --> 00:09:47,550
when I open the application and I want to read the files, 

148
00:09:47,560 --> 00:09:49,700
I want my changes to be reflected. 

149
00:09:49,950 --> 00:09:51,540
Therefore, by default,

150
00:09:52,430 --> 00:09:55,460
all this information is a fact, not only the data,

151
00:09:55,470 --> 00:09:56,860
but also the meta data. 

152
00:09:57,060 --> 00:10:00,530
This has to be on persistently started in this, 

153
00:10:00,900 --> 00:10:02,490
and the obvious place to be started. 

154
00:10:02,500 --> 00:10:03,690
It's on the risk. 

155
00:10:07,840 --> 00:10:09,750
How do you format a disk? 

156
00:10:10,400 --> 00:10:14,790
Do you know what formatting a disk mean for people? 

157
00:10:26,710 --> 00:10:28,150
So formatting meaning, 

158
00:10:29,360 --> 00:10:31,070
I want to make the discus new, 

159
00:10:32,110 --> 00:10:32,460
right? 

160
00:10:33,170 --> 00:10:35,160
I want to basically erase everything. 

161
00:10:36,330 --> 00:10:40,880
The way you do it is basically your zeros of locks. 

162
00:10:41,550 --> 00:10:42,870
And in the fact, 

163
00:10:42,880 --> 00:10:46,140
I will you you mark everything being free. 

164
00:10:48,150 --> 00:10:51,740
There is a question here from gilbert. 

165
00:10:52,160 --> 00:10:55,970
Do the blocks not have to be in order in the linguist? 

166
00:11:01,400 --> 00:11:04,420
I i'm afraid I don't know understand that question. 

167
00:11:04,430 --> 00:11:05,990
Can you be more precise? 

168
00:11:06,000 --> 00:11:08,910
Gilbert about gilbert about this question? 

169
00:11:09,370 --> 00:11:13,320
Are you asking that because the link list is fundamentally ordered? 

170
00:11:15,690 --> 00:11:19,360
Like block three is before the block dough. 

171
00:11:19,370 --> 00:11:21,920
That's exactly why we have a linguist. 

172
00:11:22,200 --> 00:11:24,700
Because when you are going to read from a blog, 

173
00:11:24,710 --> 00:11:26,860
we are going to go along the linguist. 

174
00:11:28,020 --> 00:11:29,850
So that's the main point. 

175
00:11:30,900 --> 00:11:32,290
In this particular case, 

176
00:11:33,570 --> 00:11:34,710
we are going, again,

177
00:11:34,720 --> 00:11:36,150
if you follow the linguist, 

178
00:11:36,510 --> 00:11:40,370
the link list will link the blocks in the order is your reader. 

179
00:11:41,590 --> 00:11:45,120
They are appended to the fact that's exactly where I need a linguist

180
00:11:47,520 --> 00:11:50,400
to preserve that to start that order. 

181
00:11:54,230 --> 00:12:00,750
What happens if we try to insert us something in the middle of a file for fat? 

182
00:12:01,210 --> 00:12:03,720
Do we insert a new block into the linked list? 

183
00:12:03,730 --> 00:12:05,320
Or is there something more clever? 

184
00:12:05,840 --> 00:12:12,480
If you said you see in any file system and most file systems, actually,

185
00:12:12,930 --> 00:12:15,730
you cannot insert a block in the middle, right?

186
00:12:15,740 --> 00:12:18,020
Because from the file system, 

187
00:12:18,030 --> 00:12:20,060
think about what is the interface. 

188
00:12:20,850 --> 00:12:23,920
You can just write to the blog, 

189
00:12:23,930 --> 00:12:25,690
so or read from the, sorry,

190
00:12:25,930 --> 00:12:28,220
you write through the file and read from the file. 

191
00:12:28,570 --> 00:12:29,730
If you write from the file, 

192
00:12:29,740 --> 00:12:35,700
if you write a in a in a place where already contains data, 

193
00:12:35,710 --> 00:12:37,260
you override the data, 

194
00:12:38,250 --> 00:12:40,760
you're writing an already existing block. 

195
00:12:41,300 --> 00:12:41,660
Right? 

196
00:12:42,020 --> 00:12:44,660
And if you're right at the end of the file, 

197
00:12:47,300 --> 00:12:49,510
then when if you don't have, 

198
00:12:49,990 --> 00:12:54,030
if you run out of existing at the block at the end of the file, 

199
00:12:54,040 --> 00:12:55,350
you are going to add a new block. 

200
00:12:56,110 --> 00:12:57,420
You are going to expand the fact. 

201
00:13:03,340 --> 00:13:03,980
The question, 

202
00:13:07,450 --> 00:13:10,250
how to quick format a disk, 

203
00:13:11,560 --> 00:13:15,280
you can mark all the fat entries to free. 

204
00:13:17,070 --> 00:13:18,900
And this can be easily implemented. 

205
00:13:19,150 --> 00:13:20,860
The main.here is, again,

206
00:13:20,870 --> 00:13:22,460
is like you can actually, 

207
00:13:23,040 --> 00:13:26,540
there are two ways to format it and again, 

208
00:13:26,550 --> 00:13:28,970
formal meanings in it. 

209
00:13:28,980 --> 00:13:31,960
Just you want to have the disk that's new. 

210
00:13:32,740 --> 00:13:32,970
Now, 

211
00:13:33,930 --> 00:13:36,900
if you just remove all the information in the fact, 

212
00:13:37,400 --> 00:13:39,100
without doing anything without these blocks, 

213
00:13:39,110 --> 00:13:40,750
that this block still remains, 

214
00:13:43,370 --> 00:13:44,360
you don't zero there. 

215
00:13:44,950 --> 00:13:49,200
Then from the point of view of the operating of the file system, 

216
00:13:49,620 --> 00:13:50,860
the disk is free. 

217
00:13:50,870 --> 00:13:55,080
You can allocate everything because you removed your reform. 

218
00:13:55,510 --> 00:14:01,670
You just as mark all is a fat and is being free. 

219
00:14:02,090 --> 00:14:02,250
Right? 

220
00:14:02,420 --> 00:14:05,680
You are going to allocate from the previous blocks which are written

221
00:14:05,690 --> 00:14:07,480
for a different file suggest of rights. 

222
00:14:07,880 --> 00:14:08,460
No problem. 

223
00:14:09,030 --> 00:14:12,340
Now, obviously, this is not a hard format,

224
00:14:12,350 --> 00:14:16,670
because it maintains the information from the previous files. 

225
00:14:17,060 --> 00:14:18,370
And typically, 

226
00:14:18,380 --> 00:14:19,530
when people format, 

227
00:14:19,540 --> 00:14:22,650
they also want to relate this information for security reasons. 

228
00:14:22,880 --> 00:14:26,900
So you need to be careful about what kind of format is going to happen

229
00:14:26,910 --> 00:14:27,980
on your format disc. 

230
00:14:28,570 --> 00:14:31,490
If you care about the information from your previous files, 

231
00:14:31,780 --> 00:14:33,210
do not be visible. 

232
00:14:33,750 --> 00:14:35,940
Again, for instance, your hand down,

233
00:14:36,380 --> 00:14:40,910
you hand back your computer to your employee or something like that. 

234
00:14:42,920 --> 00:14:45,950
The fact that fat directory is a fat directory. 

235
00:14:45,960 --> 00:14:49,360
It's again it's like in a director, 

236
00:14:49,370 --> 00:14:53,900
you have to remember you have these and doubles. 

237
00:14:54,150 --> 00:14:55,700
One is a file name, 

238
00:14:55,710 --> 00:14:57,260
the first part is a file name, 

239
00:14:57,270 --> 00:14:59,260
the second one is a file number. 

240
00:15:01,350 --> 00:15:04,280
Here is a factory also of have. 

241
00:15:05,520 --> 00:15:06,750
It's a linguist, right?

242
00:15:06,760 --> 00:15:09,490
This like we know all is the directory, 

243
00:15:10,100 --> 00:15:11,890
what you see in a directory, 

244
00:15:11,900 --> 00:15:14,890
which is basically a list of names. 

245
00:15:15,800 --> 00:15:16,870
What happens here? 

246
00:15:16,880 --> 00:15:19,290
You are going to have each of these, 

247
00:15:19,300 --> 00:15:24,660
what you've seen entering this directory is going to be linked all of them, 

248
00:15:25,430 --> 00:15:26,740
a a in a linguist. 

249
00:15:27,860 --> 00:15:29,890
If you remove a file, 

250
00:15:29,900 --> 00:15:36,440
then you are going to update the pointers so that you are going to step

251
00:15:36,450 --> 00:15:38,880
over that file, 

252
00:15:38,890 --> 00:15:41,880
which was over that entry, which was deleted.

253
00:15:42,300 --> 00:15:42,710
Okay? 

254
00:15:43,260 --> 00:15:45,170
That's how you have here. 

255
00:15:45,180 --> 00:15:46,450
So it's very simple. 

256
00:15:49,810 --> 00:15:50,280
One. 

257
00:15:52,170 --> 00:15:54,800
So one, there are a few things about the fad directory,

258
00:15:54,810 --> 00:15:56,000
which is worth mention. 

259
00:15:56,820 --> 00:16:00,930
It's where do you have a the attributes for a file is

260
00:16:00,940 --> 00:16:06,200
like protection and permission attributes who has access to the file, 

261
00:16:06,210 --> 00:16:07,800
to read it, to write it,

262
00:16:07,810 --> 00:16:10,360
to execute that file is if it's a binary file. 

263
00:16:11,440 --> 00:16:12,840
In the fact, 

264
00:16:12,850 --> 00:16:16,310
these attributes are maintained here in the director, 

265
00:16:16,830 --> 00:16:19,630
like we'll see in other file systems, 

266
00:16:19,930 --> 00:16:23,540
these attributes are associated with the fire itself. 

267
00:16:28,370 --> 00:16:30,320
The other question, which, in general is,

268
00:16:30,610 --> 00:16:33,120
it's an important collision for all the file systems. 

269
00:16:33,430 --> 00:16:34,410
Where do you find that? 

270
00:16:34,420 --> 00:16:35,560
Where do you start from? 

271
00:16:38,170 --> 00:16:39,200
To get the route? 

272
00:16:39,210 --> 00:16:40,640
If I give you a file name, 

273
00:16:40,650 --> 00:16:45,160
you need to go and get the route directory and then goes to the past names

274
00:16:45,170 --> 00:16:49,590
in that end the directory to find the particular a file name, 

275
00:16:49,600 --> 00:16:51,230
and then I number for the file. 

276
00:16:53,070 --> 00:17:00,840
And typically this route or what it's a well defined place on the disk. 

277
00:17:01,180 --> 00:17:01,530
Right? 

278
00:17:02,340 --> 00:17:04,410
For instance, a case of fat is blocked.

279
00:17:05,990 --> 00:17:06,860
What else here? 

280
00:17:07,270 --> 00:17:07,940
Obviously, 

281
00:17:07,950 --> 00:17:12,060
because this is maintaining a linguist and in order to read a directory

282
00:17:12,070 --> 00:17:14,670
and display the content of directory, 

283
00:17:14,680 --> 00:17:16,790
you need to go over this linguist. 

284
00:17:17,040 --> 00:17:19,670
You need also to go what which is commonly defined, 

285
00:17:19,680 --> 00:17:24,130
because when you do a display like all the entries in our directories, 

286
00:17:24,140 --> 00:17:27,490
you are want to display all the files in the directory. 

287
00:17:27,930 --> 00:17:31,060
But when you want to find a fire in a directory, 

288
00:17:31,370 --> 00:17:34,190
you still need to have to go over this linked list, 

289
00:17:34,200 --> 00:17:35,270
which can be expensive. 

290
00:17:37,420 --> 00:17:38,180
Any questions? 

291
00:17:44,160 --> 00:17:45,470
He had a few questions. 

292
00:17:49,300 --> 00:17:52,090
Suppose you start with a file number. 

293
00:17:52,100 --> 00:17:54,610
The file number is everyone like in our previous. 

294
00:17:55,800 --> 00:17:59,100
Here you see also is yellow is you have a file too. 

295
00:18:02,540 --> 00:18:04,600
Let's tell me, 

296
00:18:05,530 --> 00:18:06,000
let's see. 

297
00:18:06,010 --> 00:18:07,440
What is the time to find a blog? 

298
00:18:08,890 --> 00:18:09,960
What do you need to find a block? 

299
00:18:24,080 --> 00:18:25,670
You take this is you already, 

300
00:18:26,930 --> 00:18:29,680
it's our friend or any the number of blocks. 

301
00:18:33,160 --> 00:18:35,120
I say, in this case, you say route,

302
00:18:35,130 --> 00:18:37,160
then reverse the desired number. 

303
00:18:37,170 --> 00:18:40,270
Here you already have the file number, the third one.

304
00:18:40,790 --> 00:18:45,830
You don't need to do the directory traversal, 

305
00:18:47,680 --> 00:18:49,210
but this is correct. 

306
00:18:49,640 --> 00:18:52,380
And gilbert, so basically,

307
00:18:52,390 --> 00:18:53,620
in this particular case, 

308
00:18:53,630 --> 00:18:55,380
you need it's a linear search, right?

309
00:18:55,700 --> 00:18:58,500
You need to find a particular block. 

310
00:18:58,830 --> 00:19:02,820
You need to follow the pointers in the linguist, 

311
00:19:02,830 --> 00:19:07,810
and everyone knows at english to find something in a linguist is linear. 

312
00:19:07,820 --> 00:19:09,010
So near that, 

313
00:19:14,520 --> 00:19:16,950
what is a block layout for files? 

314
00:19:20,460 --> 00:19:21,610
It was a previous question, 

315
00:19:21,620 --> 00:19:23,210
but they need to be contiguous. 

316
00:19:23,810 --> 00:19:24,420
Not. 

317
00:19:36,100 --> 00:19:36,540
Yes. 

318
00:19:37,770 --> 00:19:38,430
It's correct. 

319
00:19:39,330 --> 00:19:41,240
Actually, they don't need to be going to go.

320
00:19:41,250 --> 00:19:42,400
They can be random, 

321
00:19:42,840 --> 00:19:49,160
because then we are going to have our linguist in the fat table to maintain

322
00:19:49,730 --> 00:19:51,200
the logical order of the loss, 

323
00:19:51,570 --> 00:19:54,930
which provides you a lot of flexibility about where to allocate the blocks. 

324
00:19:55,340 --> 00:20:01,110
And which is what sequential access. 

325
00:20:04,300 --> 00:20:04,960
What do you think about? 

326
00:20:04,970 --> 00:20:07,520
Sequential access is a fast, 

327
00:20:07,530 --> 00:20:08,760
slow. 

328
00:20:22,770 --> 00:20:23,230
Yes, 

329
00:20:23,480 --> 00:20:31,360
the director is out of link lists also are presented in the fat in the and

330
00:20:33,980 --> 00:20:35,130
there are also linguists, 

331
00:20:35,140 --> 00:20:40,170
but with directories is a linguist between the entries in the directories. 

332
00:20:41,710 --> 00:20:43,170
Here for the files themselves, 

333
00:20:43,180 --> 00:20:44,770
you have the linked list, 

334
00:20:47,530 --> 00:20:50,640
basically between the blocks of that file. 

335
00:20:53,530 --> 00:20:55,410
Now, the answer to the question,

336
00:20:55,420 --> 00:21:00,860
sequential access can be somewhat slow, 

337
00:21:00,870 --> 00:21:04,100
because need to linear is gone for every access. 

338
00:21:06,120 --> 00:21:11,060
Because we do not have a guaranteed order is correct. 

339
00:21:11,070 --> 00:21:14,140
So the sequential access can be slow, 

340
00:21:14,150 --> 00:21:20,000
because if you look about at how block01, 

341
00:21:20,010 --> 00:21:22,000
and3 are located here, 

342
00:21:22,290 --> 00:21:25,700
block zero, and one are consecutive right?

343
00:21:26,940 --> 00:21:28,490
Because they are consecutive. 

344
00:21:28,690 --> 00:21:34,000
You do not need to incur a sick latency or a patient latency. 

345
00:21:34,420 --> 00:21:36,740
What if to go from block zero to block one? 

346
00:21:39,200 --> 00:21:41,800
But now to go from block one to block two, 

347
00:21:42,040 --> 00:21:45,190
you have to incur a sick latency, rotational agency.

348
00:21:46,000 --> 00:21:47,110
This is huge overhead. 

349
00:21:49,800 --> 00:21:51,150
You have a lot of flexibility. 

350
00:21:51,160 --> 00:21:52,750
You have to put the blocks on the disk. 

351
00:21:53,940 --> 00:21:56,760
But if you are not careful and you put them around on me, 

352
00:21:57,440 --> 00:22:00,450
then is going to hurt your access to

353
00:22:14,400 --> 00:22:15,310
how is random access. 

354
00:22:19,940 --> 00:22:21,020
Yes, it's even slower.

355
00:22:21,030 --> 00:22:24,470
Since you have to encourage us, 

356
00:22:24,480 --> 00:22:27,730
you need to sequentially search for the block, 

357
00:22:28,710 --> 00:22:30,710
which contains the data you want to read. 

358
00:22:34,960 --> 00:22:35,910
It's quite slow. 

359
00:22:40,370 --> 00:22:41,370
Fragmentation. 

360
00:22:42,390 --> 00:22:43,230
How is fragmentation? 

361
00:22:57,300 --> 00:22:59,280
Fragmentation is pretty good, 

362
00:22:59,290 --> 00:23:01,360
is not much fragmentation because remember, 

363
00:23:01,370 --> 00:23:02,680
you can put the blocks anywhere. 

364
00:23:03,850 --> 00:23:05,610
See, if you have just some three blocks,

365
00:23:06,130 --> 00:23:07,070
you are going to get it. 

366
00:23:08,190 --> 00:23:08,760
No problem. 

367
00:23:10,700 --> 00:23:13,010
It's okay, it's going to help your performance.

368
00:23:13,430 --> 00:23:16,910
But you can have your fragmentation will be very low. 

369
00:23:18,260 --> 00:23:19,020
Small files. 

370
00:23:19,030 --> 00:23:20,700
Is this sufficient for small files? 

371
00:23:27,100 --> 00:23:28,380
Remember what if

372
00:23:41,180 --> 00:23:41,650
so? 

373
00:23:41,660 --> 00:23:42,090
It's, 

374
00:23:44,070 --> 00:23:45,950
yes, if the file fits in on,

375
00:23:45,960 --> 00:23:47,230
block is very efficient. 

376
00:23:48,070 --> 00:23:48,430
Right? 

377
00:23:49,170 --> 00:23:49,890
It's very good. 

378
00:23:50,450 --> 00:23:53,400
If a file fits only in one block, like why?

379
00:23:53,780 --> 00:23:56,460
Because you all in the file number, 

380
00:23:56,470 --> 00:23:59,340
it's indexed into the block. 

381
00:24:00,490 --> 00:24:01,230
The first block, 

382
00:24:03,490 --> 00:24:04,480
you find it immediately. 

383
00:24:06,540 --> 00:24:06,930
Right? 

384
00:24:07,980 --> 00:24:13,130
As you have more blocks in the file, 

385
00:24:13,380 --> 00:24:15,510
then it becomes more inefficient. 

386
00:24:15,770 --> 00:24:18,410
For the reason I mentioned, rightly mentioned.

387
00:24:18,420 --> 00:24:19,530
And for the big files, 

388
00:24:19,780 --> 00:24:21,320
it's even more inefficient. 

389
00:24:21,330 --> 00:24:25,280
It's again, because the blocks can be loud.

390
00:24:25,290 --> 00:24:26,880
They are loud on the disk, 

391
00:24:27,190 --> 00:24:28,640
can not end up being random. 

392
00:24:29,470 --> 00:24:34,650
And then you pay a lot of sick time rotation latency to read and write

393
00:24:34,660 --> 00:24:35,290
from the file. 

394
00:24:36,630 --> 00:24:42,960
This is fact like very simple and very influential. 

395
00:24:44,280 --> 00:24:46,640
Like this was for many years. 

396
00:24:47,240 --> 00:24:51,800
For decades, this was a file system or personal computers.

397
00:24:53,490 --> 00:24:58,180
Because obviously90%of the personal computers were running microsoft

398
00:24:58,190 --> 00:24:58,900
operating system. 

399
00:25:02,080 --> 00:25:05,870
Now, let's switch the gears and talk about unique file systems.

400
00:25:07,810 --> 00:25:10,660
And the next file system, 

401
00:25:12,410 --> 00:25:15,040
this is berkeley standard distribution. 

402
00:25:15,050 --> 00:25:17,160
4.1is what we are looking. 

403
00:25:17,170 --> 00:25:17,680
Now. 

404
00:25:18,750 --> 00:25:21,260
This is a part of your heritage. 

405
00:25:21,940 --> 00:25:28,010
And the similar in the linux today has very similar file structure. 

406
00:25:28,280 --> 00:25:29,910
It's again, a hugely influential,

407
00:25:29,920 --> 00:25:31,210
a file system, 

408
00:25:33,920 --> 00:25:35,800
the file number or I numbered. 

409
00:25:36,100 --> 00:25:39,940
As again, it's an index into an array of eye notes.

410
00:25:41,810 --> 00:25:46,110
I notes corresponds to a file, right?

411
00:25:46,120 --> 00:25:51,860
I notes contains the indexes to the blocks on the disk. 

412
00:25:52,420 --> 00:25:57,480
And in this case, it also contains other meta data associated with a file.

413
00:26:03,160 --> 00:26:06,240
It's pretty good for both little and large files. 

414
00:26:10,920 --> 00:26:15,630
All the assume that still all the blocks are the same size. 

415
00:26:16,580 --> 00:26:19,500
The trees, what you are going to see is estimate because you are,

416
00:26:19,740 --> 00:26:21,340
he's here is how it looks like. 

417
00:26:22,390 --> 00:26:24,020
You have an, I not array.

418
00:26:25,250 --> 00:26:28,370
The file number is the index in this area, 

419
00:26:30,570 --> 00:26:32,330
the iron ore in this area, 

420
00:26:34,320 --> 00:26:38,060
it's is basically, this is,

421
00:26:38,150 --> 00:26:39,540
I know, data structure.

422
00:26:41,040 --> 00:26:43,640
The first part, there are a bunch of attributes,

423
00:26:45,070 --> 00:26:48,060
for instance, 99basic control bits.

424
00:26:50,490 --> 00:26:56,110
You have typically owner or users, 

425
00:26:58,410 --> 00:27:00,070
group, and others.

426
00:27:01,240 --> 00:27:02,760
So it's basically, 

427
00:27:02,770 --> 00:27:05,160
it was at the owner of the file. 

428
00:27:05,820 --> 00:27:07,010
And for each of them, 

429
00:27:07,020 --> 00:27:08,290
you have three beats, 

430
00:27:08,970 --> 00:27:10,490
read, write, execute.

431
00:27:11,950 --> 00:27:14,180
So for owner of the file, 

432
00:27:14,940 --> 00:27:18,570
for the group and for others, right?

433
00:27:19,150 --> 00:27:21,040
Basically, for everyone else.

434
00:27:21,930 --> 00:27:23,330
And typically, obviously,

435
00:27:23,340 --> 00:27:25,250
the owner has the most rights, 

436
00:27:25,810 --> 00:27:26,850
then the group, 

437
00:27:28,150 --> 00:27:35,770
and then every others you have, 

438
00:27:35,780 --> 00:27:37,730
and also you have a few other beats, 

439
00:27:38,300 --> 00:27:44,610
which basically you can executed only at the owner permission

440
00:27:44,620 --> 00:27:48,090
rather than users and to execute at groups permission. 

441
00:27:53,490 --> 00:27:53,800
Again, 

442
00:27:55,630 --> 00:27:56,830
it's pretty classic. 

443
00:27:58,010 --> 00:28:00,160
The more interesting part is after this, 

444
00:28:00,570 --> 00:28:02,280
but remember this permission, 

445
00:28:02,960 --> 00:28:03,530
bits, 

446
00:28:04,160 --> 00:28:05,270
and information. 

447
00:28:05,550 --> 00:28:08,800
It's associated with the iron ore, with a file.

448
00:28:08,810 --> 00:28:11,440
In this case, in the case of fat or fat,

449
00:28:11,710 --> 00:28:14,230
it does this information on maintaining the director. 

450
00:28:17,200 --> 00:28:27,110
And then you have13 other entries in this idle structure. 

451
00:28:28,320 --> 00:28:31,210
Each entry points to a block. 

452
00:28:31,220 --> 00:28:35,320
The first ten entries are called on each of them. 

453
00:28:35,650 --> 00:28:38,220
They are pointing to one block. 

454
00:28:42,110 --> 00:28:48,230
The 11th entry point is called indirect pointer, 

455
00:28:49,130 --> 00:28:51,970
and points to a block, 

456
00:28:53,440 --> 00:28:55,150
which each element is a block. 

457
00:28:56,700 --> 00:28:58,400
It's a pointer to a real block. 

458
00:29:00,770 --> 00:29:06,520
Then you have double indirection pointers where this points to a block, 

459
00:29:06,530 --> 00:29:09,080
which is full of pointers, or each pointer,

460
00:29:09,530 --> 00:29:10,550
points to another block, 

461
00:29:10,560 --> 00:29:14,030
which is full of pointers to, finally, two blocks.

462
00:29:14,810 --> 00:29:16,610
And then you have triple in direction, 

463
00:29:17,070 --> 00:29:18,910
pointers, which is, again,

464
00:29:19,570 --> 00:29:20,810
going three levels. 

465
00:29:23,650 --> 00:29:24,420
In this case, 

466
00:29:24,950 --> 00:29:26,500
if you have four kilobytes blocks, 

467
00:29:26,510 --> 00:29:27,800
is a feature you have, 

468
00:29:33,590 --> 00:29:34,260
you have. 

469
00:29:34,790 --> 00:29:35,860
Here you have. 

470
00:29:43,210 --> 00:29:45,530
Yeah, sorry, I said the first they did.

471
00:29:45,540 --> 00:29:50,720
Direct number of direct pointers was then it's actually, sorry, it is12.

472
00:29:51,210 --> 00:29:52,360
Life is12. 

473
00:29:52,370 --> 00:29:54,240
And then you have three other ones, 

474
00:29:54,250 --> 00:29:56,580
one for india, indirect.

475
00:29:57,910 --> 00:30:00,680
Doubly direct and triple indirect. 

476
00:30:01,270 --> 00:30:02,420
So you have to12. 

477
00:30:02,890 --> 00:30:04,950
And if you have 12point, that is,

478
00:30:05,220 --> 00:30:07,740
this means that if you have four k blocks, 

479
00:30:09,200 --> 00:30:11,790
you can start using only direct pointers. 

480
00:30:12,150 --> 00:30:14,520
You can start 48 kilobytes files. 

481
00:30:16,670 --> 00:30:18,620
And if you remember, from last time,

482
00:30:18,630 --> 00:30:21,340
when you are looking at these results from this paper, 

483
00:30:22,170 --> 00:30:28,000
which are looking at the statistics of the length of the file system of size, 

484
00:30:28,010 --> 00:30:29,120
of the file systems, 

485
00:30:30,260 --> 00:30:33,750
there in that paper, in the plots,

486
00:30:34,190 --> 00:30:35,620
we presented lifetime, 

487
00:30:35,890 --> 00:30:39,800
we are seeing that most of the files are small files. 

488
00:30:40,730 --> 00:30:41,640
Therefore, 

489
00:30:42,410 --> 00:30:43,720
for most of the files, 

490
00:30:43,960 --> 00:30:46,270
you are using only the direct pointers. 

491
00:30:53,770 --> 00:30:55,400
Then for the bigger files, 

492
00:30:55,410 --> 00:30:57,560
you are going to use the indirect pointer, 

493
00:30:57,570 --> 00:30:59,640
establishing direct pointers, entry, playing direct mode.

494
00:31:01,820 --> 00:31:03,090
Just to give you a sense, 

495
00:31:03,960 --> 00:31:06,770
you can get for doubling direct pointers, 

496
00:31:07,170 --> 00:31:09,800
you can get to 4megabytes. 

497
00:31:09,810 --> 00:31:10,280
Why? 

498
00:31:10,630 --> 00:31:13,390
Because in this particular case, 

499
00:31:13,770 --> 00:31:17,790
it's again of this pointer. 

500
00:31:18,130 --> 00:31:20,220
Here, the 13pointer.

501
00:31:20,470 --> 00:31:23,110
It points you to one block. 

502
00:31:23,120 --> 00:31:25,010
A block has four kilobytes. 

503
00:31:25,430 --> 00:31:27,400
Each pointer, in this case,

504
00:31:27,410 --> 00:31:28,560
is4bytes. 

505
00:31:28,990 --> 00:31:30,180
Therefore, in a block,

506
00:31:30,190 --> 00:31:34,430
you have 1,024pointers. 

507
00:31:35,210 --> 00:31:39,820
Each of these pointers points to a physic, to a block.

508
00:31:40,410 --> 00:31:42,090
A block four has four kilobytes. 

509
00:31:42,260 --> 00:31:42,890
Now I have, 

510
00:31:43,620 --> 00:31:45,940
then1,024×4. 

511
00:31:46,260 --> 00:31:47,540
You have four kilobytes, 

512
00:31:47,550 --> 00:31:48,940
you have 4megabytes. 

513
00:31:49,150 --> 00:31:50,530
This is level two. 

514
00:31:50,920 --> 00:31:53,940
It's a 111 in direction. 

515
00:31:53,950 --> 00:31:58,710
The doubling direction is going to add another layer. 

516
00:31:58,720 --> 00:32:03,150
And it's basically you have four gigabytes. 

517
00:32:03,460 --> 00:32:05,340
And then for that hour, 

518
00:32:05,350 --> 00:32:09,670
and then for if you have the triple indirect., 

519
00:32:09,680 --> 00:32:11,610
that is you have four terabytes. 

520
00:32:14,120 --> 00:32:17,320
So it's a lot of storage. 

521
00:32:17,680 --> 00:32:20,490
Now, there is advantage for these ones.

522
00:32:20,500 --> 00:32:24,800
What is the disadvantage with the going with the that with indirect, 

523
00:32:24,810 --> 00:32:27,500
doubly indirect and triple indirect loss? 

524
00:32:28,000 --> 00:32:29,240
What is the disadvantage here? 

525
00:32:42,710 --> 00:32:43,390
Yes. 

526
00:32:43,760 --> 00:32:45,160
Longer access times. 

527
00:32:45,590 --> 00:32:46,470
Because right now, 

528
00:32:46,640 --> 00:32:53,540
I if I am going to to go to this the first level pointers, 

529
00:32:55,110 --> 00:32:56,780
i'm going to get the I node. 

530
00:32:57,310 --> 00:32:59,170
Then from I node, I get the pointers,

531
00:32:59,180 --> 00:33:00,610
all the pointers to the block. 

532
00:33:00,860 --> 00:33:03,010
I have another access to get to the data. 

533
00:33:03,760 --> 00:33:05,090
11x axis. 

534
00:33:05,880 --> 00:33:09,600
If I am going to have triple indirect in order to get to these data blocks, 

535
00:33:09,610 --> 00:33:15,860
I have to get one other access to get the first level block, 

536
00:33:15,870 --> 00:33:18,020
which contains pointers at the first level, 

537
00:33:18,030 --> 00:33:19,620
then another pointer, 

538
00:33:20,190 --> 00:33:21,900
another I need to access another. 

539
00:33:21,910 --> 00:33:25,460
They get another block at the second level to contains against pointers, 

540
00:33:25,890 --> 00:33:29,180
another block at the third level of container game pointers. 

541
00:33:29,490 --> 00:33:30,600
And finally, 

542
00:33:30,610 --> 00:33:33,790
I am going to get the data to the real block. 

543
00:33:35,550 --> 00:33:38,570
But also here I have for each of these levels, 

544
00:33:38,580 --> 00:33:40,250
I have an extra axis. 

545
00:33:42,770 --> 00:33:43,070
Okay? 

546
00:33:43,840 --> 00:33:45,960
On the other hand, it's pretty cool designed, right?

547
00:33:45,970 --> 00:33:47,440
Because for the small blocks, 

548
00:33:48,610 --> 00:33:49,560
it's pretty efficient. 

549
00:33:50,870 --> 00:33:52,750
Small block less than 48kilobytes. 

550
00:33:53,840 --> 00:33:58,270
All these pointers here are to data blocks. 

551
00:34:01,140 --> 00:34:03,130
At the same time, 

552
00:34:03,140 --> 00:34:09,160
you can store huge files like up to four terabytes in this design. 

553
00:34:15,080 --> 00:34:16,230
It's a question here. 

554
00:34:20,130 --> 00:34:23,060
This seems really similar to page tables. 

555
00:34:23,450 --> 00:34:27,890
Do file systems have the equivalent of super pages or huge pages? 

556
00:34:30,360 --> 00:34:36,080
Is very similar to the files is similar to the base table in some respects, 

557
00:34:36,090 --> 00:34:36,380
right? 

558
00:34:37,600 --> 00:34:46,830
Is one is that the unit of allocation a it's a it's a blog, it's a page.

559
00:34:47,970 --> 00:34:49,910
It's also they are connected, right?

560
00:34:50,210 --> 00:34:58,290
Because the reason for which you have pages in when we do demand beijing

561
00:34:58,680 --> 00:34:59,170
is why? 

562
00:34:59,180 --> 00:35:01,830
Because these pages needs to be stored. 

563
00:35:02,040 --> 00:35:05,560
Eventually when on the disk when they are evicted, right?

564
00:35:06,020 --> 00:35:07,700
They need to be read from the disk. 

565
00:35:08,050 --> 00:35:09,500
And the unit, again,

566
00:35:09,510 --> 00:35:10,660
it has to be the same unit. 

567
00:35:10,670 --> 00:35:12,070
It's a block, right?

568
00:35:12,460 --> 00:35:12,730
Block. 

569
00:35:12,740 --> 00:35:14,970
And the pages are basically the same unit. 

570
00:35:15,420 --> 00:35:17,860
Otherwise, to make things much more complicated,

571
00:35:19,550 --> 00:35:21,380
you'll see towards the end of the lecture, 

572
00:35:21,390 --> 00:35:24,530
hopefully can get there where you see the similarity, 

573
00:35:24,540 --> 00:35:27,610
but more because they are going to talk about memory maps. 

574
00:35:27,960 --> 00:35:30,690
So then you are going to map the files into memory. 

575
00:35:30,990 --> 00:35:35,510
And then you'll see one more of the similarity in terms of file system, 

576
00:35:35,520 --> 00:35:38,430
having the equivalent of super pages of huge pages, 

577
00:35:43,860 --> 00:35:46,900
you do have that not in unique, 

578
00:35:47,410 --> 00:35:50,820
but you don't have that in the windows, 

579
00:35:53,770 --> 00:35:57,790
the more and more than windows file system, 

580
00:35:57,800 --> 00:35:59,070
microsoft file system. 

581
00:35:59,550 --> 00:36:02,320
And in that case, you have what is called extent.

582
00:36:02,680 --> 00:36:06,750
What we are going to learn later in this lecture in visa blocks can have

583
00:36:06,760 --> 00:36:07,330
variable sites. 

584
00:36:10,940 --> 00:36:11,940
Great questions? 

585
00:36:16,360 --> 00:36:17,710
Let's take an example here, 

586
00:36:18,120 --> 00:36:19,790
I right now. 

587
00:36:19,800 --> 00:36:28,250
And that's why I was a little in this particular a it's a different example. 

588
00:36:28,260 --> 00:36:33,110
And he here assume that each block is one kilobyte. 

589
00:36:35,930 --> 00:36:42,220
We assume that there are ten direct pointers. 

590
00:36:42,980 --> 00:36:46,440
And in indirect blog, 

591
00:36:48,030 --> 00:36:49,140
the standard pointer. 

592
00:36:49,150 --> 00:36:53,980
So directly you can access only 1 kilo one, 

593
00:36:54,550 --> 00:36:56,620
1kilowatt, one kilobyte,

594
00:36:56,630 --> 00:36:59,380
ten ten×10kilobytes files. 

595
00:37:00,330 --> 00:37:02,700
Then because you have only one kilobyte. 

596
00:37:02,710 --> 00:37:03,990
If each entry, 

597
00:37:04,000 --> 00:37:05,910
each point there is 4bytes, 

598
00:37:06,170 --> 00:37:11,120
then you have only20 56indirect blocks at the first level. 

599
00:37:11,760 --> 00:37:14,230
Then you have twenty five two hundred, 

600
00:37:14,240 --> 00:37:18,950
56power to doubling the right box and 256 for three people in the right box. 

601
00:37:20,770 --> 00:37:22,520
That's kind of the layout in this case. 

602
00:37:23,150 --> 00:37:27,550
And now the question is that how many access is you need? 

603
00:37:27,560 --> 00:37:31,210
How many access is to get to the block23? 

604
00:37:32,850 --> 00:37:35,160
Assume the file is everything it's open. 

605
00:37:35,170 --> 00:37:38,870
Now, i'm just to add one process, block the industry.

606
00:37:39,590 --> 00:37:40,610
How many answers

607
00:37:49,280 --> 00:37:51,870
Is this 23 in a direct pointers? 

608
00:37:51,880 --> 00:37:56,910
But it's not right, 

609
00:37:56,920 --> 00:37:59,250
because I have only done in this stuff. 

610
00:38:02,890 --> 00:38:04,290
It's A

611
00:38:11,200 --> 00:38:13,800
23 will be in the single indirect block. 

612
00:38:14,790 --> 00:38:16,210
So you need to ask this, 

613
00:38:17,230 --> 00:38:17,510
right? 

614
00:38:17,930 --> 00:38:26,480
We need the first access to get to the root of the first level indirect locks. 

615
00:38:27,000 --> 00:38:28,240
And then from here, 

616
00:38:28,780 --> 00:38:29,910
once you get there, 

617
00:38:30,270 --> 00:38:32,750
you are going to read the data block. 

618
00:38:37,970 --> 00:38:39,050
What about block five? 

619
00:38:44,000 --> 00:38:46,100
Block five is in the first stand. 

620
00:38:47,050 --> 00:38:49,490
So you are going to have only one access. 

621
00:38:50,280 --> 00:38:51,080
It is a data block. 

622
00:38:51,690 --> 00:38:52,320
Number five, 

623
00:38:53,840 --> 00:38:55,350
block service, three hundred fourth.

624
00:38:57,250 --> 00:39:04,210
That's 340 hits in the first level, 

625
00:39:04,220 --> 00:39:05,610
the indirect loss. 

626
00:39:05,890 --> 00:39:06,580
Does it feel? 

627
00:39:07,780 --> 00:39:08,620
How many you have that? 

628
00:39:08,630 --> 00:39:11,390
You have twenty five fifty six last time, 

629
00:39:11,400 --> 00:39:17,600
which are direct is only indirect blocks or direct. 

630
00:39:21,810 --> 00:39:22,720
Therefore, 

631
00:39:24,040 --> 00:39:26,030
you need it has to be in doubling direct. 

632
00:39:28,500 --> 00:39:30,810
So then you are going to have how many axis? 

633
00:39:31,440 --> 00:39:31,880
Again, 

634
00:39:32,570 --> 00:39:35,300
one axis per level, each level.

635
00:39:35,310 --> 00:39:39,470
So you have double for each level, 

636
00:39:39,480 --> 00:39:41,110
you need one access or two, 

637
00:39:41,480 --> 00:39:43,350
and the third one for access to the right. 

638
00:39:49,980 --> 00:39:50,810
Some announcement. 

639
00:39:50,820 --> 00:39:55,850
So again, many congress for finishing the second meet them.

640
00:39:56,500 --> 00:39:57,930
We are making progress here. 

641
00:39:58,720 --> 00:40:00,640
Omar five has been released. 

642
00:40:00,650 --> 00:40:02,760
It will be due on monday, 

643
00:40:03,160 --> 00:40:05,180
november, 22nd.

644
00:40:06,960 --> 00:40:08,590
The project too. 

645
00:40:08,890 --> 00:40:11,360
Obviously, now is due on sunday.

646
00:40:12,730 --> 00:40:16,240
Hopefully everyone here, 

647
00:40:16,250 --> 00:40:19,040
it's in a good state with that project. 

648
00:40:19,500 --> 00:40:23,450
If not, please feel free to ask any questions we are here to help you.

649
00:40:29,330 --> 00:40:32,520
That was the initial file system in unix, 

650
00:40:34,140 --> 00:40:34,900
4.1. 

651
00:40:36,010 --> 00:40:36,510
Now, 

652
00:40:37,170 --> 00:40:38,490
people, obviously,

653
00:40:38,500 --> 00:40:41,520
after they used it for a while, 

654
00:40:41,910 --> 00:40:46,530
they figure out there are some limitations and they try to address these limitations. 

655
00:40:47,370 --> 00:40:52,750
And the address is limitation in what is called berkeley fast file system, 

656
00:40:52,760 --> 00:40:56,910
ffs which is bsd.4.2. 

657
00:40:59,590 --> 00:41:00,830
This was at least 84. 

658
00:41:00,840 --> 00:41:02,190
So still a long time ago, 

659
00:41:04,000 --> 00:41:06,020
it's very similar with 4.1. 

660
00:41:06,570 --> 00:41:09,260
The differences are that while in 4.1, 

661
00:41:09,270 --> 00:41:15,610
typical is a block size with one kilobyte in 4.21~4 kilobytes. 

662
00:41:16,090 --> 00:41:16,730
Why? 

663
00:41:17,020 --> 00:41:20,250
Because obviously, the discovery are increasing size.

664
00:41:22,220 --> 00:41:23,530
It's a very good paper. 

665
00:41:23,540 --> 00:41:24,970
I recommend you to read. 

666
00:41:24,980 --> 00:41:26,610
It's in the reading material. 

667
00:41:26,920 --> 00:41:30,380
If not, you can search on the web and you can get it,

668
00:41:30,390 --> 00:41:31,500
but it's very interesting. 

669
00:41:32,450 --> 00:41:34,800
And there are a bunch of optimization. 

670
00:41:35,750 --> 00:41:42,670
We are going to go briefly through these optimization and comparison with 4.1. 

671
00:41:48,750 --> 00:41:50,490
So let me go. 

672
00:41:50,500 --> 00:41:52,690
So I am not going to go now through this list. 

673
00:41:52,700 --> 00:41:57,450
I'm going while I am going to explain this optimization. 

674
00:41:57,910 --> 00:41:59,870
But the media thinks about, first of all,

675
00:41:59,880 --> 00:42:03,510
let's talk about what are the motivation? 

676
00:42:03,770 --> 00:42:10,070
What are the problems with the file systems in unix, 

677
00:42:10,080 --> 00:42:14,270
bsd 4.10 k

678
00:42:19,800 --> 00:42:25,690
the one thing is that the fire system is a fat table, 

679
00:42:25,700 --> 00:42:28,440
and all of these, 

680
00:42:28,690 --> 00:42:32,320
I note data structures, right?

681
00:42:33,290 --> 00:42:36,150
They were in a fixed disk, 

682
00:42:36,650 --> 00:42:38,240
in the fixed place on the disk. 

683
00:42:40,480 --> 00:42:41,060
Okay? 

684
00:42:43,140 --> 00:42:46,300
And the problem, 

685
00:42:46,350 --> 00:42:51,380
or is that if you have all these I notes on the disk in on place, 

686
00:42:52,800 --> 00:43:00,010
then it's very likely that

687
00:43:00,610 --> 00:43:04,530
they are going to be far from most of the data blocks. 

688
00:43:06,040 --> 00:43:09,830
The data blocks are all over, obviously.

689
00:43:10,670 --> 00:43:13,530
And the eye notes are only at the age. 

690
00:43:13,540 --> 00:43:15,370
In order to access the data blocks, 

691
00:43:15,380 --> 00:43:18,610
you need the information from the inode of that particular file. 

692
00:43:19,640 --> 00:43:19,830
Right? 

693
00:43:19,840 --> 00:43:21,310
So you need to read on I note, 

694
00:43:21,320 --> 00:43:24,950
and you are almost guaranteed that I know the place where I know the store

695
00:43:24,960 --> 00:43:28,530
on that is is far away from where the data is located on this. 

696
00:43:30,500 --> 00:43:31,330
It's sick time. 

697
00:43:31,690 --> 00:43:33,150
You are going to pay for the 6th time. 

698
00:43:34,730 --> 00:43:36,250
The other thing is reliability. 

699
00:43:37,020 --> 00:43:43,010
If somehow the outer edges tracks of the disk are destroyed, 

700
00:43:43,020 --> 00:43:48,120
because sometimes when some of the failures happen, 

701
00:43:48,130 --> 00:43:53,480
is that when you have a power outage and the discourse are rotating, 

702
00:43:53,490 --> 00:43:59,120
and sometimes the heads were kind of scratching the disk

703
00:43:59,130 --> 00:44:01,000
in that particular case. 

704
00:44:02,230 --> 00:44:09,450
Then if you lose this kind of the inode information, you lost everything.

705
00:44:14,740 --> 00:44:17,090
So that's a problem. 

706
00:44:20,010 --> 00:44:24,140
The other think it was, 

707
00:44:26,100 --> 00:44:28,460
it's hard to allocate for performance, 

708
00:44:29,960 --> 00:44:31,260
because in unix, 

709
00:44:31,480 --> 00:44:33,790
most rights in many rights are by append. 

710
00:44:33,800 --> 00:44:37,070
It's again when you write either your right to existing block, 

711
00:44:37,520 --> 00:44:39,190
because what is the existing data? 

712
00:44:39,200 --> 00:44:40,750
Is that you override the data. 

713
00:44:40,760 --> 00:44:42,350
But if you append, 

714
00:44:42,630 --> 00:44:44,870
in many cases, you just append to file,

715
00:44:44,880 --> 00:44:47,570
then you are going to add new blocks. 

716
00:44:49,500 --> 00:44:58,630
And the problem here is that you want to allocate, in some sense,

717
00:45:00,680 --> 00:45:03,960
obviously, on to allocate blocks which are contiguous, right?

718
00:45:04,570 --> 00:45:06,900
But that's kind of was difficult. 

719
00:45:07,300 --> 00:45:11,190
In the case of4.1, 

720
00:45:11,470 --> 00:45:12,990
you need to be 84.1. 

721
00:45:13,000 --> 00:45:15,450
You have a linguist for the three blocks, 

722
00:45:15,460 --> 00:45:17,240
like in the fact table. 

723
00:45:17,660 --> 00:45:19,120
And then the way you allocate, 

724
00:45:19,130 --> 00:45:20,570
you go through this list, 

725
00:45:20,870 --> 00:45:24,790
and you allocate always the first block, which is available.

726
00:45:25,360 --> 00:45:27,380
But the going through the list of the three blocks, 

727
00:45:27,390 --> 00:45:29,450
all these blocks can be all over the place. 

728
00:45:32,430 --> 00:45:33,350
So are they done? 

729
00:45:34,000 --> 00:45:35,190
So here is what they done. 

730
00:45:36,050 --> 00:45:40,030
Basically, they define this kind of block groups.

731
00:45:40,740 --> 00:45:47,490
So the tracks which are nearby are in the same block. 

732
00:45:47,780 --> 00:45:49,090
And correspondingly, also,

733
00:45:49,100 --> 00:45:51,770
they define the cylinder group, 

734
00:45:52,890 --> 00:45:58,980
like all the blocks which are fall under block groups, 

735
00:45:58,990 --> 00:46:04,850
which are falling under the

736
00:46:07,550 --> 00:46:13,550
the drive head heads on all the bladders, 

737
00:46:13,970 --> 00:46:14,970
are in the same cylinder. 

738
00:46:14,980 --> 00:46:19,130
You imagine a cylinder which are going to contain all these data blocks, 

739
00:46:19,940 --> 00:46:22,570
which are overlay one over another. 

740
00:46:27,340 --> 00:46:28,540
So right now, 

741
00:46:29,130 --> 00:46:33,010
then instead of having these I nodes, 

742
00:46:33,910 --> 00:46:38,410
and only at the edge, 

743
00:46:39,610 --> 00:46:43,800
start at the age of that is you are associating these eye notes, 

744
00:46:44,670 --> 00:46:45,190
right? 

745
00:46:45,720 --> 00:46:46,790
To the files, 

746
00:46:46,800 --> 00:46:50,790
the eye notes with which for the files, 

747
00:46:50,800 --> 00:46:54,230
which are who was that I stored in the same block, 

748
00:46:54,700 --> 00:46:56,040
are also in the same block. 

749
00:46:59,310 --> 00:47:00,960
Seriously, this is, I know,

750
00:47:00,970 --> 00:47:06,300
the information for the files which are stored in blog group one. 

751
00:47:06,800 --> 00:47:09,190
And these are the eye notes. 

752
00:47:09,630 --> 00:47:15,160
The information now for the files with data is in block group two. 

753
00:47:19,930 --> 00:47:20,970
Furthermore, 

754
00:47:20,980 --> 00:47:28,100
instead of maintaining the are available three blocks in, 

755
00:47:28,110 --> 00:47:30,140
at least you have a bit back. 

756
00:47:30,790 --> 00:47:31,460
And i'll tell you, 

757
00:47:31,470 --> 00:47:33,820
i'll show you next time you can do if you have a bit back. 

758
00:47:34,520 --> 00:47:34,880
Right? 

759
00:47:35,190 --> 00:47:36,360
But this is what it is now. 

760
00:47:37,710 --> 00:47:39,180
In terms of performance, 

761
00:47:39,540 --> 00:47:41,230
if you have this kind of layout, 

762
00:47:41,780 --> 00:47:48,630
now, because I nodes are in the same blog groups

763
00:47:52,910 --> 00:47:54,370
with the corresponding files, 

764
00:47:54,790 --> 00:47:56,000
what do I gain here? 

765
00:47:57,180 --> 00:47:58,220
What do I save here? 

766
00:47:59,640 --> 00:48:00,880
In terms of performance? 

767
00:48:04,080 --> 00:48:05,580
What is a big deal about this? 

768
00:48:14,850 --> 00:48:16,730
Again, for a file to access a file,

769
00:48:16,740 --> 00:48:18,050
I need to get its eye node. 

770
00:48:19,270 --> 00:48:20,850
And then I need to access these data. 

771
00:48:23,050 --> 00:48:24,210
Because once I get there, 

772
00:48:24,220 --> 00:48:28,310
I know I have the information or the blocks of the file are located. 

773
00:48:28,320 --> 00:48:29,550
I'm going to read or write. 

774
00:48:30,950 --> 00:48:34,380
That is a big deal about this layout. 

775
00:48:53,730 --> 00:48:55,810
If the iron ore is near the file blocks, 

776
00:48:55,820 --> 00:48:57,250
then it will be much faster, 

777
00:48:57,260 --> 00:48:59,090
but it especially for small files. 

778
00:48:59,100 --> 00:49:00,350
This is good. 

779
00:49:01,060 --> 00:49:08,750
The sick time it's exactly listeners and it's

780
00:49:08,760 --> 00:49:11,350
basically the sick time would be smaller, 

781
00:49:11,360 --> 00:49:13,970
which will be much lower. 

782
00:49:14,740 --> 00:49:14,970
Right? 

783
00:49:14,980 --> 00:49:16,170
Because the sick time, 

784
00:49:16,480 --> 00:49:19,850
it's about how far there are two tracks on from each other. 

785
00:49:19,860 --> 00:49:21,730
This is a sick time it is given by. 

786
00:49:22,630 --> 00:49:28,740
And now the blocks are on tracks which are closer together. 

787
00:49:29,340 --> 00:49:29,740
Right? 

788
00:49:30,760 --> 00:49:31,930
So this is what it is. 

789
00:49:32,360 --> 00:49:34,420
It's not only that I read the I note, 

790
00:49:34,430 --> 00:49:36,760
and i'm going to this file, separate these files,

791
00:49:36,770 --> 00:49:38,380
but also all the fire, 

792
00:49:38,390 --> 00:49:44,680
all the blocks are in each all the blocks of the file are in a blog group. 

793
00:49:44,690 --> 00:49:48,460
If they are in a blog groups and going from one block to another. 

794
00:49:48,690 --> 00:49:50,600
Even if they are not contiguous, 

795
00:49:50,920 --> 00:49:52,510
the sick time is going to be loved. 

796
00:50:02,590 --> 00:50:02,940
Also, here,

797
00:50:02,950 --> 00:50:10,200
one thing which I didn't mention is that the I note for for files, 

798
00:50:10,860 --> 00:50:16,560
and the pattern is the entire directories with the files. 

799
00:50:17,660 --> 00:50:22,300
They the file system tries to put them on the same cylinder. 

800
00:50:23,510 --> 00:50:23,930
Right? 

801
00:50:24,250 --> 00:50:29,670
So on different corresponding blocks on different bladders of that is right. 

802
00:50:30,150 --> 00:50:33,040
It's, again, to minimize a sick time, in this case,

803
00:50:33,640 --> 00:50:37,560
going to do analysis from directory. 

804
00:50:37,760 --> 00:50:40,750
You all the information is within the same cylinder. 

805
00:50:48,270 --> 00:50:52,060
I will discuss about this data block metadata and free space are

806
00:50:52,070 --> 00:50:53,260
within each block. 

807
00:50:53,730 --> 00:50:57,190
A voice huge, 6 time between user data and system structures.

808
00:51:00,240 --> 00:51:03,880
You also put the directory, like I mentioned,

809
00:51:03,890 --> 00:51:06,210
and these files in the common logo. 

810
00:51:06,700 --> 00:51:07,060
Basically, 

811
00:51:07,070 --> 00:51:11,330
you try to preserve some locality between the meta data of the files

812
00:51:11,340 --> 00:51:13,610
and the data blocks of the files

813
00:51:14,910 --> 00:51:19,470
on by being careful how you store them on the disk. 

814
00:51:19,730 --> 00:51:21,480
But I try to be close to each other. 

815
00:51:24,340 --> 00:51:25,420
Like I mentioned, 

816
00:51:25,430 --> 00:51:31,490
the least the free block allocation. 

817
00:51:33,120 --> 00:51:41,430
Here we use bit map that before we used least by using bit map, 

818
00:51:41,440 --> 00:51:44,070
you can actually avoid some fragmentation. 

819
00:51:45,090 --> 00:51:46,480
One important things, 

820
00:51:48,070 --> 00:51:49,530
which is true, 

821
00:51:49,770 --> 00:51:56,650
both for the file systems in unix, 

822
00:51:57,650 --> 00:51:59,860
bsd 4.1 and 4.2, 

823
00:52:00,050 --> 00:52:03,090
is that you need to keep some 10%, 

824
00:52:03,100 --> 00:52:05,190
20% of free space, always,

825
00:52:05,490 --> 00:52:07,060
because this, too.

826
00:52:07,340 --> 00:52:10,770
But because if you don't have any kind of free space, 

827
00:52:11,420 --> 00:52:17,320
really, you have no freedom about where to allocate the new blocks.

828
00:52:17,760 --> 00:52:20,230
They are going to become pretty, very random.

829
00:52:20,550 --> 00:52:25,580
The performance of the disk will will slow down to a crowd. 

830
00:52:26,490 --> 00:52:26,770
Right? 

831
00:52:27,470 --> 00:52:30,250
But i'll say a few more words about that. 

832
00:52:30,540 --> 00:52:32,950
But now let's see what is a big difference? 

833
00:52:32,960 --> 00:52:40,990
And what is the advantage of maintaining a big map for the three blocks? 

834
00:52:41,350 --> 00:52:43,190
Instead of linguists? 

835
00:52:44,290 --> 00:52:45,280
Here is a difference. 

836
00:52:50,730 --> 00:52:52,040
We'll go over the summary here. 

837
00:52:52,050 --> 00:52:53,120
So here is the difference. 

838
00:52:54,380 --> 00:52:55,650
So here is a bit much. 

839
00:52:56,230 --> 00:52:56,780
Okay? 

840
00:52:57,470 --> 00:53:00,460
The dark shades, 

841
00:53:00,770 --> 00:53:01,800
each rectangle, 

842
00:53:01,810 --> 00:53:03,120
it's a correspondence to block, 

843
00:53:03,130 --> 00:53:04,680
a square correspondence to block, 

844
00:53:07,930 --> 00:53:10,040
the shy shaded, one represent blocks,

845
00:53:10,050 --> 00:53:11,160
which are in yours, 

846
00:53:11,390 --> 00:53:13,390
and the white one cities and three blocks. 

847
00:53:16,870 --> 00:53:18,110
So a here, 

848
00:53:18,240 --> 00:53:19,990
a it's a very nice characteristic. 

849
00:53:20,680 --> 00:53:29,620
Let's say that I I I am starting to add to expand the a file, 

850
00:53:29,820 --> 00:53:32,870
and i'm going to allocate new blocks, right?

851
00:53:32,880 --> 00:53:34,800
I have to allocate new blocks. 

852
00:53:34,810 --> 00:53:35,030
Okay? 

853
00:53:35,440 --> 00:53:37,350
What i'm going to do here, 

854
00:53:37,570 --> 00:53:40,210
i'm going to go through this speed map. 

855
00:53:40,220 --> 00:53:42,890
I'm going to start reading from the beginning. 

856
00:53:43,550 --> 00:53:48,350
Whenever i'm going to see a free blog, 

857
00:53:48,710 --> 00:53:49,980
i'm going to allocate it. 

858
00:53:49,990 --> 00:53:51,060
So this one, 

859
00:53:51,070 --> 00:53:53,300
the blue ones are the one which have been allocated. 

860
00:53:54,580 --> 00:53:55,130
So far. 

861
00:53:55,140 --> 00:53:55,690
So good. 

862
00:53:55,700 --> 00:53:59,330
Again, it's like i'm going to allocate what I seek encounter.

863
00:53:59,340 --> 00:53:59,850
First. 

864
00:54:00,370 --> 00:54:01,620
These blocks, actually,

865
00:54:01,630 --> 00:54:03,720
in terms of the location, 

866
00:54:03,970 --> 00:54:08,510
can be quite random if they are not one near each other. 

867
00:54:09,580 --> 00:54:10,330
However, 

868
00:54:10,920 --> 00:54:20,190
when I am going to start allocating the more I allocate or file, 

869
00:54:20,530 --> 00:54:22,130
the more i'm going to start, 

870
00:54:22,410 --> 00:54:25,040
looking for bigger gaps, 

871
00:54:25,890 --> 00:54:26,270
right? 

872
00:54:26,960 --> 00:54:30,630
For more contiguous regions. 

873
00:54:31,510 --> 00:54:32,020
Okay? 

874
00:54:33,950 --> 00:54:36,460
I think that's basically the key. 

875
00:54:36,930 --> 00:54:39,100
So initially, I am allocating,

876
00:54:40,930 --> 00:54:41,930
as I find, 

877
00:54:42,640 --> 00:54:45,770
these blocks available, empty.

878
00:54:46,980 --> 00:54:48,640
But then after a while, 

879
00:54:49,090 --> 00:54:52,630
when I start to allocate more and more new blocks to file, 

880
00:54:52,850 --> 00:54:56,650
I am starting to look more and more for contiguous blocks. 

881
00:54:57,550 --> 00:54:57,900
Right? 

882
00:54:58,290 --> 00:54:59,840
Because I have a bit map. 

883
00:55:00,090 --> 00:55:02,680
It's much easier to look for continuous blocks, 

884
00:55:02,690 --> 00:55:05,580
because I know I just look at the bit map. 

885
00:55:05,960 --> 00:55:09,040
In the case of the linguist is much harder because I need to pop

886
00:55:09,050 --> 00:55:13,290
up from to go from one to another entry with a linguist. 

887
00:55:14,380 --> 00:55:15,720
With a linguist, really,

888
00:55:15,730 --> 00:55:21,350
I am going to in the order in which I am going to see to find

889
00:55:21,360 --> 00:55:23,500
in the linguist the three blocks. 

890
00:55:26,130 --> 00:55:27,120
Does it make sense? 

891
00:55:28,850 --> 00:55:34,810
Then the pldr here is that a a with a if I have a big map, 

892
00:55:36,140 --> 00:55:46,090
then it's much easier for me to identify contiguous regions of three blocks. 

893
00:55:49,240 --> 00:55:51,880
It's a simple that more efficient. 

894
00:55:53,370 --> 00:55:55,880
Then as I have of larger and larger files, 

895
00:55:55,890 --> 00:55:57,480
which advocate more and more blocks, 

896
00:55:57,490 --> 00:56:03,770
I am going to start using and allocate more of these contiguous blocks. 

897
00:56:18,690 --> 00:56:19,480
It's a bit map. 

898
00:56:19,930 --> 00:56:20,920
The question here. 

899
00:56:20,930 --> 00:56:24,120
The blocks here are in an area rather than a linguist. 

900
00:56:24,680 --> 00:56:27,700
Yes, again, it's a a bit map is by definition and others,

901
00:56:28,560 --> 00:56:32,130
but it's very efficient, right?

902
00:56:32,600 --> 00:56:32,820
A pointer. 

903
00:56:32,830 --> 00:56:34,070
How many beats you have? 

904
00:56:34,080 --> 00:56:34,320
Right? 

905
00:56:34,330 --> 00:56:37,530
For a point that you have beats 4 bytes, right?

906
00:56:37,540 --> 00:56:38,730
32 beats, at least.

907
00:56:39,650 --> 00:56:42,250
Here you have for one block, you have 1 bit.

908
00:56:46,040 --> 00:56:46,370
Right? 

909
00:56:53,900 --> 00:56:54,810
Now let's go back. 

910
00:56:57,670 --> 00:57:02,540
A summary for these fast file systems are now layout. 

911
00:57:04,300 --> 00:57:06,260
If you have a small directory, 

912
00:57:06,270 --> 00:57:10,080
you can fit all the data of the files in the directory, 

913
00:57:10,090 --> 00:57:11,240
in the same cylinder. 

914
00:57:11,510 --> 00:57:13,580
There is no very little six. 

915
00:57:14,230 --> 00:57:14,510
Right? 

916
00:57:19,700 --> 00:57:28,600
So If the file had that is are smaller than the whole blocks, 

917
00:57:28,610 --> 00:57:32,920
you can obviously fetch many of those at the same time. 

918
00:57:33,500 --> 00:57:38,700
The last one, remember that one of the disadvantage of 4.1,

919
00:57:38,710 --> 00:57:41,420
it was big reliability, 

920
00:57:42,060 --> 00:57:44,770
because all the eye notes are in one place. 

921
00:57:45,130 --> 00:57:46,980
If that place is corrupted, 

922
00:57:47,190 --> 00:57:50,110
you lost all the information from the entire risk. 

923
00:57:51,880 --> 00:57:54,590
Right here, it's basically,

924
00:57:54,600 --> 00:57:56,270
if some part is corrupted, 

925
00:57:56,950 --> 00:57:58,460
maybe you lose some eye nodes, 

926
00:57:58,470 --> 00:58:00,380
the information about some files. 

927
00:58:00,830 --> 00:58:02,780
You can never access those files, 

928
00:58:03,150 --> 00:58:04,710
but many other files, 

929
00:58:04,930 --> 00:58:06,880
they are still going to be accessible, 

930
00:58:07,110 --> 00:58:10,220
because that I knows are going to be intact because they are stored

931
00:58:10,230 --> 00:58:11,720
on different places on the disk. 

932
00:58:13,450 --> 00:58:13,900
Okay. 

933
00:58:15,490 --> 00:58:18,760
Here is another very interesting aspect is a rotation like this. 

934
00:58:18,770 --> 00:58:20,000
We talk about the sick. 

935
00:58:20,910 --> 00:58:27,270
The group block groups are intended to reduce the overhead for the sick time. 

936
00:58:27,630 --> 00:58:29,040
What about rotation letters? 

937
00:58:31,140 --> 00:58:32,450
Here is a one interesting thing. 

938
00:58:34,510 --> 00:58:36,700
Initially, with the unix,

939
00:58:38,290 --> 00:58:39,780
a lot of these blocks, 

940
00:58:40,840 --> 00:58:45,910
the block is a lot of functionality of the file system was implemented

941
00:58:45,920 --> 00:58:48,570
in the operating system. 

942
00:58:49,310 --> 00:58:51,240
The controllers of the drive, 

943
00:58:51,250 --> 00:58:52,680
this drive was very simple. 

944
00:58:53,950 --> 00:58:57,100
Now, the operating system was getting a block,

945
00:59:00,200 --> 00:59:00,530
right? 

946
00:59:01,910 --> 00:59:05,350
Say, and then needs to transfer the data from the block.

947
00:59:06,740 --> 00:59:09,230
But while transferring the data from the block, 

948
00:59:10,390 --> 00:59:13,990
the head was on top of the next sector. 

949
00:59:17,600 --> 00:59:22,820
And then you don't know, right?

950
00:59:22,830 --> 00:59:26,810
And then you are going to miss reading the data from the next sector. 

951
00:59:27,580 --> 00:59:28,000
Right? 

952
00:59:28,320 --> 00:59:29,950
Basically, think about this.

953
00:59:29,960 --> 00:59:31,190
I am want to do. 

954
00:59:31,480 --> 00:59:36,050
Ii want to transfer the data from sectors one by one. 

955
00:59:36,590 --> 00:59:38,960
Assume that the data is on contiguous sectors. 

956
00:59:39,350 --> 00:59:39,900
It's great. 

957
00:59:40,250 --> 00:59:40,700
Right? 

958
00:59:40,880 --> 00:59:44,030
But now the problem is that I read the data from a sector. 

959
00:59:44,490 --> 00:59:47,740
And while i'm transferring the data from the sector to read it, 

960
00:59:48,000 --> 00:59:49,520
the head is on the next sector. 

961
00:59:50,370 --> 00:59:50,760
Right? 

962
00:59:52,420 --> 00:59:57,490
And then I missed that I miss the beginning of the next sector, 

963
00:59:58,150 --> 00:59:58,580
right? 

964
00:59:59,120 --> 01:00:04,040
Then I need to wait for the entire rotation of the disk to get the next sector. 

965
01:00:05,840 --> 01:00:11,040
So one original techniques to address this problem, 

966
01:00:11,380 --> 01:00:15,370
it was is when I I am writing data on sectors, 

967
01:00:15,710 --> 01:00:16,770
is to intervene, 

968
01:00:16,780 --> 01:00:21,500
do not write data downs on subsequent sectors, 

969
01:00:22,000 --> 01:00:24,000
but skip one sector. 

970
01:00:24,930 --> 01:00:26,880
So that when I read the data, 

971
01:00:27,160 --> 01:00:29,570
then i'm reading the data on a sector. 

972
01:00:29,580 --> 01:00:34,690
And while i'm transferring the data from that sector to the operating system, 

973
01:00:35,410 --> 01:00:42,630
I I am not going to the next sector is fine if i'm skipping it, 

974
01:00:42,640 --> 01:00:45,190
because it doesn't contain the data from the file. 

975
01:00:45,600 --> 01:00:47,040
By the time the head, 

976
01:00:47,050 --> 01:00:48,490
it's over the next sector, 

977
01:00:48,500 --> 01:00:50,520
which contains the data from the file, 

978
01:00:50,530 --> 01:00:52,450
I am ready to read it to read. 

979
01:00:58,530 --> 01:00:59,090
Make sense? 

980
01:01:01,650 --> 01:01:06,190
So basically, here you overlap the transfer time,

981
01:01:06,840 --> 01:01:07,170
right? 

982
01:01:10,230 --> 01:01:11,030
With a rotation, 

983
01:01:16,410 --> 01:01:17,290
it is pretty cool. 

984
01:01:18,770 --> 01:01:22,930
It turns out that actually, 

985
01:01:22,940 --> 01:01:26,090
the other solution was you just read ahead. 

986
01:01:26,100 --> 01:01:28,100
I read a sector. 

987
01:01:29,320 --> 01:01:31,310
While i'm transferring it after that, 

988
01:01:31,320 --> 01:01:34,310
i'm not sure whether I need the data from the next sector or not. 

989
01:01:37,040 --> 01:01:37,750
But it's okay. 

990
01:01:38,540 --> 01:01:40,660
I'm just assuming that i'm needing it. 

991
01:01:41,470 --> 01:01:42,570
So i'm going to read ahead. 

992
01:01:45,460 --> 01:01:46,490
And if I don't need it, 

993
01:01:46,500 --> 01:01:47,730
i'm going to discuss it. 

994
01:01:50,660 --> 01:01:51,810
I'm just going to buffer it. 

995
01:01:51,820 --> 01:01:53,810
I just need a buffer to push more data. 

996
01:01:56,000 --> 01:01:59,340
So that's that's another solution. 

997
01:01:59,350 --> 01:02:00,780
It's more flexible solution. 

998
01:02:01,500 --> 01:02:06,780
And this is actually what they it's used. 

999
01:02:07,290 --> 01:02:12,440
And this is implemented mostly in the controllers of the disk. 

1000
01:02:13,440 --> 01:02:16,040
The disk has a ram has a buffer, if you remember.

1001
01:02:16,050 --> 01:02:17,440
So you read in that buffer, 

1002
01:02:17,780 --> 01:02:19,500
and then you transfer to the operating system. 

1003
01:02:23,610 --> 01:02:24,730
Any questions about this? 

1004
01:02:35,520 --> 01:02:37,870
The first solution is implementing your rewriting, 

1005
01:02:37,880 --> 01:02:41,230
while the second one is implementing your reading is a question. 

1006
01:02:42,310 --> 01:02:43,500
No, not really.

1007
01:02:43,830 --> 01:02:47,080
In both cases, you can think about this optimization for reading.

1008
01:02:47,660 --> 01:02:52,490
It's, again, the problem here is that you read a sector,

1009
01:02:52,500 --> 01:02:56,290
and then I I am going to send the request for reading the next sector

1010
01:02:56,300 --> 01:02:57,850
and the next sector and the next. 

1011
01:02:58,790 --> 01:03:00,140
I'm reading this sector. 

1012
01:03:00,530 --> 01:03:03,000
And then I need to transfer the data from the sectors. 

1013
01:03:03,010 --> 01:03:04,360
And by the time, 

1014
01:03:04,620 --> 01:03:08,070
I am going to issue the request for it in the next sector. 

1015
01:03:09,290 --> 01:03:13,020
The head, it's already over the next sector,

1016
01:03:13,030 --> 01:03:14,250
on the list. 

1017
01:03:15,620 --> 01:03:15,950
Right? 

1018
01:03:17,310 --> 01:03:18,500
I'm reading this sector, 

1019
01:03:18,510 --> 01:03:19,860
and then I am, 

1020
01:03:20,120 --> 01:03:24,160
by the time I am going to issue the request for reading the next sector

1021
01:03:25,950 --> 01:03:26,980
from the file. 

1022
01:03:28,040 --> 01:03:30,720
The next i'm already over the next sector, i'm going.

1023
01:03:30,730 --> 01:03:32,120
So if it happened, 

1024
01:03:32,740 --> 01:03:35,400
that is actually the sector. 

1025
01:03:35,660 --> 01:03:39,590
I want to read it just after the sector I am reading, 

1026
01:03:42,150 --> 01:03:43,800
then I am going to miss it, 

1027
01:03:45,320 --> 01:03:48,430
because I don't get in time the comment to read the next sector. 

1028
01:03:50,410 --> 01:03:50,960
Therefore, 

1029
01:03:50,970 --> 01:03:57,550
I I have to wait all the way for the destroyed once to read the next sector. 

1030
01:03:58,760 --> 01:04:03,140
What this first optimization says that I am reading a sector, 

1031
01:04:04,500 --> 01:04:09,360
all I am transferring and give you some time before I get the next comment. 

1032
01:04:10,810 --> 01:04:12,480
And if I get the next comment, 

1033
01:04:12,490 --> 01:04:18,010
then I am going to know i'm going to be close to this next sector after I

1034
01:04:18,020 --> 01:04:18,610
skipped one. 

1035
01:04:21,100 --> 01:04:21,580
Okay? 

1036
01:04:22,020 --> 01:04:27,580
If I want to continuously in this mode to have maximized performance, 

1037
01:04:28,010 --> 01:04:30,800
I need to interleave the sectors. 

1038
01:04:31,460 --> 01:04:32,730
I when I write them, 

1039
01:04:32,740 --> 01:04:33,810
so when I read them, 

1040
01:04:33,820 --> 01:04:40,970
I am going to read ones and while i'm transferring and be getting command

1041
01:04:40,980 --> 01:04:41,530
for it, 

1042
01:04:41,540 --> 01:04:42,970
reading the next sector, 

1043
01:04:46,070 --> 01:04:47,430
I have enough time. 

1044
01:04:47,950 --> 01:04:50,000
So I am ready to read the next section. 

1045
01:04:51,730 --> 01:04:52,480
This makes sense. 

1046
01:04:58,090 --> 01:05:02,760
How big does a track buffer usually needs to be to store the entire track? 

1047
01:05:02,770 --> 01:05:04,280
That's a very good question. 

1048
01:05:05,410 --> 01:05:07,360
So candida had the entire track. 

1049
01:05:09,870 --> 01:05:13,070
Ii don't know on top of my mind of my head, 

1050
01:05:13,370 --> 01:05:14,520
what is how much? 

1051
01:05:16,920 --> 01:05:17,160
Yeah, 

1052
01:05:18,130 --> 01:05:19,440
i'll try to get back to you, 

1053
01:05:19,450 --> 01:05:22,980
but I assume a few tens of megabytes, 

1054
01:05:23,380 --> 01:05:24,520
depending on the disk. 

1055
01:05:27,270 --> 01:05:32,620
But so gilbert did answer your question. 

1056
01:05:43,770 --> 01:05:44,820
So it's again, 

1057
01:05:44,830 --> 01:05:50,410
remember that the disks and this controller do a lot of things under the foot, 

1058
01:05:50,420 --> 01:05:50,810
right? 

1059
01:05:50,820 --> 01:05:51,130
Like, 

1060
01:05:51,630 --> 01:05:52,190
remember, 

1061
01:05:52,200 --> 01:05:56,830
we did last time we learned about c scan and other scheduling algorithms, 

1062
01:05:56,840 --> 01:05:58,350
three orders, a request.

1063
01:05:58,360 --> 01:06:01,580
So therefore, you reduce a 6 time and rotation letters,

1064
01:06:07,700 --> 01:06:09,410
the price of 4.2, 

1065
01:06:10,790 --> 01:06:13,870
you have official storage for both small and large files. 

1066
01:06:14,310 --> 01:06:17,330
And this is because you have this direct blocks, 

1067
01:06:17,340 --> 01:06:18,850
indirect block pointers, 

1068
01:06:18,860 --> 01:06:21,090
and doubling direct and triple indirect. 

1069
01:06:22,410 --> 01:06:25,730
You can accommodate both small files and large files. 

1070
01:06:28,620 --> 01:06:30,370
You have locality for boston, 

1071
01:06:30,380 --> 01:06:32,410
small and large files to try to do that, 

1072
01:06:32,420 --> 01:06:40,030
because they try to store them within the same block group or cylinder group. 

1073
01:06:40,910 --> 01:06:43,970
And you also try to, 

1074
01:06:44,300 --> 01:06:47,690
you have the locality between the meta data and data, 

1075
01:06:47,700 --> 01:06:50,130
because the meta data that is I nodes. 

1076
01:06:50,640 --> 01:06:55,510
We try to store them on the same block group, 

1077
01:06:55,830 --> 01:06:58,440
whether the files themselves are stored. 

1078
01:07:02,190 --> 01:07:04,180
We didn't talk about this when they say, no,

1079
01:07:04,190 --> 01:07:06,180
the fragmentation is necessary. 

1080
01:07:06,560 --> 01:07:12,250
Not a fragmentation in the study here because you have the big map in what

1081
01:07:12,260 --> 01:07:14,300
happens to is that with and

1082
01:07:14,310 --> 01:07:17,200
I remember that when I use it long time ago, 

1083
01:07:18,330 --> 01:07:19,640
when use fat, 

1084
01:07:20,530 --> 01:07:26,340
when you or this30 microsoft operating systems, 

1085
01:07:27,430 --> 01:07:28,620
the file systems, 

1086
01:07:28,910 --> 01:07:31,310
what you have from time to time, you need to dance,

1087
01:07:31,560 --> 01:07:32,750
the fragment, the disk,

1088
01:07:32,760 --> 01:07:34,070
the fragments of this. 

1089
01:07:34,390 --> 01:07:39,610
What meant is these to rewrite the information from the distribute. 

1090
01:07:39,620 --> 01:07:42,250
So the files are more contiguously stored, 

1091
01:07:43,310 --> 01:07:43,430
right? 

1092
01:07:43,440 --> 01:07:47,460
Because the discourse fragmented as you believe disks, 

1093
01:07:47,930 --> 01:07:51,160
as you delete files and you write more files, 

1094
01:07:51,420 --> 01:07:52,780
is more and more fragmented, 

1095
01:07:52,790 --> 01:07:58,180
meaning that the date of the files is stored more and more randomly. 

1096
01:07:58,480 --> 01:08:03,040
The blocks are more and more randomly from time to time you do the fragmentation. 

1097
01:08:03,290 --> 01:08:08,470
So you are going to try again to this to ready to rewrite the files, 

1098
01:08:08,770 --> 01:08:12,160
so to move the blocks around so to speak, 

1099
01:08:12,550 --> 01:08:16,670
so that the files are stored on contiguous blocks, 

1100
01:08:16,920 --> 01:08:18,510
and the performance will be much better. 

1101
01:08:19,110 --> 01:08:19,460
Okay? 

1102
01:08:20,160 --> 01:08:23,200
Here is not really necessary because I told you about these holistics

1103
01:08:23,210 --> 01:08:26,100
in which you try to find large, 

1104
01:08:26,380 --> 01:08:32,300
a a large bunch of three blocks for large files to store the data. 

1105
01:08:35,550 --> 01:08:38,390
The course, it's efficient,

1106
01:08:38,400 --> 01:08:40,230
inefficient for tiny files. 

1107
01:08:42,540 --> 01:08:48,530
It's a little bit unfair because it's still fundamentally the block

1108
01:08:49,040 --> 01:08:50,980
to store the unit of storage. 

1109
01:08:50,990 --> 01:08:52,090
It's a block. 

1110
01:08:52,590 --> 01:08:54,910
So even if you have1 byte, 

1111
01:08:55,230 --> 01:08:59,640
you still are going to read or write an entire blog, 

1112
01:08:59,650 --> 01:09:00,920
which is four kilobytes. 

1113
01:09:01,520 --> 01:09:04,550
In additional, you need an eye note for this data block,

1114
01:09:05,190 --> 01:09:12,040
most of the file systems will have the advantage and inefficient encoding

1115
01:09:12,050 --> 01:09:14,280
on file is mostly contiguous on the list. 

1116
01:09:14,960 --> 01:09:20,510
This basically says that you are going to have this bid map to tell you

1117
01:09:20,520 --> 01:09:21,590
where the blocks are. 

1118
01:09:22,080 --> 01:09:26,650
And if you have 1 bit a for each block, 

1119
01:09:27,230 --> 01:09:28,400
but for instance, 

1120
01:09:28,410 --> 01:09:31,860
if the file is continuously a stored on the list, 

1121
01:09:32,190 --> 01:09:34,440
then you need only 2 pieces of information. 

1122
01:09:34,450 --> 01:09:39,670
What is the beginning the point that to the first block as a point

1123
01:09:39,680 --> 01:09:40,590
up to the last block? 

1124
01:09:42,640 --> 01:09:44,710
Because everything in between is continuous, 

1125
01:09:44,720 --> 01:09:46,750
this what means it's inefficient? 

1126
01:09:46,990 --> 01:09:49,890
Encoding one files is mostly contiguous on the disk. 

1127
01:09:52,390 --> 01:09:53,580
And still, 

1128
01:09:53,590 --> 01:09:56,540
in order to avoid the fragmentation, 

1129
01:09:56,550 --> 01:10:00,310
you need to have this kind of space on the disk. 

1130
01:10:00,320 --> 01:10:05,370
So you cannot allocate the entire 100% of the disk space. 

1131
01:10:06,460 --> 01:10:07,950
You need to leave around 10, 

1132
01:10:07,960 --> 01:10:13,430
20% linux. 

1133
01:10:16,190 --> 01:10:17,440
It's pretty similar. 

1134
01:10:19,520 --> 01:10:22,430
You have12 direct pointers, 

1135
01:10:22,440 --> 01:10:24,030
like in our previous examples. 

1136
01:10:24,040 --> 01:10:24,910
If you remember, 

1137
01:10:26,630 --> 01:10:30,960
when I was a little bit confused between 12 and 10, 

1138
01:10:32,400 --> 01:10:34,630
you can have, in this case, you have 12.

1139
01:10:36,450 --> 01:10:41,960
The other thing you can configure the says the size of the blocks

1140
01:10:42,850 --> 01:10:45,360
to be different sizes. 

1141
01:10:45,610 --> 01:10:46,000
Right? 

1142
01:10:46,610 --> 01:10:50,160
You can have one kilobyte to kilobytes, four kilobytes, a kilobytes,

1143
01:10:50,170 --> 01:10:50,760
and so forth. 

1144
01:10:50,770 --> 01:10:51,320
It's again, 

1145
01:10:51,930 --> 01:10:53,840
you don't have in the same system, 

1146
01:10:54,090 --> 01:10:55,910
lots of different sizes. 

1147
01:10:56,300 --> 01:10:57,980
But when you configure the system, 

1148
01:10:58,430 --> 01:11:01,690
start with, you can choose different block sites.

1149
01:11:04,320 --> 01:11:06,510
These x two and x three, 

1150
01:11:06,520 --> 01:11:09,550
there are different versions of linux. 

1151
01:11:09,890 --> 01:11:12,360
In terms of particular of this cloud. 

1152
01:11:13,820 --> 01:11:15,100
We also have journaling. 

1153
01:11:15,410 --> 01:11:17,960
We are going to talk about journal ink later, 

1154
01:11:18,750 --> 01:11:25,370
but it's a particular way to start the files provide for tolerance. 

1155
01:11:25,750 --> 01:11:29,970
And we'll talk more about that. 

1156
01:11:30,950 --> 01:11:32,150
And other than that, 

1157
01:11:32,390 --> 01:11:35,520
is the same kind of organization here. 

1158
01:11:35,940 --> 01:11:36,700
You have, 

1159
01:11:39,530 --> 01:11:43,280
these are the pointers in the group descriptor table. 

1160
01:11:43,570 --> 01:11:45,740
You have pointer to the blocks in each blocks. 

1161
01:11:45,750 --> 01:11:46,860
You are going to have. 

1162
01:11:47,680 --> 01:11:49,320
You have, I know tables.

1163
01:11:49,730 --> 01:11:53,340
And then the I know tables are going to go to directory. 

1164
01:11:53,350 --> 01:11:59,550
This is how the directories are organized in ex two three, 

1165
01:12:01,040 --> 01:12:09,360
sending them hard, at least.

1166
01:12:10,010 --> 01:12:10,560
Sorry. 

1167
01:12:11,300 --> 01:12:13,280
So here, 

1168
01:12:13,550 --> 01:12:17,360
we remember last time we look through this directory structure

1169
01:12:17,370 --> 01:12:18,680
and the directory structure. 

1170
01:12:18,690 --> 01:12:19,670
It's an analogy. 

1171
01:12:20,730 --> 01:12:21,220
Okay. 

1172
01:12:24,900 --> 01:12:26,540
What you have, typically,

1173
01:12:26,550 --> 01:12:30,640
what you can do in unix, 

1174
01:12:31,040 --> 01:12:34,350
you can have a different, 

1175
01:12:35,030 --> 01:12:38,190
you can have another hard link is called harding, 

1176
01:12:38,200 --> 01:12:40,800
another link to the same file. 

1177
01:12:41,530 --> 01:12:41,930
Right? 

1178
01:12:41,940 --> 01:12:44,250
You can have the same file, 

1179
01:12:44,610 --> 01:12:49,710
which is basically you can have two names for that files, 

1180
01:12:49,720 --> 01:12:52,070
and these names can appear in different directors. 

1181
01:12:54,220 --> 01:12:55,570
When do you want to do that? 

1182
01:12:55,910 --> 01:13:01,040
Obviously, when I want to share a fart from different directors,

1183
01:13:02,220 --> 01:13:02,580
right? 

1184
01:13:03,380 --> 01:13:06,900
I want to appear to be locked up to that directory. 

1185
01:13:08,040 --> 01:13:08,320
Right? 

1186
01:13:08,330 --> 01:13:09,680
It's like, for instance,

1187
01:13:10,530 --> 01:13:10,810
library fire. 

1188
01:13:10,820 --> 01:13:12,110
So it seems like that. 

1189
01:13:12,840 --> 01:13:13,030
Right? 

1190
01:13:13,040 --> 01:13:14,270
And in this case, again,

1191
01:13:14,280 --> 01:13:20,980
I i'm going to have point that is the same two different file names

1192
01:13:20,990 --> 01:13:22,900
are going to point to the same file. 

1193
01:13:24,260 --> 01:13:30,270
And in the I node is i'm going to maintain a reference count why I need that? 

1194
01:13:30,570 --> 01:13:35,890
Because we're all only when all the references I know

1195
01:13:35,900 --> 01:13:38,290
to the same underlying file are removed. 

1196
01:13:38,300 --> 01:13:39,940
I carry on the file. 

1197
01:13:44,130 --> 01:13:45,160
In addition, 

1198
01:13:45,170 --> 01:13:47,160
I have also soft links. 

1199
01:13:47,460 --> 01:13:50,930
The soft links provide the same kind of behavior. 

1200
01:13:51,210 --> 01:13:51,670
It's again, 

1201
01:13:51,680 --> 01:13:58,450
they are used to create another entry in my current directory profile, 

1202
01:13:58,460 --> 01:14:00,130
which exists in a different directory. 

1203
01:14:01,980 --> 01:14:04,090
But this is symbolic link, 

1204
01:14:04,100 --> 01:14:05,530
is our softening. 

1205
01:14:05,880 --> 01:14:06,870
In this case, 

1206
01:14:06,880 --> 01:14:10,670
it's actually a symbolic link is another entering the directory, 

1207
01:14:10,990 --> 01:14:15,480
which basically about it has a file name, 

1208
01:14:15,490 --> 01:14:18,090
is the new file name, 

1209
01:14:18,100 --> 01:14:20,410
and then it's linked to the destination of file name. 

1210
01:14:21,070 --> 01:14:25,100
You think in bowling and into just something you write in your directory, 

1211
01:14:25,480 --> 01:14:26,980
which basically links the file name, 

1212
01:14:26,990 --> 01:14:31,330
the new file name with the destination finding the one which I want to link. 

1213
01:14:32,960 --> 01:14:33,320
Right? 

1214
01:14:37,710 --> 01:14:39,060
In this particular case, 

1215
01:14:39,070 --> 01:14:42,550
or if the destination file name is removed, 

1216
01:14:42,800 --> 01:14:50,340
the opening the file using the symbolic link name, 

1217
01:14:51,270 --> 01:14:52,100
it can fail, 

1218
01:14:53,330 --> 01:14:53,670
right? 

1219
01:14:54,200 --> 01:14:57,400
Because there is no one under the hood to keep the reference counting. 

1220
01:14:57,720 --> 01:15:05,220
How many as a fine name out of pointing to the same file. 

1221
01:15:06,140 --> 01:15:07,570
But this is easier to implement. 

1222
01:15:12,730 --> 01:15:13,640
This is what it is. 

1223
01:15:18,990 --> 01:15:22,450
You can create boss command line, 

1224
01:15:22,460 --> 01:15:23,610
the symbolic links, 

1225
01:15:23,620 --> 01:15:24,770
also hard links, 

1226
01:15:24,780 --> 01:15:29,690
but also you can have a system called to dramatically manipulate

1227
01:15:29,700 --> 01:15:31,010
this involving links. 

1228
01:15:33,590 --> 01:15:35,500
Let's look here as an example, 

1229
01:15:35,510 --> 01:15:39,820
and rather than close to the end of the lecture, 

1230
01:15:40,830 --> 01:15:42,680
about what happens under the hood, 

1231
01:15:43,440 --> 01:15:48,190
let's say we want to access this file, 

1232
01:15:48,200 --> 01:15:49,230
a stopped or text, 

1233
01:15:49,240 --> 01:15:55,380
and the last name is Holmes last years on c two, 

1234
01:15:55,800 --> 01:15:58,270
and then is the name of the file, stubborn text.

1235
01:15:58,840 --> 01:15:59,240
Right? 

1236
01:15:59,620 --> 01:16:02,610
First of all, we need to start from the route.

1237
01:16:04,260 --> 01:16:09,010
So you need to have the I number of the route and say, 

1238
01:16:09,020 --> 01:16:10,650
that's the position to. 

1239
01:16:13,020 --> 01:16:15,790
And this one is going, 

1240
01:16:16,150 --> 01:16:18,660
obviously, it are going to have here.

1241
01:16:18,670 --> 01:16:19,340
And I know, 

1242
01:16:20,520 --> 01:16:20,860
right? 

1243
01:16:21,760 --> 01:16:26,180
The inode is going to contain a pointer to the data. 

1244
01:16:27,060 --> 01:16:28,930
And this data, in this case,

1245
01:16:29,190 --> 01:16:32,720
contains the directory data, right?

1246
01:16:32,730 --> 01:16:33,800
Directory entries. 

1247
01:16:36,770 --> 01:16:43,190
Remember, the directory entry maps a to a file number.

1248
01:16:44,280 --> 01:16:47,390
Let's assume that the file number is 8086. 

1249
01:16:57,140 --> 01:17:00,000
Now, this is what you have in memory,

1250
01:17:00,010 --> 01:17:01,320
what you have here down. 

1251
01:17:02,130 --> 01:17:02,720
It's in memory. 

1252
01:17:04,500 --> 01:17:05,000
Now, 

1253
01:17:05,600 --> 01:17:08,280
you read the block 8086, 

1254
01:17:09,250 --> 01:17:09,600
right? 

1255
01:17:10,180 --> 01:17:11,730
What do you get there? 

1256
01:17:12,070 --> 01:17:18,540
You are going to get the I number of the file. 

1257
01:17:20,060 --> 01:17:26,140
You have the I number and the I number for this, 

1258
01:17:27,740 --> 01:17:28,820
the subdirectory, 

1259
01:17:28,830 --> 01:17:30,660
CS 162. 

1260
01:17:31,520 --> 01:17:34,520
And you are going to get from that I number. 

1261
01:17:34,530 --> 01:17:37,450
You are going to get data in that directory. 

1262
01:17:38,320 --> 01:17:43,850
And daytime the directory is going to maintain the entry and mapping

1263
01:17:43,860 --> 01:17:46,250
between csrc two. 

1264
01:17:46,570 --> 01:17:49,180
And it's I number, 

1265
01:17:50,490 --> 01:17:52,320
let's say, 7th, 32.

1266
01:17:53,920 --> 01:17:55,410
You go to 732. 

1267
01:17:55,420 --> 01:17:56,660
Now is the eye number. 

1268
01:17:58,940 --> 01:18:04,420
You are going now finally to get all the Information which is in CS

1269
01:18:04,430 --> 01:18:05,820
as in the directory, 

1270
01:18:06,100 --> 01:18:10,190
which is also you have file Starbucks next year. 

1271
01:18:10,790 --> 01:18:12,700
And one, 

1272
01:18:13,110 --> 01:18:15,070
once you read the data in the directory, 

1273
01:18:15,080 --> 01:18:18,830
you are going to find the mapping between stuff dot text. 

1274
01:18:20,290 --> 01:18:24,080
I the number now is ninety nine zero nine. 

1275
01:18:25,140 --> 01:18:27,250
Finally, I have ninety nine zero nine,

1276
01:18:27,260 --> 01:18:32,050
which is a nine number of stop dot x now I can start reading the data

1277
01:18:32,060 --> 01:18:32,980
from several text. 

1278
01:18:33,430 --> 01:18:39,510
This may require to read additional blocks before I get to the data blocks. 

1279
01:18:39,770 --> 01:18:40,970
If this file is large, 

1280
01:18:40,980 --> 01:18:45,830
and we need to have single indirected or doubling

1281
01:18:45,840 --> 01:18:49,910
direct or triple indirect data blocks. 

1282
01:18:51,140 --> 01:18:51,500
Okay? 

1283
01:18:52,520 --> 01:18:54,160
This is pretty much what happens. 

1284
01:18:54,760 --> 01:18:58,990
And this is a beside of the files, 

1285
01:18:59,490 --> 01:19:01,130
the data blocks from the file. 

1286
01:19:01,710 --> 01:19:03,630
And that's pretty much it. 

1287
01:19:04,640 --> 01:19:10,220
So let's stop here and will continue next time. 

1288
01:19:15,450 --> 01:19:16,160
So here, 

1289
01:19:17,100 --> 01:19:23,780
the question is that what is that was also file in slash dot com called CS 062? 

1290
01:19:26,030 --> 01:19:27,660
I'm going to answer this question. 

1291
01:19:28,230 --> 01:19:32,980
So basically, if it was in home,

1292
01:19:32,990 --> 01:19:35,790
another file CS, 

1293
01:19:35,800 --> 01:19:38,310
that will be CS 162 dot text. 

1294
01:19:39,230 --> 01:19:42,890
But I also have a different extension. 

1295
01:19:43,900 --> 01:19:47,120
So the file system will differentiate. 

1296
01:19:47,840 --> 01:19:54,390
You have a if as a file system would have exactly the same name

1297
01:19:54,400 --> 01:19:56,670
as a directory that cannot happen. 

1298
01:19:56,680 --> 01:20:05,610
You cannot have a file name and the directory of the same name in the same directory. 

1299
01:20:07,490 --> 01:20:08,200
You can try it. 

1300
01:20:09,960 --> 01:20:12,000
You are going, you cannot create it, you don't get another.

1301
01:20:14,760 --> 01:20:15,200
Okay? 

1302
01:20:16,010 --> 01:20:16,480
With this. 

1303
01:20:16,490 --> 01:20:17,120
Thank you. 

1304
01:20:17,130 --> 01:20:18,800
And i'll see you next time. 

