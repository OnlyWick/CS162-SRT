1
00:00:05,080 --> 00:00:06,040
Hello, everyone.

2
00:00:08,650 --> 00:00:12,530
So welcome. 

3
00:00:13,100 --> 00:00:18,250
We are going to continue our lecture on a virtual memory. 

4
00:00:19,400 --> 00:00:26,360
We are going to start discussion on caching and tlb so it's time for the translation. 

5
00:00:26,370 --> 00:00:27,530
Look aside buffers. 

6
00:00:31,360 --> 00:00:33,040
So if you recall, 

7
00:00:36,350 --> 00:00:37,600
address translation, 

8
00:00:37,610 --> 00:00:39,240
as a name implies, 

9
00:00:39,250 --> 00:00:44,820
it's about translating the addresses which are viewed by the application

10
00:00:44,830 --> 00:00:47,300
by the cp us into physical addresses. 

11
00:00:48,820 --> 00:00:56,750
There are a couple of reasons why we want to have this different kind of

12
00:00:56,760 --> 00:01:04,150
addresses for the application and versus of the physical

13
00:01:04,160 --> 00:01:04,870
addresses. 

14
00:01:06,800 --> 00:01:13,470
Some of them are about providing the illusion to each application. 

15
00:01:13,480 --> 00:01:16,200
It has its own machine, 

16
00:01:16,210 --> 00:01:17,480
its own resources, 

17
00:01:17,490 --> 00:01:18,680
including the memory, 

18
00:01:20,480 --> 00:01:27,080
which means that then you need to map the address space of each

19
00:01:27,090 --> 00:01:30,120
of the application in the same physical space, 

20
00:01:30,130 --> 00:01:31,680
which is physical memory. 

21
00:01:32,680 --> 00:01:33,800
And also, 

22
00:01:33,810 --> 00:01:35,680
another reason is protection, 

23
00:01:37,160 --> 00:01:44,310
because you want to protect the address space and of one application from another, 

24
00:01:45,280 --> 00:01:48,000
and also sharing, control, sharing, if you remember,

25
00:01:48,010 --> 00:01:52,710
in which actually some parts of the address space you want to be shared. 

26
00:01:52,950 --> 00:01:53,360
For instance, 

27
00:01:53,370 --> 00:01:58,600
the address space which contains a code of a shared library of a library, 

28
00:01:58,610 --> 00:02:00,490
which is a code of a library, 

29
00:02:00,500 --> 00:02:05,350
which is used by two applications like windows library on your own windows machine. 

30
00:02:06,040 --> 00:02:08,640
You do not want, but it begins that code in each application.

31
00:02:08,650 --> 00:02:09,560
You want to share that. 

32
00:02:13,150 --> 00:02:15,060
Typically, you do the sharing.

33
00:02:15,070 --> 00:02:16,100
It happens. 

34
00:02:17,790 --> 00:02:20,550
It's handled by one of these components are cheap, 

35
00:02:20,560 --> 00:02:25,360
which is called a lot of this memory management unit. 

36
00:02:27,060 --> 00:02:32,280
This was originally a a a was a standalone chip, 

37
00:02:32,970 --> 00:02:37,000
which is you put near your between the processor and the memory. 

38
00:02:37,550 --> 00:02:41,120
But in the more than processors, 

39
00:02:41,380 --> 00:02:44,100
it just a component of that processor. 

40
00:02:47,190 --> 00:02:53,880
One of the modest one of the techniques to do address translation was

41
00:02:53,890 --> 00:02:56,280
a segment using multi segment. 

42
00:02:57,930 --> 00:02:59,960
And in this case, if you remember,

43
00:03:00,870 --> 00:03:04,710
reach a segment is represented by a base and a limit. 

44
00:03:05,840 --> 00:03:06,260
Okay? 

45
00:03:07,170 --> 00:03:08,120
Now, the visual,

46
00:03:08,650 --> 00:03:11,440
the address, which our address is against the address,

47
00:03:11,450 --> 00:03:14,520
which is seen by the cpu and is seen by the application. 

48
00:03:15,670 --> 00:03:17,700
We split into two, 

49
00:03:17,710 --> 00:03:25,450
the first part of the first few beats represent an index in the segment table. 

50
00:03:27,520 --> 00:03:28,750
And then there is an opposite. 

51
00:03:29,850 --> 00:03:30,300
Okay? 

52
00:03:30,850 --> 00:03:32,300
When you have a virtual address, 

53
00:03:33,060 --> 00:03:34,550
you look at the first field, 

54
00:03:34,560 --> 00:03:35,800
which is the segment number. 

55
00:03:36,440 --> 00:03:38,550
The first speech represent the second number, 

56
00:03:38,810 --> 00:03:42,790
use up to index into segment table. 

57
00:03:43,270 --> 00:03:48,020
And then in that segment table, 

58
00:03:48,310 --> 00:03:51,430
you are going to find the base of the segment and the limit. 

59
00:03:52,240 --> 00:03:58,560
And you are going to compute the physical address by adding the offset, 

60
00:04:00,060 --> 00:04:06,590
which is the second giving the virtual address to the segment base. 

61
00:04:07,330 --> 00:04:09,080
These are the address. 

62
00:04:09,360 --> 00:04:15,320
And you are also going to check whether the address is generated is

63
00:04:15,330 --> 00:04:16,330
less than the limit. 

64
00:04:16,340 --> 00:04:17,630
So it's within the segment. 

65
00:04:22,640 --> 00:04:27,930
You also have in some architecture, actually,

66
00:04:27,940 --> 00:04:30,520
in intel eight x 86. 

67
00:04:31,340 --> 00:04:37,700
Instead of having the first the beats in the virtual address, 

68
00:04:37,710 --> 00:04:40,250
presenting the the base, 

69
00:04:40,260 --> 00:04:45,060
the indexing into the segment table, 

70
00:04:45,660 --> 00:04:47,200
you have just a bunch of segments, 

71
00:04:47,210 --> 00:04:48,240
you have the initial, 

72
00:04:48,250 --> 00:04:49,280
you have four segments. 

73
00:04:50,040 --> 00:04:51,580
And these segments are men, 

74
00:04:51,590 --> 00:04:53,220
are base segments, 

75
00:04:53,690 --> 00:04:57,400
are stored in special registers. 

76
00:04:58,240 --> 00:05:05,980
Like es this is s is for the stack and three other registers. 

77
00:05:07,910 --> 00:05:11,140
Then you compute the address by taking the virtual address, 

78
00:05:11,150 --> 00:05:19,780
and you are going to add it to the segment register. 

79
00:05:20,460 --> 00:05:22,650
That's how you are going to compute the physical address. 

80
00:05:24,550 --> 00:05:27,400
A finally, there is a bit valid or not valid.

81
00:05:30,770 --> 00:05:32,480
This one is at the segment, 

82
00:05:32,490 --> 00:05:36,960
not all segments of all application can fit in the physical memory

83
00:05:36,970 --> 00:05:37,760
at the same time. 

84
00:05:38,850 --> 00:05:42,290
So when you run out of space in the physical memory, 

85
00:05:42,300 --> 00:05:43,590
and you want to load, 

86
00:05:43,820 --> 00:05:48,760
you start a new application on your program that it needs to. 

87
00:05:49,090 --> 00:05:51,390
You need to allocate spacing. 

88
00:05:51,400 --> 00:05:55,270
The physical memory presenting program is a segment, is a new program.

89
00:05:56,310 --> 00:05:59,470
You may take one of the existing segments of an application. 

90
00:05:59,480 --> 00:06:02,980
It doesn't run, and we are going to store it on the disk.

91
00:06:03,980 --> 00:06:04,560
Okay? 

92
00:06:05,390 --> 00:06:08,140
Then therefore, the segment is no longer in memory.

93
00:06:08,150 --> 00:06:15,100
So then you can say it's you can use this bit to specify that. 

94
00:06:15,110 --> 00:06:16,820
So whenever next time, 

95
00:06:16,830 --> 00:06:18,820
when you are looking for something in that segment, 

96
00:06:19,830 --> 00:06:26,920
then you are going to you are going to get an exception, 

97
00:06:26,930 --> 00:06:30,040
and the exception is going to be treated by the operating system. 

98
00:06:30,420 --> 00:06:34,320
The operating system will bring the segment from the disk to memory

99
00:06:34,330 --> 00:06:36,280
before executing that instruction. 

100
00:06:41,730 --> 00:06:42,880
This is some examples. 

101
00:06:44,020 --> 00:06:44,170
Here. 

102
00:06:44,660 --> 00:06:45,530
It's a simple. 

103
00:06:48,760 --> 00:06:53,680
An example of an architecture is four segments. 

104
00:06:54,220 --> 00:06:56,550
The address is 16 bits. 

105
00:06:57,260 --> 00:07:03,780
The first 2 bits of the address are used to specify the segment number, 

106
00:07:04,860 --> 00:07:06,130
because we have four segments. 

107
00:07:06,140 --> 00:07:07,090
We need only to be. 

108
00:07:07,100 --> 00:07:09,170
So this at least 15 and 14. 

109
00:07:09,570 --> 00:07:12,400
The rest of these from 13 to 0 represent the office. 

110
00:07:13,570 --> 00:07:16,170
On the left hand side, you can see the address space,

111
00:07:16,580 --> 00:07:17,650
the virtual address space. 

112
00:07:17,660 --> 00:07:20,530
So as seen by the application, 

113
00:07:21,660 --> 00:07:23,870
we have our traditional four segments, 

114
00:07:23,880 --> 00:07:24,980
a code segments, 

115
00:07:26,080 --> 00:07:27,070
the data, 

116
00:07:27,580 --> 00:07:29,070
the stack segments. 

117
00:07:29,880 --> 00:07:32,670
This is also we added a shared segment. 

118
00:07:33,100 --> 00:07:35,770
Think about this is either that 8 hours a code, 

119
00:07:35,780 --> 00:07:39,070
which you may want to share with another application. 

120
00:07:41,110 --> 00:07:44,840
So here with in green, 

121
00:07:44,850 --> 00:07:45,960
you have the table, 

122
00:07:46,330 --> 00:07:47,360
the segment table, 

123
00:07:47,720 --> 00:07:51,620
again, four entries for code data shared and the stack.

124
00:07:52,680 --> 00:07:57,790
And you have the base and the limit for each of these segments. 

125
00:07:58,650 --> 00:07:59,240
Now, 

126
00:08:00,810 --> 00:08:01,960
let's see what happens, 

127
00:08:02,370 --> 00:08:04,200
for instance, and on the right hand side,

128
00:08:04,210 --> 00:08:05,600
you have the physical address. 

129
00:08:05,910 --> 00:08:07,740
For simply things like, in this case,

130
00:08:07,750 --> 00:08:09,900
the physical address and the virtual address spaces, 

131
00:08:09,910 --> 00:08:11,100
they have the same size. 

132
00:08:14,200 --> 00:08:15,870
Say, you are going from the code,

133
00:08:15,880 --> 00:08:18,950
you are going to execute in instruction in the code. 

134
00:08:22,100 --> 00:08:25,730
Where is that going to be mapped in the physical address space? 

135
00:08:27,390 --> 00:08:31,130
If you look about in the segment table, 

136
00:08:32,280 --> 00:08:37,870
because the first two beats of everything in the code segment at zero. 

137
00:08:38,500 --> 00:08:41,460
Therefore, you are going to identify the first entry,

138
00:08:42,370 --> 00:08:42,670
right? 

139
00:08:43,430 --> 00:08:44,730
In the segment table, 

140
00:08:45,380 --> 00:08:48,690
you have a base of four salad in hex, 

141
00:08:48,700 --> 00:08:50,170
a specimen format. 

142
00:08:51,430 --> 00:08:57,620
Therefore, you have to add an 4,000 to every address,

143
00:08:57,630 --> 00:09:00,770
a virtual address is a code segment. 

144
00:09:01,430 --> 00:09:03,250
And to get the physical responding, 

145
00:09:03,260 --> 00:09:08,000
physical address for the code in the physical outer space, 

146
00:09:11,310 --> 00:09:12,970
then for data, 

147
00:09:12,980 --> 00:09:17,710
the data starts in the visual of the space at 4,000. 

148
00:09:18,850 --> 00:09:27,660
This means that what are the first two beats of any address in the data segment? 

149
00:09:28,880 --> 00:09:29,590
Why don't you tell me? 

150
00:09:29,600 --> 00:09:32,270
It should be a very simple answer here. 

151
00:09:36,170 --> 00:09:43,070
The first we have 16 bits when we use a hexadecimal representation, 

152
00:09:43,640 --> 00:09:43,830
right? 

153
00:09:43,840 --> 00:09:46,830
4 bits represent one digit. 

154
00:09:47,690 --> 00:09:49,920
Now we have four here for us. 

155
00:09:50,730 --> 00:09:51,470
What does it mean? 

156
00:09:53,870 --> 00:09:54,780
What are the forbes? 

157
00:09:54,790 --> 00:09:55,980
The first forbids, 

158
00:09:55,990 --> 00:09:58,350
the forbids representing the 4th. 

159
00:09:59,020 --> 00:10:02,600
How do you write for in binary presentation? 

160
00:10:18,330 --> 00:10:18,800
Here it is. 

161
00:10:18,810 --> 00:10:20,560
I'm writing this in our chat, 

162
00:10:21,880 --> 00:10:23,070
foreign binary representation. 

163
00:10:23,080 --> 00:10:25,470
If you want to represent it, 

164
00:10:25,480 --> 00:10:32,230
or in using 4 bits is 10100. 

165
00:10:35,090 --> 00:10:36,130
This is it, right?

166
00:10:36,140 --> 00:10:39,430
It's 100 is 4 in the binary presentation, 

167
00:10:41,850 --> 00:10:47,520
which means that the first beats for any address in the beta segment. 

168
00:10:52,050 --> 00:10:58,410
The segment number here is what? 

169
00:10:58,420 --> 00:10:59,450
01. 

170
00:11:01,280 --> 00:11:03,160
Now it's not 00101, 

171
00:11:03,170 --> 00:11:04,680
because it's only the first to beat, 

172
00:11:05,220 --> 00:11:06,540
but it is for its product. 

173
00:11:06,750 --> 00:11:08,660
It can go, okay,

174
00:11:09,470 --> 00:11:10,020
it's 01. 

175
00:11:10,030 --> 00:11:11,870
This is what is one? 

176
00:11:13,480 --> 00:11:14,230
This is what you have. 

177
00:11:19,070 --> 00:11:22,980
Therefore, to translate any address in the data segment.

178
00:11:23,920 --> 00:11:24,650
What do you need to? 

179
00:11:25,590 --> 00:11:30,180
Do you go to the second entry in the segment table? 

180
00:11:30,190 --> 00:11:33,280
The one, which the segment id number is one,

181
00:11:34,350 --> 00:11:36,290
and the base here is 4,800. 

182
00:11:37,370 --> 00:11:40,660
So what you need to do is that you are going to add, 

183
00:11:40,970 --> 00:11:43,590
in order to translate any address in the data segment, 

184
00:11:43,920 --> 00:11:45,910
you need to add to it for the 800

185
00:11:55,180 --> 00:11:56,930
for the shared segment. 

186
00:11:57,360 --> 00:11:59,370
This is the things go. 

187
00:11:59,380 --> 00:12:00,930
This similarly, 

188
00:12:01,220 --> 00:12:02,810
for the share of settlement, 

189
00:12:02,820 --> 00:12:04,610
they started 800,000. 

190
00:12:05,450 --> 00:12:07,790
So the first four beats is eight, 

191
00:12:08,030 --> 00:12:09,050
represent eight. 

192
00:12:09,550 --> 00:12:11,370
What is the binary presentation of eight? 

193
00:12:19,060 --> 00:12:19,810
It's exactly. 

194
00:12:20,580 --> 00:12:22,860
The first two beats at 10. 

195
00:12:23,930 --> 00:12:25,280
The second one number, 

196
00:12:26,760 --> 00:12:28,520
one, it's 10 is two.

197
00:12:29,140 --> 00:12:29,340
Right? 

198
00:12:29,350 --> 00:12:31,020
Because you take only the first two beats. 

199
00:12:31,560 --> 00:12:35,690
And finally, stack c what is ac the representation?

200
00:12:39,160 --> 00:12:46,160
Binary representation of c you should remember this. 

201
00:12:47,140 --> 00:12:47,340
Right? 

202
00:12:47,350 --> 00:12:48,500
Is the review. 

203
00:12:50,400 --> 00:12:51,880
It's 1100. 

204
00:12:54,860 --> 00:12:55,300
Exactly, very good.

205
00:12:57,250 --> 00:12:58,880
The first two bits are 11. 

206
00:12:59,400 --> 00:12:59,950
It's three. 

207
00:13:00,250 --> 00:13:04,240
Number three is the last entry in the table. 

208
00:13:05,660 --> 00:13:07,090
And for go to the stack, 

209
00:13:07,790 --> 00:13:10,730
the base is zero, right?

210
00:13:10,980 --> 00:13:14,040
You add the base offset to the base. 

211
00:13:14,130 --> 00:13:15,600
We started from 000. 

212
00:13:19,820 --> 00:13:20,630
Does it make sense? 

213
00:13:24,180 --> 00:13:25,890
Let's look at this as an example. 

214
00:13:25,900 --> 00:13:26,410
By the way, 

215
00:13:27,100 --> 00:13:30,680
you should you should try. 

216
00:13:31,290 --> 00:13:33,080
These are some very important slides, 

217
00:13:34,410 --> 00:13:42,360
because you may expect not only to understand how the address translation works, 

218
00:13:42,370 --> 00:13:47,360
which is one of the fundamental mechanics in used in the existing

219
00:13:47,370 --> 00:13:50,330
in today's processors and leverage

220
00:13:50,340 --> 00:13:52,930
by the operating system to provide virtual memory, 

221
00:13:53,830 --> 00:13:54,850
abstraction, 

222
00:13:54,860 --> 00:14:00,010
but also because you can expect problems like this in your next meter. 

223
00:14:01,110 --> 00:14:01,450
Okay. 

224
00:14:03,590 --> 00:14:09,160
Now, let's look at this piece of code and see what happens under the foot.

225
00:14:09,170 --> 00:14:13,860
And we are assuming this piece of code is going to run

226
00:14:13,870 --> 00:14:15,620
on the previous architecture from. 

227
00:14:15,630 --> 00:14:18,180
Ii just showed you in the last slide, 

228
00:14:20,460 --> 00:14:22,330
you have the segment table is the same. 

229
00:14:23,920 --> 00:14:24,710
Now is a code. 

230
00:14:24,880 --> 00:14:26,710
The code starts that to 40. 

231
00:14:27,600 --> 00:14:31,470
We don't basically the entire address is 0240, 

232
00:14:31,950 --> 00:14:36,000
but you don't show the first four beats which are zero. 

233
00:14:39,320 --> 00:14:39,720
Okay. 

234
00:14:40,990 --> 00:14:42,070
Now let's see what happens. 

235
00:14:42,080 --> 00:14:44,390
And this is a serial language, 

236
00:14:44,400 --> 00:14:47,260
theodore assembly, language, code.

237
00:14:48,370 --> 00:14:50,800
Let's see what happens when we start with the disco. 

238
00:14:51,990 --> 00:14:53,910
The first instruction is a main, 

239
00:14:54,630 --> 00:14:57,420
and basically what his instruction is doing. 

240
00:14:58,050 --> 00:15:04,880
It loads an address which is bar x into register a

241
00:15:06,670 --> 00:15:08,720
zero right now, 

242
00:15:09,620 --> 00:15:16,070
this code is run in the user process, 

243
00:15:16,080 --> 00:15:17,210
the user process. 

244
00:15:17,570 --> 00:15:18,870
See virtual addresses. 

245
00:15:19,740 --> 00:15:23,550
So all the addresses you see here are virtual addresses. 

246
00:15:24,480 --> 00:15:24,820
Okay? 

247
00:15:25,840 --> 00:15:32,720
But now the code and the data they are actually stored in the physical memory

248
00:15:33,570 --> 00:15:38,130
in order to read the instructions and access a data, 

249
00:15:38,420 --> 00:15:41,630
we need to translate the virtual addresses to the physical address. 

250
00:15:45,390 --> 00:15:49,260
So they address the instruction, firstly,

251
00:15:49,830 --> 00:15:53,060
to fetch the instruction in order to execute the instructions instruction. 

252
00:15:53,070 --> 00:15:54,700
Again, it's in physical memory.

253
00:15:56,160 --> 00:15:57,750
The address of virtual address, 

254
00:15:57,760 --> 00:15:59,580
it's 0~40. 

255
00:15:59,590 --> 00:16:00,740
We discussed. 

256
00:16:01,570 --> 00:16:04,760
Here is a binary representation of the address. 

257
00:16:05,210 --> 00:16:06,440
The first to beat are zero. 

258
00:16:07,720 --> 00:16:13,790
The segment id the sigma number is zero. 

259
00:16:14,570 --> 00:16:16,960
Is that a four in order, 

260
00:16:17,370 --> 00:16:22,360
translate this address for virtual address to 40, 

261
00:16:24,000 --> 00:16:25,200
to a physical address, 

262
00:16:25,490 --> 00:16:29,840
we need to add the base address corresponding to the segment. 

263
00:16:30,730 --> 00:16:36,780
So the basis 4,000 and the virtual offset, 

264
00:16:37,430 --> 00:16:37,860
right? 

265
00:16:38,310 --> 00:16:39,070
Is 240. 

266
00:16:39,340 --> 00:16:40,110
The virtual officers. 

267
00:16:40,120 --> 00:16:45,440
The offset is the other side of the black beats. 

268
00:16:45,810 --> 00:16:46,710
In the address, 

269
00:16:47,380 --> 00:16:52,770
the beats encoding, 

270
00:16:52,780 --> 00:16:55,650
the segment identifier are the green beats. 

271
00:16:56,020 --> 00:16:56,550
Obviously, 

272
00:16:58,250 --> 00:17:00,640
you have to add all the offset, 

273
00:17:00,650 --> 00:17:03,590
which is 240 to 4,000, 

274
00:17:03,600 --> 00:17:04,670
which is a base. 

275
00:17:04,680 --> 00:17:09,200
And therefore, you are going to get the physical address 4,000, 200, 40.

276
00:17:10,180 --> 00:17:10,420
Now, 

277
00:17:10,430 --> 00:17:14,200
you are going to use this address to fetch the instruction from the memory. 

278
00:17:15,310 --> 00:17:18,310
And the instruction is basically like I told you, 

279
00:17:18,630 --> 00:17:20,690
it's to load the address, 

280
00:17:20,700 --> 00:17:22,410
which is barracks address, 

281
00:17:22,810 --> 00:17:29,250
which is 4050 is the virtual address into a registration. 

282
00:17:32,740 --> 00:17:34,510
Now, after that,

283
00:17:34,950 --> 00:17:37,070
you execute the instruction, you would know very well.

284
00:17:37,080 --> 00:17:38,230
What happens next? 

285
00:17:38,240 --> 00:17:39,750
The program counter. 

286
00:17:40,200 --> 00:17:43,110
It's increment by four, 

287
00:17:43,600 --> 00:17:47,770
because he are assuming that there are instruction, 

288
00:17:47,780 --> 00:17:49,980
they occupy 4 bytes. 

289
00:17:50,720 --> 00:17:53,270
The next instruction address is 2, 44.

290
00:17:57,540 --> 00:18:00,520
So let's execute the next instruction. 

291
00:18:03,130 --> 00:18:03,780
It's again, 

292
00:18:05,170 --> 00:18:06,530
in the next instruction, 

293
00:18:06,870 --> 00:18:11,190
you are going to see you have now the other sister for, 

294
00:18:11,200 --> 00:18:12,350
like I mentioned, 

295
00:18:12,850 --> 00:18:14,440
again, the physical,

296
00:18:14,450 --> 00:18:16,040
if you look at, 

297
00:18:16,840 --> 00:18:18,960
this will also be in the code segment, 

298
00:18:19,300 --> 00:18:21,450
we need to add the base, which is 4,000.

299
00:18:21,460 --> 00:18:23,930
The physical address would be 4244. 

300
00:18:24,440 --> 00:18:26,910
You are going to get the next instruction, 

301
00:18:26,920 --> 00:18:32,060
which is jail to jam to this string, 

302
00:18:32,070 --> 00:18:33,890
land address, 

303
00:18:34,960 --> 00:18:35,330
label. 

304
00:18:35,650 --> 00:18:36,000
All right? 

305
00:18:37,090 --> 00:18:40,360
And this is exactly what you do it. 

306
00:18:41,370 --> 00:18:44,720
But before the jumping here, 

307
00:18:44,730 --> 00:18:47,410
we store the return address. 

308
00:18:47,420 --> 00:18:49,490
After we execute the function string land, 

309
00:18:49,500 --> 00:18:51,010
we need to return, well,

310
00:18:51,700 --> 00:18:53,730
to the next instruction after the jump, 

311
00:18:53,740 --> 00:18:56,700
the next instruction after the jump would be zero, 

312
00:18:56,710 --> 00:18:59,160
x 248. 

313
00:19:02,540 --> 00:19:04,010
Therefore, we are going to,

314
00:19:04,020 --> 00:19:07,130
we assume here that we have a return address registers, 

315
00:19:07,550 --> 00:19:09,220
Which stores the return address. 

316
00:19:09,230 --> 00:19:11,540
So we are going to load into the return address, 

317
00:19:12,330 --> 00:19:13,160
0248. 

318
00:19:13,170 --> 00:19:21,250
And this is done automatically by the compiled code, 

319
00:19:21,720 --> 00:19:22,760
by your obligation. 

320
00:19:25,870 --> 00:19:28,020
Then you move in the priest program, 

321
00:19:28,030 --> 00:19:29,340
counter the address, 

322
00:19:29,350 --> 00:19:30,420
or you want to jump. 

323
00:19:30,430 --> 00:19:32,020
So the address you want to jump, 

324
00:19:32,030 --> 00:19:36,510
the label string line is corresponding to the address360. 

325
00:19:37,890 --> 00:19:38,990
So you're going to jump there, 

326
00:19:39,000 --> 00:19:42,220
and you are going to execute that next instruction, 

327
00:19:42,230 --> 00:19:44,780
which will be the address 360360. 

328
00:19:45,690 --> 00:19:48,100
Its, again, is in the segment code.

329
00:19:48,580 --> 00:19:50,470
In order to compute the physical address, 

330
00:19:50,480 --> 00:19:52,330
you are going towards the base, 

331
00:19:54,290 --> 00:19:57,600
which is 4,000 of 4,000+360, 

332
00:19:58,140 --> 00:20:00,210
is 400, 660.

333
00:20:00,220 --> 00:20:03,690
And then you are going to read from the physical memory. 

334
00:20:03,990 --> 00:20:05,780
You are going to read, 

335
00:20:06,510 --> 00:20:11,950
and this instruction is basically initialize this account, put a zero,

336
00:20:12,280 --> 00:20:14,940
a in a register v zero. 

337
00:20:17,370 --> 00:20:20,000
Once you execute that to go to the next instruction, 

338
00:20:22,080 --> 00:20:23,280
and the next instruction, 

339
00:20:24,770 --> 00:20:27,350
the other is 364. 

340
00:20:28,020 --> 00:20:29,670
And this next instruction, 

341
00:20:29,880 --> 00:20:35,170
it loads what is at this particular address, 

342
00:20:35,180 --> 00:20:36,570
which is stored in a zero? 

343
00:20:36,780 --> 00:20:39,090
Remember that what is stored in the a zero? 

344
00:20:39,100 --> 00:20:41,580
It was bar x address. 

345
00:20:41,970 --> 00:20:44,560
This is a bar x address is 4050. 

346
00:20:45,760 --> 00:20:50,290
Now we are one to load in register t zero. 

347
00:20:50,800 --> 00:20:55,040
The content of the address barracks of the address 4050. 

348
00:20:56,440 --> 00:20:59,190
When we want to do that and we want to access it, 

349
00:20:59,840 --> 00:21:03,030
to see what is the content of that mutual address. 

350
00:21:03,040 --> 00:21:05,470
The mutual address is 4050. 

351
00:21:06,420 --> 00:21:08,130
This is a binary representation. 

352
00:21:08,140 --> 00:21:10,290
The first two beats are 01. 

353
00:21:11,200 --> 00:21:12,430
The segment index, 

354
00:21:12,440 --> 00:21:15,390
which corresponds to this address is one. 

355
00:21:16,470 --> 00:21:21,580
Therefore, the base address of that segment is840 800.

356
00:21:22,300 --> 00:21:25,700
Therefore, you need to add the 4,800 to what?

357
00:21:26,450 --> 00:21:27,240
To the offset. 

358
00:21:27,770 --> 00:21:29,150
So what is the offset here? 

359
00:21:29,460 --> 00:21:31,290
The offset here, notice is 50.

360
00:21:31,770 --> 00:21:34,720
The virtual address is 4050. 

361
00:21:36,280 --> 00:21:37,230
But remember, 

362
00:21:37,530 --> 00:21:42,270
the first 2 bits of this address represent the segment id that's one. 

363
00:21:42,820 --> 00:21:45,040
And the last, in this case,

364
00:21:45,520 --> 00:21:48,270
14 beats represents the opposite, 

365
00:21:48,570 --> 00:21:50,710
but the last 14 beats is 50. 

366
00:21:52,800 --> 00:21:54,990
Now is the offset is 50. 

367
00:21:55,000 --> 00:21:59,630
It's, again, offset is a black digits,

368
00:21:59,640 --> 00:22:00,670
like 01. 

369
00:22:03,730 --> 00:22:08,130
Then you are going to add the offset to the basis, 

370
00:22:08,140 --> 00:22:09,290
4,800. 

371
00:22:09,660 --> 00:22:13,030
The physical address you are going to compute is 4,850. 

372
00:22:15,990 --> 00:22:20,160
And you are going to load the bite from that address to d zero. 

373
00:22:20,960 --> 00:22:22,400
And you increment the program count. 

374
00:22:24,350 --> 00:22:26,740
The main thing to note here that everything, 

375
00:22:26,750 --> 00:22:29,260
which is in what the processor sees, 

376
00:22:30,250 --> 00:22:31,130
everything, 

377
00:22:31,690 --> 00:22:33,970
what is in the registers of the processors? 

378
00:22:34,930 --> 00:22:37,260
All these are virtual addresses. 

379
00:22:38,360 --> 00:22:43,320
The translation happens only where you are going to access a memory. 

380
00:22:45,780 --> 00:22:49,240
So the memory management units really sits

381
00:22:49,250 --> 00:22:55,290
between the arithmetic logical units and all the registers and the memory. 

382
00:22:57,860 --> 00:22:58,880
Any questions? 

383
00:23:07,860 --> 00:23:10,420
We spent quite a bit of time on this one, 

384
00:23:10,430 --> 00:23:11,460
but this is important. 

385
00:23:11,470 --> 00:23:15,150
Please make sure that you understand this example, 

386
00:23:17,490 --> 00:23:24,280
as you'll see, from the previous years and previous exams,

387
00:23:25,320 --> 00:23:28,500
you are going to see a lot of problems like this one. 

388
00:23:33,110 --> 00:23:36,560
So a few things about some segmentation. 

389
00:23:38,510 --> 00:23:40,870
The one problem with the segmentation is nice. 

390
00:23:40,880 --> 00:23:42,630
It's a very elegant solution, 

391
00:23:43,330 --> 00:23:46,000
but you are going to translate on every instruction, 

392
00:23:46,720 --> 00:23:49,310
everything even in fetching instruction, 

393
00:23:49,530 --> 00:23:53,730
access of read some data, 

394
00:23:53,740 --> 00:23:55,130
write some data from the node. 

395
00:24:01,200 --> 00:24:04,380
And virtual address space has halls, right?

396
00:24:04,910 --> 00:24:09,300
Because you are not going to use everything in your visual address. 

397
00:24:13,470 --> 00:24:16,260
That's why I use a segmentation in the first part, 

398
00:24:16,270 --> 00:24:21,410
in the first thing in the first in the first place. 

399
00:24:21,910 --> 00:24:23,660
Because if you think about, 

400
00:24:23,670 --> 00:24:25,500
if you have the code and the segment, 

401
00:24:25,900 --> 00:24:27,210
the segment grows, 

402
00:24:28,230 --> 00:24:30,540
you put the segment as a high addresses, 

403
00:24:30,890 --> 00:24:32,920
because it grows to the smaller, 

404
00:24:32,930 --> 00:24:35,200
grows downwards to the smaller addresses. 

405
00:24:35,670 --> 00:24:37,050
For instance, a data segment,

406
00:24:37,060 --> 00:24:39,290
you have to be as a lower others, 

407
00:24:39,570 --> 00:24:40,690
because it's going growing up. 

408
00:24:41,490 --> 00:24:42,000
Okay? 

409
00:24:43,410 --> 00:24:45,010
Whilst the stack growing down, 

410
00:24:45,020 --> 00:24:47,690
so you need to separate them and between them, there is a gap.

411
00:24:48,350 --> 00:24:48,710
Right? 

412
00:24:49,990 --> 00:24:51,540
If you have segments, 

413
00:24:51,550 --> 00:24:52,700
if you don't have the gap, 

414
00:24:53,950 --> 00:24:55,820
if you're sorry, if you don't have the segments,

415
00:24:56,040 --> 00:24:59,710
that gap will occupy space in the physical memory. 

416
00:25:01,180 --> 00:25:02,860
Facebook would have been used empty space, 

417
00:25:02,870 --> 00:25:07,080
can be used to allocate to other processes, 

418
00:25:07,410 --> 00:25:08,470
other applications. 

419
00:25:09,570 --> 00:25:12,440
However, if I have these two segments,

420
00:25:12,450 --> 00:25:16,700
now each segment can have the one segment can have data, 

421
00:25:16,710 --> 00:25:18,440
one segment can serve the stack. 

422
00:25:18,850 --> 00:25:22,630
And then they are going to be mapped on the physical memory. 

423
00:25:22,970 --> 00:25:24,620
The gap I don't need to map it. 

424
00:25:24,630 --> 00:25:28,340
I don't need to just waste the space on the physical memory. 

425
00:25:34,350 --> 00:25:35,810
So now, 

426
00:25:36,460 --> 00:25:38,730
the one thing to notice here is, 

427
00:25:38,740 --> 00:25:43,770
I said you are located segments for the stack and the data. 

428
00:25:44,310 --> 00:25:52,230
But if allocate and how allocate the stack has a certain size and allocate that

429
00:25:52,600 --> 00:25:55,990
physical memory for the stack at that given size. 

430
00:25:56,000 --> 00:25:59,110
What happens when the stack growth and that stock growth? 

431
00:25:59,120 --> 00:26:03,420
Because they call more functions of, say, recursive programs.

432
00:26:03,710 --> 00:26:08,560
Every call puts the arguments and put the return values and supports

433
00:26:08,570 --> 00:26:09,640
on the stack. 

434
00:26:12,610 --> 00:26:13,640
How do I do that? 

435
00:26:14,130 --> 00:26:19,510
Well, in the sense that when i'm going to grow the stack, for instance,

436
00:26:19,940 --> 00:26:27,720
then i'm going to access and others outside the limit that will generate

437
00:26:27,730 --> 00:26:28,480
an exception. 

438
00:26:29,060 --> 00:26:31,930
The exception will be treated by the operating system, 

439
00:26:32,610 --> 00:26:34,800
which is going to grow the stack. 

440
00:26:36,660 --> 00:26:42,320
There is a limit on modify the base and provide more room now. 

441
00:26:42,690 --> 00:26:46,190
So the program can add put more things on the stack, 

442
00:26:46,200 --> 00:26:47,810
the same thing for the kids. 

443
00:26:49,100 --> 00:26:50,250
There is a question, 

444
00:26:53,140 --> 00:26:57,210
why did we not translate barracks in the first line on the previous slide? 

445
00:26:58,370 --> 00:26:59,920
That's a very good question. 

446
00:26:59,930 --> 00:27:01,640
Why didn't translate barracks? 

447
00:27:02,170 --> 00:27:04,090
Remember, what I said,

448
00:27:04,840 --> 00:27:06,720
everything is in the registers, 

449
00:27:07,620 --> 00:27:08,860
is virtual addresses. 

450
00:27:08,870 --> 00:27:10,380
These are all virtual addresses, 

451
00:27:11,790 --> 00:27:16,660
because the rule is that the addresses are only translated when I

452
00:27:16,670 --> 00:27:18,020
am going to access a memo. 

453
00:27:20,440 --> 00:27:22,400
In this case, I am not accessing the memory.

454
00:27:22,820 --> 00:27:25,370
Virus is just a virtual address. 

455
00:27:26,340 --> 00:27:26,750
Right? 

456
00:27:28,030 --> 00:27:29,820
I don't need to access the memory for that. 

457
00:27:30,200 --> 00:27:33,520
When I need to access the memory is when i'm going to read the content

458
00:27:34,840 --> 00:27:36,120
as a virtual others. 

459
00:27:36,790 --> 00:27:39,790
And then I need to call to find the corresponding physical address, 

460
00:27:40,580 --> 00:27:41,890
and then on a good translation. 

461
00:27:43,080 --> 00:27:45,010
But everything what is in the process, 

462
00:27:47,380 --> 00:27:50,130
in the registers, 

463
00:27:50,580 --> 00:27:54,790
it's a virtual address space. 

464
00:28:04,950 --> 00:28:07,870
Of course, you need to put to protect the segment table.

465
00:28:07,880 --> 00:28:12,000
Only the operating system has to be able to modify it. 

466
00:28:14,350 --> 00:28:15,320
And also, 

467
00:28:15,330 --> 00:28:19,760
it provides us the operating system provides protections for different segments, 

468
00:28:20,430 --> 00:28:25,940
for instance, to make the code segment being agreed only.

469
00:28:29,260 --> 00:28:29,720
Now, 

470
00:28:30,570 --> 00:28:31,970
let's say we do a context switching. 

471
00:28:31,980 --> 00:28:32,170
Now. 

472
00:28:33,350 --> 00:28:36,950
What do we need to do to say very start on contact switching when you have

473
00:28:36,960 --> 00:28:37,870
a process context switching? 

474
00:28:42,880 --> 00:28:50,590
Besides that we need to to save a

475
00:28:50,600 --> 00:28:56,730
bunch of things like file identifiers and things like that. 

476
00:28:58,340 --> 00:29:05,630
The other thing we need to torn out the segment table, 

477
00:29:06,300 --> 00:29:08,350
because the segment table, as I shown, you,

478
00:29:08,810 --> 00:29:10,820
in the previous slide, 

479
00:29:10,830 --> 00:29:11,900
in the previous example, 

480
00:29:11,910 --> 00:29:14,580
you have one segment table per virtual address space, 

481
00:29:14,590 --> 00:29:18,460
and you have one virtual address space for the process of the application. 

482
00:29:21,190 --> 00:29:24,230
You switch context with your process. 

483
00:29:25,920 --> 00:29:29,260
You have also to save the segment table, 

484
00:29:29,270 --> 00:29:31,380
because the next process is going to run, 

485
00:29:31,730 --> 00:29:33,810
is going to have its own segment table. 

486
00:29:36,490 --> 00:29:41,660
Also, like I mentioned earlier on some of the segments of the process,

487
00:29:41,670 --> 00:29:48,330
which is is which is no longer running, 

488
00:29:48,780 --> 00:29:55,780
can be stored on the disk in order to make room for the segments of the new

489
00:29:56,190 --> 00:29:58,300
of the next process being around. 

490
00:30:02,560 --> 00:30:04,670
Again, this is what happens is that, again,

491
00:30:04,680 --> 00:30:06,430
if not all segments within memory, 

492
00:30:06,670 --> 00:30:08,590
you save them on the disk and you swap them. 

493
00:30:08,600 --> 00:30:09,750
So basically, 

494
00:30:10,730 --> 00:30:13,560
you say p one, c process, p one.

495
00:30:18,520 --> 00:30:23,160
It's is we switch from con this process beyond to be two, 

496
00:30:23,930 --> 00:30:31,790
then we can save the segment of process p one on the disk to make room

497
00:30:31,800 --> 00:30:35,830
for the segment of process p two to be brought in the memory. 

498
00:30:39,240 --> 00:30:40,630
If you have to do that, 

499
00:30:41,170 --> 00:30:44,690
the context switch costs will grow dramatically. 

500
00:30:46,240 --> 00:30:46,580
Okay? 

501
00:30:47,620 --> 00:30:52,290
You need to be very careful about what you switch off or what you swap

502
00:30:52,300 --> 00:30:54,850
out and swapping on swapping, 

503
00:30:56,000 --> 00:30:59,320
because you really want to minimize your operation on the disk. 

504
00:30:59,570 --> 00:31:01,170
And we are going to learn about that. 

505
00:31:01,650 --> 00:31:03,470
The next, a couple of lectures.

506
00:31:07,880 --> 00:31:10,590
Problem is fragmentation, 

507
00:31:10,600 --> 00:31:12,670
problems with segmentation. 

508
00:31:12,680 --> 00:31:16,380
One of the biggest problem is fragmentation, 

509
00:31:16,390 --> 00:31:20,410
because now you need to start a different, 

510
00:31:21,490 --> 00:31:27,180
you need to have to be able to have to store and to fit segments

511
00:31:27,190 --> 00:31:28,900
of different sizes in memory. 

512
00:31:29,750 --> 00:31:31,260
If you remember the last lecture, 

513
00:31:31,270 --> 00:31:33,540
we had an example in which you gave, 

514
00:31:33,550 --> 00:31:35,140
you believe a lot of gaps. 

515
00:31:35,730 --> 00:31:41,220
You can get to a point in which you have many gaps in the physical memory, 

516
00:31:41,230 --> 00:31:48,450
but none of the gaps can be big enough to start a new segment, 

517
00:31:48,460 --> 00:31:50,770
rather to start a new segment. 

518
00:31:51,130 --> 00:31:54,540
Despite the fact that if you add them all the gap, if you add up,

519
00:31:54,550 --> 00:31:59,940
all the gaps is much more than what is needed by one by that segment. 

520
00:32:00,170 --> 00:32:04,050
But I think about you have 100 gaps, each gap.

521
00:32:04,060 --> 00:32:05,290
It's one gigabyte. 

522
00:32:06,970 --> 00:32:11,280
You have 100 gigabytes in total of available memory. 

523
00:32:11,290 --> 00:32:15,310
But now you have one segment which requires two gigabytes. 

524
00:32:17,290 --> 00:32:19,270
You have plenty of available space, 

525
00:32:19,730 --> 00:32:22,560
but none of the available spaces, 

526
00:32:23,060 --> 00:32:24,170
contiguous basis. 

527
00:32:24,180 --> 00:32:28,740
It's large enough to start that segment to gigabyte segment. 

528
00:32:31,280 --> 00:32:32,330
So how do you do that? 

529
00:32:32,620 --> 00:32:38,120
You can take one of the segments which are there to addition to one

530
00:32:38,130 --> 00:32:39,680
of these one gigabyte gap. 

531
00:32:39,690 --> 00:32:42,160
And you are going to start on the disk. 

532
00:32:42,170 --> 00:32:44,640
You are swapping out to make more room, 

533
00:32:44,980 --> 00:32:46,420
or you can move segments around. 

534
00:32:50,400 --> 00:32:55,160
So there are 2 kinds of fragmentation. 

535
00:32:55,170 --> 00:32:57,160
Both of them were space, 

536
00:32:57,950 --> 00:32:59,500
internal fragmentation. 

537
00:32:59,510 --> 00:33:02,700
You don't need all the memory within allocated chunks. 

538
00:33:02,710 --> 00:33:04,060
And this is also, 

539
00:33:05,010 --> 00:33:07,480
this is all this and then external, 

540
00:33:07,490 --> 00:33:09,520
which is free gaps between allocating chance. 

541
00:33:09,530 --> 00:33:11,880
So I think this example I mentioned to you, 

542
00:33:12,110 --> 00:33:14,210
I was talking about the external fragmentation. 

543
00:33:17,630 --> 00:33:21,260
And next, we are going to talk also about internal fragmentation.

544
00:33:26,240 --> 00:33:26,760
Okay. 

545
00:33:29,490 --> 00:33:30,080
So basically, 

546
00:33:30,090 --> 00:33:35,440
this is about another view about the general how the address translation happens. 

547
00:33:36,010 --> 00:33:40,240
This providing a little more intuition by showing two visual address

548
00:33:40,250 --> 00:33:42,760
spaces mapped to the same physical address space. 

549
00:33:44,790 --> 00:33:45,330
Okay? 

550
00:33:45,820 --> 00:33:50,790
And the these programs on and programs to or this process on and process

551
00:33:50,800 --> 00:33:54,030
to the virtual address spaces to each of them. 

552
00:33:54,550 --> 00:33:56,710
You can look absolutely identical. 

553
00:33:57,820 --> 00:34:02,020
Think about your on the same application to instances of the same application. 

554
00:34:03,540 --> 00:34:04,910
But the translation, 

555
00:34:04,920 --> 00:34:07,220
while in the virtual spaces are identical, 

556
00:34:07,230 --> 00:34:09,320
you have in both virtual spaces, 

557
00:34:09,330 --> 00:34:11,080
the same thing as the same addresses, 

558
00:34:11,830 --> 00:34:12,970
virtual addresses. 

559
00:34:13,460 --> 00:34:18,670
When you are going to map these virtual addresses to the physical outer space, 

560
00:34:18,960 --> 00:34:20,090
when you are going to translate them, 

561
00:34:20,100 --> 00:34:23,130
you are going to translate in such a way that they are not going to conflict. 

562
00:34:29,220 --> 00:34:32,180
So now, with segmentation,

563
00:34:32,190 --> 00:34:35,340
we have this with external fragmentation. 

564
00:34:38,710 --> 00:34:46,890
Sometimes it's harder to to allocate storage to variable sized chunks. 

565
00:34:48,930 --> 00:34:50,400
There is a solution for that, 

566
00:34:51,050 --> 00:34:52,370
and a solution for that, 

567
00:34:52,380 --> 00:34:53,650
which is very simple. 

568
00:34:54,170 --> 00:34:57,390
It's about, instead of allocating variable,

569
00:34:57,400 --> 00:34:58,550
says chunks, 

570
00:34:59,020 --> 00:35:00,860
you allocate fixed size chunks. 

571
00:35:01,380 --> 00:35:03,160
And these are called pages. 

572
00:35:06,260 --> 00:35:10,090
Every chunk of physical memory is a cable and be the same that it has

573
00:35:10,100 --> 00:35:11,250
the same size. 

574
00:35:12,520 --> 00:35:19,690
And this can allow you to specially to simplify a lot of things. 

575
00:35:20,690 --> 00:35:21,780
For instance, 

576
00:35:22,060 --> 00:35:23,530
how do you handle allocation? 

577
00:35:24,120 --> 00:35:27,840
One way to handle the allocation is to have a bit vector. 

578
00:35:28,820 --> 00:35:33,200
And each bit in the vector represents 1 page. 

579
00:35:33,720 --> 00:35:37,510
The value zero is that whether that page has been allocated

580
00:35:37,520 --> 00:35:38,870
from the physical memory, 

581
00:35:39,830 --> 00:35:41,570
one, if it was allocated.

582
00:35:42,170 --> 00:35:44,770
So if you want to find a page, 

583
00:35:44,780 --> 00:35:47,080
you in physical memory, you can allocate,

584
00:35:47,090 --> 00:35:51,400
you just find a zero in this bit vector. 

585
00:35:55,570 --> 00:35:58,000
Now, what about the size of the pages?

586
00:35:59,200 --> 00:36:01,030
If the pages are too large? 

587
00:36:02,140 --> 00:36:04,060
Again, all pages have the same size.

588
00:36:04,070 --> 00:36:04,820
What is the problem? 

589
00:36:05,430 --> 00:36:07,200
What is the problems that pages are too large? 

590
00:36:17,920 --> 00:36:19,960
Waste, spice, internal fragmentation.

591
00:36:19,970 --> 00:36:20,920
Excellent. 

592
00:36:24,140 --> 00:36:32,020
So I buy beef and edison and and cost of context switching can be higher if

593
00:36:32,030 --> 00:36:34,450
you need to swap that page out. 

594
00:36:35,070 --> 00:36:35,290
Right? 

595
00:36:35,530 --> 00:36:35,980
That's correct. 

596
00:36:37,380 --> 00:36:41,290
But the main thing is about internal fragmentation, 

597
00:36:41,300 --> 00:36:42,530
because if you think about, 

598
00:36:42,900 --> 00:36:46,470
if you have this page, you say you have a page of one gigabyte.

599
00:36:46,890 --> 00:36:50,660
If your program is only one megabyte, 

600
00:36:50,670 --> 00:36:53,740
you waste enormous a lot of most of the space. 

601
00:36:54,510 --> 00:36:56,030
So you want small babies. 

602
00:36:59,650 --> 00:37:01,280
The problem with the small pages, 

603
00:37:01,290 --> 00:37:02,920
what is the problem with the small pages? 

604
00:37:08,370 --> 00:37:09,080
Any guess? 

605
00:37:14,590 --> 00:37:17,020
Lots of accounting, more translation is, yes.

606
00:37:17,480 --> 00:37:18,400
Lots of accounting. 

607
00:37:18,410 --> 00:37:21,500
Ii wouldn't say more translations and larger base table. 

608
00:37:21,820 --> 00:37:23,360
You already know about it. 

609
00:37:24,510 --> 00:37:24,940
Yes. 

610
00:37:25,240 --> 00:37:30,170
But it's accounting is hard like you have to deal with more things. 

611
00:37:36,040 --> 00:37:36,590
Let's see. 

612
00:37:38,120 --> 00:37:40,230
Now, how do you do the translation?

613
00:37:40,240 --> 00:37:45,700
But there are no men more translation because in theory, right?

614
00:37:45,710 --> 00:37:48,860
Because you still need to be every virtual address. 

615
00:37:48,870 --> 00:37:51,270
You need to translate your physical address. 

616
00:37:52,940 --> 00:37:57,160
The little bit of truth of that the higher overhead per translation could be. 

617
00:37:58,230 --> 00:38:00,610
But the number of translation is basically the same. 

618
00:38:03,770 --> 00:38:05,570
Yeah, some cash can be that as well.

619
00:38:07,910 --> 00:38:12,140
So how is a translation we spend works with beijing? 

620
00:38:13,390 --> 00:38:15,150
It's very similarly segmentation, 

621
00:38:15,160 --> 00:38:17,130
but with a few differences. 

622
00:38:17,140 --> 00:38:19,250
So first of all, you have a base table.

623
00:38:21,750 --> 00:38:25,380
And the virtual address, as again, is in two parts.

624
00:38:25,960 --> 00:38:27,940
We have a virtual patient number and an officer, 

625
00:38:29,620 --> 00:38:30,890
but there is a difference. 

626
00:38:32,560 --> 00:38:35,600
The offset is not added to obeys address. 

627
00:38:36,080 --> 00:38:38,310
The offset of the address remains the same. 

628
00:38:38,880 --> 00:38:42,410
So is be with translation when you use beijing. 

629
00:38:42,700 --> 00:38:43,450
What happens? 

630
00:38:43,460 --> 00:38:46,310
It's only the virtual page part, 

631
00:38:46,320 --> 00:38:47,990
the first field changes. 

632
00:38:48,550 --> 00:38:48,930
Right? 

633
00:38:49,590 --> 00:38:54,020
A virtual page number is replaced by a physical patient. 

634
00:38:55,500 --> 00:38:56,030
That's it. 

635
00:38:56,910 --> 00:38:59,290
So the same like previously, 

636
00:38:59,670 --> 00:39:01,420
the first speech, in this case,

637
00:39:01,430 --> 00:39:02,580
a virtual page number, 

638
00:39:02,590 --> 00:39:03,860
in the previous case, 

639
00:39:03,870 --> 00:39:05,460
was a segment number, 

640
00:39:05,920 --> 00:39:08,150
are going to index in the page table. 

641
00:39:08,700 --> 00:39:09,730
But in the page table, 

642
00:39:09,740 --> 00:39:10,850
what you are going to fail, 

643
00:39:10,860 --> 00:39:12,850
if I find you have a page number, 

644
00:39:12,860 --> 00:39:14,450
which is a physical page number, 

645
00:39:15,000 --> 00:39:17,400
you are going to take that physical patient number, 

646
00:39:17,410 --> 00:39:21,300
and you are going to concatenate with the offset of the visual address, 

647
00:39:21,650 --> 00:39:23,080
the offset of the physical address, 

648
00:39:23,090 --> 00:39:26,340
and the offset of the physical address are the same. 

649
00:39:31,720 --> 00:39:36,510
Typical page sizes are between four kilobytes and 16 kilobytes are quite small. 

650
00:39:36,810 --> 00:39:37,830
Four kilobytes means what? 

651
00:39:37,840 --> 00:39:39,630
12 beats you need, 12 beats,

652
00:39:40,020 --> 00:39:41,860
and 16 kilobytes you need. 

653
00:39:43,070 --> 00:39:46,270
But another14 bits. 

654
00:39:52,730 --> 00:39:55,860
So if you have even smaller pages, 

655
00:39:56,420 --> 00:39:56,820
right? 

656
00:39:57,110 --> 00:39:59,060
This is where you see the number. 

657
00:39:59,430 --> 00:40:01,100
The problem is a small pages. 

658
00:40:01,110 --> 00:40:03,400
So you have a 32 bit address. 

659
00:40:04,110 --> 00:40:07,220
You are going to use one by one kilobyte pages, 

660
00:40:07,230 --> 00:40:08,860
so you can need 10 bits offset. 

661
00:40:09,330 --> 00:40:10,780
It's what you need a 10 bits offset. 

662
00:40:12,010 --> 00:40:13,340
Therefore, the gift,

663
00:40:13,830 --> 00:40:15,500
the virtual page number, 

664
00:40:15,510 --> 00:40:17,220
the number of visa is 22 bits, 

665
00:40:17,230 --> 00:40:19,200
32-10, 202 bits.

666
00:40:19,620 --> 00:40:22,760
Therefore, the base table have 4 million century huge.

667
00:40:25,230 --> 00:40:29,180
And just think about if you have 64 bits, others,

668
00:40:35,120 --> 00:40:36,790
in order to do that, for instance,

669
00:40:37,000 --> 00:40:45,660
you are also going to not allocate space for the maximum size space table. 

670
00:40:46,830 --> 00:40:51,790
So you are going to just grow this page table as you add not more pages to it. 

671
00:40:53,150 --> 00:40:54,380
Therefore, you are going to have,

672
00:40:54,390 --> 00:40:56,420
in addition to the page table pointer, 

673
00:40:56,430 --> 00:40:59,210
which represents the start of the page table, 

674
00:40:59,650 --> 00:41:02,410
also the paste stable size, which is,

675
00:41:02,500 --> 00:41:04,440
as the name implied, 

676
00:41:04,450 --> 00:41:05,560
the size of the paste table, 

677
00:41:05,570 --> 00:41:08,690
which can be increased that you add more tables, 

678
00:41:09,180 --> 00:41:11,570
or as you allocate more pages than you have a lot. 

679
00:41:11,580 --> 00:41:16,320
So that afforded your allocate more entries, 

680
00:41:16,960 --> 00:41:18,670
you add more entries to the base table. 

681
00:41:21,930 --> 00:41:23,200
Also, with this page,

682
00:41:23,210 --> 00:41:27,880
you are going to have a bunch of bits which represents some. 

683
00:41:30,010 --> 00:41:33,820
We are going to discuss them or a little bit later. 

684
00:41:35,160 --> 00:41:36,670
Keep in mind about these beats. 

685
00:41:39,720 --> 00:41:41,240
We are going to give an example, 

686
00:41:41,250 --> 00:41:43,180
a few slides. 

687
00:41:44,400 --> 00:41:44,850
Later. 

688
00:41:47,460 --> 00:41:49,210
It's a very simple page table. 

689
00:41:51,810 --> 00:41:53,330
You have a four by space. 

690
00:41:53,420 --> 00:41:54,930
It's a trivial example. 

691
00:41:55,300 --> 00:41:56,820
You have this on the virtual memory. 

692
00:41:56,830 --> 00:42:02,500
You have 4 pages from starting from 04, and 8.

693
00:42:03,070 --> 00:42:06,580
Then you have a page table only with three entries, right?

694
00:42:06,590 --> 00:42:11,520
Because you have 3 pages in the virtual memo. 

695
00:42:13,390 --> 00:42:20,570
Assume that the address space here it has equivalent of eight beats. 

696
00:42:20,580 --> 00:42:22,370
So he's 64 bytes. 

697
00:42:24,040 --> 00:42:25,230
So the address, 

698
00:42:25,430 --> 00:42:29,840
if you need for the page table, again, if you have four beats,

699
00:42:29,850 --> 00:42:31,560
you need only two beats, right?

700
00:42:32,250 --> 00:42:33,720
To represent 4 bytes, 

701
00:42:34,910 --> 00:42:35,950
to address 4 bytes. 

702
00:42:36,120 --> 00:42:40,140
Therefore, the last two beats represent the offset,

703
00:42:40,150 --> 00:42:46,160
and the first six beats to represent what represent the page number

704
00:42:48,220 --> 00:42:50,660
for if you want. 

705
00:42:50,890 --> 00:42:53,300
A is that the other is zero here. 

706
00:42:53,850 --> 00:42:56,480
If you want to translate that at zero, 

707
00:42:56,780 --> 00:43:03,180
then the page number of identify the first entry in the table. 

708
00:43:03,480 --> 00:43:06,130
The first century in the table contained four. 

709
00:43:06,530 --> 00:43:06,820
Now, 

710
00:43:06,830 --> 00:43:12,360
four is a new physical patient numbers who are going to conquer concatinate, 

711
00:43:12,370 --> 00:43:16,560
these four with the offset, which is zero.

712
00:43:17,160 --> 00:43:19,600
You are going to get zero, 

713
00:43:19,610 --> 00:43:21,200
x one zero. 

714
00:43:26,630 --> 00:43:27,450
The same thing, 

715
00:43:27,780 --> 00:43:34,110
similar things happen if you want to access the first address, 

716
00:43:34,600 --> 00:43:38,930
the address for the virtual address for the future address for now

717
00:43:38,940 --> 00:43:40,330
is going to lead you, 

718
00:43:40,340 --> 00:43:43,490
because the offset which one is going to lead you to the second entry

719
00:43:43,500 --> 00:43:44,570
in the page table. 

720
00:43:44,780 --> 00:43:47,530
The second in being the base table contains threes who

721
00:43:47,540 --> 00:43:49,410
are going to concatenate three with zero, 

722
00:43:49,420 --> 00:43:50,730
which is the offset. 

723
00:43:51,030 --> 00:43:54,270
You are going to get to the address zero, 

724
00:43:54,280 --> 00:43:57,820
c physical address, and so forth.

725
00:44:00,610 --> 00:44:01,410
Any questions? 

726
00:44:05,480 --> 00:44:06,110
Question here? 

727
00:44:06,120 --> 00:44:09,750
Why were space size issues and between four kilobytes and 16 kilobytes? 

728
00:44:10,160 --> 00:44:12,400
This is, again, always a trade off.

729
00:44:13,050 --> 00:44:14,420
The smaller is a table, 

730
00:44:14,880 --> 00:44:17,440
the smaller the page, the smaller the internal fragmentation,

731
00:44:17,450 --> 00:44:20,520
so the less wasted space. 

732
00:44:21,200 --> 00:44:22,480
However, the smaller the page,

733
00:44:22,490 --> 00:44:24,120
the larger the page tables are. 

734
00:44:24,920 --> 00:44:25,880
So therefore, 

735
00:44:25,890 --> 00:44:29,290
it's much more context switching actually can be more expensive. 

736
00:44:34,700 --> 00:44:35,380
Good question. 

737
00:44:40,020 --> 00:44:44,180
And these are some other translation, 

738
00:44:44,570 --> 00:44:46,770
translating the address five. 

739
00:44:46,780 --> 00:44:48,530
It's going to translate to all the others, 

740
00:44:48,540 --> 00:44:49,610
in this case, 

741
00:44:50,070 --> 00:44:54,240
is basically 11717. 

742
00:44:54,690 --> 00:44:56,530
And I think there is another example. 

743
00:44:56,540 --> 00:44:58,450
Nine is going to be the same. 

744
00:44:59,060 --> 00:44:59,540
Sorry. 

745
00:45:00,360 --> 00:45:04,370
Previous case, the address six was trans translating to the address one,

746
00:45:04,900 --> 00:45:05,820
16. 

747
00:45:05,830 --> 00:45:06,900
And the second case, 

748
00:45:06,910 --> 00:45:13,550
the address nine is going to translate to address five, 

749
00:45:14,280 --> 00:45:15,140
physical address five. 

750
00:45:35,120 --> 00:45:39,190
There is anonymous question asking about if the zero, 

751
00:45:39,200 --> 00:45:42,510
x 12345678, 

752
00:45:43,180 --> 00:45:44,660
the others could, 

753
00:45:44,670 --> 00:45:47,860
the first 123456 can be the offset. 

754
00:45:48,660 --> 00:45:49,120
Now, 

755
00:45:50,050 --> 00:45:51,760
the again, 

756
00:45:51,770 --> 00:45:56,450
the offset are are the last beat in the address. 

757
00:45:57,680 --> 00:45:58,210
Okay? 

758
00:45:59,130 --> 00:46:01,760
In this particular case, again, the offset,

759
00:46:03,000 --> 00:46:06,000
if you look at the first one example here, 

760
00:46:07,050 --> 00:46:08,930
the offset is 10, 

761
00:46:09,860 --> 00:46:11,170
are the black beats. 

762
00:46:12,590 --> 00:46:14,540
The page number are the bits, 

763
00:46:14,550 --> 00:46:15,580
are the red bits. 

764
00:46:18,630 --> 00:46:21,690
So the offset is two, in this case.

765
00:46:21,700 --> 00:46:25,480
And the page number is one. 

766
00:46:26,540 --> 00:46:29,860
And basic number one selects the second ending the base table, 

767
00:46:29,870 --> 00:46:30,580
which is three. 

768
00:46:30,590 --> 00:46:31,660
So it's 11. 

769
00:46:32,560 --> 00:46:35,130
And the offset remains 10. 

770
00:46:35,700 --> 00:46:37,010
Now I have 1110, 

771
00:46:37,020 --> 00:46:44,760
which is basically e what about sharing? 

772
00:46:46,260 --> 00:46:49,370
If you want to share a page between processes? 

773
00:46:50,630 --> 00:46:52,460
These are pretty easy. 

774
00:46:53,270 --> 00:46:53,750
Right? 

775
00:46:55,410 --> 00:46:58,600
You have each of the processes has its own page label. 

776
00:46:59,080 --> 00:47:01,710
If you want to share the same pages, 

777
00:47:01,720 --> 00:47:06,340
then the corresponding entries are going to point to the same physical table. 

778
00:47:07,700 --> 00:47:10,660
It very elegant. 

779
00:47:13,040 --> 00:47:14,090
Where is page sharing? 

780
00:47:14,100 --> 00:47:14,610
Yours? 

781
00:47:15,390 --> 00:47:25,520
Generally, region of the processes of every for the processes,

782
00:47:25,530 --> 00:47:28,280
you have a general region, as you remember.

783
00:47:28,290 --> 00:47:30,900
So every process has the same, 

784
00:47:30,910 --> 00:47:35,170
all the processes they have to see that you are going to share this code, 

785
00:47:35,180 --> 00:47:37,900
the kernel code across all the processes, 

786
00:47:38,440 --> 00:47:40,390
because the same code is not going to change. 

787
00:47:43,480 --> 00:47:44,070
You can, 

788
00:47:48,370 --> 00:47:50,040
by the way, this is protected, right?

789
00:47:50,050 --> 00:47:52,280
Is like the kernel will have. 

790
00:47:56,500 --> 00:47:59,330
The process only can access at the user level and are talking

791
00:47:59,340 --> 00:48:00,650
about the kernel region. 

792
00:48:00,660 --> 00:48:03,530
I'm not talking about kernel region being accessed by the process. 

793
00:48:03,540 --> 00:48:08,010
I'm talking about the kernel regions associated with the process, 

794
00:48:08,020 --> 00:48:10,370
which is accessed by the kernel during the context, 

795
00:48:10,380 --> 00:48:16,150
which during different processes running the same binary, 

796
00:48:19,970 --> 00:48:26,750
you don't need to duplicate that because the code is read only user level libraries, 

797
00:48:26,760 --> 00:48:27,790
like I mentioned, 

798
00:48:28,260 --> 00:48:30,350
or even sharing the data between you, 

799
00:48:30,360 --> 00:48:32,750
you can share the data between the processes. 

800
00:48:32,760 --> 00:48:34,610
You can use a share memory. 

801
00:48:41,160 --> 00:48:42,710
This is another example. 

802
00:48:42,720 --> 00:48:44,710
This is a summary of beijing. 

803
00:48:46,310 --> 00:48:47,540
On the left hand side, 

804
00:48:47,550 --> 00:48:49,500
you have the virtual memory view. 

805
00:48:49,510 --> 00:48:50,500
On the right hand side. 

806
00:48:50,510 --> 00:48:52,060
You have the physical memory view. 

807
00:48:53,650 --> 00:48:56,200
In the middle, you have the base table.

808
00:48:57,890 --> 00:49:00,780
You see that many entries in the tables are now, 

809
00:49:01,320 --> 00:49:03,070
but this is a full page table. 

810
00:49:03,720 --> 00:49:08,770
And here we are assuming and eight beats address. 

811
00:49:08,780 --> 00:49:12,410
And now the offset are the last three beats. 

812
00:49:12,420 --> 00:49:14,900
So the base size, it's about three,

813
00:49:15,260 --> 00:49:16,300
it's 8 bytes. 

814
00:49:16,750 --> 00:49:20,160
And the patient number is 5 bits. 

815
00:49:21,740 --> 00:49:23,970
You are going to have 2.5. 

816
00:49:23,980 --> 00:49:28,630
You have 72 entries in the page table up to. 

817
00:49:30,230 --> 00:49:30,750
Okay. 

818
00:49:31,210 --> 00:49:32,680
Now, the one thing,

819
00:49:33,070 --> 00:49:34,420
and on the right hand side, 

820
00:49:35,710 --> 00:49:37,740
you have, again, like the physical memory.

821
00:49:38,540 --> 00:49:40,690
One thing here, I just want to show you.

822
00:49:40,700 --> 00:49:42,410
And i'm so earlier on, 

823
00:49:42,420 --> 00:49:44,650
I said that the stack, 

824
00:49:45,060 --> 00:49:48,090
how the stack and the heap grows here. 

825
00:49:49,700 --> 00:49:52,890
Now, the stack again, grows downwards.

826
00:49:52,900 --> 00:49:54,610
So gonna go grows, 

827
00:49:55,530 --> 00:49:57,160
going to lower addresses. 

828
00:49:57,770 --> 00:49:59,290
And you see here, 

829
00:49:59,420 --> 00:50:00,690
the stack, 

830
00:50:00,700 --> 00:50:02,050
it's on the right hand side. 

831
00:50:02,330 --> 00:50:06,470
And with with what I represented here is a gray, 

832
00:50:06,480 --> 00:50:09,110
the pages which they are all the allocate, 

833
00:50:09,800 --> 00:50:12,790
only the pages which are white are not allocated yet. 

834
00:50:13,530 --> 00:50:16,480
So let's see what happens and how you are going to grow the stock. 

835
00:50:17,450 --> 00:50:17,880
Now, 

836
00:50:17,890 --> 00:50:22,570
the problem is that let's say that I want to grow the stack by 2 pages, 

837
00:50:22,580 --> 00:50:25,730
I decided to grow the stack by 2 pages in the virtual memory. 

838
00:50:26,000 --> 00:50:29,110
The virtual memory, I can very conveniently grow the style,

839
00:50:29,120 --> 00:50:31,030
because I have enough space in the virtual memory. 

840
00:50:31,560 --> 00:50:33,030
However, is a physical memory.

841
00:50:33,040 --> 00:50:34,910
If I am going to try to grow it, 

842
00:50:35,860 --> 00:50:37,610
I can allocate page. 

843
00:50:38,380 --> 00:50:40,170
You can allocate another page. 

844
00:50:41,020 --> 00:50:44,590
Maybe you have only room for another page there if you want to locate

845
00:50:44,600 --> 00:50:47,070
continuously that the pages to the stack. 

846
00:50:47,620 --> 00:50:51,880
But the point is a page a with a translation that these pages

847
00:50:51,890 --> 00:50:55,170
do not need to be allocated continuously. 

848
00:50:55,390 --> 00:50:55,810
Right? 

849
00:50:56,340 --> 00:50:58,010
Therefore, the only thing you can do,

850
00:50:58,660 --> 00:50:59,850
the only thing you need to do, 

851
00:50:59,860 --> 00:51:04,250
you need to find the room for two other pages. 

852
00:51:04,570 --> 00:51:06,980
And you are going to allocate these pages for the stock. 

853
00:51:07,370 --> 00:51:10,500
But again, they don't need to be contiguous, right?

854
00:51:10,870 --> 00:51:12,620
Whatever is contiguous in the virtual memory, 

855
00:51:12,630 --> 00:51:14,940
doesn't need to be contiguous in the physical. 

856
00:51:34,620 --> 00:51:35,130
Now, 

857
00:51:35,940 --> 00:51:37,790
the biggest problem is the challenge, 

858
00:51:37,800 --> 00:51:39,470
the type of table size. 

859
00:51:39,480 --> 00:51:41,030
If you in the simplest version, 

860
00:51:41,040 --> 00:51:44,210
in the simple instantiation, 

861
00:51:44,220 --> 00:51:46,060
in the simplest implementation, 

862
00:51:46,070 --> 00:51:47,180
the type of size, 

863
00:51:47,440 --> 00:51:51,780
but if it's equal with a number of babies in the virtual memory, 

864
00:51:53,820 --> 00:51:56,160
and this can be absolutely huge. 

865
00:52:00,000 --> 00:52:01,470
Let's give take an example. 

866
00:52:02,410 --> 00:52:04,360
You have 32 beats address space, 

867
00:52:06,240 --> 00:52:09,430
you have four gigabytes at others, 

868
00:52:09,440 --> 00:52:10,630
mutual address space. 

869
00:52:17,470 --> 00:52:20,580
These are just a unit for you to remember. 

870
00:52:21,510 --> 00:52:22,940
The one things to remember here. 

871
00:52:22,950 --> 00:52:30,720
And one confusion i've all seen often is that when you are talking

872
00:52:30,730 --> 00:52:31,650
about the memory, 

873
00:52:32,620 --> 00:52:35,740
we are talking about the power of two units. 

874
00:52:38,010 --> 00:52:40,640
One kilobyte is ten to power ten, 

875
00:52:41,960 --> 00:52:43,420
one megabyte to power ten, 

876
00:52:45,590 --> 00:52:46,890
and gigabyte to power set. 

877
00:52:48,570 --> 00:52:52,510
I when we are talking about bandwidth, 

878
00:52:55,570 --> 00:53:02,160
and how much capacity network capacity we are talking in power of that? 

879
00:53:05,260 --> 00:53:07,800
1 kilobyte or 1 kilobit. 

880
00:53:08,340 --> 00:53:09,900
It's 1,000 bits, 

881
00:53:11,060 --> 00:53:12,180
one gigabyte, 

882
00:53:12,700 --> 00:53:15,040
one gigabit represent, 

883
00:53:17,610 --> 00:53:19,970
but it's1 billion bits. 

884
00:53:23,900 --> 00:53:27,310
So now assume the typical pay size is four kilobytes. 

885
00:53:27,820 --> 00:53:29,050
It's to power them. 

886
00:53:29,060 --> 00:53:36,730
We need ten beats for to address any byte in a 4 kilobyte page. 

887
00:53:37,450 --> 00:53:38,610
So there are four. 

888
00:53:42,800 --> 00:53:45,310
Sorry, we need to have what i'm talking about.

889
00:53:45,940 --> 00:53:48,400
If the page is four kilobytes, 

890
00:53:48,410 --> 00:53:50,970
this means to power 12. 

891
00:53:51,770 --> 00:53:56,100
Therefore, I need 12 beats to address any bite within a page.

892
00:53:56,110 --> 00:53:58,610
So the offset is stern beats. 

893
00:53:58,980 --> 00:54:00,150
And therefore, 

894
00:54:00,790 --> 00:54:02,350
if the offset mister beats, 

895
00:54:04,510 --> 00:54:06,300
the page number, 

896
00:54:07,270 --> 00:54:08,360
it's 30. 

897
00:54:09,100 --> 00:54:11,280
2-12 is 20 bits. 

898
00:54:12,220 --> 00:54:12,890
Now, 

899
00:54:15,120 --> 00:54:21,620
the base table size can have as big as 4 megabytes. 

900
00:54:25,700 --> 00:54:26,020
Right? 

901
00:54:26,510 --> 00:54:27,660
Why is 4 megabytes? 

902
00:54:29,600 --> 00:54:37,390
Because each of the entry in the page table needs to have 20 bits. 

903
00:54:39,920 --> 00:54:42,220
Then you are also going to have some other, 

904
00:54:42,230 --> 00:54:45,130
like you see some other flags associated. 

905
00:54:45,140 --> 00:54:47,710
So you have 30° for each end. 

906
00:54:49,140 --> 00:54:50,160
So it's 4 bytes, 

907
00:54:50,640 --> 00:54:52,440
and you have to power 20 entries. 

908
00:54:52,980 --> 00:54:54,340
So it's 4 megabytes the top. 

909
00:54:57,710 --> 00:54:59,180
This was a lot of memory. 

910
00:55:00,430 --> 00:55:02,420
Now think about this was in the past, 

911
00:55:02,430 --> 00:55:05,840
and you have said little bit as the standard. 

912
00:55:05,850 --> 00:55:07,760
But now the standard is 64 bits. 

913
00:55:08,780 --> 00:55:09,900
There is no way, right?

914
00:55:11,250 --> 00:55:13,200
If you try to do the same thing here, 

915
00:55:13,580 --> 00:55:15,680
you are going to have 30 extra bytes, 

916
00:55:16,780 --> 00:55:18,920
which is only for the pace table. 

917
00:55:18,930 --> 00:55:19,280
Actually, 

918
00:55:19,290 --> 00:55:22,620
you don't have enough physical memory for that physical to store

919
00:55:22,630 --> 00:55:24,380
that the pace label. 

920
00:55:26,870 --> 00:55:28,130
This is really a lot of space. 

921
00:55:28,360 --> 00:55:29,450
What is the solution here? 

922
00:55:31,830 --> 00:55:33,820
By the way, all this space is empty.

923
00:55:34,790 --> 00:55:35,980
Most of this, no, not always,

924
00:55:35,990 --> 00:55:37,240
most of the space is empty, 

925
00:55:37,760 --> 00:55:39,360
because they don't have as many base tables, 

926
00:55:39,370 --> 00:55:40,880
but I do have very few space tables, 

927
00:55:41,550 --> 00:55:41,900
right? 

928
00:55:43,450 --> 00:55:50,130
Which are actually allocated a so this is a big problem. 

929
00:55:50,140 --> 00:55:51,570
And we are looking out for a solution, 

930
00:55:54,000 --> 00:55:57,350
a little bit of a discussion about base table before going forward. 

931
00:55:59,480 --> 00:56:02,470
So what do you need to switch on the page label? 

932
00:56:03,390 --> 00:56:04,990
What do you need to do this? 

933
00:56:05,230 --> 00:56:06,370
When the context switch happens? 

934
00:56:06,380 --> 00:56:07,750
What do we need to do? 

935
00:56:11,120 --> 00:56:14,470
You have a page for the table point as the page label pointer, 

936
00:56:14,640 --> 00:56:17,710
the beginning of the page table, 

937
00:56:18,290 --> 00:56:19,160
the limit, 

938
00:56:20,280 --> 00:56:21,450
the size of the page table. 

939
00:56:24,090 --> 00:56:24,780
Again, 

940
00:56:25,830 --> 00:56:28,870
remember about the dual mode operation. 

941
00:56:28,880 --> 00:56:36,590
And because you these space tables can be only

942
00:56:39,100 --> 00:56:42,300
modified and accessed by the kernel, 

943
00:56:42,600 --> 00:56:48,140
you cannot let an application access the space labels, 

944
00:56:49,070 --> 00:56:51,020
because then they can change the page table, 

945
00:56:51,030 --> 00:56:55,670
and they can.to anywhere to any other address, 

946
00:56:56,110 --> 00:57:00,510
including the kennel or the address of another applications. 

947
00:57:02,250 --> 00:57:07,420
And now let's look at the pros and cons. 

948
00:57:09,280 --> 00:57:10,490
On the pro side. 

949
00:57:11,590 --> 00:57:13,270
It's a very simple memory allocation. 

950
00:57:13,280 --> 00:57:15,470
Remember, you have a bit vector in zero or one,

951
00:57:15,480 --> 00:57:18,390
whether the page is allocated or not in the physical memory. 

952
00:57:19,660 --> 00:57:22,260
The bit vector contains 1 bit for each physical, 

953
00:57:23,390 --> 00:57:24,820
for each page in the physical memo, 

954
00:57:26,830 --> 00:57:31,440
easy to share the cons we seen. 

955
00:57:32,050 --> 00:57:33,970
The other space is very sparse. 

956
00:57:34,630 --> 00:57:35,920
The base table can be huge. 

957
00:57:46,630 --> 00:57:48,480
It's again, if the base table is peace big,

958
00:57:48,490 --> 00:57:51,400
then you need also probably the context which you cannot keep all the time

959
00:57:51,410 --> 00:57:52,080
in the memory. 

960
00:57:52,420 --> 00:57:54,090
If the process is painful, 

961
00:57:54,860 --> 00:57:58,290
is that there is a base level of a process. 

962
00:58:01,040 --> 00:58:09,740
If the process was is now switched off and is no longer using the cpu you

963
00:58:09,750 --> 00:58:10,460
may want, 

964
00:58:10,470 --> 00:58:11,620
it was preempted. 

965
00:58:11,630 --> 00:58:16,440
You may want to take the page table of that process and swap on the disk. 

966
00:58:16,880 --> 00:58:18,100
But if that is large, 

967
00:58:18,320 --> 00:58:19,550
then the overhead is very large. 

968
00:58:22,380 --> 00:58:24,540
So the deal we are here, 

969
00:58:24,550 --> 00:58:25,660
the best table, 

970
00:58:27,910 --> 00:58:29,720
the paging as a technique, 

971
00:58:29,730 --> 00:58:31,980
it's elegant solution, 

972
00:58:32,690 --> 00:58:34,210
very simple to implement, 

973
00:58:35,440 --> 00:58:38,710
provides low internal fragmentation. 

974
00:58:39,560 --> 00:58:41,520
If the pages are small. 

975
00:58:42,350 --> 00:58:43,590
On the downside, 

976
00:58:44,500 --> 00:58:49,170
the problem we encounter is when we have big, 

977
00:58:49,180 --> 00:58:51,960
it is because the page tables can be huge. 

978
00:58:54,900 --> 00:58:56,000
So what is the solution? 

979
00:58:57,830 --> 00:58:58,320
Right? 

980
00:58:58,670 --> 00:59:03,440
The solution is you repair that the same technique I do like you recursive, 

981
00:59:03,450 --> 00:59:04,160
they do it. 

982
00:59:05,140 --> 00:59:06,900
It's multilevel beijing. 

983
00:59:07,330 --> 00:59:07,690
Right? 

984
00:59:08,160 --> 00:59:10,900
Look, if the page labels are very large,

985
00:59:11,390 --> 00:59:14,590
then why don't we have a base table for that base table? 

986
00:59:14,600 --> 00:59:14,880
Right? 

987
00:59:16,500 --> 00:59:18,530
Or you can combine painting segmentation? 

988
00:59:23,860 --> 00:59:27,740
These are the two solutions. 

989
00:59:28,360 --> 00:59:31,410
A segment mapping, you are going to have segments.

990
00:59:31,420 --> 00:59:32,990
And in the segments, 

991
00:59:33,000 --> 00:59:34,190
you are going to have, 

992
00:59:36,210 --> 00:59:37,720
you page the segments, 

993
00:59:40,390 --> 00:59:44,050
and then in the page table as you are going to the page tables. 

994
00:59:45,760 --> 00:59:49,230
And let's look about how this is work. 

995
00:59:59,710 --> 01:00:02,620
As a core remembers that the page table is a map

996
01:00:02,630 --> 01:00:05,620
between the virtual page number and the physical page. 

997
01:00:07,800 --> 01:00:08,700
This is where it is. 

998
01:00:11,800 --> 01:00:14,030
A simple page table is just a look up table. 

999
01:00:16,890 --> 01:00:18,840
Vpn, the virtual page number.

1000
01:00:18,850 --> 01:00:20,120
It's an index in this table, 

1001
01:00:20,130 --> 01:00:22,000
which contains a physical page number. 

1002
01:00:25,470 --> 01:00:27,420
By the way, what are the map structures?

1003
01:00:27,430 --> 01:00:28,100
When you think of? 

1004
01:00:30,750 --> 01:00:33,310
There are many of them, trees, hash table, and so forth.

1005
01:00:34,890 --> 01:00:37,690
But obviously, these are more complicated,

1006
01:00:37,700 --> 01:00:38,930
means higher overhead, 

1007
01:00:39,350 --> 01:00:42,340
even though they can have slower storage overhead. 

1008
01:00:43,010 --> 01:00:46,330
The beautiful things about the very stable is very quick to access it. 

1009
01:00:47,130 --> 01:00:47,290
Right? 

1010
01:00:47,300 --> 01:00:49,650
It's just a needless. 

1011
01:00:51,530 --> 01:00:54,160
If you use the trees and hash tables, 

1012
01:00:54,170 --> 01:00:55,280
and we'll see about that. 

1013
01:00:57,380 --> 01:00:58,890
They are much more space efficient. 

1014
01:00:58,900 --> 01:01:00,530
You don't need to maintain all the entries, 

1015
01:01:00,540 --> 01:01:02,450
which for it, there is no table.

1016
01:01:03,530 --> 01:01:05,810
But accessing those is much more expensive. 

1017
01:01:07,840 --> 01:01:08,780
There is a trade off here. 

1018
01:01:13,980 --> 01:01:17,730
One simple solution is like we alluded, we mentioned,

1019
01:01:17,740 --> 01:01:23,930
is to have to do the problem of having very big page tables is to page

1020
01:01:24,210 --> 01:01:25,260
these page tables. 

1021
01:01:27,210 --> 01:01:30,870
Basically, here is a two level page labels.

1022
01:01:30,880 --> 01:01:33,380
And here is that instead of now, 

1023
01:01:33,390 --> 01:01:40,110
the address has three fields at the end of the offset, like before,

1024
01:01:40,120 --> 01:01:41,110
no difference here. 

1025
01:01:42,040 --> 01:01:49,050
But what was previously corresponding to the page number? 

1026
01:01:49,930 --> 01:01:51,760
Now you split into two fields, 

1027
01:01:52,140 --> 01:01:57,900
which corresponds to virtual page numbers of page indexes for the two level

1028
01:01:57,910 --> 01:01:58,500
pages. 

1029
01:02:02,190 --> 01:02:03,450
The first ten beats, 

1030
01:02:03,460 --> 01:02:04,500
in this case, 

1031
01:02:05,570 --> 01:02:12,750
represents a virtual p one index in the index, 

1032
01:02:12,760 --> 01:02:14,430
in the first level table, 

1033
01:02:15,160 --> 01:02:15,890
page table. 

1034
01:02:17,980 --> 01:02:19,730
This is going to take, 

1035
01:02:19,740 --> 01:02:26,580
you is going to contain an address to

1036
01:02:27,320 --> 01:02:31,810
a page containing the page table entries at the second level. 

1037
01:02:36,350 --> 01:02:36,960
Okay? 

1038
01:02:38,480 --> 01:02:41,870
In order to compute now the entire physical address, 

1039
01:02:41,880 --> 01:02:48,790
use a few an index to find the address of the page containing

1040
01:02:53,000 --> 01:02:54,530
the physical page number, 

1041
01:02:56,370 --> 01:02:57,980
which is stored in the second level. 

1042
01:03:01,570 --> 01:03:05,840
This physical page number is going to be concatenate with the offset like before. 

1043
01:03:06,550 --> 01:03:08,210
And now you have the physical address. 

1044
01:03:11,390 --> 01:03:11,820
Okay? 

1045
01:03:13,430 --> 01:03:15,420
It's the same thing. 

1046
01:03:15,430 --> 01:03:21,010
The only difference is that now you split the physical page number into a part, 

1047
01:03:21,020 --> 01:03:26,070
which is going to index into a page table, 

1048
01:03:27,370 --> 01:03:28,330
first level page table, 

1049
01:03:28,340 --> 01:03:33,150
which contains the address of a second level page table. 

1050
01:03:33,160 --> 01:03:39,600
And the second field in this page number is going to index

1051
01:03:39,610 --> 01:03:41,600
in this second level page table. 

1052
01:03:42,100 --> 01:03:43,450
And at that entry, 

1053
01:03:43,750 --> 01:03:46,250
corresponding entry are going to hand physical page now. 

1054
01:03:50,190 --> 01:03:52,190
And you can have many moral levels. 

1055
01:03:54,390 --> 01:03:55,860
Now, these are some announcements.

1056
01:03:55,870 --> 01:04:00,820
We are just 15 minutes before the class ends, 

1057
01:04:00,830 --> 01:04:03,060
but here are some announcements. 

1058
01:04:03,070 --> 01:04:04,540
We release a midterm scores, 

1059
01:04:05,730 --> 01:04:10,120
and please check piazza for degrading policies. 

1060
01:04:11,900 --> 01:04:13,950
I think you did quite well, 

1061
01:04:15,080 --> 01:04:23,100
the scores and the distribution is very much in line with that of the past midterms. 

1062
01:04:23,620 --> 01:04:24,770
In the recent years, 

1063
01:04:28,050 --> 01:04:32,120
the project two design documentary member is due by this at the end

1064
01:04:32,130 --> 01:04:33,160
of this friday. 

1065
01:04:34,210 --> 01:04:38,300
The homeless three is due on sunday at the end of the day. 

1066
01:04:40,930 --> 01:04:43,590
If you want an extra credit., 

1067
01:04:43,960 --> 01:04:50,820
please feel free is a mid semester survey and check on piazza for details. 

1068
01:04:51,460 --> 01:04:52,810
So it's free. 

1069
01:04:53,270 --> 01:04:54,020
Three extra credit. 

1070
01:04:55,790 --> 01:04:56,660
The next lecture, 

1071
01:04:56,670 --> 01:05:02,730
i'll be out of town at nathan pemperton with a senior phd student, 

1072
01:05:02,740 --> 01:05:09,110
which you expect boston architectures and systems is going to beach this class. 

1073
01:05:09,550 --> 01:05:10,850
He's a fantastic teacher. 

1074
01:05:11,310 --> 01:05:11,780
Fun. 

1075
01:05:12,540 --> 01:05:15,250
I really urge you to attend his lecture. 

1076
01:05:16,200 --> 01:05:19,310
He is there going to be a lot more fun than my lectures? 

1077
01:05:22,150 --> 01:05:23,180
He's a great presenter. 

1078
01:05:26,580 --> 01:05:31,130
I remember that iii mentioned to you now that in a page table entry, 

1079
01:05:31,140 --> 01:05:34,370
besides the besides of physical page number, 

1080
01:05:35,360 --> 01:05:37,430
we are going also to have some bits. 

1081
01:05:43,190 --> 01:05:44,460
And here is an example. 

1082
01:05:44,860 --> 01:05:46,120
Let's take our previous examples. 

1083
01:05:46,650 --> 01:05:52,160
If you are going to have an offside offset of the or you have a 32 beats address, 

1084
01:05:53,410 --> 01:05:54,730
the offset is 12 bits, 

1085
01:05:54,740 --> 01:05:58,400
so the physical page number is 20 bits. 

1086
01:06:00,680 --> 01:06:02,060
So now, 

1087
01:06:05,070 --> 01:06:06,470
in a base table, 

1088
01:06:07,030 --> 01:06:09,860
what you need the physical page number, 

1089
01:06:09,870 --> 01:06:11,660
which is this 20 bits. 

1090
01:06:11,670 --> 01:06:15,220
So what about the rest of the rest of 12 bits? 

1091
01:06:16,050 --> 01:06:17,510
For the rest of the 12 beats? 

1092
01:06:17,520 --> 01:06:22,020
You are going to have a bunch of flags which are used. 

1093
01:06:23,400 --> 01:06:28,430
They have different use that they can use it in different ways. 

1094
01:06:30,150 --> 01:06:31,540
But here it's an example. 

1095
01:06:31,550 --> 01:06:34,020
And this is from intel architecture. 

1096
01:06:36,430 --> 01:06:41,090
So these are examples about this beats. 

1097
01:06:41,100 --> 01:06:49,710
And we are going to start from the this significant means zero is p this

1098
01:06:49,720 --> 01:06:50,590
is present. 

1099
01:06:51,390 --> 01:06:52,580
It's the same as valid. 

1100
01:06:53,140 --> 01:06:55,500
Is a page present in physical memory or not? 

1101
01:06:56,120 --> 01:06:57,580
W write a book. 

1102
01:06:58,200 --> 01:07:00,840
Can you write on this page or not? 

1103
01:07:00,850 --> 01:07:05,130
If it's zero, then it's read only its user accessible,

1104
01:07:05,140 --> 01:07:07,690
this page accessible only by user. 

1105
01:07:12,220 --> 01:07:14,210
Pwt page write transparent. 

1106
01:07:14,220 --> 01:07:15,770
This is related with a cash. 

1107
01:07:15,780 --> 01:07:21,490
Typical you have cash is to to reduce the latency to access the data. 

1108
01:07:22,000 --> 01:07:22,460
Right? 

1109
01:07:22,990 --> 01:07:24,540
When you have caches a problem, 

1110
01:07:24,550 --> 01:07:28,740
the question is about how you are going to update the physical memory, 

1111
01:07:28,750 --> 01:07:30,840
the data in the physical memory. 

1112
01:07:30,850 --> 01:07:31,190
Right? 

1113
01:07:34,460 --> 01:07:36,450
There are two ways here we are going to learn. 

1114
01:07:36,460 --> 01:07:40,410
But one way is that whenever we are going to access and we

1115
01:07:40,420 --> 01:07:42,850
are going to write to the cache and modify the data, 

1116
01:07:42,860 --> 01:07:47,170
we are also going to modify the data in the physical memory. 

1117
01:07:49,080 --> 01:07:52,450
And this is page writes, transparent,

1118
01:07:53,410 --> 01:07:55,720
bcd space cash disabled. 

1119
01:07:57,330 --> 01:07:59,120
You cannot catch the pages. 

1120
01:07:59,560 --> 01:08:02,790
A its access page has been accessed recently. 

1121
01:08:02,800 --> 01:08:05,730
This is used also for cashing. 

1122
01:08:06,120 --> 01:08:07,340
But I think it's accessed recently. 

1123
01:08:07,350 --> 01:08:10,090
And the next two is the same, first of all, cash.

1124
01:08:11,560 --> 01:08:15,300
You want to know whether the pages access recently and whether is dirty

1125
01:08:15,610 --> 01:08:16,200
was written, 

1126
01:08:17,060 --> 01:08:22,590
and the physical memory associated with physical memory was not updated. 

1127
01:08:23,150 --> 01:08:25,180
So you need to know about that. 

1128
01:08:25,190 --> 01:08:26,830
And then you are going, 

1129
01:08:27,500 --> 01:08:31,550
we may decide to page that to this is. 

1130
01:08:33,460 --> 01:08:34,720
Okay, how do I say?

1131
01:08:34,730 --> 01:08:36,080
So these two beats, 

1132
01:08:37,110 --> 01:08:43,380
the only thing you need to know now are used when deciding what page

1133
01:08:43,770 --> 01:08:45,070
to swap out of the

1134
01:08:45,080 --> 01:08:47,150
memory to make the room for me pages. 

1135
01:08:48,590 --> 01:08:49,110
Fundamentally, 

1136
01:08:49,120 --> 01:08:55,800
you do not want to swap up a page of a process which will be accessed india. 

1137
01:09:02,840 --> 01:09:03,990
I it's a question. 

1138
01:09:12,110 --> 01:09:13,430
The pcd means, 

1139
01:09:13,440 --> 01:09:18,370
the question is obesity means it's about obesity means the pcd means

1140
01:09:18,380 --> 01:09:19,810
that the page is not cached. 

1141
01:09:21,440 --> 01:09:25,070
Again, the reason you may choose to not cash a page is that, for instance,

1142
01:09:25,080 --> 01:09:26,590
in multiprocessor systems, 

1143
01:09:27,070 --> 01:09:28,070
multicore systems, 

1144
01:09:28,080 --> 01:09:34,270
when you have concurrency on on the same page, 

1145
01:09:34,280 --> 01:09:36,990
you have a page with a shared to different processes, 

1146
01:09:37,360 --> 01:09:39,290
which run on different processors. 

1147
01:09:39,910 --> 01:09:42,640
And they can concurrently access that page. 

1148
01:09:43,210 --> 01:09:45,360
And if you want to update the page, 

1149
01:09:45,610 --> 01:09:48,430
if it's cashed each process in each process of cash, 

1150
01:09:48,810 --> 01:09:50,900
then you have a cache coherence problem. 

1151
01:09:51,520 --> 01:09:53,110
If you want to simplify that problem, 

1152
01:09:53,120 --> 01:09:54,750
if you want to remove that problem, 

1153
01:09:54,760 --> 01:09:57,710
you can say this page is never going to be cash. 

1154
01:10:05,140 --> 01:10:10,390
Example of how to use pd invalid pd es is that it's, again,

1155
01:10:10,400 --> 01:10:14,880
even this one can in the imply different things and the operating system

1156
01:10:14,890 --> 01:10:16,600
besides how to use these flags

1157
01:10:21,150 --> 01:10:21,710
once. 

1158
01:10:23,090 --> 01:10:28,340
And one we use is that which I didn't mention is that the address space

1159
01:10:28,350 --> 01:10:29,460
is actually not valid, 

1160
01:10:29,470 --> 01:10:29,940
right? 

1161
01:10:32,650 --> 01:10:34,040
It doesn't is not allocated. 

1162
01:10:34,050 --> 01:10:36,760
But another way is basically say the page director, 

1163
01:10:36,770 --> 01:10:38,590
it's that page, 

1164
01:10:38,830 --> 01:10:40,760
it's not in the memo, it's on the disk.

1165
01:10:41,150 --> 01:10:41,420
Right? 

1166
01:10:41,590 --> 01:10:48,470
In that case, you need it a it's a a it's a trap to the operating system,

1167
01:10:48,480 --> 01:10:49,030
exception. 

1168
01:10:49,040 --> 01:10:52,320
It results into a trap to the operating system. 

1169
01:10:52,330 --> 01:10:55,480
And the operating system is going to figure out where is the biggest start, 

1170
01:10:55,490 --> 01:10:56,800
and it's going to bring it to memory. 

1171
01:11:00,000 --> 01:11:01,900
This is going to be used by the main page. 

1172
01:11:02,230 --> 01:11:03,420
We are going to learn about that. 

1173
01:11:03,960 --> 01:11:09,780
Another use here is about copy and write for the pd basically, 

1174
01:11:09,790 --> 01:11:10,540
when you fork, 

1175
01:11:10,930 --> 01:11:12,180
remember that the fork, 

1176
01:11:12,590 --> 01:11:14,740
when you fork a process, a fork process copy,

1177
01:11:14,750 --> 01:11:16,890
actually the parent process, right?

1178
01:11:17,140 --> 01:11:18,130
It has everything. 

1179
01:11:19,320 --> 01:11:22,350
And now the question is that do you want to copy it right away? 

1180
01:11:23,100 --> 01:11:23,540
Right? 

1181
01:11:24,790 --> 01:11:26,500
Are you going to copy everything? 

1182
01:11:26,510 --> 01:11:29,060
And it's not smart to do it, because,

1183
01:11:29,440 --> 01:11:29,950
for instance, 

1184
01:11:29,960 --> 01:11:34,350
the code of the process of the parent process is the same code. 

1185
01:11:34,360 --> 01:11:36,510
You are the child process is going to execute. 

1186
01:11:36,520 --> 01:11:38,550
The code is read only, so you can only to copy.

1187
01:11:39,590 --> 01:11:42,150
But the same is also true about the data. 

1188
01:11:42,780 --> 01:11:47,380
But I I do want to copy to move that to copy the data from the process

1189
01:11:47,390 --> 01:11:49,690
at a space to the child at the space. 

1190
01:11:50,150 --> 01:11:54,010
The answer there is that only if the child ideally only of the child access, 

1191
01:11:54,770 --> 01:11:55,010
right? 

1192
01:11:55,020 --> 01:11:56,010
And write it, right?

1193
01:11:56,620 --> 01:11:59,740
So when that's what, 

1194
01:11:59,750 --> 01:12:00,900
so initially, 

1195
01:12:02,500 --> 01:12:04,050
when you are going to create, 

1196
01:12:04,060 --> 01:12:09,190
if you because you want to reduce the overhead to create at the forecast process, 

1197
01:12:09,580 --> 01:12:13,500
the four process can share the entire address that via address space

1198
01:12:13,510 --> 01:12:16,400
to the parent process. 

1199
01:12:16,410 --> 01:12:18,480
So the reads are very, 

1200
01:12:19,160 --> 01:12:22,950
there are going to the same memory is memory efficient is fast, 

1201
01:12:24,110 --> 01:12:24,840
right before. 

1202
01:12:27,700 --> 01:12:36,350
But then the only one you can start doing it is when you write it. 

1203
01:12:36,360 --> 01:12:40,460
So when you write a page, now,

1204
01:12:40,470 --> 01:12:49,230
only now you are going to create a copy of that page for the child. 

1205
01:12:50,010 --> 01:12:53,110
And now the child can write and read from that copy. 

1206
01:12:54,830 --> 01:12:56,110
But as long as you want to read, 

1207
01:12:56,120 --> 01:13:00,770
you can read from the same memory, physical memory,

1208
01:13:00,780 --> 01:13:04,540
which is shared a a with a balance. 

1209
01:13:07,120 --> 01:13:08,790
Another use case here. 

1210
01:13:09,110 --> 01:13:10,820
It's a zero field on demand. 

1211
01:13:10,830 --> 01:13:11,860
So say, 

1212
01:13:12,800 --> 01:13:14,110
you allocate, 

1213
01:13:15,500 --> 01:13:18,490
say, ten gigabytes of memory and you want to initialize the zero.

1214
01:13:20,610 --> 01:13:24,930
Just that it initialization can take seconds many seconds. 

1215
01:13:26,650 --> 01:13:28,170
Just to do this initialization, 

1216
01:13:29,770 --> 01:13:31,680
you don't want to pay the overhead, 

1217
01:13:31,690 --> 01:13:33,800
then when you are going to order allocation, 

1218
01:13:34,900 --> 01:13:37,770
instead of you can do zero fill on demand. 

1219
01:13:40,490 --> 01:13:44,040
The os now that this pages needs to be zero, 

1220
01:13:44,050 --> 01:13:45,960
but initially doesn't make them zero. 

1221
01:13:46,680 --> 01:13:48,920
It may seem zero only on your axis average. 

1222
01:13:50,470 --> 01:13:51,530
And that's perfectly fine, 

1223
01:13:51,540 --> 01:13:56,800
because you amortize zeroing it or even better, 

1224
01:13:56,810 --> 01:14:01,960
maybe the application is not going to ever touch every bite, 

1225
01:14:02,920 --> 01:14:04,980
which is allocating these standard devices. 

1226
01:14:05,750 --> 01:14:06,020
Right? 

1227
01:14:06,980 --> 01:14:09,170
Say this, again, some smart ways to use this video.

1228
01:14:13,830 --> 01:14:16,070
So sharing with multiple level pages, 

1229
01:14:18,370 --> 01:14:18,740
sorry. 

1230
01:14:19,700 --> 01:14:20,070
Oops. 

1231
01:14:20,870 --> 01:14:21,790
You can see here, 

1232
01:14:22,640 --> 01:14:26,600
you have two processes. 

1233
01:14:27,290 --> 01:14:34,740
You have this each process has its own base table at rt

1234
01:14:36,850 --> 01:14:38,160
the first level page, 

1235
01:14:38,660 --> 01:14:40,420
you can see for each process, 

1236
01:14:40,430 --> 01:14:46,500
it's pointed from you have the base table pointer for employees, part,

1237
01:14:46,810 --> 01:14:48,960
base table pointer, crime,

1238
01:14:49,380 --> 01:14:52,450
for the two base labels, 

1239
01:14:52,460 --> 01:14:53,650
different base labels, 

1240
01:14:53,660 --> 01:14:55,050
first level base tables. 

1241
01:14:56,080 --> 01:14:59,510
Each of them, they have point to second level page tables.

1242
01:14:59,520 --> 01:15:04,740
And what you can see here that some of the second level page tables are shared. 

1243
01:15:05,210 --> 01:15:13,800
Obviously, all the pages to each entries in the shared space tables,

1244
01:15:14,300 --> 01:15:16,120
.2are also shared. 

1245
01:15:16,490 --> 01:15:16,790
Right? 

1246
01:15:21,290 --> 01:15:22,380
And finally, 

1247
01:15:24,130 --> 01:15:24,670
you remember, 

1248
01:15:24,680 --> 01:15:31,580
I we started with this solving this problem that the page tables

1249
01:15:32,210 --> 01:15:34,120
can become extremely large. 

1250
01:15:35,140 --> 01:15:36,010
If we have, 

1251
01:15:37,380 --> 01:15:42,090
and many of the entries are from these huge base tables are now, 

1252
01:15:42,440 --> 01:15:44,080
so contains no Information. 

1253
01:15:45,140 --> 01:15:52,270
And we said that the two level page table is going to solve that, 

1254
01:15:52,280 --> 01:15:53,430
address that problem, 

1255
01:15:53,440 --> 01:15:55,110
or at least alleviate that problem. 

1256
01:15:55,470 --> 01:15:56,580
Here is an example. 

1257
01:15:57,010 --> 01:15:58,760
If you remember, this is an example,

1258
01:15:58,770 --> 01:16:01,080
and let me just try to go back here. 

1259
01:16:03,470 --> 01:16:04,860
This is a previous example. 

1260
01:16:04,870 --> 01:16:08,010
So this is the example which are going to have, 

1261
01:16:08,020 --> 01:16:10,810
if you can see you, 

1262
01:16:11,220 --> 01:16:13,420
this was a 111 level table. 

1263
01:16:13,430 --> 01:16:16,180
So you have, I think, 32 entries,

1264
01:16:16,190 --> 01:16:17,580
many of these centuries are now. 

1265
01:16:18,230 --> 01:16:18,670
Right? 

1266
01:16:19,830 --> 01:16:23,030
This is a corresponding example. 

1267
01:16:34,780 --> 01:16:40,630
That's this is a corresponding example you can see. 

1268
01:16:40,640 --> 01:16:41,670
And you can count. 

1269
01:16:42,030 --> 01:16:44,280
You have much fuels. 

1270
01:16:44,290 --> 01:16:49,410
It requires to appear less storage for storing these space labels. 

1271
01:16:50,360 --> 01:16:50,690
Right? 

1272
01:16:51,410 --> 01:16:54,250
And certainly, you have much more fewer malignants.

1273
01:17:02,210 --> 01:17:03,400
Let's continue. 

1274
01:17:03,410 --> 01:17:05,360
We have just a few more minutes. 

1275
01:17:06,110 --> 01:17:11,870
And this also tells you about how the translation is done. 

1276
01:17:12,870 --> 01:17:14,260
In this particular case, 

1277
01:17:14,270 --> 01:17:19,080
we have for the first page, the level page table,

1278
01:17:19,090 --> 01:17:21,440
we use three beats for the second level two beats, 

1279
01:17:21,450 --> 01:17:24,110
and for the offset 3 bits. 

1280
01:17:26,960 --> 01:17:28,270
So in the best case, an article,

1281
01:17:28,280 --> 01:17:31,790
the size of the page tables is a number of pages used by the program

1282
01:17:32,070 --> 01:17:33,480
in the spiritual memory. 

1283
01:17:33,750 --> 01:17:35,160
Unlike the previous case, 

1284
01:17:35,170 --> 01:17:42,160
in which the number of pages was the one available in the physical memory, 

1285
01:17:44,120 --> 01:17:49,440
the price to pay here is that you have one more additional memory access, 

1286
01:17:49,990 --> 01:17:50,350
right? 

1287
01:17:51,250 --> 01:17:54,370
Because they need to do index on both space labels, 

1288
01:17:55,640 --> 01:17:56,400
advanced level. 

1289
01:18:06,020 --> 01:18:15,560
How about about segments and pages? 

1290
01:18:15,570 --> 01:18:15,880
Right? 

1291
01:18:15,890 --> 01:18:17,880
This is another way to do it, right?

1292
01:18:17,890 --> 01:18:19,510
Like we have two level tables. 

1293
01:18:19,520 --> 01:18:24,090
But another way to sell to solve similar problems is have to combine

1294
01:18:24,100 --> 01:18:26,330
segmentation with spaging. 

1295
01:18:27,010 --> 01:18:28,110
In this case, again,

1296
01:18:28,120 --> 01:18:32,300
you have the address is split into three fields, 

1297
01:18:32,560 --> 01:18:35,260
but the first field represent a segment number. 

1298
01:18:35,270 --> 01:18:38,390
The second field represents a virtual page number, 

1299
01:18:38,400 --> 01:18:39,550
resumes a segment, 

1300
01:18:40,030 --> 01:18:41,250
and then you have the offset. 

1301
01:18:42,610 --> 01:18:45,170
It's a very similar approach. 

1302
01:18:49,570 --> 01:18:50,240
It's again here. 

1303
01:18:50,250 --> 01:18:52,160
What do you need to save and store? 

1304
01:18:52,170 --> 01:18:53,200
When contact switching? 

1305
01:18:53,210 --> 01:18:54,680
You need to store the segment table. 

1306
01:18:54,690 --> 01:18:57,570
You need to start the page table for that process. 

1307
01:18:58,270 --> 01:19:00,990
How do you share the data across different segments? 

1308
01:19:01,490 --> 01:19:06,640
When you have these both segments and pay and Beijing? 

1309
01:19:07,500 --> 01:19:11,250
It's the same very similar way that I you are going to have

1310
01:19:11,260 --> 01:19:12,490
from two different processes. 

1311
01:19:13,310 --> 01:19:19,910
They can share the pages by simply having the base

1312
01:19:24,920 --> 01:19:26,070
by sharing the segment, 

1313
01:19:26,080 --> 01:19:26,390
right? 

1314
01:19:26,900 --> 01:19:28,600
If you understand a bunch of pages, 

1315
01:19:28,610 --> 01:19:31,600
you are going to put all these pages in the same segment, 

1316
01:19:31,850 --> 01:19:38,180
then you are going to share the same very soon. 

1317
01:19:41,100 --> 01:19:44,130
Let me do this one last slide, 

1318
01:19:44,140 --> 01:19:46,170
and then I am going to stop here. 

1319
01:19:46,850 --> 01:19:50,230
When you have multilevel translation pages, 

1320
01:19:50,240 --> 01:19:52,150
what are the pros and cons? 

1321
01:19:52,620 --> 01:19:53,260
Okay? 

1322
01:19:53,690 --> 01:19:58,970
The big PRO is that you get to is much less space for the page labels. 

1323
01:19:59,960 --> 01:20:00,280
Right? 

1324
01:20:00,920 --> 01:20:01,390
That's it. 

1325
01:20:02,000 --> 01:20:04,270
The phone number, the Beijing in themselves,

1326
01:20:04,280 --> 01:20:07,430
they have the big advantage that it's fixed size. 

1327
01:20:07,750 --> 01:20:09,450
So they retain to some simplicity, 

1328
01:20:09,460 --> 01:20:12,110
you have no external fragmentation, 

1329
01:20:12,120 --> 01:20:13,590
have only internal fragmentation. 

1330
01:20:14,750 --> 01:20:21,160
The cause is that the page tables can be huge, 

1331
01:20:21,730 --> 01:20:24,740
because they need to be continuous because you need to indexing with them. 

1332
01:20:25,650 --> 01:20:26,210
Therefore, 

1333
01:20:26,220 --> 01:20:31,660
you need to have multiple level of labels in order to get

1334
01:20:31,670 --> 01:20:33,980
the memory allocation with the two to get

1335
01:20:34,530 --> 01:20:37,780
efficient memory allocation for the page tables. 

1336
01:20:40,390 --> 01:20:44,900
But the big problem is that now you need to have multiple look UPS for translation, 

1337
01:20:44,910 --> 01:20:50,650
because you need to look to have a look up for each page level. 

1338
01:20:54,750 --> 01:20:58,480
Let's stop here again. 

1339
01:20:59,700 --> 01:21:01,940
Please attend Nathan lecture on Thursday, 

1340
01:21:01,950 --> 01:21:06,340
and i'll see you next Monday. 

1341
01:21:08,760 --> 01:21:08,870
Thanks. 

1342
01:21:08,880 --> 01:21:10,430
So we are done. 

1343
01:21:10,440 --> 01:21:13,820
Let me just some recording. 

