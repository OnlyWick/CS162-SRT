1
00:00:20,860 --> 00:00:21,890
Hello, everyone.

2
00:00:23,830 --> 00:00:25,220
Welcome to today's lecture. 

3
00:00:25,230 --> 00:00:29,700
So today we are going to finish our discussion on demand beijing

4
00:00:30,800 --> 00:00:32,520
and on memory in general. 

5
00:00:33,310 --> 00:00:42,470
And we are going to start the discussion on io if time permitted as always, 

6
00:00:42,480 --> 00:00:50,940
please ask any questions anytime I will try to answer them as quickly as possible. 

7
00:00:55,030 --> 00:00:57,180
If you remember the last time, 

8
00:00:57,190 --> 00:01:01,340
we ended with showing this five, 

9
00:01:01,350 --> 00:01:02,760
for example, 

10
00:01:02,920 --> 00:01:05,500
policy for pace replacement. 

11
00:01:07,460 --> 00:01:09,130
Why do you need pace replacement? 

12
00:01:10,480 --> 00:01:17,780
Why do you need to evict pages out of memory on the discord ssd this is

13
00:01:17,790 --> 00:01:18,700
a question for you. 

14
00:01:41,020 --> 00:01:41,770
It's exactly. 

15
00:01:41,780 --> 00:01:49,680
So the main reason you need to evict pages from memory on the

16
00:01:49,690 --> 00:01:57,430
disk is because you are going the memory allocated by

17
00:01:57,440 --> 00:02:02,500
processes is going to exceed the physical memory. 

18
00:02:04,590 --> 00:02:09,200
The memory allocated by processes is there which we are virtual memory? 

19
00:02:09,570 --> 00:02:14,090
Each process is its own virtual memory that locates part

20
00:02:14,100 --> 00:02:16,210
of that virtual memory for its code, 

21
00:02:16,860 --> 00:02:20,850
for the stack and for his heap and data. 

22
00:02:21,910 --> 00:02:28,030
And then this all these have to be stored in the physical memory when they

23
00:02:28,040 --> 00:02:28,790
are accessed, 

24
00:02:30,400 --> 00:02:35,150
because the sum of all this allocation for overall processes on a machine

25
00:02:35,520 --> 00:02:36,360
is going to, 

26
00:02:36,370 --> 00:02:37,080
in general, 

27
00:02:37,090 --> 00:02:42,170
be higher than the physical memory. 

28
00:02:42,470 --> 00:02:47,430
Then sometimes you need to move the day the pages from the physical memory

29
00:02:47,440 --> 00:02:47,910
to the risk. 

30
00:02:49,070 --> 00:02:50,720
And because you want to do that, 

31
00:02:51,330 --> 00:02:57,850
then the question about which page you are going to decide to evict, 

32
00:02:59,560 --> 00:03:01,020
it's an important one, 

33
00:03:02,000 --> 00:03:04,630
because evicting different pages, 

34
00:03:05,330 --> 00:03:09,600
will I have a significant impact on performance? 

35
00:03:09,610 --> 00:03:13,770
So which page of you are going to choose to be is going to have an impact

36
00:03:13,780 --> 00:03:14,230
on performance. 

37
00:03:15,170 --> 00:03:17,120
For instance, if you have bigger page,

38
00:03:17,450 --> 00:03:19,320
which you are going to access next, 

39
00:03:19,830 --> 00:03:22,300
then he's not going to be a good idea, because remember,

40
00:03:22,310 --> 00:03:26,990
then there is a pretty high overhead in bringing the page

41
00:03:27,000 --> 00:03:29,630
back from the disk to memory. 

42
00:03:32,970 --> 00:03:35,130
And on the other hand, 

43
00:03:35,140 --> 00:03:40,260
if you remember the optimal replacement policy, 

44
00:03:40,930 --> 00:03:46,410
the eviction policy is basically evicting the page, 

45
00:03:46,740 --> 00:03:50,530
which will be accessed the farthest in the future. 

46
00:03:54,010 --> 00:03:57,150
So, but that's hard to implement.

47
00:03:57,160 --> 00:03:58,390
And we discussed, 

48
00:03:58,980 --> 00:03:59,840
as we discussed. 

49
00:03:59,850 --> 00:04:07,240
So we are now going through a few simple cash pay replacement policies. 

50
00:04:07,250 --> 00:04:10,900
And we started last time with a 501. 

51
00:04:11,440 --> 00:04:14,630
The fight for replacement policy is very simple. 

52
00:04:14,930 --> 00:04:18,140
You always a be evict the page, 

53
00:04:22,440 --> 00:04:24,540
the first one, which was brought to memory,

54
00:04:26,140 --> 00:04:27,310
but I have to brought in memory. 

55
00:04:28,020 --> 00:04:29,930
We went through this simple example. 

56
00:04:29,940 --> 00:04:32,170
This is just to refresh your memory. 

57
00:04:32,490 --> 00:04:39,100
Here we have the physical memory has 3 pages, 

58
00:04:39,110 --> 00:04:40,300
3 page frames. 

59
00:04:41,410 --> 00:04:47,420
And we are accessing4 pages, so not all of them,

60
00:04:47,430 --> 00:04:49,060
abcd not all of them, 

61
00:04:49,190 --> 00:04:51,220
are going to fit in memory at a given time, 

62
00:04:51,230 --> 00:04:53,810
because they have four and the memory has only 3 pages. 

63
00:04:55,310 --> 00:04:58,260
This is a sequence in which you are accessing these pages. 

64
00:04:59,440 --> 00:05:03,870
So you remember, it's abc these are all compulsory misses.

65
00:05:03,880 --> 00:05:04,350
You. 

66
00:05:04,360 --> 00:05:08,890
The baby is not in the memories you need to brings a page from the disk to memory. 

67
00:05:09,890 --> 00:05:10,940
That's a miss. 

68
00:05:11,660 --> 00:05:14,450
Now, after you asked the first three,

69
00:05:14,460 --> 00:05:15,970
now the memory is full. 

70
00:05:16,240 --> 00:05:19,030
Now you access a is great. 

71
00:05:19,040 --> 00:05:20,270
It's already in the memory. 

72
00:05:20,280 --> 00:05:21,510
You don't need to do anything. 

73
00:05:21,520 --> 00:05:24,350
Then you access b is the same thing with your memory. 

74
00:05:24,550 --> 00:05:25,900
Don't need to do anything. 

75
00:05:26,410 --> 00:05:29,400
Now, you are accessing db is not in memory.

76
00:05:29,690 --> 00:05:30,600
What you are going to do, 

77
00:05:30,610 --> 00:05:34,880
you are going to have to choose the week to one of the existing pages

78
00:05:35,140 --> 00:05:36,580
to bring b into memory. 

79
00:05:37,000 --> 00:05:39,300
And a was the one, in this case,

80
00:05:39,310 --> 00:05:43,530
because it's five for you are going to evict a because a as you can see, 

81
00:05:43,540 --> 00:05:44,850
in this figure, 

82
00:05:44,860 --> 00:05:48,370
was the first one which was brought in memory, 

83
00:05:49,350 --> 00:05:52,580
should be a so now you have bbc in memory. 

84
00:05:52,590 --> 00:05:53,780
A comes. 

85
00:05:54,990 --> 00:05:57,460
So a is accessed again. 

86
00:05:57,650 --> 00:05:59,820
So unfortunately, as you can see,

87
00:05:59,830 --> 00:06:03,910
here was not a great idea in hindsight to evict a because now you

88
00:06:03,920 --> 00:06:05,260
need to bring it back. 

89
00:06:06,360 --> 00:06:09,070
But again, according to the fight for policy, now,

90
00:06:09,380 --> 00:06:11,640
you are going to evict be right? 

91
00:06:12,910 --> 00:06:15,020
Because from the existing pages in the memory, 

92
00:06:15,030 --> 00:06:16,140
b was of one, 

93
00:06:16,150 --> 00:06:21,060
which was the oldest is the oldest song. 

94
00:06:22,220 --> 00:06:24,140
Then d again, you don't do anything,

95
00:06:24,150 --> 00:06:25,900
because these already in memory, 

96
00:06:26,190 --> 00:06:29,890
now becomes you access bb is no longer in memory. 

97
00:06:29,900 --> 00:06:37,720
So you need to replace the oldest page which you see and so forth. 

98
00:06:38,200 --> 00:06:38,540
Okay? 

99
00:06:39,920 --> 00:06:41,660
As we looked at that, 

100
00:06:41,670 --> 00:06:43,410
and if you remember again, 

101
00:06:43,420 --> 00:06:44,810
from the last time, 

102
00:06:44,910 --> 00:06:50,910
we have seven misses or 7 page faults. 

103
00:06:52,350 --> 00:06:53,780
Three are compulsory misses, 

104
00:06:53,790 --> 00:06:59,450
abc and the danbc are capacity misses. 

105
00:06:59,710 --> 00:07:02,280
We had the miss because the memory was not large enough. 

106
00:07:04,920 --> 00:07:05,300
Okay. 

107
00:07:08,280 --> 00:07:08,790
Now, 

108
00:07:08,800 --> 00:07:14,710
let's look about how this optimal policy mean or at least recently mean

109
00:07:15,360 --> 00:07:15,990
will work. 

110
00:07:17,420 --> 00:07:20,860
So suppose we have the same reference stream. 

111
00:07:21,870 --> 00:07:27,730
Again, the same memory with 3 pages,

112
00:07:28,380 --> 00:07:30,670
abc the same thing happens. 

113
00:07:30,680 --> 00:07:31,830
Nothing changes, right?

114
00:07:31,840 --> 00:07:33,110
Until you fill in the memory, 

115
00:07:33,120 --> 00:07:34,510
because obviously, 

116
00:07:34,520 --> 00:07:35,950
before you fill in the memory, 

117
00:07:35,960 --> 00:07:38,150
there is no miss is a story. 

118
00:07:38,160 --> 00:07:39,650
There is no ambition. 

119
00:07:41,730 --> 00:07:43,560
A again, nothing happened,

120
00:07:43,570 --> 00:07:44,600
b nothing happened. 

121
00:07:46,510 --> 00:07:47,560
So now, 

122
00:07:50,550 --> 00:07:53,070
tell me without looking to the slides, 

123
00:07:53,990 --> 00:07:59,750
please tell me now I have b now I am going to access after b i'm going

124
00:07:59,760 --> 00:08:03,450
to access d which page i'm going to replace and why? 

125
00:08:16,480 --> 00:08:22,400
So I want to access to replace a page which will be

126
00:08:24,120 --> 00:08:26,570
accessed far as us in the future. 

127
00:08:28,940 --> 00:08:34,290
I'm here md so after that, 

128
00:08:34,300 --> 00:08:37,010
i'm going to access adbcb

129
00:08:49,200 --> 00:08:56,150
the answer c because abbc

130
00:09:00,380 --> 00:09:00,790
okay? 

131
00:09:01,400 --> 00:09:02,110
That's correct. 

132
00:09:02,120 --> 00:09:09,780
So after I am going to access b I am going after that, 

133
00:09:09,790 --> 00:09:15,280
i'm going to access a then b and b and c so c is the one which is

134
00:09:15,290 --> 00:09:16,480
farthest in the future. 

135
00:09:20,610 --> 00:09:23,480
I'm going to replace d now next, 

136
00:09:23,490 --> 00:09:27,760
I am going to access a nothing happens. 

137
00:09:28,450 --> 00:09:31,090
Now I am going to access d again, 

138
00:09:31,100 --> 00:09:36,640
and now i'm going to access b nothing happens. 

139
00:09:37,260 --> 00:09:41,970
Now I am going to access cc is no longer in memory. 

140
00:09:41,980 --> 00:09:50,200
I have only ab and d which which I am going to replace which page

141
00:09:50,210 --> 00:09:51,080
i'm going to replace. 

142
00:09:51,090 --> 00:09:51,240
Now. 

143
00:09:53,050 --> 00:09:59,000
I'm here b then following on rc and b a okay. 

144
00:10:02,090 --> 00:10:04,090
Do you see another page I could replace? 

145
00:10:15,130 --> 00:10:16,720
You can replace a is fine. 

146
00:10:16,730 --> 00:10:23,710
What I if I would have replaced d yes, 

147
00:10:23,720 --> 00:10:25,030
b is also an option. 

148
00:10:25,710 --> 00:10:26,490
Okay? 

149
00:10:27,230 --> 00:10:29,290
Because if I replace these the following two axis, 

150
00:10:29,300 --> 00:10:30,850
rc and b again, 

151
00:10:30,860 --> 00:10:31,890
I have no miss, 

152
00:10:33,690 --> 00:10:34,380
no pace fault. 

153
00:10:35,150 --> 00:10:37,780
Now, you can see that instead of seven,

154
00:10:37,790 --> 00:10:40,440
now you have only 5 page faults. 

155
00:10:42,040 --> 00:10:42,450
Right? 

156
00:10:43,570 --> 00:10:45,160
Remember, abc were compulsory.

157
00:10:45,170 --> 00:10:47,050
You are going to have them anyway. 

158
00:10:47,060 --> 00:10:50,490
So from capacity misses, 

159
00:10:50,500 --> 00:10:52,330
before we have four, now we have two.

160
00:10:55,080 --> 00:10:56,310
It's quite an improvement. 

161
00:10:57,830 --> 00:11:00,870
Now, we said that with minimum, with mean,

162
00:11:01,730 --> 00:11:03,220
while it's optimal, 

163
00:11:03,730 --> 00:11:05,490
it's very hard to implement, right?

164
00:11:05,500 --> 00:11:07,530
Because it's assumed that the future, 

165
00:11:08,910 --> 00:11:10,120
but you don't know the future. 

166
00:11:10,560 --> 00:11:11,860
And what people do, 

167
00:11:12,850 --> 00:11:13,970
it's approximated. 

168
00:11:13,980 --> 00:11:18,300
And the one way to approximate it is using least recently used. 

169
00:11:19,060 --> 00:11:19,980
So they assume, 

170
00:11:19,990 --> 00:11:27,760
basically is that the axis are local also in time or in any space. 

171
00:11:28,220 --> 00:11:32,050
And basically, they say the assumption is that if I am going,

172
00:11:32,060 --> 00:11:36,820
if I access a page recently, 

173
00:11:37,310 --> 00:11:40,450
I am also going to access it soon. 

174
00:11:41,810 --> 00:11:44,900
If I haven't accessed the page for a long time, 

175
00:11:46,040 --> 00:11:49,600
I am no longer to access that page for a long time in the future. 

176
00:11:54,280 --> 00:11:57,270
By this one, this means that I am going through big pages,

177
00:11:57,280 --> 00:12:01,220
which I haven't accessed for a long time. 

178
00:12:02,130 --> 00:12:02,830
That's what it is. 

179
00:12:02,840 --> 00:12:04,030
So let's see what happens here. 

180
00:12:05,460 --> 00:12:05,870
Again, 

181
00:12:07,570 --> 00:12:08,490
let's now see. 

182
00:12:09,300 --> 00:12:10,530
This is a stream. 

183
00:12:12,930 --> 00:12:14,360
Let's see, 

184
00:12:15,060 --> 00:12:19,760
abc the same b now, 

185
00:12:19,770 --> 00:12:22,070
d which one i'm going to replace? 

186
00:12:22,080 --> 00:12:24,450
I have to replace, 

187
00:12:24,460 --> 00:12:25,610
remember the pages, 

188
00:12:25,620 --> 00:12:32,050
which was which has not been accessed in the past for a long time, 

189
00:12:32,950 --> 00:12:33,820
for the longest time. 

190
00:12:36,120 --> 00:12:37,550
Which one i'm going to replace here? 

191
00:12:37,560 --> 00:12:37,590
A

192
00:12:49,170 --> 00:12:49,520
got it, 

193
00:12:50,130 --> 00:12:50,510
right? 

194
00:12:50,890 --> 00:12:56,450
Because a was has been not accessed for whatever two time units

195
00:12:56,460 --> 00:12:57,730
for 3 time units events. 

196
00:12:57,740 --> 00:12:58,130
How to come? 

197
00:13:01,790 --> 00:13:05,570
I replace a so now I have dbc now, a comes.

198
00:13:07,020 --> 00:13:08,390
Which one i'm going to replace? 

199
00:13:13,840 --> 00:13:14,570
B right? 

200
00:13:16,020 --> 00:13:16,610
Very good. 

201
00:13:17,420 --> 00:13:25,850
Somali a and now it's come c no, sorry,

202
00:13:25,860 --> 00:13:28,590
it's can be beats again. 

203
00:13:31,460 --> 00:13:32,500
Is I need to replace, 

204
00:13:32,510 --> 00:13:37,160
i'm going to replace c because he wasn't access for a long time

205
00:13:37,500 --> 00:13:38,490
for the longest time. 

206
00:13:38,930 --> 00:13:44,070
Now I have c i'm going to replace c i'm going to replace d and so forth. 

207
00:13:48,420 --> 00:13:48,850
Now, 

208
00:13:50,550 --> 00:13:53,550
the things about about this scenario, 

209
00:13:55,090 --> 00:14:03,390
it is that I love you for this particular input doesn't behave very well. 

210
00:14:04,000 --> 00:14:04,320
Right? 

211
00:14:05,140 --> 00:14:06,240
And it's, again,

212
00:14:06,330 --> 00:14:09,240
the reason it doesn't behave very well. 

213
00:14:09,730 --> 00:14:13,910
It is because you don't know the future. 

214
00:14:14,740 --> 00:14:18,830
This means that the assumption behind are you is broken. 

215
00:14:19,520 --> 00:14:19,780
Right? 

216
00:14:19,790 --> 00:14:20,140
Again, 

217
00:14:20,150 --> 00:14:23,920
remember that the assumption is that the paintings which

218
00:14:23,930 --> 00:14:26,040
haven't been accessed for a long time, 

219
00:14:26,050 --> 00:14:27,760
they are not going to be accessed in the future. 

220
00:14:28,300 --> 00:14:29,660
But this is exactly wrong, 

221
00:14:30,190 --> 00:14:30,350
right? 

222
00:14:30,360 --> 00:14:31,630
Because after the here, 

223
00:14:31,640 --> 00:14:35,990
i'm accessing a which hasn't been accessed for a long time in the future, 

224
00:14:36,000 --> 00:14:37,910
I longest time in the past, 

225
00:14:38,440 --> 00:14:39,360
and so forth. 

226
00:14:40,190 --> 00:14:45,290
Now, the one thing I should have said in the previous slide,

227
00:14:45,550 --> 00:14:47,060
if you look in the previous slide, 

228
00:14:47,490 --> 00:14:50,470
let's look in the previous slide and do the same thing. 

229
00:14:52,140 --> 00:14:53,410
First we tried mean. 

230
00:14:53,760 --> 00:14:59,580
Now let's try to think about how will allah you work? 

231
00:15:00,350 --> 00:15:05,120
So let's see how allah you work for this, the same strip.

232
00:15:06,020 --> 00:15:10,430
So now think is allah you this recently used. 

233
00:15:11,050 --> 00:15:15,870
So now I ai am accessing a right? 

234
00:15:16,880 --> 00:15:26,110
Now I have bi am accessing b and now I I am having b according to our real policy. 

235
00:15:27,040 --> 00:15:30,790
When I get d which page I am going to replace? 

236
00:15:41,660 --> 00:15:42,160
Correct? 

237
00:15:43,710 --> 00:15:44,670
I'm going, 

238
00:15:50,270 --> 00:15:52,780
i'm going to replace, actually,

239
00:15:52,790 --> 00:15:54,700
allison is correct. 

240
00:15:54,890 --> 00:15:59,290
I'm going to replace c and brian and eric and others. 

241
00:15:59,300 --> 00:16:07,830
The reason I am not going to replace a a was accessed right here. 

242
00:16:08,120 --> 00:16:09,350
Do you see my cursor? 

243
00:16:09,360 --> 00:16:10,430
Do you see my pointer? 

244
00:16:16,020 --> 00:16:16,290
Great. 

245
00:16:17,310 --> 00:16:19,520
You see a was axis here, 

246
00:16:21,880 --> 00:16:23,240
and b was axis here, 

247
00:16:24,300 --> 00:16:26,400
which means that when b comes, 

248
00:16:29,410 --> 00:16:32,770
c is a page which was not accessed for a long, longest time.

249
00:16:34,120 --> 00:16:36,270
So the difference is at risk fivefold. 

250
00:16:37,110 --> 00:16:40,790
The time which matters is when the page was brought into memory. 

251
00:16:42,050 --> 00:16:43,090
With other you, 

252
00:16:43,100 --> 00:16:47,110
the time which matters is when the page was accessed, 

253
00:16:47,760 --> 00:16:48,460
there's a difference. 

254
00:16:50,160 --> 00:16:51,760
So I have to replace this here. 

255
00:16:52,510 --> 00:16:57,730
Now a i'm going to access a i'm bn and now d i'm going to access d

256
00:16:58,190 --> 00:16:59,950
now i'm going to b

257
00:17:01,010 --> 00:17:05,640
i'm going to bring bb is already in memory, 

258
00:17:05,650 --> 00:17:08,910
and now i'm going to get c c is no longer in memory, 

259
00:17:09,650 --> 00:17:13,180
but let's say when I get c which page i'm going to replace, 

260
00:17:13,990 --> 00:17:14,220
again, 

261
00:17:14,230 --> 00:17:17,820
it has to be the page which has not been accessed for the longest time

262
00:17:17,830 --> 00:17:18,540
in the past. 

263
00:17:22,300 --> 00:17:22,450
Right? 

264
00:17:22,740 --> 00:17:24,090
Bo is access here, 

265
00:17:24,530 --> 00:17:25,770
dos axis here, 

266
00:17:26,130 --> 00:17:27,150
aos axis here, 

267
00:17:27,280 --> 00:17:28,670
which one i'm going to replace? 

268
00:17:28,680 --> 00:17:36,540
Aok

269
00:17:38,980 --> 00:17:39,690
now be, 

270
00:17:39,700 --> 00:17:40,770
it's already memory. 

271
00:17:41,610 --> 00:17:42,720
In this particular case, 

272
00:17:42,730 --> 00:17:45,470
the point here is that min and allah, 

273
00:17:45,480 --> 00:17:47,470
you behave the same. 

274
00:17:48,430 --> 00:17:50,070
But this is not necessary. 

275
00:17:52,010 --> 00:17:54,440
Like we've seen in the preview in the next example. 

276
00:17:54,710 --> 00:17:57,740
Actually, I love you can perform quite badly.

277
00:17:58,660 --> 00:17:58,970
Right? 

278
00:17:59,650 --> 00:18:02,160
If the assumption is violated, 

279
00:18:08,030 --> 00:18:10,900
obviously, meaning this case that's much better.

280
00:18:11,320 --> 00:18:15,330
When I am going to access the i'm here, 

281
00:18:15,340 --> 00:18:18,090
i'm accessing d which is a long as a page, 

282
00:18:18,100 --> 00:18:20,770
which is not access for the longest time in the future. 

283
00:18:21,160 --> 00:18:22,160
Is c right? 

284
00:18:22,920 --> 00:18:29,530
I am going to replace c now i'm going to get a and b i'm going to abr

285
00:18:29,540 --> 00:18:30,730
already in memory. 

286
00:18:31,250 --> 00:18:33,280
Now, cc is no longer in memory,

287
00:18:33,290 --> 00:18:36,880
c but i'm looking at c when it's accessed by looking in the future, 

288
00:18:36,890 --> 00:18:38,120
I can look in the future. 

289
00:18:38,460 --> 00:18:41,770
Then axis dab and c again. 

290
00:18:42,550 --> 00:18:46,050
The longest the one which will not be accessed for the longest time

291
00:18:46,060 --> 00:18:51,770
in the future is b i'm going to replace b and then so forth. 

292
00:18:52,560 --> 00:18:53,950
In this particular case, 

293
00:18:53,960 --> 00:19:01,660
I is going to have six false or

294
00:19:01,670 --> 00:19:07,740
missus while allah leo is going to have12. 

295
00:19:13,900 --> 00:19:14,320
Good. 

296
00:19:17,170 --> 00:19:20,800
But still no matter like you're seeing the rest of this lecture. 

297
00:19:21,270 --> 00:19:21,380
Still, 

298
00:19:22,170 --> 00:19:25,280
you is considered a very good already sticks, 

299
00:19:26,100 --> 00:19:32,550
because many programs are exhibit locality in their memory access. 

300
00:19:33,450 --> 00:19:33,910
Okay? 

301
00:19:34,410 --> 00:19:38,170
As you'll see is a problem it will be then to approximate allergy. 

302
00:19:39,520 --> 00:19:42,660
Because allergy itself is it's expensive to implement. 

303
00:19:44,900 --> 00:19:49,350
But before going that let's look about a little bit more that take a step

304
00:19:49,360 --> 00:19:51,520
back and look about

305
00:19:52,640 --> 00:19:58,280
what is if the number of page faults Versus the number of frames? 

306
00:19:58,450 --> 00:20:00,640
This is our memory size on the x axis. 

307
00:20:00,650 --> 00:20:04,350
We have the memory size in terms of the number of frames. 

308
00:20:04,730 --> 00:20:05,830
On the y axis, 

309
00:20:05,840 --> 00:20:07,790
you have the number of page faults. 

310
00:20:10,090 --> 00:20:11,110
As you'd expect. 

311
00:20:11,440 --> 00:20:13,410
As the number of frames increases, 

312
00:20:13,790 --> 00:20:17,110
you'd expect the number of which falls to decrease. 

313
00:20:20,590 --> 00:20:21,390
Does it make sense? 

314
00:20:21,700 --> 00:20:23,610
More memory, fewer pitch faults.

315
00:20:29,930 --> 00:20:30,520
However, 

316
00:20:31,240 --> 00:20:35,520
it turns out there are anomalies to this. 

317
00:20:37,350 --> 00:20:40,680
There are certain page replacement algorithms. 

318
00:20:43,480 --> 00:20:45,600
We do not have these properties, 

319
00:20:46,680 --> 00:20:49,460
which means that I increase a memory. 

320
00:20:50,250 --> 00:20:51,950
And for the same workload, 

321
00:20:52,570 --> 00:20:56,840
the number of page falls increases, 

322
00:20:57,890 --> 00:20:59,160
very counter intuitive. 

323
00:21:00,440 --> 00:21:02,740
You have more resources, you perform worse.

324
00:21:05,190 --> 00:21:05,450
Right? 

325
00:21:06,940 --> 00:21:08,050
And here is an example. 

326
00:21:10,230 --> 00:21:10,730
Okay? 

327
00:21:11,130 --> 00:21:14,640
By the way, this is not for ok all page replacement policies.

328
00:21:14,920 --> 00:21:20,220
It's only specific ones like five. 

329
00:21:20,640 --> 00:21:24,920
Like, for instance, it turns out that for our alert real and mean,

330
00:21:25,300 --> 00:21:29,170
this is not the case for other you and me, 

331
00:21:29,460 --> 00:21:33,760
whenever I increase the memory size, 

332
00:21:34,080 --> 00:21:38,640
the number of baseballs is not going to increase, 

333
00:21:39,100 --> 00:21:41,530
either stay the same or is going to decrease. 

334
00:21:42,250 --> 00:21:44,330
But now this example, 

335
00:21:44,340 --> 00:21:53,860
an example in which using 54 will result in more baseball. 

336
00:21:53,870 --> 00:21:55,260
So I increase the basis. 

337
00:21:57,190 --> 00:22:01,650
Here you have abcdi have now 5 pages. 

338
00:22:03,240 --> 00:22:05,120
I'm asking 5 pages. 

339
00:22:05,130 --> 00:22:08,420
The memory has still three frames, 

340
00:22:08,430 --> 00:22:09,740
123. 

341
00:22:10,450 --> 00:22:14,230
This is for this particular access patterns. 

342
00:22:15,220 --> 00:22:16,890
This is what the page falls of. 

343
00:22:16,900 --> 00:22:17,890
The page falls I have. 

344
00:22:19,020 --> 00:22:21,180
Now, there are 9 page faults,

345
00:22:21,780 --> 00:22:26,950
but now assume that I am going to increase the number of pages

346
00:22:26,960 --> 00:22:30,310
or the number of frames in the memory from 3 to 4. 

347
00:22:32,840 --> 00:22:34,960
And as it turns out, 

348
00:22:35,400 --> 00:22:38,720
again, with 5454 is very simple to look, right?

349
00:22:39,170 --> 00:22:40,190
Because you always, 

350
00:22:40,530 --> 00:22:42,700
when you have a baseball during place, 

351
00:22:43,160 --> 00:22:44,920
the one which was brought first, 

352
00:22:45,320 --> 00:22:49,260
and on this graphic is very simple to see the one which was brought first. 

353
00:22:51,270 --> 00:22:52,720
You just look on each line, 

354
00:22:52,970 --> 00:22:55,670
which is the first in memory. 

355
00:22:57,170 --> 00:22:57,790
Right? 

356
00:22:57,800 --> 00:22:58,420
Okay. 

357
00:22:59,380 --> 00:23:02,610
You replay and you can convince yourself and you get e here. 

358
00:23:02,620 --> 00:23:07,000
You are going to replace a a you are going to replace b and so forth. 

359
00:23:07,270 --> 00:23:08,030
And by doing, 

360
00:23:09,080 --> 00:23:11,930
if I have now instead of 34 frames, 

361
00:23:12,330 --> 00:23:13,970
then I get 10 page faults. 

362
00:23:15,360 --> 00:23:20,430
The number, the memory size increases from three frames to four frames.

363
00:23:20,680 --> 00:23:31,540
And the number of phase faults increases from 9 to 10. 

364
00:23:31,550 --> 00:23:32,580
Any questions? 

365
00:23:36,050 --> 00:23:37,120
It's a cool example, right?

366
00:23:37,130 --> 00:23:38,740
It's like, you don't expect that.

367
00:23:46,200 --> 00:23:52,130
Now is a reason for other you or mean the reason this doesn't happen

368
00:23:52,140 --> 00:23:54,050
for larry and meaning because they have these

369
00:23:54,060 --> 00:23:59,110
properties that if say, 

370
00:23:59,520 --> 00:24:03,560
I have a as a memory size, 

371
00:24:03,570 --> 00:24:06,350
it's x frames. 

372
00:24:07,630 --> 00:24:12,240
If I increase the number of frames by, say, one,

373
00:24:13,030 --> 00:24:14,200
then the subs, 

374
00:24:15,230 --> 00:24:19,350
the i'm guaranteed that the pages I have in memory, 

375
00:24:19,690 --> 00:24:24,710
when the memory side goes x it's a subset of the pages i'm going to have

376
00:24:24,720 --> 00:24:25,350
in memory. 

377
00:24:25,570 --> 00:24:26,840
When the memory is x plus one, 

378
00:24:27,610 --> 00:24:29,700
because you have the subset property, 

379
00:24:29,960 --> 00:24:32,100
then the number of baseballs cannot increase. 

380
00:24:35,830 --> 00:24:36,640
So that's the reason. 

381
00:24:45,050 --> 00:24:47,440
Now, as I mentioned, if you remember,

382
00:24:47,450 --> 00:24:53,780
you mentioned that in the last lecture that alu is not easy to implement, 

383
00:24:53,790 --> 00:24:57,860
because alu requires that you one way to implement, 

384
00:24:57,870 --> 00:24:59,780
at least recently used to have a least. 

385
00:25:00,530 --> 00:25:03,570
Whenever you access page in this list, 

386
00:25:03,580 --> 00:25:04,930
you take that page, 

387
00:25:05,290 --> 00:25:07,510
and you bring it at the head of the list. 

388
00:25:07,910 --> 00:25:10,040
Then when you have to replace a page, 

389
00:25:10,050 --> 00:25:13,180
you take the page from the end of the list. 

390
00:25:13,480 --> 00:25:15,420
And that's the one you replace. 

391
00:25:17,410 --> 00:25:20,500
But just on every access, 

392
00:25:20,870 --> 00:25:25,440
manipulating the list and taking the page you accessed to bring us

393
00:25:25,450 --> 00:25:26,440
ahead of the list, 

394
00:25:26,780 --> 00:25:29,150
is very expensive, multiple memory access.

395
00:25:29,560 --> 00:25:31,230
So you do not want to do that. 

396
00:25:31,940 --> 00:25:32,230
Next, 

397
00:25:32,240 --> 00:25:38,230
we are going to talk about some approximation of least recently used one

398
00:25:38,240 --> 00:25:38,980
of such approximation. 

399
00:25:38,990 --> 00:25:42,510
The first one we are going to start with is a clock album. 

400
00:25:43,590 --> 00:25:43,950
Okay? 

401
00:25:46,900 --> 00:25:48,010
We'll have some examples. 

402
00:25:48,020 --> 00:25:54,650
So this is imagine that the all pages are arranged in a a in a ink. 

403
00:25:55,750 --> 00:25:58,360
And you have a clock like a hand, 

404
00:25:58,370 --> 00:26:00,200
a clock as a clock hand, 

405
00:26:00,570 --> 00:26:02,240
which advanced one by 1. 

406
00:26:02,950 --> 00:26:04,360
And you look at every page. 

407
00:26:08,390 --> 00:26:13,600
So, and when you need to evict a page,

408
00:26:14,070 --> 00:26:17,750
this clock hand will move to the next page. 

409
00:26:18,190 --> 00:26:20,880
You check for babies which are not used recently. 

410
00:26:21,280 --> 00:26:26,270
And then you also mark the pages which are used recently. 

411
00:26:29,480 --> 00:26:33,000
And with all this approximation, 

412
00:26:33,610 --> 00:26:34,960
the way you approximate, 

413
00:26:34,970 --> 00:26:37,080
you still replace an old page, 

414
00:26:37,090 --> 00:26:38,280
but not the oldest page. 

415
00:26:38,950 --> 00:26:41,630
Okay, here, how things are working?

416
00:26:43,970 --> 00:26:46,740
So remember that you have a use bit, 

417
00:26:47,450 --> 00:26:47,710
right? 

418
00:26:47,720 --> 00:26:48,710
Or access bit, 

419
00:26:49,700 --> 00:26:56,460
you speed in the pdpd is a page table entry for each page, right?

420
00:26:56,470 --> 00:26:57,240
If you remember. 

421
00:26:58,670 --> 00:27:00,670
And that beat, 

422
00:27:00,680 --> 00:27:03,880
whenever you ask as a page, is set to zero.

423
00:27:04,880 --> 00:27:05,230
Right? 

424
00:27:07,510 --> 00:27:07,770
Sorry. 

425
00:27:07,780 --> 00:27:12,770
Whenever you ask what if it's whenever you access a page, 

426
00:27:13,360 --> 00:27:14,230
you said with one. 

427
00:27:16,330 --> 00:27:18,910
So if I see a one, this means that the page was used.

428
00:27:20,690 --> 00:27:22,730
Now this clock is looking at the page. 

429
00:27:22,740 --> 00:27:26,990
And if he sees 11 it's reseting, 

430
00:27:27,000 --> 00:27:28,850
it and or to zero. 

431
00:27:30,170 --> 00:27:31,650
If he sees a zero, 

432
00:27:31,660 --> 00:27:33,250
then he's replacing that page. 

433
00:27:34,520 --> 00:27:38,180
Because this means that the page hasn't been up access in a while. 

434
00:27:40,050 --> 00:27:41,230
If it's a one, 

435
00:27:41,240 --> 00:27:43,950
this means that it was access recently. 

436
00:27:43,960 --> 00:27:47,440
So you give a chance second chance to that page. 

437
00:27:49,430 --> 00:27:50,460
Let's see how it's worked. 

438
00:27:51,820 --> 00:27:52,090
Here. 

439
00:27:52,100 --> 00:27:55,140
I'm showing an example. 

440
00:27:55,850 --> 00:27:59,250
And I have with

441
00:28:05,470 --> 00:28:06,800
with these all district angles, 

442
00:28:06,810 --> 00:28:11,570
obviously, there are pages or sorry, or frames.

443
00:28:12,670 --> 00:28:17,550
The one with the dash rectangles represent free frames. 

444
00:28:17,970 --> 00:28:19,020
There is nothing there. 

445
00:28:20,170 --> 00:28:22,740
And then for these pages, 

446
00:28:23,160 --> 00:28:25,810
for a few pages, I also put the value of the use.

447
00:28:27,700 --> 00:28:29,670
You have 1101. 

448
00:28:30,830 --> 00:28:34,790
This is now I want to bring a page from the disk. 

449
00:28:34,800 --> 00:28:39,460
So I want to find the page i'm going to replace. 

450
00:28:41,090 --> 00:28:41,520
Okay? 

451
00:28:42,570 --> 00:28:44,640
When i'm going to go through this, 

452
00:28:46,570 --> 00:28:48,040
the hand is going to move. 

453
00:28:49,020 --> 00:28:51,340
Now remember this first page, 

454
00:28:51,350 --> 00:28:52,500
the usb+1. 

455
00:28:54,490 --> 00:28:54,970
Okay? 

456
00:28:55,720 --> 00:28:59,580
I'm going to reset it to set it to zero because use one mean, 

457
00:28:59,590 --> 00:29:01,920
it won't be meant that it was access recent. 

458
00:29:05,140 --> 00:29:08,330
Then i'm going to the next page. 

459
00:29:08,340 --> 00:29:09,490
And again, 

460
00:29:10,620 --> 00:29:14,300
a it was said, as a you speak to us, one, i'm reseting.

461
00:29:14,910 --> 00:29:16,770
I'm setting it to zero. 

462
00:29:17,960 --> 00:29:19,100
And finally, 

463
00:29:20,090 --> 00:29:22,170
now this next page, 

464
00:29:22,750 --> 00:29:24,020
the use bit was zero, 

465
00:29:26,510 --> 00:29:27,740
because the u speed is zero. 

466
00:29:28,750 --> 00:29:32,460
This mean, this means that the page hasn't been accessed in a while,

467
00:29:32,860 --> 00:29:42,290
at least is it wasn't accept since the last time the hand visited that page. 

468
00:29:43,720 --> 00:29:46,110
So we are going to replace this page. 

469
00:29:47,530 --> 00:29:51,590
If is a page was written, 

470
00:29:51,600 --> 00:29:53,950
since was brought, was modified,

471
00:29:54,600 --> 00:29:56,470
you save it on the disk first, 

472
00:29:57,360 --> 00:30:01,350
then you allow the page and update the pt by the way, 

473
00:30:01,360 --> 00:30:03,150
when you evict the page, 

474
00:30:03,390 --> 00:30:08,700
you also invalidate the pity of that page and invalidate the tlb entry

475
00:30:08,710 --> 00:30:09,420
of that page. 

476
00:30:11,540 --> 00:30:13,600
And now I just loaded, 

477
00:30:13,950 --> 00:30:15,190
i'm going to access it, 

478
00:30:15,200 --> 00:30:17,070
so you speed its one. 

479
00:30:17,500 --> 00:30:23,000
And now assume that, in the meantime, for instance,

480
00:30:23,010 --> 00:30:26,080
when I access another this page here, 

481
00:30:26,420 --> 00:30:32,970
which has a bit set u which had the us be set to zero. 

482
00:30:33,460 --> 00:30:37,900
By this, when the hand visited the last time,

483
00:30:38,240 --> 00:30:41,510
I am going to set up the usb to one again, 

484
00:30:41,520 --> 00:30:42,790
because it is accessed. 

485
00:30:44,030 --> 00:30:46,970
Now, finally say that we have another page fold.

486
00:30:47,460 --> 00:30:55,660
And I am going to go to the next page. 

487
00:30:56,340 --> 00:30:59,130
It has used by uusb towards one. 

488
00:30:59,470 --> 00:31:01,310
Now i'm going to set up to zero. 

489
00:31:01,640 --> 00:31:03,790
Then i'm going to go to the next page. 

490
00:31:04,120 --> 00:31:06,220
And that frame, it's actually a frame.

491
00:31:06,230 --> 00:31:07,020
It's an empty frame. 

492
00:31:08,600 --> 00:31:10,230
I'm just going to load the page, 

493
00:31:10,240 --> 00:31:11,710
and i'm going to set up to one. 

494
00:31:11,720 --> 00:31:14,310
I'm going to initialize it pt and so forth, 

495
00:31:15,500 --> 00:31:16,420
typically. 

496
00:31:16,650 --> 00:31:20,230
And this is a little generalized here, a little bit.

497
00:31:20,610 --> 00:31:25,360
You only the free frames are in a different list. 

498
00:31:25,760 --> 00:31:26,290
Okay? 

499
00:31:26,850 --> 00:31:29,360
I put it here to have a global example, 

500
00:31:30,170 --> 00:31:31,680
but typically, frames are in,

501
00:31:31,690 --> 00:31:33,360
three frames are in different list, 

502
00:31:34,200 --> 00:31:36,900
just for you to keep in mind. 

503
00:31:38,370 --> 00:31:39,470
So i'm stopping here. 

504
00:31:39,480 --> 00:31:41,310
And any questions

505
00:31:51,200 --> 00:31:52,950
whenever a page is accessed, 

506
00:31:53,240 --> 00:31:54,500
the usb is at one. 

507
00:31:56,690 --> 00:31:59,160
Whenever a hand visit a page, 

508
00:32:00,810 --> 00:32:02,170
because there was a page fault. 

509
00:32:03,280 --> 00:32:04,740
If they use beatles one, 

510
00:32:06,390 --> 00:32:09,350
you set it to zero. 

511
00:32:09,360 --> 00:32:10,550
If they use beat is zero. 

512
00:32:11,830 --> 00:32:14,610
You have bigger page and brings a new beijing. 

513
00:32:22,390 --> 00:32:23,620
Let me ask you this question. 

514
00:32:26,580 --> 00:32:29,160
Say the hand is moving very fast. 

515
00:32:32,000 --> 00:32:32,800
What does it mean? 

516
00:32:33,840 --> 00:32:34,550
Is that good? 

517
00:32:34,560 --> 00:32:35,270
Is it bad? 

518
00:32:51,650 --> 00:32:54,010
Yes, gilbert and alexander,

519
00:32:55,460 --> 00:32:58,050
it's bad because this means there are a lot of page faults. 

520
00:32:59,080 --> 00:32:59,450
Right? 

521
00:33:00,710 --> 00:33:01,860
If it's moving slowly, 

522
00:33:01,870 --> 00:33:03,420
there are very few base faults. 

523
00:33:09,260 --> 00:33:09,620
Good. 

524
00:33:13,760 --> 00:33:19,410
The other thing is not is that if all the bits are set to one, 

525
00:33:21,810 --> 00:33:25,460
that's still okay, because the handle move,

526
00:33:28,470 --> 00:33:34,100
while moving is going to set up each use bit of each page to zero. 

527
00:33:36,290 --> 00:33:37,480
When it comes back, 

528
00:33:38,890 --> 00:33:40,280
after one, rotation,

529
00:33:41,490 --> 00:33:46,510
is going to find a page with aubu bit of zero. 

530
00:33:46,520 --> 00:33:53,100
That was a page who is hand set the b to zero first time. 

531
00:34:10,630 --> 00:34:13,700
Alison, it's a question here, actually,

532
00:34:13,710 --> 00:34:14,820
about the hand, 

533
00:34:14,830 --> 00:34:17,410
whether it's moving back fast, it's bad.

534
00:34:20,470 --> 00:34:25,230
Is she says that might just mean that we have all our page pages being used. 

535
00:34:25,240 --> 00:34:31,510
And so that hand has to step over a lot of in your spaces. 

536
00:34:41,140 --> 00:34:42,640
This can happen, 

537
00:34:42,650 --> 00:34:48,340
but then it will still be, 

538
00:34:50,590 --> 00:34:52,300
again, there are two reasons.

539
00:34:52,840 --> 00:34:55,190
The hand is going to move fast. 

540
00:34:56,180 --> 00:34:58,770
One absolutely is because of beige faults. 

541
00:34:59,310 --> 00:35:01,950
If there are no base faults, 

542
00:35:01,960 --> 00:35:04,180
the hand will not move. 

543
00:35:04,570 --> 00:35:04,980
Pity it. 

544
00:35:05,990 --> 00:35:06,410
Right? 

545
00:35:08,880 --> 00:35:10,110
As a reason, 

546
00:35:10,550 --> 00:35:15,500
it's obviously because you need to step over a lot of pages which are used

547
00:35:15,510 --> 00:35:17,650
like there is bd set. 

548
00:35:19,690 --> 00:35:23,350
And that can be the case, 

549
00:35:23,360 --> 00:35:25,230
but it's also unlikely, 

550
00:35:25,240 --> 00:35:31,500
because if you assume that will happen only if all the pages

551
00:35:31,510 --> 00:35:33,220
are very uniformly accessed, 

552
00:35:34,020 --> 00:35:35,160
which is not the case. 

553
00:35:35,740 --> 00:35:36,170
Right? 

554
00:35:36,620 --> 00:35:39,810
You have to have all the pages being uniform access, 

555
00:35:40,560 --> 00:35:40,810
right? 

556
00:35:40,820 --> 00:35:43,790
At least since the last time, 

557
00:35:43,800 --> 00:35:46,730
the hand visited them in order to be a one. 

558
00:35:47,600 --> 00:35:51,290
And if you have locality that it's unlikely to happen. 

559
00:35:53,290 --> 00:35:54,360
But it's a good question, 

560
00:35:54,730 --> 00:35:55,910
a good.. 

561
00:35:59,600 --> 00:36:02,390
So I discussed what if hand was moving slowly, 

562
00:36:03,180 --> 00:36:04,650
good sign or bad sign. 

563
00:36:04,660 --> 00:36:06,570
This is not many pages false, 

564
00:36:07,120 --> 00:36:08,070
or fine page quickly. 

565
00:36:08,080 --> 00:36:09,570
What if hand is moving quickly? 

566
00:36:09,580 --> 00:36:12,320
Lots of page faults or lots of reference with that, right?

567
00:36:13,780 --> 00:36:14,960
We discuss both of them, 

568
00:36:14,970 --> 00:36:16,780
but this is what it is, right?

569
00:36:16,790 --> 00:36:21,880
It's like you have a lot of reference besides only if you have. 

570
00:36:22,810 --> 00:36:25,850
It's pretty uniform memory access. 

571
00:36:31,060 --> 00:36:38,060
One way to view the clock algorithms is that you group the pages into 2 groups, 

572
00:36:38,630 --> 00:36:45,650
one with your access recently or one or access longer time in the past. 

573
00:36:48,620 --> 00:36:49,130
Obviously, 

574
00:36:49,140 --> 00:36:54,630
you are going to pick one from the ones which are accessed longer in the past. 

575
00:36:59,330 --> 00:37:02,590
So an obvious question, 

576
00:37:02,600 --> 00:37:04,670
because you think about these 2 groups, 

577
00:37:04,680 --> 00:37:07,670
you have these 2 groups is why not actually partition it. 

578
00:37:07,680 --> 00:37:10,610
And instead of having this kind of clock algorithms, 

579
00:37:10,620 --> 00:37:12,590
just have two groups. 

580
00:37:15,530 --> 00:37:17,160
We are going to talk about that. 

581
00:37:18,710 --> 00:37:19,810
But before that, 

582
00:37:19,820 --> 00:37:27,660
let's look a lot about a version of the coke algorithms. 

583
00:37:27,670 --> 00:37:29,410
We generalize it, clock algorithms,

584
00:37:30,050 --> 00:37:32,820
and its ends chance version, right?

585
00:37:33,830 --> 00:37:37,730
With any chance think about right now, 

586
00:37:38,040 --> 00:37:40,380
you are going to evict a page, 

587
00:37:41,160 --> 00:37:41,520
right? 

588
00:37:42,470 --> 00:37:45,140
You give only so to speak one chance, 

589
00:37:45,480 --> 00:37:53,370
because you set the beat once the

590
00:37:53,380 --> 00:38:00,600
hand sets the use bit of a page to zero is going to evicted the next time

591
00:38:01,690 --> 00:38:03,660
unless the pages and access in the meantime. 

592
00:38:06,610 --> 00:38:10,170
So another way is to have more than 1 bit. 

593
00:38:11,620 --> 00:38:14,410
And this is about ends chance algorithms. 

594
00:38:16,780 --> 00:38:20,670
So now the os keeps a counter per page, 

595
00:38:22,650 --> 00:38:23,980
which is a number of sweeps, 

596
00:38:24,410 --> 00:38:26,370
a number of times it was visited. 

597
00:38:28,290 --> 00:38:32,290
While the page was not accessed on page four, 

598
00:38:32,300 --> 00:38:34,010
the os check the you speed. 

599
00:38:35,860 --> 00:38:38,480
And if it's one, 

600
00:38:39,070 --> 00:38:39,810
you clear it, 

601
00:38:40,770 --> 00:38:41,180
right? 

602
00:38:41,430 --> 00:38:42,870
Like before, is zero.

603
00:38:45,480 --> 00:38:49,270
You also initialize you clear what it is sweep counter. 

604
00:38:51,490 --> 00:38:54,560
If it's zero, you just increment the counter.

605
00:38:54,890 --> 00:38:58,580
And only if the counter is equal is n you replace the page. 

606
00:39:00,510 --> 00:39:05,240
This means that the page has any chances. 

607
00:39:06,750 --> 00:39:14,430
So it can be visited by the hand and times before being evicted. 

608
00:39:16,300 --> 00:39:18,850
Here i'm talking about the page which is not accessed

609
00:39:20,320 --> 00:39:21,850
while these end sweeps happen. 

610
00:39:25,660 --> 00:39:29,170
So obviously, one question is, how do you pick up?

611
00:39:30,800 --> 00:39:36,550
What happens n if n is very large? 

612
00:39:36,960 --> 00:39:39,080
You can actually better approximate alert. 

613
00:39:39,090 --> 00:39:44,770
You say n is 1,000. 

614
00:39:44,780 --> 00:39:46,520
That is really good approximation. 

615
00:39:48,780 --> 00:39:49,890
What is the problem we speak in? 

616
00:39:49,900 --> 00:39:50,170
Gallar? 

617
00:39:50,180 --> 00:39:50,610
Gens? 

618
00:39:52,490 --> 00:39:53,840
Why wouldn't you pick a larger? 

619
00:40:04,350 --> 00:40:05,390
Is less efficient. 

620
00:40:05,980 --> 00:40:07,860
Danny, why is less efficient?

621
00:40:16,600 --> 00:40:19,780
Sweeping will take up lot of rotation, right?

622
00:40:19,790 --> 00:40:27,530
Because think about you need to go, 

623
00:40:28,300 --> 00:40:33,300
you need to visit a page and times and sweeps before you can evict it. 

624
00:40:35,560 --> 00:40:37,390
So it's a lot of pages. 

625
00:40:38,470 --> 00:40:40,870
Then this will take a long time. 

626
00:40:41,650 --> 00:40:42,170
It's exactly. 

627
00:40:42,640 --> 00:40:43,630
So it's not efficient. 

628
00:40:45,520 --> 00:40:47,560
Takes a long time to find free pages. 

629
00:40:50,040 --> 00:40:53,350
What about modified or dirty pages? 

630
00:40:55,690 --> 00:40:57,210
Obviously, it takes extra overhead,

631
00:40:57,220 --> 00:41:02,290
like we saw in the previous example to replace the dirty page, right?

632
00:41:02,970 --> 00:41:03,690
A dirty page, 

633
00:41:03,700 --> 00:41:09,360
meaning that was modified since what or since when it was brought in memory, 

634
00:41:10,540 --> 00:41:10,860
right? 

635
00:41:16,020 --> 00:41:17,370
Because they need to write it to the disk. 

636
00:41:18,180 --> 00:41:22,500
So these algorithms has something some improvement here. 

637
00:41:23,410 --> 00:41:25,170
And basically, 

638
00:41:25,720 --> 00:41:27,800
before a page, 

639
00:41:28,410 --> 00:41:30,400
counter guessed to the end, 

640
00:41:31,000 --> 00:41:33,470
you or write it back to the disk. 

641
00:41:33,690 --> 00:41:40,250
So if you are going next time to decide to replace that page, 

642
00:41:40,570 --> 00:41:42,140
it was already written to the risk. 

643
00:41:44,610 --> 00:41:45,650
So for instance, 

644
00:41:46,660 --> 00:41:50,500
one approach is for the clean pages to use. 

645
00:41:50,510 --> 00:41:52,180
And it's always one, 

646
00:41:52,490 --> 00:41:56,040
which is basically the original clock algorithm. 

647
00:41:57,910 --> 00:41:59,920
But for the dirty pages, 

648
00:42:00,210 --> 00:42:03,330
use any college to for any core is one. 

649
00:42:03,590 --> 00:42:04,580
You write it back. 

650
00:42:04,840 --> 00:42:06,580
If you look at these algorithms now. 

651
00:42:07,130 --> 00:42:07,340
Right? 

652
00:42:07,350 --> 00:42:08,220
If it's a page, 

653
00:42:08,830 --> 00:42:09,620
it's clean, 

654
00:42:10,650 --> 00:42:11,960
it has not modified. 

655
00:42:12,910 --> 00:42:14,890
If the counter is one, you replace it.

656
00:42:17,890 --> 00:42:19,340
If it's a dirty page, 

657
00:42:20,180 --> 00:42:22,650
then when the counter which is one, you don't replace it.

658
00:42:22,950 --> 00:42:24,680
You just write it back to the disk. 

659
00:42:26,220 --> 00:42:28,330
And when the counter is still, you replace it.

660
00:42:30,930 --> 00:42:32,600
This means that hopeful is the next time. 

661
00:42:32,610 --> 00:42:35,300
When you come by the time you decide for this, 

662
00:42:35,310 --> 00:42:41,880
you either are going to find a page which is clean. 

663
00:42:42,580 --> 00:42:44,760
So you don't need to write the disk, 

664
00:42:44,770 --> 00:42:46,810
so you pick that to replace it. 

665
00:42:46,820 --> 00:42:48,610
Or in the worst case, you come back to the page,

666
00:42:48,620 --> 00:42:50,090
you decided to write back. 

667
00:42:50,660 --> 00:42:52,130
But this, by that time,

668
00:42:52,140 --> 00:42:53,180
hopefully it's clean. 

669
00:42:53,690 --> 00:42:55,910
So then the overhead is going to be low. 

670
00:42:59,570 --> 00:43:00,390
Any questions? 

671
00:43:06,400 --> 00:43:06,960
Okay. 

672
00:43:07,860 --> 00:43:09,250
Let's this, again,

673
00:43:09,260 --> 00:43:16,090
the pd this is out of the

674
00:43:18,580 --> 00:43:19,790
page stably, 

675
00:43:20,970 --> 00:43:22,190
the page table entry. 

676
00:43:23,160 --> 00:43:24,650
Again, these are the beats,

677
00:43:25,220 --> 00:43:31,750
which are in the pd so we have aa bit which is present or valid. 

678
00:43:31,760 --> 00:43:33,710
This means, if you remember,

679
00:43:34,080 --> 00:43:36,230
whether specify whether there is a page, 

680
00:43:36,240 --> 00:43:37,550
it's in the memory or not, 

681
00:43:37,560 --> 00:43:38,950
if p zero, 

682
00:43:38,960 --> 00:43:40,190
then it's in valley, 

683
00:43:40,360 --> 00:43:42,900
it's a page for the they should be on the disk. 

684
00:43:43,700 --> 00:43:44,560
It's a writable, 

685
00:43:46,240 --> 00:43:47,820
its access control. 

686
00:43:48,240 --> 00:43:52,120
This is about whether the page is. 

687
00:43:52,430 --> 00:43:54,130
You can write to the page or not. 

688
00:43:54,720 --> 00:43:56,010
Like, for instance,

689
00:43:57,480 --> 00:44:00,400
if the pages which contain the code, 

690
00:44:00,850 --> 00:44:01,930
they are not writable, 

691
00:44:02,480 --> 00:44:02,740
right? 

692
00:44:02,750 --> 00:44:05,740
Because the code is immutable or it should be immutable, 

693
00:44:06,750 --> 00:44:08,500
then it's access bit or use bit. 

694
00:44:08,800 --> 00:44:10,820
We talk quite a bit about it. 

695
00:44:11,160 --> 00:44:13,280
This was what is using the clock algorithm. 

696
00:44:13,670 --> 00:44:15,170
It's a dirty bit, right?

697
00:44:15,180 --> 00:44:16,330
Modified, which is used,

698
00:44:18,730 --> 00:44:23,280
sorry, by any page replacement algorithms.

699
00:44:23,740 --> 00:44:28,290
Because if the page is dirty, was modified,

700
00:44:28,300 --> 00:44:30,410
you need to write it back to the disk. 

701
00:44:33,050 --> 00:44:34,620
So this is what kind of you have. 

702
00:44:34,960 --> 00:44:37,240
And here, 

703
00:44:41,300 --> 00:44:45,130
so again, for just to summarize for the clock algorithms,

704
00:44:45,140 --> 00:44:48,050
like the way as we discuss so far, 

705
00:44:48,450 --> 00:44:52,930
we use bit and the dirty bit. 

706
00:44:54,950 --> 00:44:57,300
But this being said, is it the same thing?

707
00:44:57,690 --> 00:45:01,010
P and w are almost always used. 

708
00:45:02,000 --> 00:45:04,070
They are going to be used by the operating system. 

709
00:45:04,300 --> 00:45:04,800
Obviously, 

710
00:45:11,280 --> 00:45:13,790
now here these are some interesting questions. 

711
00:45:19,290 --> 00:45:23,190
Again, b and w they are a must in general, right?

712
00:45:23,580 --> 00:45:25,940
Because its protection, 

713
00:45:26,550 --> 00:45:31,170
w is protection and p you need to know whether the pages in memory or not. 

714
00:45:31,560 --> 00:45:33,030
You cannot go around those. 

715
00:45:34,390 --> 00:45:36,860
Now, the question is about these other bits,

716
00:45:37,750 --> 00:45:38,080
right? 

717
00:45:38,540 --> 00:45:44,320
And the question is that are they really necessary to implement, 

718
00:45:44,330 --> 00:45:45,600
for instance, a clock algorithm?

719
00:45:50,280 --> 00:46:00,340
And yes, that's great.

720
00:46:00,350 --> 00:46:00,780
Harrison. 

721
00:46:00,790 --> 00:46:04,820
You can use a valley bit and always set it to invalid to force a fault

722
00:46:04,830 --> 00:46:05,700
on each axis. 

723
00:46:06,270 --> 00:46:07,350
Is super slow, though.

724
00:46:08,390 --> 00:46:09,060
That's correct. 

725
00:46:09,070 --> 00:46:14,380
So the trick here is that if you do not have these bits in the hardware is

726
00:46:14,390 --> 00:46:15,220
these registers. 

727
00:46:16,790 --> 00:46:17,930
What you can do, 

728
00:46:17,940 --> 00:46:20,210
you can maintain this bit in software. 

729
00:46:22,280 --> 00:46:26,120
Now you need to find a way to modify to look at the speeds and modify them. 

730
00:46:28,280 --> 00:46:31,210
And allison is correct about how you can do it. 

731
00:46:32,190 --> 00:46:34,290
Here how you can do it in more details. 

732
00:46:35,650 --> 00:46:36,700
You can do it. 

733
00:46:37,370 --> 00:46:41,740
Also for now, let's assume we can do it using the beat only bit.

734
00:46:44,540 --> 00:46:48,880
So basically, when you we are talking about the modify bit,

735
00:46:48,890 --> 00:46:49,920
so basically, 

736
00:46:49,930 --> 00:46:54,590
what you have here is that when you read a page, 

737
00:46:55,270 --> 00:47:00,520
you market read only no matter whether is that they contain data or code. 

738
00:47:05,920 --> 00:47:12,310
And then when all of them are italy, 

739
00:47:13,030 --> 00:47:22,630
and then when you are going to access it, 

740
00:47:23,810 --> 00:47:26,230
and you want to write it, 

741
00:47:27,510 --> 00:47:32,590
then you are going to have a an exception, 

742
00:47:33,880 --> 00:47:34,070
right? 

743
00:47:34,080 --> 00:47:36,270
Because you want to write a page which is read only. 

744
00:47:36,890 --> 00:47:38,830
It's a trap in the operating system. 

745
00:47:41,470 --> 00:47:43,000
And in the operating system, 

746
00:47:43,310 --> 00:47:45,500
in the software, you maintain this modified bit.

747
00:47:47,000 --> 00:47:48,670
First time when you bring the page in, 

748
00:47:48,680 --> 00:47:51,440
you make and you make it read only. 

749
00:47:51,760 --> 00:47:54,370
You set this modified bit to zero. 

750
00:47:56,120 --> 00:47:57,120
When you write it, 

751
00:47:57,970 --> 00:48:00,410
you get an exception like we discussed, 

752
00:48:01,060 --> 00:48:02,620
traps operating system. 

753
00:48:02,930 --> 00:48:06,620
The operating system is going to measure to make the page read, right?

754
00:48:07,050 --> 00:48:08,520
And set the modified bit wrong. 

755
00:48:09,690 --> 00:48:09,860
Right? 

756
00:48:09,870 --> 00:48:11,660
Again, modified building software.

757
00:48:13,000 --> 00:48:15,270
Whenever the page is written back to the disk, 

758
00:48:16,310 --> 00:48:16,670
right? 

759
00:48:17,380 --> 00:48:20,660
You reset the modified bit to zero, 

760
00:48:20,670 --> 00:48:26,780
because now is a but you have in memory is exactly what you have on the disk. 

761
00:48:27,400 --> 00:48:28,750
And your mark, again, redundant.

762
00:48:32,410 --> 00:48:33,290
So that's pretty cool. 

763
00:48:34,600 --> 00:48:35,060
Now, 

764
00:48:35,570 --> 00:48:38,170
it turns out that actually, 

765
00:48:38,180 --> 00:48:40,010
you don't even need the use bit, 

766
00:48:41,630 --> 00:48:42,020
right? 

767
00:48:45,090 --> 00:48:46,600
Like, again, in this case,

768
00:48:46,610 --> 00:48:52,090
if you have the use between the pte you have to keep it in software. 

769
00:48:53,760 --> 00:48:59,310
So the canon is to keep it the way you do it. 

770
00:48:59,320 --> 00:49:02,190
Now, you can mark all pages as invalid,

771
00:49:02,810 --> 00:49:04,010
even if that in memory. 

772
00:49:07,370 --> 00:49:13,700
And then you set the use beat and modify beats, which are, again,

773
00:49:13,710 --> 00:49:15,260
in software you set up to zero. 

774
00:49:15,680 --> 00:49:18,100
You bring a page in. 

775
00:49:20,440 --> 00:49:22,100
And even if, 

776
00:49:23,200 --> 00:49:24,910
again, I was a biggest memory,

777
00:49:26,750 --> 00:49:31,000
you still keep the invalid bit being set for that page. 

778
00:49:32,150 --> 00:49:33,670
However, in the software,

779
00:49:34,940 --> 00:49:38,950
you keep in mind that you brought in the page, 

780
00:49:39,290 --> 00:49:43,230
you set up the beast for years and modified to zero for that page. 

781
00:49:46,660 --> 00:49:52,200
Now, any read or write to this invalid page will drop to operating system.

782
00:49:53,900 --> 00:49:54,430
Okay? 

783
00:49:55,360 --> 00:49:57,030
Now is the operating system. 

784
00:49:57,550 --> 00:50:00,270
Then it's going to set the use bit one, 

785
00:50:00,830 --> 00:50:01,730
because you access it. 

786
00:50:02,690 --> 00:50:02,940
Right? 

787
00:50:03,770 --> 00:50:04,970
And if it's a read, 

788
00:50:05,440 --> 00:50:07,830
you are going to only if it's a read, 

789
00:50:07,840 --> 00:50:13,590
you are going to set the page to read only like before to catch the future rights. 

790
00:50:14,120 --> 00:50:15,030
If right, 

791
00:50:15,610 --> 00:50:17,440
you also set the modified bit to work, 

792
00:50:17,980 --> 00:50:23,550
and you mark the page are writable when the clock hand passes and they

793
00:50:23,560 --> 00:50:24,550
would be to zero. 

794
00:50:25,840 --> 00:50:26,850
You can, again,

795
00:50:26,860 --> 00:50:27,870
mark the page, 

796
00:50:27,880 --> 00:50:31,020
you when the clock hand passes, 

797
00:50:31,380 --> 00:50:34,400
you reset the b to zero, 

798
00:50:34,410 --> 00:50:35,440
use b to zero, 

799
00:50:35,450 --> 00:50:37,520
and mark the page again as being invalid. 

800
00:50:40,280 --> 00:50:40,630
Sorry. 

801
00:50:46,960 --> 00:50:49,690
The modified bit is not, obviously,

802
00:50:51,910 --> 00:50:59,820
you are not going to right on that bit. 

803
00:50:59,830 --> 00:51:05,300
You are not going to modify the modified bit unless the page is written

804
00:51:05,310 --> 00:51:06,060
back on the disk. 

805
00:51:10,590 --> 00:51:11,380
Any questions? 

806
00:51:17,210 --> 00:51:17,970
So it's very cool. 

807
00:51:17,980 --> 00:51:25,990
So basically, the tldr here is that you can get away by not starting the

808
00:51:26,000 --> 00:51:32,630
modified and used by not having the modified and use bits in the

809
00:51:33,640 --> 00:51:35,050
page table entry. 

810
00:51:37,110 --> 00:51:38,340
Because you don't have that. 

811
00:51:38,350 --> 00:51:39,740
You need to have them somewhere. 

812
00:51:39,750 --> 00:51:42,030
So you are going to keep them in camera. 

813
00:51:44,130 --> 00:51:46,970
But now you need to modify a need to look at those speeds. 

814
00:51:48,010 --> 00:51:49,860
So you need to go to the kernel to do that. 

815
00:51:51,280 --> 00:51:52,870
In order to go to the colonel, 

816
00:51:52,880 --> 00:51:55,670
you need to force that trap to the kernel. 

817
00:51:56,440 --> 00:52:01,380
The way you do you for that trap using the other bits like invalid bits, 

818
00:52:01,930 --> 00:52:06,120
or write, only beat,

819
00:52:07,940 --> 00:52:09,090
or read, write beats,

820
00:52:09,100 --> 00:52:10,700
or writable beats. 

821
00:52:11,340 --> 00:52:13,430
In order to force that trap, 

822
00:52:14,060 --> 00:52:14,850
you force, 

823
00:52:14,860 --> 00:52:19,850
you are going to give the control to the operating system to handle

824
00:52:21,700 --> 00:52:23,280
the modified and use beats. 

825
00:52:27,100 --> 00:52:27,660
Make sense? 

826
00:52:36,410 --> 00:52:36,830
Okay? 

827
00:52:38,370 --> 00:52:41,040
Now let's talk about the second chance list algorithm. 

828
00:52:41,170 --> 00:52:42,480
It's a variation. 

829
00:52:43,700 --> 00:52:49,130
Another early sport is another approximation of our area. 

830
00:52:50,050 --> 00:52:54,910
This was implementing in backs vms you do not know about that. 

831
00:52:54,920 --> 00:52:56,390
You haven't seen it. 

832
00:52:56,400 --> 00:52:58,710
Probably maybe you're only in the museum. 

833
00:52:59,180 --> 00:53:01,280
But this is a very popular computer. 

834
00:53:01,290 --> 00:53:02,980
It was called mini computer. 

835
00:53:03,510 --> 00:53:05,940
And before the personal computers, 

836
00:53:08,710 --> 00:53:09,860
it was in 70s, 

837
00:53:10,370 --> 00:53:10,880
80s, 

838
00:53:13,910 --> 00:53:15,540
but it was vex was a very, 

839
00:53:15,550 --> 00:53:17,060
very influential computer. 

840
00:53:19,560 --> 00:53:21,670
In this case, you have two lists,

841
00:53:22,360 --> 00:53:23,510
you divided into lists. 

842
00:53:25,790 --> 00:53:31,130
And the first list is direct, 

843
00:53:31,610 --> 00:53:32,950
mapped pages. 

844
00:53:33,800 --> 00:53:36,430
And they are all marked, read, write.

845
00:53:37,870 --> 00:53:41,460
And you keep 54, 

846
00:53:41,470 --> 00:53:43,820
y 5454 is very fast, 

847
00:53:44,440 --> 00:53:44,770
right? 

848
00:53:45,090 --> 00:53:47,450
With 54 is very simple, right?

849
00:53:47,830 --> 00:53:50,860
You're one, and you bring a page in memory,

850
00:53:50,870 --> 00:53:53,740
you put it at the end of the list. 

851
00:53:54,190 --> 00:54:01,000
When also you put at the head of the list, 

852
00:54:01,250 --> 00:54:02,470
when you remove a page, 

853
00:54:02,480 --> 00:54:04,430
you remove from the end of this. 

854
00:54:07,670 --> 00:54:08,360
Very simple. 

855
00:54:09,840 --> 00:54:11,720
While things in this list are accessed, 

856
00:54:11,730 --> 00:54:13,880
you don't know how to don't do anything. 

857
00:54:16,350 --> 00:54:18,460
But then you have a second chance list. 

858
00:54:18,730 --> 00:54:22,190
And they are marketing valid and this is allergy implements allergy. 

859
00:54:24,070 --> 00:54:27,010
This is how you speak the memory have directly my page

860
00:54:27,020 --> 00:54:31,000
and the second chance list page ok so let's see how it works. 

861
00:54:32,520 --> 00:54:39,340
So if you access a page in this one of these green pages, 

862
00:54:39,350 --> 00:54:41,060
they are also called activists, 

863
00:54:41,940 --> 00:54:42,320
right? 

864
00:54:44,070 --> 00:54:45,760
Then you access it, no problem.

865
00:54:47,050 --> 00:54:49,180
If you don't access a page, 

866
00:54:49,190 --> 00:54:50,580
which is in the active list, 

867
00:54:51,600 --> 00:54:57,120
you are going to have a baseball on the page fold. 

868
00:54:57,130 --> 00:55:01,640
Always you are moving the page from the end of the activist to front

869
00:55:01,650 --> 00:55:03,280
of the second chance list. 

870
00:55:04,310 --> 00:55:05,470
And market is invalid. 

871
00:55:06,080 --> 00:55:06,270
Right? 

872
00:55:06,280 --> 00:55:06,990
This is five. 

873
00:55:11,040 --> 00:55:12,070
And then, 

874
00:55:13,370 --> 00:55:16,550
if the pages is a second chance list, 

875
00:55:18,210 --> 00:55:22,260
you move that page to the front of the activist, 

876
00:55:22,920 --> 00:55:24,180
and you market to rewrite, 

877
00:55:24,550 --> 00:55:26,560
because all the pages in the activist. 

878
00:55:26,830 --> 00:55:31,220
I read right now, 

879
00:55:31,230 --> 00:55:37,530
if the page you are looking for is not in the second chance list, 

880
00:55:42,570 --> 00:55:47,160
you page it directly in the active list as the front of the activist, 

881
00:55:47,390 --> 00:55:49,160
your market as a read, write,

882
00:55:49,850 --> 00:55:56,060
and your page out and a victim from second chance list. 

883
00:55:58,110 --> 00:55:59,310
Allah you using allah you. 

884
00:56:01,190 --> 00:56:03,490
So let's take a step back and see what happens here. 

885
00:56:05,520 --> 00:56:07,830
What happens here and why we do this. 

886
00:56:08,660 --> 00:56:13,700
It's because we I love you. 

887
00:56:13,710 --> 00:56:15,140
It's expensive to implement. 

888
00:56:15,620 --> 00:56:23,100
And obviously writing back to the disk and reading from the disco page, 

889
00:56:23,110 --> 00:56:23,970
it's also expensive. 

890
00:56:26,320 --> 00:56:26,860
So, 

891
00:56:27,670 --> 00:56:30,170
therefore, what we say, well,

892
00:56:30,640 --> 00:56:36,410
let's take a bunch of pages from memory and organize them in a 554 is

893
00:56:36,420 --> 00:56:37,210
super efficient, 

894
00:56:38,120 --> 00:56:39,270
very simple to implement. 

895
00:56:40,430 --> 00:56:42,040
But the problem is 54, obviously,

896
00:56:42,050 --> 00:56:48,780
is that I do see and is not pretty good in limiting the number of page faults. 

897
00:56:50,350 --> 00:56:51,540
And now the second thing comes, 

898
00:56:51,550 --> 00:56:53,900
they say I have page faults with five. 

899
00:56:53,910 --> 00:56:55,820
I know that i'm going to have a lot of page faults, 

900
00:56:57,060 --> 00:56:58,820
but let's make them cheap. 

901
00:57:01,180 --> 00:57:07,530
So the way you make them cheap is that with the second chance with a list, 

902
00:57:08,520 --> 00:57:13,510
and because you hope that a lot of times the page you are looking at is

903
00:57:14,350 --> 00:57:15,240
still in memory, 

904
00:57:15,250 --> 00:57:17,000
is this in the second chance list? 

905
00:57:20,270 --> 00:57:20,780
That's the key. 

906
00:57:20,790 --> 00:57:24,130
And for the second chance list, 

907
00:57:26,920 --> 00:57:28,590
you can afford to do allow you. 

908
00:57:29,010 --> 00:57:31,070
Because anyway, in order to you,

909
00:57:31,080 --> 00:57:39,030
you expect your experience are paid for to get to

910
00:57:39,040 --> 00:57:41,750
get a page from the second chance list. 

911
00:57:44,960 --> 00:57:47,160
So increase the number of page faults, 

912
00:57:48,820 --> 00:57:49,780
because you have 54, 

913
00:57:49,790 --> 00:57:53,960
and you are using only a subset of frames in this active list. 

914
00:57:56,410 --> 00:58:01,070
But you reduce the overhead of the page folds, 

915
00:58:02,300 --> 00:58:08,650
because many times the page fold will beijing at least aa base, 

916
00:58:08,660 --> 00:58:10,090
which is already in the memory? 

917
00:58:14,110 --> 00:58:14,640
Make sense? 

918
00:58:26,990 --> 00:58:30,810
Now, the interesting things to notice here and like, for instance,

919
00:58:31,530 --> 00:58:34,780
what happens if the second chance, 

920
00:58:35,670 --> 00:58:37,410
least is zero? 

921
00:58:38,420 --> 00:58:44,580
All the memory frames are allocated to the active page activist. 

922
00:58:45,680 --> 00:58:46,870
Then you have five. 

923
00:58:47,770 --> 00:58:49,050
There's a recreation policy. 

924
00:58:51,040 --> 00:58:53,750
What if activity is zero? 

925
00:58:55,170 --> 00:58:55,380
Right? 

926
00:58:55,390 --> 00:58:58,340
And you allocates everything to the second chance list, 

927
00:58:59,920 --> 00:59:01,240
then you have allergy, 

928
00:59:02,450 --> 00:59:03,390
but it's very expensive. 

929
00:59:05,340 --> 00:59:06,270
This is what it says. 

930
00:59:06,860 --> 00:59:09,760
But because you are going to page fold on every page reference, 

931
00:59:11,840 --> 00:59:14,070
you pick an intermediate value, obviously,

932
00:59:14,800 --> 00:59:21,780
in terms of how many frames you are going to have in In the activist. 

933
00:59:22,850 --> 00:59:28,980
And this theory, 

934
00:59:28,990 --> 00:59:32,990
this will reduce the number of these classes, 

935
00:59:33,000 --> 00:59:34,030
because fundamentally, 

936
00:59:34,040 --> 00:59:36,830
if you look from the.of view of the entire memory, now,

937
00:59:37,020 --> 00:59:40,930
you use alleria, not an approximation of the real approximation of alleria.

938
00:59:43,270 --> 00:59:46,780
If you are very efficient in terms of the number of disk axis is, 

939
00:59:47,650 --> 00:59:53,010
but you are going to increase the number of contact switching. 

940
00:59:53,020 --> 00:59:55,210
You are increasing the number of vessels. 

941
01:00:02,250 --> 01:00:03,720
Any question? 

942
01:00:24,580 --> 01:00:24,850
Again, 

943
01:00:24,860 --> 01:00:29,890
with aa base translation will see that you can adapt to any kind of access

944
01:00:29,900 --> 01:00:31,790
to program of

945
01:00:33,650 --> 01:00:35,860
any access patterns of the products. 

946
01:00:39,790 --> 01:00:45,660
One interesting tippy here was that when vax was originally designed, 

947
01:00:47,710 --> 01:00:54,510
the use bit was not the part of the pd

948
01:00:55,530 --> 01:00:58,020
the story that a striker, 

949
01:00:58,030 --> 01:01:02,940
the architect actually went to operating to the software people and ask them, 

950
01:01:03,690 --> 01:01:05,130
always people say, no,

951
01:01:05,140 --> 01:01:06,290
we don't need it. 

952
01:01:06,790 --> 01:01:07,960
So they didn't implement it. 

953
01:01:07,970 --> 01:01:09,180
Of course, 

954
01:01:11,890 --> 01:01:14,690
eventually, when they implemented the cash replacement policy,

955
01:01:15,260 --> 01:01:16,490
had they needed it? 

956
01:01:18,610 --> 01:01:21,800
They always use it what they did about it, of course,

957
01:01:22,200 --> 01:01:25,670
because it doesn't in the pde they have to keep it in software. 

958
01:01:25,920 --> 01:01:31,600
So they need to make sure that we get a trap to the operating system

959
01:01:31,610 --> 01:01:33,940
to the kernel in order to modify the bit, 

960
01:01:34,330 --> 01:01:36,610
like you've seen in the previous few slides. 

961
01:01:38,150 --> 01:01:40,540
And obviously, he was also not obviously,

962
01:01:40,550 --> 01:01:42,780
but he was also blamed for this omission. 

963
01:01:46,800 --> 01:01:49,080
So don't trust the operating always people. 

964
01:01:49,570 --> 01:01:52,340
That's kind of the moral of the story here. 

965
01:01:56,480 --> 01:02:02,330
The other things which didn't we alluded, 

966
01:02:02,340 --> 01:02:04,010
but we haven't discussed so far. 

967
01:02:06,740 --> 01:02:10,990
It's, in general, even a with a with the algorithm,

968
01:02:11,000 --> 01:02:12,310
with all these algorithms, 

969
01:02:12,320 --> 01:02:13,960
even in the clock algorithms. 

970
01:02:13,970 --> 01:02:18,730
In practice, you do have you maintain also free list,

971
01:02:19,790 --> 01:02:24,030
and the free list is a list of frames which are available. 

972
01:02:24,040 --> 01:02:25,950
You can allocate, they are not allocated yet.

973
01:02:27,020 --> 01:02:30,630
And so therefore, 

974
01:02:31,040 --> 01:02:37,160
if you initially and the way you do that, 

975
01:02:38,200 --> 01:02:40,760
you use it again as a sort of cash. 

976
01:02:41,560 --> 01:02:43,670
For instance, with the clock algorithm,

977
01:02:43,940 --> 01:02:45,920
when you are going to evict a page, 

978
01:02:45,930 --> 01:02:47,540
you are going to fly this, 

979
01:02:47,550 --> 01:02:50,360
ride the space to the free list. 

980
01:02:51,010 --> 01:02:52,250
Instead of writing it, 

981
01:02:52,260 --> 01:02:54,150
it directly to the disk. 

982
01:02:56,120 --> 01:02:58,680
And then in the background, 

983
01:02:59,290 --> 01:03:00,750
there is a demon, 

984
01:03:01,180 --> 01:03:06,190
which is going to look at the free list and to look at the pages which are

985
01:03:06,200 --> 01:03:07,640
dirty in the free list, 

986
01:03:08,520 --> 01:03:11,950
and then write these pages to the disk. 

987
01:03:13,150 --> 01:03:15,540
The advantage of this is that it's, again,

988
01:03:15,550 --> 01:03:19,470
it's like when I need to replace a page, 

989
01:03:19,710 --> 01:03:22,630
even if the page was modified, 

990
01:03:22,640 --> 01:03:26,540
I don't need to wait for it to be returned to the disk, 

991
01:03:27,030 --> 01:03:30,380
because it's going to be written quickly, 

992
01:03:30,730 --> 01:03:33,110
just move in another list in memory. 

993
01:03:39,360 --> 01:03:41,150
This is very similar with the wax. 

994
01:03:41,160 --> 01:03:45,430
The second chance is to just learn about any questions? 

995
01:03:57,620 --> 01:03:58,370
Obviously, 

996
01:03:59,740 --> 01:04:00,770
this high level, right?

997
01:04:00,780 --> 01:04:02,090
Is the high level pictures. 

998
01:04:02,370 --> 01:04:04,160
There are many details we haven't discussed. 

999
01:04:04,170 --> 01:04:05,680
So let's discuss a few of them. 

1000
01:04:06,480 --> 01:04:09,200
Remember that when you are going to evict the page, 

1001
01:04:09,210 --> 01:04:10,880
you need to invalidate its p ds. 

1002
01:04:12,940 --> 01:04:14,040
Because the next time, 

1003
01:04:14,050 --> 01:04:17,470
when you are going to access that page, 

1004
01:04:17,480 --> 01:04:19,680
you need to bring this page in memory. 

1005
01:04:19,690 --> 01:04:24,140
So you need to get the kernel, do that for you.

1006
01:04:24,150 --> 01:04:32,740
So it has to be a trap you need. 

1007
01:04:32,750 --> 01:04:33,940
So then for, therefore,

1008
01:04:33,950 --> 01:04:35,580
you need to keep the reverse mapping. 

1009
01:04:36,130 --> 01:04:39,040
So that when I am going to evict a page, 

1010
01:04:39,270 --> 01:04:41,880
I need to know with what is, 

1011
01:04:42,920 --> 01:04:45,680
which is its pd to invalidate. 

1012
01:04:46,400 --> 01:04:52,190
The same is true also for the tlbok so how do you do that? 

1013
01:04:53,170 --> 01:04:58,290
And there are many ways to do it. 

1014
01:05:00,180 --> 01:05:03,320
You can keep a link list of page entries. 

1015
01:05:08,620 --> 01:05:09,380
Actually, 

1016
01:05:12,450 --> 01:05:13,440
in some sense, 

1017
01:05:14,470 --> 01:05:17,470
again, there are many software solutions here.

1018
01:05:19,160 --> 01:05:21,030
But in some sense, 

1019
01:05:21,040 --> 01:05:23,390
the things one gets complicated. 

1020
01:05:24,190 --> 01:05:31,660
It's when you have shared pages across multiple processes, 

1021
01:05:32,970 --> 01:05:33,400
right? 

1022
01:05:34,170 --> 01:05:36,140
Because then remember, 

1023
01:05:36,370 --> 01:05:41,510
each process has its own virtual address space. 

1024
01:05:42,330 --> 01:05:46,840
And each process has its own page table. 

1025
01:05:47,840 --> 01:05:49,320
So there are four, 

1026
01:05:49,550 --> 01:05:52,190
if a page is shared by two processes, 

1027
01:05:53,100 --> 01:05:53,870
then, 

1028
01:05:55,150 --> 01:05:56,960
like we've seen in the last lecture, 

1029
01:05:57,560 --> 01:06:00,730
you are going to have two entries, 

1030
01:06:00,740 --> 01:06:03,650
two pt two base tables, entries,

1031
01:06:04,690 --> 01:06:04,890
right? 

1032
01:06:04,900 --> 01:06:08,250
In the base table of the two processes pointing to the same page. 

1033
01:06:09,170 --> 01:06:10,310
So you need to evaluate. 

1034
01:06:10,630 --> 01:06:12,910
They took it is when you read that page. 

1035
01:06:13,750 --> 01:06:15,930
So you need to find both of those. 

1036
01:06:16,280 --> 01:06:16,650
Right? 

1037
01:06:17,210 --> 01:06:21,840
Just keeping the simple reverse mapping is not enough, no.

1038
01:06:22,870 --> 01:06:26,810
And one way to address this problem is like, 

1039
01:06:28,180 --> 01:06:32,230
it's you can see on this slide is basically you can have a list, 

1040
01:06:33,240 --> 01:06:33,620
right? 

1041
01:06:33,630 --> 01:06:39,290
Of a page table entries for each page. 

1042
01:06:40,140 --> 01:06:42,280
If there are two or, 

1043
01:06:42,720 --> 01:06:44,000
say, four processes,

1044
01:06:44,240 --> 01:06:48,590
we share the same page. 

1045
01:06:48,840 --> 01:06:50,220
When the page is for that, 

1046
01:06:50,230 --> 01:06:52,540
then for that associated with that page, 

1047
01:06:52,850 --> 01:07:01,200
you have a linguist of the four p ds of these processes works as a page. 

1048
01:07:04,060 --> 01:07:04,770
You invite you. 

1049
01:07:04,780 --> 01:07:07,210
Now, you go back to this list and you validate everything,

1050
01:07:07,220 --> 01:07:08,010
which is the list. 

1051
01:07:11,250 --> 01:07:13,100
And there are other solutions here. 

1052
01:07:13,750 --> 01:07:14,880
Any questions? 

1053
01:07:22,680 --> 01:07:23,160
Okay? 

1054
01:07:25,180 --> 01:07:26,690
Now let's with the gears. 

1055
01:07:26,700 --> 01:07:27,930
And now we are done, 

1056
01:07:28,580 --> 01:07:33,170
in some sense, with this kind of low level pay replacement policies.

1057
01:07:34,490 --> 01:07:35,000
Now, 

1058
01:07:35,010 --> 01:07:40,120
we are talking about how the memory will be allocated across processes. 

1059
01:07:41,670 --> 01:07:42,390
But before then, 

1060
01:07:45,550 --> 01:07:46,240
any questions? 

1061
01:07:46,250 --> 01:07:53,720
So memory is resource. 

1062
01:07:54,110 --> 01:07:56,660
It's like very much like the cpo right? 

1063
01:07:57,020 --> 01:08:02,830
And we are talking about all these policies or scheduling policies, 

1064
01:08:02,840 --> 01:08:06,540
which page replacement policies, 

1065
01:08:06,550 --> 01:08:10,280
because the resources are oversubscribed. 

1066
01:08:11,010 --> 01:08:13,330
If the resource is not a versus oversubscribed, 

1067
01:08:13,980 --> 01:08:15,010
we don't need to do anything. 

1068
01:08:15,950 --> 01:08:17,100
We have enough for everyone. 

1069
01:08:19,440 --> 01:08:19,790
Right? 

1070
01:08:20,120 --> 01:08:25,880
We've seen all these scheduling algorithms about how to allocate the cpu

1071
01:08:25,890 --> 01:08:28,280
to across multiple processes threads, 

1072
01:08:28,530 --> 01:08:29,870
in a fair manner, 

1073
01:08:30,520 --> 01:08:33,330
whatever you can imagine. 

1074
01:08:34,340 --> 01:08:37,180
We have the same problems to solve. 

1075
01:08:37,190 --> 01:08:40,100
We have the same problems to solve in the case of the memory as well. 

1076
01:08:40,900 --> 01:08:41,260
Right? 

1077
01:08:43,290 --> 01:08:45,020
The same questions, right?

1078
01:08:45,400 --> 01:08:49,300
If you have multiple processes competing for the physical memory, 

1079
01:08:50,560 --> 01:08:52,880
how you are going to allocate the memory across processes, 

1080
01:08:54,610 --> 01:08:55,990
you are going to allocate fairly, 

1081
01:08:56,790 --> 01:08:57,200
right. 

1082
01:08:58,510 --> 01:08:59,880
The same number of pages. 

1083
01:09:00,670 --> 01:09:01,160
Also, 

1084
01:09:01,170 --> 01:09:04,440
we need to keep in mind that each process needs a minimum number of pages

1085
01:09:04,450 --> 01:09:04,960
to work. 

1086
01:09:05,790 --> 01:09:10,360
We cannot work without having a certain number of pages in memory. 

1087
01:09:14,240 --> 01:09:16,900
So, like, for instance, is one case.

1088
01:09:17,210 --> 01:09:20,210
This is ibm 370, 370,

1089
01:09:21,170 --> 01:09:23,130
which for one instruction, 

1090
01:09:24,280 --> 01:09:28,810
you can need a up to 6 pages to be in memory. 

1091
01:09:30,560 --> 01:09:37,560
And this was an instruction to move a bunch of bytes from one location to another. 

1092
01:09:38,770 --> 01:09:40,740
First, the instruction is 6 bytes,

1093
01:09:41,230 --> 01:09:42,740
my span 2 pages. 

1094
01:09:46,750 --> 01:09:51,350
And then you can have

1095
01:09:56,480 --> 01:10:02,800
you can have the region spanning the source region from oriental copy, 

1096
01:10:03,070 --> 01:10:09,010
can span2 pages and the destination where you want to copy that

1097
01:10:09,310 --> 01:10:10,940
data also can spend the pages, 

1098
01:10:10,950 --> 01:10:12,440
so 6 pages in total. 

1099
01:10:13,030 --> 01:10:13,350
Right? 

1100
01:10:15,100 --> 01:10:18,330
And the other things is again, 

1101
01:10:18,340 --> 01:10:22,220
but here is the only the difference. 

1102
01:10:22,230 --> 01:10:29,950
And you have to appreciate that the difference between the cpu and memory

1103
01:10:30,510 --> 01:10:35,610
is that with cpu actually, 

1104
01:10:38,650 --> 01:10:41,560
it's more fungible that I disappear is more fungible. 

1105
01:10:42,250 --> 01:10:43,070
It's memorabulous. 

1106
01:10:43,080 --> 01:10:44,150
In some sense. 

1107
01:10:44,160 --> 01:10:49,250
It's like, I am going to decide when squad processed the squad to schedule.

1108
01:10:49,260 --> 01:10:51,430
I am going to schedule it. 

1109
01:10:52,300 --> 01:10:55,370
Every time start, i'm going to pick an another process, right?

1110
01:10:55,720 --> 01:10:58,830
Every times it's, when I say,

1111
01:10:59,160 --> 01:11:02,150
is stateless, is that because every time quanta,

1112
01:11:02,510 --> 01:11:05,380
I can pick another process to schedule. 

1113
01:11:06,700 --> 01:11:07,580
But here, 

1114
01:11:08,520 --> 01:11:09,630
i'm not going, 

1115
01:11:11,320 --> 01:11:12,640
i'm going to start. 

1116
01:11:12,930 --> 01:11:19,730
The decision is not what for which process to bring a page in. 

1117
01:11:19,930 --> 01:11:22,980
It's only the memory is full with pages from all the processes. 

1118
01:11:22,990 --> 01:11:25,060
I have to decide which page to evict, 

1119
01:11:25,620 --> 01:11:25,900
right? 

1120
01:11:26,500 --> 01:11:28,680
Which it's more difficult. 

1121
01:11:29,600 --> 01:11:33,250
And eviction policy can be global, 

1122
01:11:33,500 --> 01:11:36,730
meaning that when I am going to pick up page to evict, 

1123
01:11:36,740 --> 01:11:41,540
i'm going to look at all across all the process of all the biggest memory. 

1124
01:11:41,940 --> 01:11:44,570
Or another way to think about it can be lock off. 

1125
01:11:44,880 --> 01:11:47,070
When i'm going to decide which space to evict, 

1126
01:11:47,540 --> 01:11:52,710
I am going to look only a more across the pages of the process, 

1127
01:11:53,090 --> 01:11:54,130
which calls a page one. 

1128
01:11:55,070 --> 01:11:58,810
I'm going to bring a page from the disk for the new for a process. 

1129
01:11:59,320 --> 01:12:02,360
And i'm going to evict a page from that's the same process. 

1130
01:12:04,450 --> 01:12:08,430
Here are a few policies which are kind of obvious equal allocation. 

1131
01:12:08,720 --> 01:12:11,300
One way to say it is to be super fair. 

1132
01:12:11,630 --> 01:12:15,530
You just divide static is a memory across processes. 

1133
01:12:15,990 --> 01:12:17,230
You have five processes, 

1134
01:12:17,240 --> 01:12:18,750
you have 100 frames, 

1135
01:12:19,000 --> 01:12:21,310
then each process gets turned different period, 

1136
01:12:22,020 --> 01:12:22,270
right? 

1137
01:12:22,280 --> 01:12:24,560
Or you can have a proportional location, 

1138
01:12:24,570 --> 01:12:28,140
also fixed scheme in which you have a weight. 

1139
01:12:28,400 --> 01:12:31,930
And you are going to allocate the memory according to that weight. 

1140
01:12:32,980 --> 01:12:35,060
Now, what is the problem with a fixed allocation?

1141
01:12:35,780 --> 01:12:38,910
Can someone tell me what is the problem with these fixed allocations? 

1142
01:12:57,840 --> 01:13:00,110
These are very good question, very good answers,

1143
01:13:00,120 --> 01:13:01,190
michael and allison. 

1144
01:13:01,200 --> 01:13:08,070
So one problem is that if a process requires more less than its allocation, 

1145
01:13:09,180 --> 01:13:11,330
then memory is wasted. 

1146
01:13:13,130 --> 01:13:18,410
The other thing is that what happens when a new process is created? 

1147
01:13:19,500 --> 01:13:19,920
Okay? 

1148
01:13:20,810 --> 01:13:24,960
Then you need to redistribute all these pages across the processes. 

1149
01:13:27,880 --> 01:13:29,370
Then it's a priority allocation. 

1150
01:13:29,960 --> 01:13:31,130
You can use a priority, 

1151
01:13:31,140 --> 01:13:34,320
and you can assign priority to each part to each processes. 

1152
01:13:35,430 --> 01:13:38,290
You can use the same priority which areas for scheduling. 

1153
01:13:38,600 --> 01:13:43,320
And then when you need to decide which space to evict space to evict, 

1154
01:13:43,330 --> 01:13:48,750
you are going to evict a page from the process with a lower product, 

1155
01:13:50,610 --> 01:13:53,130
or you can use any adaptive skills. 

1156
01:13:55,100 --> 01:13:59,270
Another way to think it is about a frequency allocation. 

1157
01:13:59,770 --> 01:14:01,360
Basically, here you think about,

1158
01:14:01,370 --> 01:14:05,270
I want everyone to kind of get the same performance. 

1159
01:14:06,010 --> 01:14:10,860
The performance is dictated by the frequency of the page faults, 

1160
01:14:11,120 --> 01:14:16,330
1 kind of to equalize the page faults that each process experience a frequency. 

1161
01:14:17,670 --> 01:14:19,100
In this particular case, 

1162
01:14:22,080 --> 01:14:25,260
you can look at to have some thresholds. 

1163
01:14:25,840 --> 01:14:30,030
And if a if a process, 

1164
01:14:30,330 --> 01:14:34,440
the number of frequencies of the page faults is lower than the slower bound, 

1165
01:14:34,960 --> 01:14:39,530
then you are going to evict pages from this process. 

1166
01:14:39,540 --> 01:14:43,300
We are going to reduce the number of pages allocated to this process. 

1167
01:14:44,300 --> 01:14:49,830
If the number of baseballs for the process exceed another threshold, 

1168
01:14:50,300 --> 01:14:54,860
then you have too many page faults. 

1169
01:14:55,080 --> 01:14:59,940
You are going to allocate more pages to this process. 

1170
01:15:02,390 --> 01:15:03,450
So that's what you can go. 

1171
01:15:04,710 --> 01:15:08,380
And but still, 

1172
01:15:08,390 --> 01:15:10,300
no matter what you are talking about here, 

1173
01:15:10,930 --> 01:15:14,330
there can be still cases in which you don't have enough memory. 

1174
01:15:15,030 --> 01:15:16,740
When you don't have enough memories, 

1175
01:15:16,750 --> 01:15:19,780
what happens is kind of trash and trashing. 

1176
01:15:19,790 --> 01:15:22,570
You can actually identify that in a simpler way. 

1177
01:15:22,580 --> 01:15:29,260
You see a lot of io activity and the cpu very little utilization. 

1178
01:15:29,530 --> 01:15:34,580
Because trashing meaning that you have a very high number of base falls. 

1179
01:15:35,220 --> 01:15:36,310
The program, 

1180
01:15:36,750 --> 01:15:43,690
or the processes spend most of their time page folding than doing useful work. 

1181
01:15:44,680 --> 01:15:45,690
And in that case, 

1182
01:15:45,700 --> 01:15:47,250
no one is making progress. 

1183
01:15:47,720 --> 01:15:49,130
So what is a solution here? 

1184
01:15:49,840 --> 01:15:50,310
Right? 

1185
01:15:53,450 --> 01:15:56,580
By the way, how we do take the trashing is very simple, right?

1186
01:15:56,590 --> 01:15:58,140
It's like I mentioned to you, right?

1187
01:15:58,150 --> 01:16:02,110
It's like you have a lot of io activity, 

1188
01:16:02,120 --> 01:16:05,120
and the securitization is basically zero, right?

1189
01:16:06,550 --> 01:16:07,690
What you can do here, 

1190
01:16:13,190 --> 01:16:14,480
no one is making progress. 

1191
01:16:15,400 --> 01:16:26,030
So what you can do, well,

1192
01:16:26,360 --> 01:16:34,190
one simple solution you can do is to suspend one process or killer process. 

1193
01:16:38,100 --> 01:16:38,680
Very good. 

1194
01:16:40,490 --> 01:16:42,480
We went over this last time. 

1195
01:16:43,130 --> 01:16:46,480
You remember that we have a similar plot here, 

1196
01:16:46,490 --> 01:16:53,400
and this represent the access pattern of a program of a process over time. 

1197
01:16:55,030 --> 01:16:57,980
On the y axis, you have the page number on the x axis.

1198
01:16:57,990 --> 01:16:58,940
You have the time. 

1199
01:16:59,200 --> 01:17:03,250
And you have a dot at every position where you have an access

1200
01:17:03,600 --> 01:17:08,090
to a particular page offset at a particular time. 

1201
01:17:08,800 --> 01:17:09,160
Right? 

1202
01:17:09,470 --> 01:17:11,020
So that's kind of what you have here. 

1203
01:17:12,650 --> 01:17:18,490
And it's again, when the program executes at different times,

1204
01:17:18,500 --> 01:17:22,170
you are going to access different location in memory. 

1205
01:17:23,320 --> 01:17:25,680
And the group of pages, 

1206
01:17:25,690 --> 01:17:28,440
which are accessed together at a given time, 

1207
01:17:28,450 --> 01:17:31,560
as they are called working sets, right?

1208
01:17:31,990 --> 01:17:36,340
The working set defines a minimal number of pages that a process

1209
01:17:36,350 --> 01:17:40,420
have to have in memory in order to work well. 

1210
01:17:40,740 --> 01:17:44,540
So do not spend his time too much time in page folding. 

1211
01:17:45,320 --> 01:17:45,810
Okay? 

1212
01:17:46,500 --> 01:17:54,710
Therefore, this means that if you do not have enough space in memory to

1213
01:17:55,070 --> 01:17:58,040
accommodate the working sets of all the active processes, 

1214
01:17:58,880 --> 01:18:00,910
then you have a problem. 

1215
01:18:01,670 --> 01:18:05,380
The solution like we discuss is to swap out a process. 

1216
01:18:06,210 --> 01:18:06,320
Now, 

1217
01:18:06,330 --> 01:18:10,280
how you define the working set when you design a group of pages access

1218
01:18:10,290 --> 01:18:11,400
at the same time, 

1219
01:18:11,630 --> 01:18:13,450
we need to define the same time. 

1220
01:18:13,460 --> 01:18:16,130
And typically, this is a time interval.

1221
01:18:16,510 --> 01:18:18,540
So basically, look at the current time,

1222
01:18:18,550 --> 01:18:23,260
and you are looking in the past for some time interval about all the active, 

1223
01:18:23,270 --> 01:18:26,500
all the pages which are access during that interval. 

1224
01:18:26,710 --> 01:18:28,510
And this is what you call the working set. 

1225
01:18:29,120 --> 01:18:29,500
Okay? 

1226
01:18:29,930 --> 01:18:30,250
Obviously, 

1227
01:18:30,260 --> 01:18:35,860
about how long is the interval which is also called working set window, 

1228
01:18:36,100 --> 01:18:40,670
is that it's a good question, 

1229
01:18:41,040 --> 01:18:43,780
but you need to take a good, 

1230
01:18:44,270 --> 01:18:46,470
because if it's too long, 

1231
01:18:46,860 --> 01:18:51,740
then it's encompasses all the pages ever access by the program. 

1232
01:18:52,320 --> 01:18:52,780
Right? 

1233
01:18:53,020 --> 01:18:54,450
So that's not good. 

1234
01:18:54,460 --> 01:18:59,370
If it's too little is going to encompass only the most recent pages. 

1235
01:18:59,380 --> 01:19:02,290
And you are going to miss made me as of many other pages. 

1236
01:19:02,300 --> 01:19:10,070
It should be accessed a very in engineer in the near future. 

1237
01:19:10,610 --> 01:19:10,920
Right? 

1238
01:19:11,730 --> 01:19:13,100
So you miss the locality. 

1239
01:19:15,580 --> 01:19:18,240
But anyway, so once you set up this window,

1240
01:19:18,250 --> 01:19:20,360
now you can define the working set. 

1241
01:19:21,290 --> 01:19:26,900
Then the simple thing is that the sum of the working set of all programs, 

1242
01:19:27,860 --> 01:19:28,410
let's say, 

1243
01:19:29,460 --> 01:19:33,290
if is defined by d and if d is greater, 

1244
01:19:33,710 --> 01:19:35,880
then the memory size you have trashing. 

1245
01:19:38,840 --> 01:19:41,590
If d is less than the memory size, you are fine.

1246
01:19:44,130 --> 01:19:51,330
This is the last slide I'm going to make about, like we dis.

1247
01:19:51,340 --> 01:19:58,020
We remember that only discussed about this page replacement policies. 

1248
01:19:58,270 --> 01:19:59,780
And about these examples, always,

1249
01:19:59,790 --> 01:20:01,100
we are going to, 

1250
01:20:01,110 --> 01:20:02,750
we started these compulsory misses, 

1251
01:20:03,470 --> 01:20:03,770
right? 

1252
01:20:04,240 --> 01:20:05,330
And obviously, 

1253
01:20:05,830 --> 01:20:09,250
compulsory misses are unavoidable in some sets. 

1254
01:20:09,580 --> 01:20:11,360
But the question, can you do it better?

1255
01:20:12,120 --> 01:20:15,070
The answer you can do it better. 

1256
01:20:15,960 --> 01:20:19,070
Like, for instance, for clustering the pages,

1257
01:20:19,460 --> 01:20:20,690
when a page fault, 

1258
01:20:20,890 --> 01:20:24,370
you do not think only 1 page in memory. 

1259
01:20:24,630 --> 01:20:27,690
You are bringing a set of pages as consecutive pages. 

1260
01:20:28,010 --> 01:20:29,560
Because if you assume locality, 

1261
01:20:29,570 --> 01:20:31,700
assume that if you ask, 

1262
01:20:32,270 --> 01:20:35,070
say, instructions is in the current page,

1263
01:20:35,080 --> 01:20:38,390
you are also is likely to access instruction in the next page. 

1264
01:20:38,400 --> 01:20:45,910
So you are mortar is the cost of of baseballs by bringing more pages in memory. 

1265
01:20:46,480 --> 01:20:46,900
Right? 

1266
01:20:47,460 --> 01:20:50,290
And the same things about the working set. 

1267
01:20:50,710 --> 01:20:54,590
If you're now kind of the working set and you have some knowledge

1268
01:20:54,600 --> 01:20:55,550
about the locality, 

1269
01:20:58,150 --> 01:21:00,240
you can try to, 

1270
01:21:00,890 --> 01:21:03,320
for instance, when you stop a process on the disk,

1271
01:21:03,630 --> 01:21:04,900
your swap is working set. 

1272
01:21:04,910 --> 01:21:06,660
And when you bring the process in, 

1273
01:21:06,670 --> 01:21:07,940
you bring its working set, 

1274
01:21:07,950 --> 01:21:09,380
all the biggest in the working set, 

1275
01:21:10,250 --> 01:21:12,040
we are going to stop here. 

1276
01:21:12,290 --> 01:21:13,680
And thank you very much. 

1277
01:21:13,690 --> 01:21:16,640
And let me know if you have any other questions. 

