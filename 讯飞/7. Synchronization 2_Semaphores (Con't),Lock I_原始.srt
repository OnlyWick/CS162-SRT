1
00:00:08,920 --> 00:00:09,850
Hello, everyone.

2
00:00:10,420 --> 00:00:12,890
Welcome to the seven lectures. 

3
00:00:12,900 --> 00:00:17,290
So today we are going to continue our discussion about concurrency. 

4
00:00:18,250 --> 00:00:24,220
This will happen also over the next couple of lectures, 

5
00:00:24,880 --> 00:00:29,210
as well as we are going to discuss about lock implementation, 

6
00:00:29,220 --> 00:00:35,840
which is one of the main primitives helping us or is controlling concurrence. 

7
00:00:40,280 --> 00:00:41,650
Remember about, again,

8
00:00:41,660 --> 00:00:42,750
this picture. 

9
00:00:43,250 --> 00:00:43,660
Excuse me, 

10
00:00:47,870 --> 00:00:50,420
it's basically we are going to have a program. 

11
00:00:50,430 --> 00:00:56,550
And here what we are trying to do is about it's how this program we

12
00:00:57,590 --> 00:00:58,860
is going to give, 

13
00:01:00,650 --> 00:01:02,210
yield the axis, 

14
00:01:02,220 --> 00:01:04,610
the cpu to another product. 

15
00:01:04,620 --> 00:01:04,830
Right? 

16
00:01:04,840 --> 00:01:06,590
If you remember, this was the old examples.

17
00:01:07,040 --> 00:01:08,900
Each one of the first examples, 

18
00:01:09,110 --> 00:01:10,420
you have two instructions. 

19
00:01:10,430 --> 00:01:11,540
The first one, 

20
00:01:12,250 --> 00:01:15,880
trying to print to compute pie and print pie. 

21
00:01:16,380 --> 00:01:20,220
Then the second instruction trying to bring the class list, 

22
00:01:20,230 --> 00:01:21,620
if I remember correctly. 

23
00:01:21,970 --> 00:01:27,340
And the point there is that if you try to print by, 

24
00:01:27,390 --> 00:01:31,380
which means also need to compute all the digits, 

25
00:01:31,630 --> 00:01:32,720
you'll never end, 

26
00:01:32,950 --> 00:01:38,220
because spy has an infinite number of decimals, right?

27
00:01:38,830 --> 00:01:42,780
Then the solution was that while you are computing by, 

28
00:01:42,790 --> 00:01:45,900
you are the one to give from a time to time, 

29
00:01:46,350 --> 00:01:51,540
access to the cpu to another process to continue other. 

30
00:01:51,550 --> 00:01:57,770
Otherwise, the cpu will be only hauled by this computer by program.

31
00:01:57,780 --> 00:01:58,610
Now yield. 

32
00:01:58,870 --> 00:02:01,360
It's a system call and the system call. 

33
00:02:02,810 --> 00:02:05,640
It's going to result in a trap to the kernel. 

34
00:02:05,960 --> 00:02:10,660
And the kernel will then take over. 

35
00:02:10,670 --> 00:02:16,780
And it will suspend the current program thread. 

36
00:02:17,200 --> 00:02:19,660
And that on the new one, 

37
00:02:21,170 --> 00:02:23,080
this is a pseudo code, very simple.

38
00:02:23,090 --> 00:02:26,160
So this kind of you see that on your thread, 

39
00:02:26,310 --> 00:02:29,670
this is what is a function run by the kernel, 

40
00:02:31,100 --> 00:02:35,520
which basically picks a new thread and switch from the current thread, 

41
00:02:35,730 --> 00:02:37,540
which is in blue here to the new stretch, 

42
00:02:37,980 --> 00:02:42,530
and is doing some housekeeping and some clean up. 

43
00:02:42,870 --> 00:02:44,560
When he's going to do this, 

44
00:02:45,130 --> 00:02:47,840
update some counters at the time, 

45
00:02:48,070 --> 00:02:49,080
as a for instance, 

46
00:02:49,090 --> 00:02:51,110
a thread run and things like that. 

47
00:02:53,610 --> 00:02:55,810
Now the question, obviously, the key is like,

48
00:02:56,420 --> 00:02:58,490
there are two things we want to understand. 

49
00:02:58,500 --> 00:03:02,000
It's like how to pick any thread and how you are going to switch

50
00:03:02,010 --> 00:03:03,720
from the current thread to the new thread. 

51
00:03:08,630 --> 00:03:11,300
And if you remember, obviously,

52
00:03:11,310 --> 00:03:12,900
in order to do that, 

53
00:03:13,120 --> 00:03:16,110
we need to save the state of the current thread. 

54
00:03:16,430 --> 00:03:20,980
And then to initialize the registers of the processor, 

55
00:03:20,990 --> 00:03:22,300
the bc counter, 

56
00:03:22,550 --> 00:03:25,300
with the values, with the state of the new thread,

57
00:03:25,310 --> 00:03:27,040
and then execute that new thread. 

58
00:03:30,070 --> 00:03:30,480
Okay? 

59
00:03:31,930 --> 00:03:38,600
One of these111 important part of the state of a thread, if you remember,

60
00:03:38,780 --> 00:03:40,060
is a stack, right?

61
00:03:40,900 --> 00:03:45,610
And let's look a little bit more into more details about these four simple examples. 

62
00:03:46,140 --> 00:03:48,890
If you are going to have two functions, 

63
00:03:49,160 --> 00:03:55,030
a and ba calls b and b is that executive look. 

64
00:03:55,410 --> 00:03:58,590
Within that loop, you yield every time you execute the loop.

65
00:03:59,100 --> 00:03:59,470
Right? 

66
00:03:59,890 --> 00:04:02,810
And suppose that we have two threads, 

67
00:04:02,820 --> 00:04:07,080
s and d and running this program. 

68
00:04:08,860 --> 00:04:11,020
Both of them run this program. 

69
00:04:11,440 --> 00:04:12,800
Thread as right, 

70
00:04:12,810 --> 00:04:14,960
is called function a here. 

71
00:04:15,330 --> 00:04:16,320
This is on the stack. 

72
00:04:16,330 --> 00:04:21,240
You remember that the stack grows from the high addresses to the lower addresses. 

73
00:04:21,700 --> 00:04:22,800
On the stack, 

74
00:04:22,810 --> 00:04:29,850
you are going to have the return values as a return address after executive

75
00:04:30,160 --> 00:04:31,030
to the function, 

76
00:04:31,470 --> 00:04:32,310
as well. 

77
00:04:32,320 --> 00:04:33,510
As when you call a function, 

78
00:04:33,520 --> 00:04:35,230
you are going to put on the stack, 

79
00:04:35,480 --> 00:04:37,470
the argument for that function. 

80
00:04:38,260 --> 00:04:39,690
Here there are no arguments, 

81
00:04:39,980 --> 00:04:42,010
but that happens, in general, right?

82
00:04:42,100 --> 00:04:44,970
You have a first which you call you put on the stack, 

83
00:04:45,230 --> 00:04:49,180
then b and this is a one which execute a while loop, 

84
00:04:49,190 --> 00:04:53,380
and then is going to execute and run yield. 

85
00:04:54,270 --> 00:04:56,260
And then, 

86
00:04:57,380 --> 00:04:57,810
again, 

87
00:04:57,820 --> 00:05:04,580
yield is going to to call the operating system and the operating system. 

88
00:05:05,990 --> 00:05:12,570
It's going to execute the run new thread and switch to the new thread. 

89
00:05:12,990 --> 00:05:16,510
And when you switch is going to run the other thread feel. 

90
00:05:16,520 --> 00:05:18,670
He said that we have to thread in the system, right?

91
00:05:19,030 --> 00:05:19,760
And the threes, 

92
00:05:20,410 --> 00:05:23,600
the new thread will basically they could the same thing. 

93
00:05:24,030 --> 00:05:32,870
And the example is going to execute a and b and b whenever it's going to execute. 

94
00:05:32,880 --> 00:05:35,400
So while is going to yield, 

95
00:05:35,700 --> 00:05:38,300
go again, you go to the operating system,

96
00:05:38,310 --> 00:05:42,100
and then your ping pong between the two threats. 

97
00:05:42,110 --> 00:05:42,350
Okay? 

98
00:05:42,520 --> 00:05:43,380
This is what we have. 

99
00:05:44,180 --> 00:05:44,560
Okay? 

100
00:05:45,020 --> 00:05:46,330
Now, it's, again,

101
00:05:46,340 --> 00:05:50,210
like one thing we need to do in when you are going to switch

102
00:05:50,220 --> 00:05:54,000
from the current strategies and you thread is we need to

103
00:05:55,120 --> 00:05:57,660
save the state of the current stretch, 

104
00:05:57,670 --> 00:05:58,220
right? 

105
00:05:58,810 --> 00:05:59,560
What does it mean? 

106
00:05:59,570 --> 00:06:01,320
This is that registers. 

107
00:06:01,330 --> 00:06:04,080
You see, r zero to r seven is that registers.

108
00:06:04,880 --> 00:06:07,430
And then sp is a stack pointer. 

109
00:06:07,700 --> 00:06:11,210
And cpu is a return, a pointer.

110
00:06:11,380 --> 00:06:16,960
This is the pointer of the next instruction we should be executed when I

111
00:06:16,970 --> 00:06:20,600
am going to resume the execution of this thread. 

112
00:06:21,070 --> 00:06:21,430
Okay? 

113
00:06:22,790 --> 00:06:26,540
Now the next thing we need to now to take care of the new thread, 

114
00:06:26,960 --> 00:06:32,410
we are going to update the register of the processor, 

115
00:06:33,300 --> 00:06:34,370
the stack pointers, 

116
00:06:34,380 --> 00:06:36,650
npc with a new. 

117
00:06:37,270 --> 00:06:44,280
We started a with a state corresponding state of the new of the new thread

118
00:06:44,290 --> 00:06:45,080
we want to run. 

119
00:06:45,090 --> 00:06:46,160
And by the way, 

120
00:06:46,170 --> 00:06:49,680
you see where this state it's stored, what is stored.

121
00:06:49,690 --> 00:06:52,330
It's in dcb it's thread control block. 

122
00:06:55,030 --> 00:06:56,460
I hope this kind of makes sense, 

123
00:06:56,470 --> 00:06:58,020
and this will be pretty simple. 

124
00:06:58,370 --> 00:06:58,820
Right? 

125
00:06:59,010 --> 00:07:01,820
Now, obviously, you need to be careful and implement that.

126
00:07:02,180 --> 00:07:04,350
And by the way, if you have any questions,

127
00:07:04,660 --> 00:07:07,740
let me know i'll be happy to answer as always. 

128
00:07:09,320 --> 00:07:12,350
So you need to be very careful, right?

129
00:07:12,360 --> 00:07:13,270
I for instance, 

130
00:07:13,840 --> 00:07:18,490
if you forget to save or store a particular register, say,

131
00:07:19,380 --> 00:07:21,210
and register study too, 

132
00:07:21,220 --> 00:07:23,210
then what will happen? 

133
00:07:23,220 --> 00:07:23,690
Right? 

134
00:07:24,140 --> 00:07:25,610
Something that happened, 

135
00:07:27,730 --> 00:07:29,040
what happens? 

136
00:07:29,250 --> 00:07:33,370
It will very much depend about whether the value is that register

137
00:07:33,380 --> 00:07:36,010
is going to be used by the program. 

138
00:07:36,020 --> 00:07:37,450
If it's not going to be used, 

139
00:07:38,040 --> 00:07:38,830
nothing will happen. 

140
00:07:38,840 --> 00:07:39,990
But if it's going to be used, 

141
00:07:40,000 --> 00:07:44,630
you are going to see probably a random is a random results or random failures. 

142
00:07:49,530 --> 00:07:54,840
You will say, why wouldn't you then start?

143
00:07:56,080 --> 00:07:58,350
You test carefully the entire code? 

144
00:07:59,370 --> 00:08:01,200
Is that testing the entire code, 

145
00:08:01,210 --> 00:08:04,880
especially passing its exhaustively? 

146
00:08:05,130 --> 00:08:08,080
It's very difficult because there are many combinations. 

147
00:08:08,090 --> 00:08:09,940
Why is there are many combinations? 

148
00:08:10,610 --> 00:08:15,720
There are many combinations because you a thread can be interrupted anywhere. 

149
00:08:17,910 --> 00:08:19,100
So if you have a thread, 

150
00:08:19,110 --> 00:08:23,770
which is you have 1,000 instructions, 

151
00:08:23,970 --> 00:08:26,750
it can be interrupted after each of these instructions. 

152
00:08:27,260 --> 00:08:27,660
Right? 

153
00:08:28,600 --> 00:08:31,590
You have another strategy and other ones of the instructions. 

154
00:08:31,870 --> 00:08:35,060
Now you have combination about where you are going to interrupt the first thread, 

155
00:08:35,070 --> 00:08:37,940
and we are going to resume the second thread like 1 million. 

156
00:08:38,500 --> 00:08:38,910
Right? 

157
00:08:40,280 --> 00:08:44,560
There are many stories about errors. 

158
00:08:45,020 --> 00:08:48,000
In some cases, you are found after a long time,

159
00:08:48,250 --> 00:08:49,910
like, for instance, in this case,

160
00:08:50,730 --> 00:08:53,400
it was aa very early kernel top, 

161
00:08:53,410 --> 00:08:54,480
as you can see, 

162
00:08:54,490 --> 00:08:56,440
based on the sale on the size. 

163
00:08:56,950 --> 00:09:00,810
It was obviously very well tested. 

164
00:09:01,080 --> 00:09:03,280
But it was one thing. 

165
00:09:05,480 --> 00:09:10,030
What happened is that it was one instruction, 

166
00:09:10,040 --> 00:09:15,200
one correctly saving the state of a thread, 

167
00:09:15,210 --> 00:09:20,260
depending of whether the kernel size was less than one megabyte, 

168
00:09:20,620 --> 00:09:22,770
initially was the less than one megabyte, right?

169
00:09:22,780 --> 00:09:25,370
But over time, like with any software,

170
00:09:25,380 --> 00:09:26,490
the size increased. 

171
00:09:26,790 --> 00:09:30,820
And people are developers forgot about this limitation. 

172
00:09:31,120 --> 00:09:35,750
And when it did happen and the size increase overall megabyte, 

173
00:09:36,060 --> 00:09:40,730
then they start to get superiors errors. 

174
00:09:43,520 --> 00:09:45,390
This kind of like we'll discuss, 

175
00:09:45,400 --> 00:09:50,090
this kind of errors are also very hard to to the back, 

176
00:09:50,330 --> 00:09:51,750
because they are not deterministic. 

177
00:09:53,460 --> 00:09:56,290
Be honest again, like when you design be very,

178
00:09:56,300 --> 00:09:59,090
very careful design, for simplicity, simple code,

179
00:09:59,300 --> 00:10:02,690
it's easier to check than more complex code and all. 

180
00:10:07,260 --> 00:10:07,840
Now, 

181
00:10:09,410 --> 00:10:14,760
one of the question is about we are switching between when are switching

182
00:10:14,770 --> 00:10:15,990
between two threads. 

183
00:10:16,370 --> 00:10:18,470
We are also switching. 

184
00:10:19,560 --> 00:10:20,910
It's compact switching. 

185
00:10:22,890 --> 00:10:26,910
We also refer as contact switching when you are switching between two processes. 

186
00:10:27,550 --> 00:10:28,050
Okay. 

187
00:10:29,470 --> 00:10:29,780
Now, 

188
00:10:30,870 --> 00:10:32,700
and this, again, we discuss this in the past,

189
00:10:32,710 --> 00:10:35,620
but let me repeat because it's a very important aspect. 

190
00:10:38,510 --> 00:10:40,300
When you do process switching, 

191
00:10:40,310 --> 00:10:42,140
when you switch between two processes, 

192
00:10:42,520 --> 00:10:45,240
which means that the boat at the end of the day, 

193
00:10:45,250 --> 00:10:47,990
because you are switching between two threads in a different processes

194
00:10:49,190 --> 00:10:51,800
that sewage is much more expensive. 

195
00:10:52,270 --> 00:10:52,790
Okay? 

196
00:10:53,430 --> 00:10:58,360
The reason that switch is much more expensive is simply because the state

197
00:10:58,610 --> 00:11:01,410
associated with the process is much larger. 

198
00:11:01,890 --> 00:11:02,290
Right? 

199
00:11:02,570 --> 00:11:06,540
You need, again, the process is also on another space, right?

200
00:11:07,010 --> 00:11:09,160
It's also on the file descriptors. 

201
00:11:09,410 --> 00:11:09,850
Okay? 

202
00:11:11,440 --> 00:11:12,390
Fundamentally, 

203
00:11:12,400 --> 00:11:16,270
it's a lot of more things you need to do when you switch a context versus

204
00:11:16,280 --> 00:11:17,150
switching a threat. 

205
00:11:19,070 --> 00:11:20,100
These are the numbers. 

206
00:11:20,110 --> 00:11:22,220
Actually, the frequency context,

207
00:11:22,230 --> 00:11:26,540
the switching between processes can take between, 

208
00:11:26,550 --> 00:11:29,060
in this case, for these numbers, again,

209
00:11:29,070 --> 00:11:30,420
depends on the implementation, 

210
00:11:30,430 --> 00:11:31,500
depends on the hardware. 

211
00:11:31,950 --> 00:11:34,100
Take these numbers, a great grain of salt.

212
00:11:34,110 --> 00:11:39,250
They are only supposed to give you the relative a sense about the relative difference. 

213
00:11:39,730 --> 00:11:41,240
When you see between processes, 

214
00:11:41,250 --> 00:11:44,000
it can be like between 3 and 4 micro seconds. 

215
00:11:44,010 --> 00:11:47,000
When you see between two studies only 100 and a second. 

216
00:11:47,450 --> 00:11:48,840
In this particular case, 

217
00:11:48,850 --> 00:11:51,990
you can see that the overhead is 30, 40,

218
00:11:52,000 --> 00:11:54,320
times higher when I see between processes, 

219
00:11:55,490 --> 00:12:00,070
as compared when you switch, 

220
00:12:00,570 --> 00:12:02,900
just behind be between two threats. 

221
00:12:03,590 --> 00:12:05,500
And the frequency of context switching. 

222
00:12:05,510 --> 00:12:10,430
Here we are talking is about10 or 100 millisecond. 

223
00:12:11,360 --> 00:12:13,870
You don't want to contact switch all the time. 

224
00:12:13,880 --> 00:12:15,470
You want to contact switch. 

225
00:12:16,340 --> 00:12:17,560
Still fast enough, 

226
00:12:18,830 --> 00:12:21,690
but not as fast. 

227
00:12:21,980 --> 00:12:25,770
So that the amount of computation is the same order. 

228
00:12:25,780 --> 00:12:29,530
Remind you of squeeze the amount of overhead, it takes the switch.

229
00:12:30,840 --> 00:12:31,230
Okay. 

230
00:12:32,380 --> 00:12:36,140
We have a question here from a sheet. 

231
00:12:36,150 --> 00:12:38,500
Isn't it trivial to change the address space? 

232
00:12:38,510 --> 00:12:44,610
Because you just change the pointer and for fallacy that again, 

233
00:12:44,620 --> 00:12:46,730
don't you just change this process structure? 

234
00:12:46,740 --> 00:12:51,480
.2is more than that. 

235
00:12:51,890 --> 00:12:53,280
You also need to have. 

236
00:12:55,150 --> 00:12:56,220
You have the buffers, 

237
00:12:56,230 --> 00:12:58,740
if you remember the, for instance, files tomorrow,

238
00:12:58,750 --> 00:13:01,970
io the other things you need to do, 

239
00:13:02,420 --> 00:13:05,320
fundamentally, you need to have the entire page table.

240
00:13:06,640 --> 00:13:08,790
You need to take care of it, 

241
00:13:09,210 --> 00:13:13,250
because the page table that is a translation of the address

242
00:13:13,260 --> 00:13:15,050
virtual addresses to physical addresses. 

243
00:13:15,410 --> 00:13:16,180
It is. 

244
00:13:20,470 --> 00:13:21,300
This is what? 

245
00:13:21,310 --> 00:13:22,820
Each process outs. 

246
00:13:25,400 --> 00:13:25,630
Yeah, 

247
00:13:26,150 --> 00:13:26,650
what? 

248
00:13:26,660 --> 00:13:31,520
And also when you see the address space, 

249
00:13:31,800 --> 00:13:38,560
then you can because you are going to have probably some of the babies

250
00:13:38,790 --> 00:13:40,430
which of the process, 

251
00:13:40,650 --> 00:13:42,080
which are going to be, 

252
00:13:43,170 --> 00:13:46,210
we have a big deal from the memory to make room for new processes, 

253
00:13:46,220 --> 00:13:51,020
and they are going to go to disk or whatever ssd therefore, 

254
00:13:51,030 --> 00:13:56,330
you may also have to do some work to get some pages in when you switch

255
00:13:56,340 --> 00:13:57,290
between the processes, 

256
00:14:01,320 --> 00:14:07,100
even cheaper you can actually use without the operating system support. 

257
00:14:09,240 --> 00:14:13,840
You can use as you can use yield in the user level. 

258
00:14:13,850 --> 00:14:18,330
So the application actually is 50 that are thread libraries, 

259
00:14:18,340 --> 00:14:21,030
user levels for several thread libraries. 

260
00:14:21,290 --> 00:14:24,640
These are the libraries which provide you like a thread interface, 

261
00:14:24,870 --> 00:14:27,430
but the operating system doesn't know anything about. 

262
00:14:29,910 --> 00:14:32,910
And then what happens when you use a thread, 

263
00:14:32,920 --> 00:14:34,230
use that level thread, 

264
00:14:34,240 --> 00:14:35,990
then when you call yield, 

265
00:14:36,000 --> 00:14:38,630
you call the library which running the same process. 

266
00:14:38,640 --> 00:14:40,190
Again, it's not a system,

267
00:14:40,810 --> 00:14:41,330
kernel. 

268
00:14:41,530 --> 00:14:44,120
And then that library is going to invoke, 

269
00:14:44,490 --> 00:14:46,760
you are going to just make a call a function, 

270
00:14:46,770 --> 00:14:50,260
call to another thread in the same process. 

271
00:14:50,430 --> 00:14:51,900
This is very, very lightweight,

272
00:14:51,910 --> 00:14:53,100
is just a function call. 

273
00:14:54,670 --> 00:14:57,580
This is some of the first stress systems have been implemented. 

274
00:14:57,800 --> 00:14:58,950
That is the application level. 

275
00:15:00,270 --> 00:15:02,790
In this case, all fundamentally,

276
00:15:02,800 --> 00:15:12,190
all these user level threads are going to be basically mapped on, say,

277
00:15:12,200 --> 00:15:13,430
one cpu now. 

278
00:15:14,040 --> 00:15:16,190
With a kernel, in general,

279
00:15:16,200 --> 00:15:19,070
kernel also uses some threads, right?

280
00:15:19,080 --> 00:15:19,950
And the number. 

281
00:15:19,960 --> 00:15:21,430
And these are kernel threads. 

282
00:15:21,440 --> 00:15:22,790
And you then, in general,

283
00:15:23,000 --> 00:15:25,310
you map the user thread on the kernel threads. 

284
00:15:26,490 --> 00:15:28,040
The kernel said, typically,

285
00:15:28,050 --> 00:15:31,040
you uses a number as a number of catalysts. 

286
00:15:31,230 --> 00:15:34,970
The number of kennel thread is typically equal, 

287
00:15:34,980 --> 00:15:37,770
is a number of cp us or a number. 

288
00:15:38,720 --> 00:15:39,110
Okay? 

289
00:15:39,120 --> 00:15:40,870
And again, you have it difficult.

290
00:15:40,880 --> 00:15:47,200
You have few tens on your cpu but you can have then thousand or tens

291
00:15:47,210 --> 00:15:49,130
of thousand of user level threads. 

292
00:15:51,760 --> 00:15:55,150
When the kernel has a concept of thread, 

293
00:15:55,160 --> 00:15:56,390
then what you happen, 

294
00:15:56,400 --> 00:16:00,280
you are going to map the user thread on top on calendar sets. 

295
00:16:02,370 --> 00:16:03,320
Let's look, 

296
00:16:10,030 --> 00:16:13,180
is this server overhead on context? 

297
00:16:14,140 --> 00:16:15,700
Switch between process is purely, 

298
00:16:15,710 --> 00:16:17,340
do you have to switch of the address space? 

299
00:16:17,350 --> 00:16:18,580
That's a big part of it. 

300
00:16:22,090 --> 00:16:24,530
Again, there are also file descriptors and things like that,

301
00:16:24,540 --> 00:16:26,770
but the address space is a big partner. 

302
00:16:28,980 --> 00:16:29,810
Okay. 

303
00:16:33,590 --> 00:16:34,860
In today, lecture,

304
00:16:34,870 --> 00:16:37,980
we are going to talk what in the first part of today lecture, 

305
00:16:37,990 --> 00:16:40,820
we are going to talk about this, 

306
00:16:40,870 --> 00:16:47,740
12the 1~1 thread model in the one grand thread model, actually,

307
00:16:48,100 --> 00:16:49,490
in this particular case, 

308
00:16:49,790 --> 00:16:55,020
we are going to have for one users said we are going to have assumed

309
00:16:55,030 --> 00:16:56,220
there is a kernel said. 

310
00:16:56,230 --> 00:16:58,140
So this means that for one user said, 

311
00:16:58,150 --> 00:17:00,700
we are going to have a cpu to run on. 

312
00:17:03,370 --> 00:17:04,720
Again, it's another figure,

313
00:17:05,370 --> 00:17:11,480
another representation to for you to better understand how things

314
00:17:11,490 --> 00:17:12,800
are working under the hood. 

315
00:17:14,100 --> 00:17:15,200
So here is, again,

316
00:17:15,210 --> 00:17:17,250
you have two processes, 

317
00:17:17,260 --> 00:17:20,130
these rounded yellow boxes. 

318
00:17:20,670 --> 00:17:23,600
Each process you have a few threads. 

319
00:17:23,610 --> 00:17:26,070
A thread has its own state. 

320
00:17:26,670 --> 00:17:30,980
Then for they have some state they share is a process like memory and our state. 

321
00:17:31,920 --> 00:17:34,110
Then this is os with green, 

322
00:17:34,120 --> 00:17:35,590
and you have acpu scalar, 

323
00:17:35,600 --> 00:17:39,950
which speaks on which cpu the threat that will run. 

324
00:17:39,960 --> 00:17:43,250
And you initially, let's assume that we have one.

325
00:17:44,260 --> 00:17:44,770
Okay. 

326
00:17:47,170 --> 00:17:47,830
Now, 

327
00:17:49,370 --> 00:17:50,710
let's look at the switch of our heads. 

328
00:17:50,720 --> 00:17:51,870
Now, the switch of our heads.

329
00:17:51,880 --> 00:17:53,430
There are multiple cases here. 

330
00:17:54,050 --> 00:17:55,390
The switch overhead of two threads. 

331
00:17:55,400 --> 00:17:55,660
Again. 

332
00:17:55,670 --> 00:17:58,900
Eventually, what you run on the cpu is a strap.

333
00:17:59,210 --> 00:17:59,540
Right? 

334
00:18:00,190 --> 00:18:03,490
So the switch overhead between two threads. 

335
00:18:03,820 --> 00:18:05,930
If they are on the same process is very low, 

336
00:18:06,530 --> 00:18:06,990
right? 

337
00:18:07,240 --> 00:18:14,030
Because all you need to soldiers abuse the you need to save and resume

338
00:18:14,190 --> 00:18:15,960
this the stress state, 

339
00:18:16,500 --> 00:18:16,870
right? 

340
00:18:18,490 --> 00:18:19,120
Which is small. 

341
00:18:20,560 --> 00:18:20,850
Now, 

342
00:18:20,860 --> 00:18:25,570
if you need to go from one thread in one process into a thread

343
00:18:25,580 --> 00:18:26,770
in a different process. 

344
00:18:26,780 --> 00:18:29,770
Now, you need also to see the context of processes.

345
00:18:29,780 --> 00:18:31,910
So then the switch overhead is high. 

346
00:18:32,600 --> 00:18:35,200
Now, why do you have threads and processes?

347
00:18:35,570 --> 00:18:38,070
Because the processes, 

348
00:18:38,080 --> 00:18:40,950
while it is a context which between processes is slow, 

349
00:18:40,960 --> 00:18:43,310
they provide some things that do not provide. 

350
00:18:43,790 --> 00:18:45,070
That is protection. 

351
00:18:46,450 --> 00:18:46,830
Right? 

352
00:18:47,280 --> 00:18:51,190
The protection between two strides running in the same process is very low. 

353
00:18:51,200 --> 00:18:53,630
It's because they are sharing the same memory. 

354
00:18:54,080 --> 00:18:58,770
One thread can read and write from the memory of the data, 

355
00:18:58,780 --> 00:19:00,850
from the data of another thread. 

356
00:19:01,580 --> 00:19:05,260
While if the strategy could run on different processes, 

357
00:19:05,270 --> 00:19:06,490
that's not possible. 

358
00:19:07,560 --> 00:19:07,990
Okay? 

359
00:19:08,650 --> 00:19:10,530
Now sharing overhead, as we know,

360
00:19:10,900 --> 00:19:14,820
and we learned last past lectures, 

361
00:19:15,600 --> 00:19:15,940
threads. 

362
00:19:15,950 --> 00:19:21,540
And you may want to share data because the applications are pretty complex. 

363
00:19:21,960 --> 00:19:25,460
And they want to communicate with the multiple step. 

364
00:19:25,470 --> 00:19:27,020
They want to communicate with each other. 

365
00:19:28,230 --> 00:19:31,140
Now, if there are two threads are in the same process,

366
00:19:31,150 --> 00:19:33,100
it's very easy for them to communicate. 

367
00:19:33,110 --> 00:19:34,460
It's also low overhead. 

368
00:19:34,750 --> 00:19:35,020
Why? 

369
00:19:35,030 --> 00:19:37,660
Because they can't communicate through the shared memory, 

370
00:19:37,670 --> 00:19:39,780
the memory they share in the same process. 

371
00:19:40,180 --> 00:19:43,070
They just read and write to the memory super easy. 

372
00:19:43,370 --> 00:19:44,450
On the other hand, 

373
00:19:44,460 --> 00:19:46,130
if these are two processes, 

374
00:19:46,140 --> 00:19:47,730
the sellers are into processes, 

375
00:19:47,920 --> 00:19:51,870
then what do you know what the overhead is much higher? 

376
00:19:51,880 --> 00:19:54,150
Because how you can communicate between the processes? 

377
00:19:54,160 --> 00:19:55,030
Do you remember? 

378
00:19:55,120 --> 00:19:57,590
You can use pipe, you can use sockets,

379
00:19:57,840 --> 00:20:00,870
but all or you can read and write from a file. 

380
00:20:01,280 --> 00:20:04,750
All of this operation are far more expensive than reading and writing

381
00:20:04,760 --> 00:20:05,620
from the memory. 

382
00:20:10,800 --> 00:20:12,150
What about the parallels? 

383
00:20:12,770 --> 00:20:15,120
In the case of parallels here, there is no parallels,

384
00:20:15,130 --> 00:20:16,840
because you have only one core. 

385
00:20:16,850 --> 00:20:18,760
You can run only once at a time. 

386
00:20:20,060 --> 00:20:21,370
Here, it's a model.

387
00:20:21,380 --> 00:20:24,720
General example is you have four course. 

388
00:20:25,490 --> 00:20:29,440
You can have four different kernel threads running at the same time. 

389
00:20:29,740 --> 00:20:31,310
So now you have parallelism. 

390
00:20:31,890 --> 00:20:39,630
Now you need to the sharing of our head is a little bit even more complex, 

391
00:20:40,070 --> 00:20:43,300
because if you have the same process is low, 

392
00:20:44,990 --> 00:20:46,540
different process is high. 

393
00:20:46,550 --> 00:20:48,880
But now there are different process. 

394
00:20:49,280 --> 00:20:54,520
If actually, it turns out that if you have simultaneous scores,

395
00:20:54,530 --> 00:20:57,070
that's so they are running, 

396
00:20:57,620 --> 00:20:59,570
you can have processes. 

397
00:21:00,140 --> 00:21:01,450
So this is more complicated, 

398
00:21:01,460 --> 00:21:04,530
but you can have kernel stress running on the same car. 

399
00:21:04,740 --> 00:21:07,950
And we see next slide how you can that have that. 

400
00:21:08,310 --> 00:21:12,010
Then the overhead of communication of sharing is lower. 

401
00:21:12,830 --> 00:21:19,250
And this is what I meant is a concept of multithreading or hypothetic, 

402
00:21:19,260 --> 00:21:20,850
actually is hypothetical, right?

403
00:21:20,860 --> 00:21:23,010
Simultaneous multithreading or hypothetical. 

404
00:21:23,940 --> 00:21:33,340
This what they are talking about so far in everything I I said, 

405
00:21:33,760 --> 00:21:36,320
you can run one thread on one core. 

406
00:21:42,470 --> 00:21:45,820
But it turns out that in practice, 

407
00:21:46,040 --> 00:21:48,110
you can run at the same time, 

408
00:21:48,120 --> 00:21:50,910
multiple one multiple setting shadow, in general,

409
00:21:50,920 --> 00:21:53,530
only two threads on the same call. 

410
00:21:54,920 --> 00:21:55,280
Right? 

411
00:21:56,120 --> 00:21:58,810
And this is called hypothetical. 

412
00:22:00,860 --> 00:22:04,940
And almost all processors today provided, 

413
00:22:05,890 --> 00:22:06,270
right? 

414
00:22:06,930 --> 00:22:11,480
It's actually, when you look at amazon for those of you, they give,

415
00:22:11,490 --> 00:22:17,190
they say bcpu virtual cpu a virtual cpu is actually a hyper threat, 

416
00:22:18,110 --> 00:22:19,460
is not one core necessary. 

417
00:22:21,060 --> 00:22:22,080
So what is the idea? 

418
00:22:22,610 --> 00:22:25,080
Here is as things look at these figures, 

419
00:22:25,090 --> 00:22:28,040
do you see my pointer on the screen? 

420
00:22:31,890 --> 00:22:33,570
Can someone ask us if you see my point? 

421
00:22:38,770 --> 00:22:39,160
Perfect. 

422
00:22:40,860 --> 00:22:44,530
So here is a time on the vertical. 

423
00:22:45,150 --> 00:22:46,990
Here are, if you remember,

424
00:22:47,000 --> 00:22:53,950
from 61 c the processor have in the aromatic logical unit and everything

425
00:22:54,680 --> 00:23:00,690
there are different components that you need to fetch the instruction, 

426
00:23:00,700 --> 00:23:04,940
then you need to. 

427
00:23:06,390 --> 00:23:10,380
Then you may use different components like ads

428
00:23:10,390 --> 00:23:13,800
or from the aromatic processor units, 

429
00:23:14,030 --> 00:23:16,550
a logical unit to perform that operation. 

430
00:23:18,730 --> 00:23:22,180
Each of this line, it's an instruction.

431
00:23:23,550 --> 00:23:24,580
And vertical. 

432
00:23:24,590 --> 00:23:29,610
Each of the vertical is one component in the process in that core. 

433
00:23:31,170 --> 00:23:33,000
So this color, what is color?

434
00:23:33,010 --> 00:23:35,000
This means that this instruction, 

435
00:23:37,210 --> 00:23:38,670
where is a colored? 

436
00:23:38,970 --> 00:23:43,270
Is that particular instruction uses that component. 

437
00:23:44,100 --> 00:23:44,530
Right? 

438
00:23:46,040 --> 00:23:48,590
For instance, from in this example,

439
00:23:48,640 --> 00:23:52,070
in the first instruction using the first and the third component. 

440
00:23:52,540 --> 00:23:54,560
Okay, but not using it doesn't use the second one.

441
00:23:54,970 --> 00:23:56,880
And then for the next, 

442
00:23:57,690 --> 00:23:58,370
actually, 

443
00:23:58,880 --> 00:24:02,330
ii I was not accurate. 

444
00:24:02,340 --> 00:24:05,810
Sorry, each of this line represents a cycle instruction cycle.

445
00:24:06,160 --> 00:24:07,410
But at many instructions, 

446
00:24:07,730 --> 00:24:09,680
they run in a single cycle, some of them,

447
00:24:10,150 --> 00:24:11,390
but some of them do not. 

448
00:24:11,690 --> 00:24:12,170
Okay. 

449
00:24:13,220 --> 00:24:15,870
It's instruction cycle in this cycle. 

450
00:24:17,200 --> 00:24:21,920
These two first and the third component are yours. 

451
00:24:22,400 --> 00:24:23,920
In the next cycle, 

452
00:24:23,930 --> 00:24:27,070
there is no component being used. 

453
00:24:27,370 --> 00:24:29,410
And maybe this is because it has stalled. 

454
00:24:30,080 --> 00:24:31,470
The data is not available, 

455
00:24:31,480 --> 00:24:33,990
and the instruction cannot proceed or something like that, 

456
00:24:35,560 --> 00:24:36,510
and so forth. 

457
00:24:37,070 --> 00:24:42,160
The main point here is that not all components are used at the same time. 

458
00:24:46,210 --> 00:24:49,650
So then what you can do then, 

459
00:24:49,660 --> 00:24:56,230
is basically to run two streams of instructions from two different threads. 

460
00:24:57,510 --> 00:25:03,710
If a stream doesn't use all the components at the same time, 

461
00:25:04,520 --> 00:25:06,270
then the other string can use them. 

462
00:25:08,360 --> 00:25:09,800
So that's kind of the intuition. 

463
00:25:10,640 --> 00:25:14,790
One stream of instructions doesn't use all the components of the core

464
00:25:15,500 --> 00:25:16,430
at all times. 

465
00:25:17,910 --> 00:25:20,960
So you can take advantage of that to support the second stream

466
00:25:21,550 --> 00:25:23,850
to better use other components. 

467
00:25:25,190 --> 00:25:32,290
So that's why you can run two streams of instruction on virtually the same harder. 

468
00:25:32,300 --> 00:25:35,490
So just better utilizing the particular core. 

469
00:25:37,280 --> 00:25:37,640
All right. 

470
00:25:38,260 --> 00:25:38,970
That's what it is. 

471
00:25:39,310 --> 00:25:39,750
Okay. 

472
00:25:39,760 --> 00:25:45,570
So it basically provides you the illusion that now you can run multiple. 

473
00:25:45,990 --> 00:25:47,380
You like, you have multiple,

474
00:25:50,190 --> 00:25:52,140
the speedup is nonlinear, 

475
00:25:52,150 --> 00:25:55,940
because sometimes you have conflicts, 

476
00:25:56,220 --> 00:25:59,370
like you have the two stream instruction at the given cycle. 

477
00:25:59,380 --> 00:26:02,780
They want to use the same component. 

478
00:26:05,520 --> 00:26:09,480
But this is super useful and technique. 

479
00:26:10,540 --> 00:26:13,540
And it's used by almost every processor. 

480
00:26:20,680 --> 00:26:21,210
Now, 

481
00:26:22,070 --> 00:26:25,890
if I remember a process, 

482
00:26:26,150 --> 00:26:29,610
can relinquish access to the cpu in multiple ways. 

483
00:26:29,890 --> 00:26:30,130
Right? 

484
00:26:30,140 --> 00:26:31,810
One is voluntarily yield. 

485
00:26:32,200 --> 00:26:39,130
Another one is io when it's making an io one is calling an io operation, 

486
00:26:39,140 --> 00:26:40,890
like, in this case, it is from a file.

487
00:26:41,690 --> 00:26:42,880
Then it's another question. 

488
00:26:42,890 --> 00:26:44,980
Let me try to answer the question. 

489
00:26:44,990 --> 00:26:47,520
Are some components not used, 

490
00:26:47,530 --> 00:26:49,160
even if we do pipelining? 

491
00:26:49,450 --> 00:26:52,340
Yes, because pipelining means there are multiple.

492
00:26:53,650 --> 00:26:54,760
You are also going, 

493
00:26:55,180 --> 00:26:58,810
you can also have stalls and dependencies in the pipelines

494
00:26:59,380 --> 00:27:00,730
across instruction in the pipeline. 

495
00:27:02,510 --> 00:27:06,930
The answer is actually all the processors are all already do pipeline, 

496
00:27:10,290 --> 00:27:10,700
right? 

497
00:27:11,810 --> 00:27:12,680
Pipelining. 

498
00:27:13,410 --> 00:27:16,980
It helps you to each instruction, new instruction,

499
00:27:16,990 --> 00:27:18,620
to every clock cycle. 

500
00:27:18,630 --> 00:27:20,810
You start the new instruction, 

501
00:27:21,160 --> 00:27:24,470
but pipelining helps with the use it utilization, 

502
00:27:24,480 --> 00:27:26,070
but it doesn't solve it entirely. 

503
00:27:28,530 --> 00:27:29,100
Great question. 

504
00:27:30,260 --> 00:27:31,890
Let's go back here. 

505
00:27:31,900 --> 00:27:32,370
Again. 

506
00:27:32,380 --> 00:27:33,730
We are going to show the stack, 

507
00:27:34,130 --> 00:27:35,730
and you have copy file, 

508
00:27:36,310 --> 00:27:37,180
cold read. 

509
00:27:37,530 --> 00:27:38,810
And when cold read, 

510
00:27:39,070 --> 00:27:42,250
read it, again, it's a system call.

511
00:27:42,780 --> 00:27:44,650
You call it a kernel read. 

512
00:27:45,150 --> 00:27:46,590
And what is the kernel doing? 

513
00:27:48,360 --> 00:27:51,020
Is going to start the read operation. 

514
00:27:51,480 --> 00:27:54,240
But before you get the answer to the read operation, 

515
00:27:54,510 --> 00:27:55,780
the cpu is free. 

516
00:27:56,050 --> 00:27:56,810
So therefore, 

517
00:27:56,820 --> 00:28:02,330
is going to switch to suspend your being the copy file program, 

518
00:28:02,530 --> 00:28:07,100
and give the cpu to another thread. 

519
00:28:08,090 --> 00:28:08,450
Right? 

520
00:28:09,220 --> 00:28:10,260
The same thing happens. 

521
00:28:10,750 --> 00:28:11,020
Right? 

522
00:28:11,980 --> 00:28:12,780
And the same, 

523
00:28:14,230 --> 00:28:20,360
it is similar when you have signals and joints or operate operations on other. 

524
00:28:22,880 --> 00:28:23,280
Okay. 

525
00:28:27,540 --> 00:28:30,290
Finally, one question.

526
00:28:30,300 --> 00:28:31,690
So we also ask in the past, 

527
00:28:31,700 --> 00:28:34,770
what happens if there no is a program? 

528
00:28:35,250 --> 00:28:41,270
Doesn't voluntarily yield the cpu there is no io and in general, 

529
00:28:41,280 --> 00:28:41,690
never waits. 

530
00:28:42,490 --> 00:28:42,860
Right? 

531
00:28:45,440 --> 00:28:46,630
In that case, 

532
00:28:47,900 --> 00:28:52,510
you still needs to multiply the cpu between different threads. 

533
00:28:52,900 --> 00:28:55,130
The way you do it using external events. 

534
00:28:55,370 --> 00:28:58,390
External events like in this, like interrupts.

535
00:28:58,870 --> 00:28:59,490
In particular, 

536
00:28:59,500 --> 00:29:05,100
timer interrupts a you program the timer to give an interrupt. 

537
00:29:05,450 --> 00:29:07,060
Every 100 millisecond. 

538
00:29:07,370 --> 00:29:08,790
When you get this interrupt, 

539
00:29:08,800 --> 00:29:12,950
the kernel is going to switch from the current threat or infrastructure. 

540
00:29:15,440 --> 00:29:15,810
Okay? 

541
00:29:17,880 --> 00:29:18,910
That's what it is. 

542
00:29:24,090 --> 00:29:25,760
Let's see another question. 

543
00:29:26,370 --> 00:29:29,310
It seemed like the hyperthreading benefits concurrency. 

544
00:29:29,320 --> 00:29:31,490
What about parallels? 

545
00:29:31,910 --> 00:29:35,040
It definitely also benefits parallels because you are going to have

546
00:29:35,050 --> 00:29:38,750
now if you have you are going to double the number of threads you

547
00:29:38,760 --> 00:29:41,270
are going to to run at the same time. 

548
00:29:48,360 --> 00:29:54,900
So this is a picture which basically show you here is acpu and then I show

549
00:29:54,910 --> 00:29:57,900
you how you are going to interface with different devices. 

550
00:29:58,800 --> 00:29:59,230
Right? 

551
00:29:59,750 --> 00:30:01,740
Again, the way interface, actually,

552
00:30:01,750 --> 00:30:06,410
the operating system with a different devices is through these interrupts

553
00:30:06,850 --> 00:30:10,860
when an event which requires the attention of the kernel happens, 

554
00:30:11,220 --> 00:30:17,020
that device has to going to jane to generate this kind of event which is interact. 

555
00:30:17,630 --> 00:30:17,960
Right? 

556
00:30:21,520 --> 00:30:27,980
You can also have software interrupts like seek kill is a software interrupt. 

557
00:30:29,960 --> 00:30:31,460
It doesn't come from a device. 

558
00:30:32,070 --> 00:30:35,480
It comes from another process or it comes from the kettle. 

559
00:30:37,320 --> 00:30:40,950
This is a timer, which is a special kind of interrupt like we discussed.

560
00:30:45,040 --> 00:30:48,590
For interrupt, you can mask interrupts and we'll see.

561
00:30:48,960 --> 00:30:51,120
And the interrupt they have some priority. 

562
00:30:55,990 --> 00:30:59,070
The higher priority interrupts, 

563
00:30:59,890 --> 00:31:02,600
for instance can interrupt the lower priority interrupt. 

564
00:31:03,810 --> 00:31:04,210
Okay? 

565
00:31:04,640 --> 00:31:06,520
But this is what have you have? 

566
00:31:06,530 --> 00:31:08,140
Basically this is actually this hardware, 

567
00:31:08,980 --> 00:31:11,510
this kind of different lines, 

568
00:31:11,820 --> 00:31:18,150
how to go to lines in the interrupt, 

569
00:31:20,320 --> 00:31:20,760
least. 

570
00:31:21,400 --> 00:31:28,020
And then the key kernel will always look at the highest interrupt

571
00:31:28,030 --> 00:31:29,940
and will treat the highest interrupt. 

572
00:31:30,780 --> 00:31:31,190
Okay? 

573
00:31:32,040 --> 00:31:38,630
If higher interrupts and the one you are currently treating occurs, 

574
00:31:38,900 --> 00:31:42,310
then you are not going to switch to treat the higher interrupt and then you

575
00:31:42,320 --> 00:31:42,990
come back, 

576
00:31:43,450 --> 00:31:45,490
finish treating the lower interrupt. 

577
00:31:47,370 --> 00:31:47,840
Okay? 

578
00:31:51,190 --> 00:31:57,100
The software interrupts can be cleared by software and cpu can disable

579
00:31:57,110 --> 00:31:59,140
all interrupts with some internal flags. 

580
00:32:00,160 --> 00:32:00,630
Okay? 

581
00:32:01,240 --> 00:32:04,620
So I don't want to be interrupted because what i'm doing is very important. 

582
00:32:08,310 --> 00:32:16,860
And there is also some non maskable interrupts which you don't have

583
00:32:16,870 --> 00:32:17,780
anything what to do like, 

584
00:32:17,790 --> 00:32:18,540
for instance, 

585
00:32:18,730 --> 00:32:21,750
reset is a nomas couple interrupt. 

586
00:32:22,440 --> 00:32:22,770
Right? 

587
00:32:24,710 --> 00:32:31,430
So you have to just kill and reset everything on the computer and restart, 

588
00:32:31,440 --> 00:32:32,150
right? 

589
00:32:32,450 --> 00:32:33,230
That's one example. 

590
00:32:37,490 --> 00:32:41,470
Now, this is an example about how the network interrupt occurs.

591
00:32:41,720 --> 00:32:43,030
Let's say you execute this, 

592
00:32:43,040 --> 00:32:44,750
call these instructions. 

593
00:32:45,630 --> 00:32:49,720
Now, you get an external interrupt because a packet arrives.

594
00:32:50,220 --> 00:32:55,600
So the kernel needs to copy the data into the kernel buffer. 

595
00:32:56,620 --> 00:32:57,460
So what do you do? 

596
00:32:58,660 --> 00:33:00,010
First of all, your pipeline,

597
00:33:00,020 --> 00:33:01,840
you flash the pipeline, right?

598
00:33:01,850 --> 00:33:07,590
The pipeline of the processor from the state of the current Instructions. 

599
00:33:10,430 --> 00:33:12,040
You save the program counter, 

600
00:33:13,200 --> 00:33:13,620
right? 

601
00:33:14,090 --> 00:33:17,520
To know when you are going to resume where you are going to come back, 

602
00:33:17,530 --> 00:33:22,190
what is a program counter if you have to come back to and disable all the interrupts? 

603
00:33:24,000 --> 00:33:28,970
Because now you need to do some work, 

604
00:33:29,190 --> 00:33:30,660
and you don't want to be interrupted. 

605
00:33:33,190 --> 00:33:35,130
And basically what you do here, 

606
00:33:35,480 --> 00:33:38,740
you raise a priority and you mask all the lower level interrupt, 

607
00:33:38,750 --> 00:33:44,960
because I don't want to be interrupted by lower level interrupts when you

608
00:33:44,970 --> 00:33:45,480
do that. 

609
00:33:47,010 --> 00:33:52,990
And you save the registers for this current thread, 

610
00:33:55,900 --> 00:33:57,970
you dispatched to the handler of the interrupt, 

611
00:33:58,740 --> 00:33:59,840
because you need to treat the interact. 

612
00:33:59,850 --> 00:34:00,960
In this particular case, 

613
00:34:00,970 --> 00:34:02,770
read the data from the network, 

614
00:34:05,140 --> 00:34:06,540
transfer the network packets, 

615
00:34:06,550 --> 00:34:08,060
from harvard to the canal buffers. 

616
00:34:09,440 --> 00:34:10,460
Once you're done with that, 

617
00:34:10,470 --> 00:34:12,020
you restore the registers, 

618
00:34:13,470 --> 00:34:13,930
right? 

619
00:34:16,550 --> 00:34:20,500
You clear current interrupt because you are done with it. 

620
00:34:23,480 --> 00:34:26,830
You desirable, all interrupts are going to do your work.

621
00:34:27,520 --> 00:34:29,750
Do you don't want to be interrupted as a journal? 

622
00:34:30,950 --> 00:34:32,960
And you restore the priority? 

623
00:34:36,720 --> 00:34:38,190
You then clear the masks. 

624
00:34:38,500 --> 00:34:38,730
Right? 

625
00:34:38,740 --> 00:34:41,450
The set, the mask which are clear here,

626
00:34:43,620 --> 00:34:46,970
the mask, which you said here to not be interrupted.

627
00:34:46,980 --> 00:34:48,050
Now you clear it, 

628
00:34:48,330 --> 00:34:51,490
basically saying, now I can be interrupted by anything by any.

629
00:34:52,000 --> 00:34:52,180
Right? 

630
00:34:52,190 --> 00:34:55,000
And now I return from the interact. 

631
00:34:57,720 --> 00:34:58,230
That's it. 

632
00:35:00,250 --> 00:35:01,030
It's very simple. 

633
00:35:09,690 --> 00:35:11,520
And it's, again, an interim, though,

634
00:35:11,530 --> 00:35:14,600
it was to think about it's a hardware involved context switch. 

635
00:35:18,340 --> 00:35:19,810
There is no separate state. 

636
00:35:19,820 --> 00:35:22,850
There is no decision of what to run next. 

637
00:35:23,380 --> 00:35:24,100
It's very clear. 

638
00:35:24,110 --> 00:35:28,880
I am going to run the handle to treat the interrupt. 

639
00:35:30,980 --> 00:35:34,890
And i'm going to go back to this program. 

640
00:35:34,900 --> 00:35:36,290
I just interrupted. 

641
00:35:41,890 --> 00:35:43,070
So like we mentioned, 

642
00:35:43,730 --> 00:35:51,680
one way to interrupt a program now and give and give

643
00:35:51,690 --> 00:35:57,480
control to another program is simple simply by using the time of interact. 

644
00:35:58,050 --> 00:35:58,480
Right? 

645
00:35:58,880 --> 00:36:01,240
As the time I interrupt on the interrupt, happens,

646
00:36:01,250 --> 00:36:02,520
time I interrupt happens, 

647
00:36:04,390 --> 00:36:10,640
you are going to kennel is going to execute this time or interrupt handle. 

648
00:36:11,280 --> 00:36:13,700
And the time of interrupt handle or a pin, 

649
00:36:14,910 --> 00:36:16,980
it's doing some housekeeping. 

650
00:36:17,460 --> 00:36:18,140
It's again, 

651
00:36:19,290 --> 00:36:21,380
update some counters and things like that, 

652
00:36:21,780 --> 00:36:23,350
and then run new thread, 

653
00:36:24,350 --> 00:36:24,670
right? 

654
00:36:25,910 --> 00:36:28,580
And that you run new threads, what he's doing,

655
00:36:28,830 --> 00:36:30,850
save the state of the current thread. 

656
00:36:34,580 --> 00:36:35,170
Initially, 

657
00:36:35,180 --> 00:36:42,930
the state is a state into registers of the new thread and start the new threat. 

658
00:36:42,940 --> 00:36:44,090
And in between, 

659
00:36:44,540 --> 00:36:46,860
you need to decide which instead you are going to run. 

660
00:36:50,340 --> 00:36:52,250
This is what we are talking about. 

661
00:36:55,750 --> 00:37:00,750
You initialize the registered field of that dcb or stack pointer

662
00:37:01,130 --> 00:37:03,040
with pc return address. 

663
00:37:04,400 --> 00:37:06,110
Also, in this case,

664
00:37:06,450 --> 00:37:09,220
is the functions and the function arguments. 

665
00:37:09,540 --> 00:37:13,290
You.out to this function and the point of the function to the list of

666
00:37:13,300 --> 00:37:14,250
function arguments, 

667
00:37:14,480 --> 00:37:17,270
which you put into registers, in this case, a zero and a one.

668
00:37:19,890 --> 00:37:21,160
Then all about the stacks. 

669
00:37:21,170 --> 00:37:24,200
Again, the stack is in the memory, served by the processor.

670
00:37:24,210 --> 00:37:29,030
You don't need to do anything other than pointing to the rockaric location

671
00:37:29,040 --> 00:37:29,910
of the stack, 

672
00:37:29,920 --> 00:37:31,270
which is a stack pointer. 

673
00:37:35,840 --> 00:37:37,710
Again, let's see what happens here.

674
00:37:39,120 --> 00:37:40,390
In this particular case, 

675
00:37:40,400 --> 00:37:41,950
this is the old one. 

676
00:37:42,510 --> 00:37:46,100
It's basically we went through this one here, use yield,

677
00:37:46,510 --> 00:37:51,890
which is voluntarily relinquish the cpu to be used by another thread. 

678
00:37:52,580 --> 00:37:54,220
And when this happened, 

679
00:37:54,530 --> 00:37:56,330
you and you set up the new thread, 

680
00:37:56,590 --> 00:38:03,580
you are going to initialize the greatest, 

681
00:38:04,190 --> 00:38:10,000
the pointers and registers of the processors with the values from the pcb

682
00:38:11,270 --> 00:38:12,940
from the thread control block. 

683
00:38:13,390 --> 00:38:13,670
Right? 

684
00:38:17,240 --> 00:38:20,870
And then you are going to run the newsletter. 

685
00:38:25,460 --> 00:38:27,100
So this thread road, 

686
00:38:28,330 --> 00:38:31,640
this is a route for all the thread routines. 

687
00:38:31,650 --> 00:38:33,770
So when you have to switch, 

688
00:38:34,070 --> 00:38:35,550
which from one thread to another thread, 

689
00:38:35,560 --> 00:38:37,470
this is what you are going to execute. 

690
00:38:39,540 --> 00:38:40,070
Okay? 

691
00:38:41,060 --> 00:38:47,030
The thread wrote what it takes to take this address to the function

692
00:38:47,040 --> 00:38:49,450
of the thread you want to execute, 

693
00:38:49,460 --> 00:38:49,730
right? 

694
00:38:49,740 --> 00:38:50,850
Remember a strategy, 

695
00:38:50,860 --> 00:38:54,170
just a function you have to execute at the end of the day, right?

696
00:38:54,540 --> 00:38:56,530
You need to provide to this thread route, 

697
00:38:57,060 --> 00:39:03,420
the function of the new thread to execute and the front and the arguments, 

698
00:39:03,430 --> 00:39:03,650
right? 

699
00:39:05,380 --> 00:39:07,120
Again, you lose some households,

700
00:39:07,790 --> 00:39:08,600
housekeeping. 

701
00:39:10,900 --> 00:39:13,090
You do the user mode switch. 

702
00:39:13,410 --> 00:39:15,100
So now you are in the kernel, 

703
00:39:15,110 --> 00:39:17,460
so you need to go to the user mode, 

704
00:39:18,240 --> 00:39:20,560
because the application runs in the user mode, 

705
00:39:20,850 --> 00:39:25,880
and then simply invoke the the thread function with the arguments. 

706
00:39:26,440 --> 00:39:26,960
And you are done. 

707
00:39:26,970 --> 00:39:33,280
And like I mentioned, 

708
00:39:33,290 --> 00:39:37,080
the housekeeping includes things like recording the start time of the strategy, 

709
00:39:37,350 --> 00:39:45,270
how long the thread is spare run of the cpu while other statistics, 

710
00:39:45,280 --> 00:39:47,510
number of context switching and things like that. 

711
00:39:49,720 --> 00:39:50,160
Obviously, 

712
00:39:50,170 --> 00:39:53,880
the struck stack will grow and shrink with the execution of a strategy. 

713
00:39:56,870 --> 00:40:01,430
And when you return from this function, 

714
00:40:01,830 --> 00:40:05,040
you this is you call the thread finish, right?

715
00:40:05,050 --> 00:40:06,240
What is the thread finish? 

716
00:40:07,810 --> 00:40:10,130
Is you need to execute another thread, 

717
00:40:10,830 --> 00:40:11,310
right? 

718
00:40:11,830 --> 00:40:14,720
You need to find and wake up a sleeping threat. 

719
00:40:18,660 --> 00:40:20,930
So now we really go into concurrence. 

720
00:40:24,330 --> 00:40:28,040
It's again, once you have multiple threads running at the same time,

721
00:40:30,790 --> 00:40:32,170
and have the kernel, 

722
00:40:33,370 --> 00:40:40,270
non deterministic decide at what point to interrupt a threat to suspend it

723
00:40:40,280 --> 00:40:41,550
and regime on other side. 

724
00:40:43,740 --> 00:40:44,930
Now you need to be very careful. 

725
00:40:46,360 --> 00:40:50,400
And you need to be careful because these threads can share the same data. 

726
00:40:52,590 --> 00:40:54,160
If there is no share, state,

727
00:40:54,660 --> 00:40:56,090
is fine, no problems.

728
00:40:57,090 --> 00:40:58,620
But if the state is shared, 

729
00:40:59,010 --> 00:41:00,040
then you can run in, 

730
00:41:00,050 --> 00:41:01,360
we can run into problems. 

731
00:41:02,970 --> 00:41:03,320
Here. 

732
00:41:03,330 --> 00:41:05,720
Are you want to be very careful on the design? 

733
00:41:06,180 --> 00:41:11,810
And you should try to what we call correctness by design, 

734
00:41:12,050 --> 00:41:14,280
meaning that we need to convince yourself. 

735
00:41:14,650 --> 00:41:15,650
Maybe in some case, 

736
00:41:15,660 --> 00:41:19,540
you can even prove that the design of, 

737
00:41:19,550 --> 00:41:27,990
despite the fact that multiple concurrent threads can access the same data, 

738
00:41:30,420 --> 00:41:32,380
the design is correct, nothing bad.

739
00:41:33,780 --> 00:41:33,990
Happened. 

740
00:41:34,850 --> 00:41:36,250
Recall again, different executions.

741
00:41:36,260 --> 00:41:41,630
And the execution we really care about is b and c where threads

742
00:41:41,640 --> 00:41:44,330
are interleaved or they are running at the same time. 

743
00:41:44,340 --> 00:41:47,360
So they can touch the data at the same time. 

744
00:41:50,250 --> 00:41:52,490
This is extremely important. 

745
00:41:53,100 --> 00:41:53,320
Right? 

746
00:41:53,690 --> 00:41:57,530
Here is an example to drive home. 

747
00:41:57,540 --> 00:42:00,930
The point is that handling the concurrency is important. 

748
00:42:01,700 --> 00:42:02,690
So think about idea. 

749
00:42:02,700 --> 00:42:04,490
You have an idea. 

750
00:42:06,320 --> 00:42:07,710
You have, obviously,

751
00:42:07,720 --> 00:42:12,450
with atm you want to either deposit or withdraw money. 

752
00:42:14,160 --> 00:42:16,220
And the state assumes that it's in a database. 

753
00:42:19,240 --> 00:42:20,680
So we need to be very careful here. 

754
00:42:23,070 --> 00:42:25,610
So you're supposed that you want to implement this functionality. 

755
00:42:29,110 --> 00:42:35,320
Then you need to process fundamentally, 

756
00:42:35,330 --> 00:42:41,180
you have to have an infinite loop where you wait for request from the users. 

757
00:42:42,040 --> 00:42:43,480
And then you process the requests. 

758
00:42:44,230 --> 00:42:44,430
Right? 

759
00:42:44,440 --> 00:42:47,270
And the request is basically specifying operation, 

760
00:42:48,090 --> 00:42:49,050
withdraw, 

761
00:42:49,630 --> 00:42:50,400
or deposit, 

762
00:42:51,590 --> 00:42:53,830
account id as the amount. 

763
00:42:55,800 --> 00:42:56,150
Right? 

764
00:42:57,410 --> 00:42:59,930
This is you receive the request and then you process the request. 

765
00:43:02,450 --> 00:43:04,820
The process request is simple, right?

766
00:43:04,830 --> 00:43:06,880
If it's a deposit, 

767
00:43:07,390 --> 00:43:14,580
you deposit the amount in account id if it's if it's withdrawal, 

768
00:43:16,910 --> 00:43:19,260
you subtract the amount from the deposit, 

769
00:43:22,130 --> 00:43:23,560
the deposit functions. 

770
00:43:23,850 --> 00:43:24,960
What is a deposit function? 

771
00:43:24,970 --> 00:43:25,920
How does it look like? 

772
00:43:26,500 --> 00:43:30,720
You get account id you get the account data structure from the account id

773
00:43:31,670 --> 00:43:34,260
and you add the amount to the balance. 

774
00:43:35,020 --> 00:43:38,620
And then you store the account reader account, 

775
00:43:38,630 --> 00:43:40,660
modifies the account, store, the account.

776
00:43:45,150 --> 00:43:46,730
So if you do this thing, 

777
00:43:47,860 --> 00:43:48,180
right? 

778
00:43:49,290 --> 00:43:50,660
At one given time, 

779
00:43:51,550 --> 00:43:53,980
you are only to set up a single request. 

780
00:43:57,970 --> 00:43:59,430
So what is the problem with that? 

781
00:44:00,210 --> 00:44:02,100
The problem is can be very slow. 

782
00:44:02,740 --> 00:44:03,770
And why is slow? 

783
00:44:05,150 --> 00:44:06,660
Not because of computation. 

784
00:44:06,950 --> 00:44:08,640
Adding numbers is super fast. 

785
00:44:09,610 --> 00:44:09,990
Right? 

786
00:44:11,010 --> 00:44:15,820
What is slow is to access a database to get the account information

787
00:44:15,830 --> 00:44:19,780
from the database and to store the account information to the database. 

788
00:44:21,470 --> 00:44:23,720
That is what is slow. 

789
00:44:25,180 --> 00:44:26,410
And during this time, 

790
00:44:27,350 --> 00:44:28,550
the program is blocked, 

791
00:44:28,810 --> 00:44:33,650
just waiting for the database operation to complete. 

792
00:44:35,390 --> 00:44:42,860
The opportunity here is to overlap communication is a database io who is a computation. 

793
00:44:43,680 --> 00:44:50,620
While you wait for an account to be read from the database or written

794
00:44:50,630 --> 00:44:51,660
to the database, 

795
00:44:52,350 --> 00:44:56,290
you can very well serve as a users. 

796
00:44:56,710 --> 00:44:59,500
And by the way, the users actually, in this case,

797
00:45:00,320 --> 00:45:03,810
they can operate on different accounts on their own accounts. 

798
00:45:06,220 --> 00:45:06,430
Right? 

799
00:45:06,910 --> 00:45:08,000
So how do you do that? 

800
00:45:09,670 --> 00:45:10,860
One way to do it, 

801
00:45:10,870 --> 00:45:12,900
and this is typical is called event driven. 

802
00:45:14,580 --> 00:45:17,390
And with the event driven approach, 

803
00:45:18,430 --> 00:45:20,150
you basically split the requests, 

804
00:45:21,880 --> 00:45:22,190
right? 

805
00:45:24,150 --> 00:45:25,430
In multiple pieces. 

806
00:45:26,020 --> 00:45:27,610
1 piece, for instance,

807
00:45:27,950 --> 00:45:30,270
you start on the request is basically, for instance,

808
00:45:30,280 --> 00:45:34,500
this piece can only start the aisle. 

809
00:45:35,670 --> 00:45:37,910
It can only makes any questions, a database.

810
00:45:37,920 --> 00:45:40,820
And then you switch, you end up,

811
00:45:42,250 --> 00:45:47,550
and you wait for an event to come from the database, 

812
00:45:47,560 --> 00:45:54,550
basically saying from then the operating system saying this request set

813
00:45:55,760 --> 00:45:59,070
has been completed. 

814
00:45:59,730 --> 00:46:00,640
Now there is a data. 

815
00:46:00,650 --> 00:46:03,680
Now you can go to continuous requests to read the data. 

816
00:46:05,680 --> 00:46:06,110
Okay? 

817
00:46:07,480 --> 00:46:10,570
This is kind of the things you do it, right?

818
00:46:11,240 --> 00:46:16,230
By hand, you are going to basically say that in the programming by hand,

819
00:46:16,240 --> 00:46:18,670
I think that explicitly in the program, 

820
00:46:19,060 --> 00:46:23,530
you make sure that there is no part of the program that's wait

821
00:46:24,120 --> 00:46:28,090
for is blocked further than I already quest to complete. 

822
00:46:33,830 --> 00:46:37,520
But now this way to write programs, 

823
00:46:40,660 --> 00:46:41,490
it's pretty hard. 

824
00:46:42,420 --> 00:46:43,860
What if you miss the blocking aisle? 

825
00:46:46,300 --> 00:46:47,480
Then you are going to block. 

826
00:46:48,920 --> 00:46:50,440
The performance is going to suffer. 

827
00:46:53,260 --> 00:46:54,010
What do you have? 

828
00:46:54,820 --> 00:46:56,410
Your function? 

829
00:46:57,550 --> 00:46:59,150
Has hundreds of aisles. 

830
00:47:00,400 --> 00:47:02,950
You need to split into hundreds of pieces, 

831
00:47:03,220 --> 00:47:07,170
very hard to reason and be back. 

832
00:47:08,720 --> 00:47:10,580
However, this is super fast.

833
00:47:11,190 --> 00:47:12,960
It's even faster than threads. 

834
00:47:13,940 --> 00:47:14,350
Right? 

835
00:47:14,980 --> 00:47:18,990
There is not even context switching between threats super fast. 

836
00:47:19,510 --> 00:47:21,720
This is used when you really, 

837
00:47:21,730 --> 00:47:25,160
really need performance like graphical program. 

838
00:47:28,740 --> 00:47:29,250
Now, 

839
00:47:29,260 --> 00:47:32,890
the obvious question is that and this is what we brought in this example. 

840
00:47:33,640 --> 00:47:34,600
Then you may say, 

841
00:47:35,650 --> 00:47:36,650
but what about threads? 

842
00:47:36,660 --> 00:47:38,970
We just said that threads can handle concurrency. 

843
00:47:38,980 --> 00:47:40,170
It's a unit of concurrence. 

844
00:47:41,850 --> 00:47:42,390
Indeed. 

845
00:47:42,750 --> 00:47:44,010
And using threads, 

846
00:47:44,540 --> 00:47:46,140
you can do this much easier. 

847
00:47:47,670 --> 00:47:48,020
Right? 

848
00:47:50,080 --> 00:47:51,720
So let's see how this is done. 

849
00:47:52,220 --> 00:47:52,630
Right? 

850
00:47:53,350 --> 00:47:56,500
Basically, you run each of this operation in different threads.

851
00:47:58,340 --> 00:47:58,560
Right? 

852
00:47:58,570 --> 00:47:59,760
You can do another thread. 

853
00:47:59,770 --> 00:48:01,560
Each operation can be another thread. 

854
00:48:02,200 --> 00:48:03,230
You have a thread, 

855
00:48:03,240 --> 00:48:08,270
you can have a thread pool to make sure that you don't have a huge number

856
00:48:08,280 --> 00:48:08,750
of threads. 

857
00:48:08,760 --> 00:48:10,270
So the system is going to crash, 

858
00:48:10,420 --> 00:48:11,960
like we learned the last lecture. 

859
00:48:12,500 --> 00:48:13,270
But otherwise, 

860
00:48:13,280 --> 00:48:18,680
the only thing you need to do each operation is a differential, 

861
00:48:20,480 --> 00:48:22,470
because if you remember from what you learn, 

862
00:48:22,480 --> 00:48:26,830
what a thread is going to wait for an eye operation, 

863
00:48:26,990 --> 00:48:28,330
it's going to be suspended. 

864
00:48:29,870 --> 00:48:33,940
And the kennel will let another thread to run. 

865
00:48:35,370 --> 00:48:35,840
Okay? 

866
00:48:37,230 --> 00:48:39,960
The problems are here is that, 

867
00:48:40,710 --> 00:48:41,250
okay. 

868
00:48:41,770 --> 00:48:48,060
Now, it's the two threads can access the same data.

869
00:48:49,900 --> 00:48:51,330
Here is a very simple example. 

870
00:48:56,150 --> 00:49:02,230
We have maybe here two threads which are depositing in the same account. 

871
00:49:03,010 --> 00:49:03,450
Right? 

872
00:49:05,020 --> 00:49:05,970
What happened here? 

873
00:49:05,980 --> 00:49:06,170
Right? 

874
00:49:06,180 --> 00:49:08,750
The straight one is reading the balance. 

875
00:49:11,390 --> 00:49:13,640
After that the threat to read the balance, 

876
00:49:15,960 --> 00:49:21,290
and then add the amount to the balance, 

877
00:49:21,300 --> 00:49:22,490
which is in other one, 

878
00:49:24,540 --> 00:49:25,960
and then save the balance. 

879
00:49:29,110 --> 00:49:31,860
But now I am going to resume to set one. 

880
00:49:31,870 --> 00:49:33,580
I said one, the first thing is doing,

881
00:49:33,590 --> 00:49:36,140
it's at its own amount to the balance, 

882
00:49:38,150 --> 00:49:39,310
and then start the balance. 

883
00:49:41,040 --> 00:49:41,830
What did they do? 

884
00:49:41,840 --> 00:49:43,310
What is this code accomplish? 

885
00:49:44,330 --> 00:49:45,340
What is not accomplishing? 

886
00:49:46,270 --> 00:49:47,060
What happens here? 

887
00:49:48,270 --> 00:49:49,380
What is your own behavior? 

888
00:49:52,010 --> 00:49:54,440
I have an ebola thread one, say.

889
00:49:55,330 --> 00:49:58,820
I want to add the balance $100 thread to, 

890
00:49:58,830 --> 00:50:03,920
I want to add to the balance $200. 

891
00:50:05,710 --> 00:50:08,780
I should have added to the balance behind the dollars. 

892
00:50:09,640 --> 00:50:11,400
But if I execute the code, what happens?

893
00:50:15,010 --> 00:50:16,190
A mountain is lost. 

894
00:50:16,680 --> 00:50:17,440
Very good, simon.

895
00:50:18,450 --> 00:50:20,080
So basically, 

896
00:50:20,090 --> 00:50:21,200
in our example, 

897
00:50:22,130 --> 00:50:27,910
only $100 are going to be added to the balance and the 200 will be lost. 

898
00:50:32,100 --> 00:50:32,640
Okay. 

899
00:50:36,250 --> 00:50:37,680
There are many examples, 

900
00:50:38,520 --> 00:50:39,620
like in this example, 

901
00:50:40,240 --> 00:50:42,360
thread one is x say, 

902
00:50:42,370 --> 00:50:45,390
x one and set by is still. 

903
00:50:45,980 --> 00:50:47,350
This case is simple, right?

904
00:50:47,360 --> 00:50:49,660
They are separate thread, separate data structure.

905
00:50:49,670 --> 00:50:50,650
They don't interfere. 

906
00:50:50,910 --> 00:50:51,850
Everything is fine. 

907
00:50:54,030 --> 00:50:55,290
However, in this case,

908
00:50:55,630 --> 00:50:58,770
they have operate on a common variable. 

909
00:51:02,090 --> 00:51:03,850
What are the possible values of x here? 

910
00:51:08,440 --> 00:51:11,000
Why don't you take a little bit of time and answer this question? 

911
00:51:17,390 --> 00:51:23,850
If I run thread one and thread a and thread b the initial value of y is 12. 

912
00:51:26,060 --> 00:51:27,460
What results I can get here? 

913
00:51:33,940 --> 00:51:34,550
One answer. 

914
00:51:35,130 --> 00:51:36,270
Please more answers. 

915
00:51:40,200 --> 00:51:40,830
Okay. 

916
00:51:44,510 --> 00:51:45,210
Excellent. 

917
00:51:46,490 --> 00:51:46,740
Right. 

918
00:51:46,750 --> 00:51:49,220
So you need to take all why is 12? 

919
00:51:50,140 --> 00:51:51,750
But I still remember so in, 

920
00:51:52,100 --> 00:51:55,310
say, 3 days is running to completion.

921
00:51:56,790 --> 00:51:57,170
Right? 

922
00:52:01,480 --> 00:52:04,480
Then what you get is 13. 

923
00:52:04,490 --> 00:52:04,870
Right? 

924
00:52:06,380 --> 00:52:08,020
Now say thread this, 

925
00:52:08,030 --> 00:52:09,460
france before saturday. 

926
00:52:10,090 --> 00:52:10,810
What happens? 

927
00:52:11,140 --> 00:52:13,540
Why is to it over as well? 

928
00:52:14,300 --> 00:52:16,750
Then you multiply by 2 service 4. 

929
00:52:17,980 --> 00:52:19,910
And then here you are going to have five, 

930
00:52:23,120 --> 00:52:23,560
right? 

931
00:52:25,140 --> 00:52:32,860
Or you can only run the first instruction of b before you run a again, 

932
00:52:32,870 --> 00:52:36,860
you initialize y we stood over I 12 initial value, 

933
00:52:37,290 --> 00:52:38,500
and the result will be three. 

934
00:52:40,930 --> 00:52:42,280
You see pretty complicated, 

935
00:52:42,290 --> 00:52:46,130
but also fun to write for to do this exercises. 

936
00:52:46,140 --> 00:52:46,650
Oops. 

937
00:52:47,960 --> 00:52:49,600
But this is even simple examples. 

938
00:52:49,610 --> 00:52:51,800
X is equal one and x equal two. 

939
00:52:52,890 --> 00:52:54,050
What is the result? 

940
00:52:54,060 --> 00:52:55,730
Not that means you get one or two. 

941
00:52:56,670 --> 00:53:02,680
For fun, if the instruction to store data is not deterministic,

942
00:53:02,910 --> 00:53:05,390
you can even get something in between. 

943
00:53:06,440 --> 00:53:06,760
Right? 

944
00:53:08,190 --> 00:53:12,110
Sorry, if the instruction to store the data in memory is not atomic,

945
00:53:12,490 --> 00:53:14,330
I said, no, not their music, which is wrong.

946
00:53:14,960 --> 00:53:15,820
It's nonatomic. 

947
00:53:17,190 --> 00:53:17,530
Right. 

948
00:53:18,410 --> 00:53:20,090
We learn more about atomic instruction. 

949
00:53:21,410 --> 00:53:22,320
So it's a mess. 

950
00:53:28,200 --> 00:53:30,310
So to understand the concurrent program, 

951
00:53:30,320 --> 00:53:32,270
like in this past example, you've seen,

952
00:53:32,280 --> 00:53:34,470
you need to know what is the indivisible operation? 

953
00:53:34,600 --> 00:53:36,570
What is atomic operation? 

954
00:53:36,580 --> 00:53:37,930
An atomic operation? 

955
00:53:38,660 --> 00:53:40,750
What is an atomic operation is indivisible? 

956
00:53:40,760 --> 00:53:47,990
You can interrupt in between in the middle is a run or doesn't run at all. 

957
00:53:49,090 --> 00:53:51,610
That's all right. 

958
00:53:53,190 --> 00:53:59,490
You cannot just have upset of the output of running half of atomic operation. 

959
00:53:59,750 --> 00:54:02,180
Now, your output is the upset.

960
00:54:02,190 --> 00:54:10,270
Output is either as if the entire operation runs or none of the operation

961
00:54:10,280 --> 00:54:10,990
as a run at all. 

962
00:54:12,360 --> 00:54:14,070
This is a fundamental building block. 

963
00:54:16,870 --> 00:54:18,090
On most machines, 

964
00:54:18,330 --> 00:54:19,960
load and stores are atomic. 

965
00:54:21,190 --> 00:54:27,640
The world exam wild examples in the previous slide cannot happen in this case, 

966
00:54:29,000 --> 00:54:30,400
but many atomics, 

967
00:54:30,410 --> 00:54:31,520
many instructions. 

968
00:54:31,900 --> 00:54:36,450
And here we are talking about processor instructions are not atomic. 

969
00:54:37,310 --> 00:54:38,910
Double precisions have not atomic, 

970
00:54:38,920 --> 00:54:40,350
so you can interrupt in the middle. 

971
00:54:40,940 --> 00:54:45,190
And there are instructions on the old computers run, 

972
00:54:45,200 --> 00:54:47,220
which copy a whole area. 

973
00:54:48,380 --> 00:54:49,150
They are not atomic. 

974
00:54:50,600 --> 00:54:51,030
Right? 

975
00:54:51,410 --> 00:54:52,790
If bad things happen, 

976
00:54:52,800 --> 00:54:57,880
you can see the results only of a partially running instruction. 

977
00:55:02,210 --> 00:55:02,650
Now, 

978
00:55:04,160 --> 00:55:08,420
if we run, if we know only what are the atomic instructions,

979
00:55:08,430 --> 00:55:09,420
this is helpful, 

980
00:55:10,340 --> 00:55:11,610
but it's still not enough, 

981
00:55:12,320 --> 00:55:15,460
because you can see that atomicity, 

982
00:55:15,470 --> 00:55:22,200
it's a very convenient way to control the access to a share of variables. 

983
00:55:23,700 --> 00:55:24,380
Because atomistic, 

984
00:55:24,390 --> 00:55:29,100
if I can say all this bunch of instructions is not going to be interrupted. 

985
00:55:29,110 --> 00:55:32,610
I don't need to be worried that someone will read. 

986
00:55:32,620 --> 00:55:33,190
All right? 

987
00:55:33,490 --> 00:55:35,220
Or I am executing these operations. 

988
00:55:36,130 --> 00:55:37,410
You remember how these are called? 

989
00:55:38,150 --> 00:55:39,400
It's critical section, right?

990
00:55:42,310 --> 00:55:43,340
The way to do it, 

991
00:55:43,680 --> 00:55:45,470
in general, you do is, example, is a lock.

992
00:55:46,640 --> 00:55:47,520
You have one lock, 

993
00:55:48,680 --> 00:55:50,110
and you acquire the lock, 

994
00:55:51,240 --> 00:55:53,100
and you execute some code. 

995
00:55:54,180 --> 00:55:55,210
While you have the lock, 

996
00:55:55,220 --> 00:55:56,810
no one else can acquire the lock. 

997
00:55:59,480 --> 00:56:02,250
So no one else may be able to execute these instructions. 

998
00:56:03,260 --> 00:56:04,680
And then you release a lock when you are done. 

999
00:56:07,500 --> 00:56:09,260
And the threads, libraries,

1000
00:56:09,570 --> 00:56:11,610
they do have the lock, 

1001
00:56:12,260 --> 00:56:12,970
primitive. 

1002
00:56:18,140 --> 00:56:19,500
How do you fix it? 

1003
00:56:20,000 --> 00:56:21,350
The previous example, 

1004
00:56:21,650 --> 00:56:26,720
remember, when multiple threats can run this at the same time,

1005
00:56:27,150 --> 00:56:32,320
they can run at the same time and then can access data at the same time. 

1006
00:56:35,840 --> 00:56:37,100
Simply simple, 

1007
00:56:37,920 --> 00:56:38,340
right? 

1008
00:56:39,000 --> 00:56:44,040
You acquire the lock before you execute all the instruction on operation, 

1009
00:56:44,050 --> 00:56:45,000
on an account, 

1010
00:56:45,750 --> 00:56:46,880
and then you release a clock. 

1011
00:56:49,190 --> 00:56:52,580
This is what in the middle of the acquiring and releasing the lock

1012
00:56:52,590 --> 00:56:54,140
is called critical section. 

1013
00:56:57,050 --> 00:56:59,720
If multiple threads want to execute the same code, 

1014
00:57:00,010 --> 00:57:01,710
only one will execute at a given time. 

1015
00:57:04,140 --> 00:57:07,260
Very simple on thread, 

1016
00:57:07,270 --> 00:57:12,050
and then thread b and thread cok

1017
00:57:15,500 --> 00:57:19,010
but you need all this value of the same lock or the same lock

1018
00:57:19,020 --> 00:57:23,290
should be shared by all states want to access the same critical

1019
00:57:26,420 --> 00:57:26,770
section. 

1020
00:57:27,990 --> 00:57:28,720
So remember, 

1021
00:57:29,630 --> 00:57:30,160
okay. 

1022
00:57:31,180 --> 00:57:35,250
These 23 notions synchronization using a topping operation to ensure

1023
00:57:35,260 --> 00:57:39,110
cooperation between threats for

1024
00:57:39,120 --> 00:57:41,470
now only slows and stores, 

1025
00:57:41,480 --> 00:57:44,500
we assume are atomic mutual exclusion. 

1026
00:57:44,900 --> 00:57:48,580
We ensure that only one thread as a particular thing at a given time. 

1027
00:57:50,250 --> 00:57:50,620
Right? 

1028
00:57:50,870 --> 00:57:55,660
This means that one thread exclude another thread from running the same code. 

1029
00:57:56,430 --> 00:58:02,280
And critical section is a either side of the mutual exclusion coin. 

1030
00:58:02,830 --> 00:58:05,070
And critical section basically define, 

1031
00:58:05,080 --> 00:58:08,790
which is the sequence of instruction on the code, 

1032
00:58:09,220 --> 00:58:14,710
which is can be executed by a single thread at a given time. 

1033
00:58:19,450 --> 00:58:20,650
Here is another example, 

1034
00:58:21,650 --> 00:58:28,280
thread a and thread b thread a start with I initialize to zero, 

1035
00:58:28,950 --> 00:58:30,270
and then adds one. 

1036
00:58:31,190 --> 00:58:32,530
Has a loop adds one. 

1037
00:58:33,360 --> 00:58:38,850
And when you get to ten exits and say, brings a wings,

1038
00:58:39,550 --> 00:58:42,830
thread b is doing similar things, 

1039
00:58:42,840 --> 00:58:44,110
but decrement. 

1040
00:58:45,210 --> 00:58:47,410
Start with I zero, decrements it.

1041
00:58:47,840 --> 00:58:53,380
And if you reach to minus ten bos both of them, 

1042
00:58:53,390 --> 00:58:54,700
they share these variables. 

1043
00:58:57,240 --> 00:58:58,380
What is the result here? 

1044
00:58:59,730 --> 00:59:00,950
Who is a or b

1045
00:59:09,170 --> 00:59:13,490
let's only 200 minutes remaining. 

1046
00:59:13,500 --> 00:59:16,660
So let's get a little bit of energy. 

1047
00:59:20,320 --> 00:59:21,750
Could be easier, right?

1048
00:59:22,100 --> 00:59:22,940
You cannot know. 

1049
00:59:24,000 --> 00:59:24,400
Right? 

1050
00:59:28,190 --> 00:59:29,580
Let me ask you another question. 

1051
00:59:32,720 --> 00:59:35,090
Are you guaranteed that at least wanna win? 

1052
00:59:47,050 --> 00:59:47,530
Now? 

1053
00:59:48,990 --> 00:59:52,250
Excellent, at least on induction.

1054
00:59:52,640 --> 00:59:53,110
Now, 

1055
00:59:54,600 --> 00:59:57,110
because in the worst case, you see these three instruction,

1056
00:59:57,120 --> 00:59:58,670
I is equal I plus one. 

1057
00:59:58,970 --> 01:00:00,310
I is equally die medicine. 

1058
01:00:00,630 --> 01:00:04,100
What happens if you have contact switching

1059
01:00:04,360 --> 01:00:07,950
and between saturday and thread b and this thread only execute

1060
01:00:07,960 --> 01:00:08,630
this instruction. 

1061
01:00:10,470 --> 01:00:10,860
Right? 

1062
01:00:11,950 --> 01:00:13,750
You are get stuck with the same value. 

1063
01:00:14,300 --> 01:00:15,060
You never finish. 

1064
01:00:15,750 --> 01:00:16,270
None of this. 

1065
01:00:16,280 --> 01:00:16,950
Let's finish this. 

1066
01:00:19,400 --> 01:00:19,760
Excellent. 

1067
01:00:19,770 --> 01:00:20,280
Thank you. 

1068
01:00:31,250 --> 01:00:32,760
It's again, this is the inner loop,

1069
01:00:32,770 --> 01:00:35,600
and this is we see what is happening under the hood. 

1070
01:00:36,200 --> 01:00:39,070
Although the fact that what you see is that in the program, 

1071
01:00:39,600 --> 01:00:40,910
it's even more subtle. 

1072
01:00:41,380 --> 01:00:43,530
Because when he sees a program in the previous slide, 

1073
01:00:43,540 --> 01:00:45,330
let me just we should have said, 

1074
01:00:45,630 --> 01:00:49,360
when you see this, I I plus one or I I minus one,

1075
01:00:49,720 --> 01:00:52,380
actually, maybe you think that this is also atomic,

1076
01:00:53,750 --> 01:00:56,970
that means executes to completion, 

1077
01:00:58,930 --> 01:00:59,820
cannot be interrupted. 

1078
01:01:01,060 --> 01:01:01,850
It's not true. 

1079
01:01:01,860 --> 01:01:04,530
Remember, only lord loves and stores are at all.

1080
01:01:05,410 --> 01:01:05,840
Actually, 

1081
01:01:05,850 --> 01:01:09,920
things are even more complicated because I and I plus one and I is I

1082
01:01:09,930 --> 01:01:12,940
minus one can be interrupted in the middle. 

1083
01:01:14,040 --> 01:01:15,250
And this is one example, 

1084
01:01:17,570 --> 01:01:17,950
right? 

1085
01:01:18,610 --> 01:01:19,930
Where you execute, 

1086
01:01:21,570 --> 01:01:25,420
you interleave the instruction from three and three b and the result

1087
01:01:25,430 --> 01:01:27,390
here is what? 

1088
01:01:29,560 --> 01:01:30,790
Nothing changes. 

1089
01:01:40,810 --> 01:01:41,980
Because in the middle, 

1090
01:01:43,140 --> 01:01:44,640
you read the same values, 

1091
01:01:46,500 --> 01:01:48,820
you write the same at the same location. 

1092
01:01:48,830 --> 01:01:49,860
And in the middle, 

1093
01:01:50,780 --> 01:01:52,810
we want is a value on and is abstract on. 

1094
01:01:53,890 --> 01:01:54,620
So nothing changed. 

1095
01:01:56,680 --> 01:01:57,070
Okay? 

1096
01:02:00,030 --> 01:02:00,760
So, 

1097
01:02:03,780 --> 01:02:04,850
and typically, 

1098
01:02:04,860 --> 01:02:06,490
this is called race conditions. 

1099
01:02:06,500 --> 01:02:08,210
When you have two strides attempting blocks, 

1100
01:02:08,220 --> 01:02:13,030
the same data at the same time with one of them performing the right. 

1101
01:02:18,050 --> 01:02:19,210
So how do you fix it? 

1102
01:02:19,770 --> 01:02:24,240
We know now you put a lock that is fix it. 

1103
01:02:27,270 --> 01:02:29,020
Not really, because we discussed, right?

1104
01:02:29,030 --> 01:02:31,580
You can execute this block of instruction, 

1105
01:02:31,590 --> 01:02:32,860
ysy plus one, 

1106
01:02:33,750 --> 01:02:36,190
and then execute the second block of instruction. 

1107
01:02:36,890 --> 01:02:40,670
And it's true that you are going to see the changes. 

1108
01:02:41,820 --> 01:02:44,560
But before they execute the next while, 

1109
01:02:47,740 --> 01:02:50,270
the value was updated to the same value. 

1110
01:02:53,400 --> 01:02:53,800
Right? 

1111
01:02:58,070 --> 01:02:59,430
And the main.here, 

1112
01:02:59,440 --> 01:03:02,890
and I need probably to got it be faster. 

1113
01:03:03,390 --> 01:03:05,430
Concurrency is hard like, look,

1114
01:03:05,750 --> 01:03:07,070
these simple examples. 

1115
01:03:07,960 --> 01:03:09,400
There are a bunch of instructions, 

1116
01:03:09,410 --> 01:03:10,440
just a few instructions. 

1117
01:03:10,450 --> 01:03:10,800
What? 

1118
01:03:11,470 --> 01:03:13,290
Three instruction, four instructions,

1119
01:03:13,890 --> 01:03:14,890
even that is hard. 

1120
01:03:15,890 --> 01:03:17,900
Now, imagine that you have thousands,

1121
01:03:18,390 --> 01:03:20,460
tens of thousands of instructions. 

1122
01:03:22,890 --> 01:03:24,680
There are many such issues. 

1123
01:03:27,370 --> 01:03:30,870
And these are just some examples. 

1124
01:03:30,880 --> 01:03:34,630
He says there are 25 radiation therapy machines. 

1125
01:03:36,180 --> 01:03:38,640
As a result of this kind of race condition, 

1126
01:03:38,650 --> 01:03:42,070
concurrency of not being careful, 

1127
01:03:43,950 --> 01:03:50,880
accessing the same variable from different threads resulted in an overdose, 

1128
01:03:51,510 --> 01:03:52,530
which cause even death. 

1129
01:03:55,580 --> 01:03:58,340
It was improper synchronization between the input thread

1130
01:03:59,230 --> 01:04:03,070
and the positioning high software where to apply the

1131
01:04:03,920 --> 01:04:10,240
radiation marked by find a priority inversion. 

1132
01:04:12,640 --> 01:04:13,180
Proud you. 

1133
01:04:13,190 --> 01:04:16,240
Inversion here means that basically, 

1134
01:04:16,250 --> 01:04:17,320
what happens? 

1135
01:04:17,840 --> 01:04:19,680
You have a high priority job. 

1136
01:04:19,690 --> 01:04:21,280
A high will learn more about that. 

1137
01:04:22,120 --> 01:04:30,550
A high priority thread waiting for something from a low priority thread. 

1138
01:04:31,570 --> 01:04:33,700
But the hybrid thread contains a lock, 

1139
01:04:33,710 --> 01:04:34,740
maintains a lock, 

1140
01:04:36,100 --> 01:04:40,780
which is required by the operator threat to update that value or to do

1141
01:04:40,790 --> 01:04:44,310
something for its high priority thread. 

1142
01:04:45,480 --> 01:04:47,120
Wait, but you cannot do it,

1143
01:04:48,410 --> 01:04:53,200
because the critical section is owned by high priority threat. 

1144
01:04:53,580 --> 01:04:54,430
So you get hacked. 

1145
01:04:56,030 --> 01:04:57,100
It's another things, 

1146
01:04:58,330 --> 01:05:00,090
toyota and control acceleration. 

1147
01:05:00,400 --> 01:05:08,960
This was 256,000 lines of seek out and whatever 11,000 global variables. 

1148
01:05:11,070 --> 01:05:13,300
So here it is inconsistent with your exclusion. 

1149
01:05:14,980 --> 01:05:15,400
Right? 

1150
01:05:16,090 --> 01:05:18,360
Acceleration was uncontrollable, right?

1151
01:05:18,370 --> 01:05:21,910
You just doesn't respond. 

1152
01:05:21,920 --> 01:05:23,190
You click a little bit. 

1153
01:05:23,800 --> 01:05:26,080
The carrot takes off, 

1154
01:05:26,510 --> 01:05:30,030
like you would floor the acceleration battle. 

1155
01:05:34,890 --> 01:05:39,270
Next, let's look about a little bit more sophisticated things.

1156
01:05:41,580 --> 01:05:44,430
Let's look at about queue, 

1157
01:05:45,370 --> 01:05:46,460
producer, consumer,

1158
01:05:47,280 --> 01:05:48,330
with a banded buffer. 

1159
01:05:48,590 --> 01:05:49,870
Why this is important. 

1160
01:05:50,090 --> 01:05:51,310
Remember about pipes. 

1161
01:05:51,790 --> 01:05:53,830
Last time, we learned about pipes.

1162
01:05:54,410 --> 01:05:55,300
Pipes is above, 

1163
01:05:55,840 --> 01:05:56,500
is a cube. 

1164
01:05:57,710 --> 01:05:59,160
You put that one in the queue, 

1165
01:05:59,170 --> 01:06:03,760
one end of the queue and get the data from the other end of the queue. 

1166
01:06:06,180 --> 01:06:07,020
When you do a pipe, 

1167
01:06:07,030 --> 01:06:10,180
all this is also and you do the piping between different pieces. 

1168
01:06:10,750 --> 01:06:16,090
When you change different shell comments, 

1169
01:06:16,100 --> 01:06:17,130
the same thing happened. 

1170
01:06:20,010 --> 01:06:24,600
And we'll have another example of cover machine later. 

1171
01:06:25,010 --> 01:06:25,500
Okay? 

1172
01:06:28,020 --> 01:06:29,100
And there are many examples. 

1173
01:06:29,370 --> 01:06:30,270
But this is what you want. 

1174
01:06:32,140 --> 01:06:35,720
Ideally, you put at one end of the buffer,

1175
01:06:35,730 --> 01:06:38,480
and you read from a different end of the buffer, and typically,

1176
01:06:38,490 --> 01:06:39,720
there is circular buffers. 

1177
01:06:40,380 --> 01:06:41,650
There is years to handle. 

1178
01:06:45,620 --> 01:06:48,370
You have immediately to deal with several problems, 

1179
01:06:48,380 --> 01:06:49,690
how to tell if full, 

1180
01:06:51,130 --> 01:06:53,120
how to take the buffer is empty. 

1181
01:06:55,870 --> 01:06:57,430
What to do, if is a buffer is full?

1182
01:06:57,440 --> 01:06:58,230
What to do is above? 

1183
01:06:58,240 --> 01:06:58,830
For example, 

1184
01:06:59,740 --> 01:07:00,670
one needs to be atomic. 

1185
01:07:04,090 --> 01:07:10,980
Let's take a simply that let's think about what is the simple implementation. 

1186
01:07:10,990 --> 01:07:12,560
All right? 

1187
01:07:13,190 --> 01:07:17,210
The producer, what you need to do while the buffer is full,

1188
01:07:19,000 --> 01:07:19,880
don't do anything. 

1189
01:07:20,470 --> 01:07:23,230
You cannot put another item because you don't have anywhere to put it. 

1190
01:07:25,080 --> 01:07:26,450
If the buffer is not full, 

1191
01:07:26,460 --> 01:07:27,650
you incure the item, 

1192
01:07:30,190 --> 01:07:32,280
because you need to do this operation, 

1193
01:07:32,290 --> 01:07:33,780
you want to be atomic. 

1194
01:07:35,870 --> 01:07:39,330
You are going to guard it, 

1195
01:07:39,660 --> 01:07:41,850
be a a with a lock. 

1196
01:07:46,780 --> 01:07:48,750
Can anyone tell me why you need to do this? 

1197
01:07:50,880 --> 01:07:51,650
What can happen? 

1198
01:07:52,170 --> 01:07:53,500
What can happen if I don't look? 

1199
01:08:08,050 --> 01:08:09,360
You may have buffer overflow. 

1200
01:08:10,300 --> 01:08:10,870
Excellent. 

1201
01:08:15,930 --> 01:08:16,130
Right? 

1202
01:08:16,140 --> 01:08:18,610
Because you can have two producers, two threads,

1203
01:08:22,050 --> 01:08:25,190
and one execute while both executed, while buffered.

1204
01:08:26,780 --> 01:08:27,730
Both are happy. 

1205
01:08:29,030 --> 01:08:31,890
The buffer is just one place for only one item, 

1206
01:08:34,450 --> 01:08:34,800
right? 

1207
01:08:35,340 --> 01:08:39,310
But both are going to pass of the wild. 

1208
01:08:42,490 --> 01:08:44,240
But now, once is interrupted,

1209
01:08:46,190 --> 01:08:47,030
obviously, right?

1210
01:08:47,640 --> 01:08:50,120
And the other one is going to include the item. 

1211
01:08:51,540 --> 01:08:52,920
Now, the buffer is full.

1212
01:08:53,860 --> 01:08:55,030
But for the first, 

1213
01:08:55,040 --> 01:08:58,470
for the soldiers interrupted or were suspended resumes, 

1214
01:08:59,320 --> 01:09:01,720
he doesn't know he's going to try to add another item, 

1215
01:09:03,470 --> 01:09:04,450
and I have the overflow. 

1216
01:09:06,240 --> 01:09:06,760
Okay? 

1217
01:09:07,320 --> 01:09:09,150
Now is at the queue, the same.

1218
01:09:09,160 --> 01:09:11,990
You do lock for this critical section, 

1219
01:09:12,000 --> 01:09:14,240
and you wait now is a buffer is empty. 

1220
01:09:14,250 --> 01:09:15,240
You don't do anything. 

1221
01:09:15,250 --> 01:09:17,750
If the buffer is not empty, you are going to delete it.

1222
01:09:20,610 --> 01:09:20,980
Right. 

1223
01:09:27,600 --> 01:09:28,000
Now, 

1224
01:09:28,990 --> 01:09:31,420
let's assume now for this crowd, 

1225
01:09:32,790 --> 01:09:33,750
if we do this, 

1226
01:09:36,230 --> 01:09:38,220
will we ever come out of the way? 

1227
01:09:39,590 --> 01:09:40,260
This is a question. 

1228
01:09:59,690 --> 01:10:01,280
Say that is nothing is a buffer. 

1229
01:10:06,840 --> 01:10:07,210
Right? 

1230
01:10:10,640 --> 01:10:11,550
Then that's fine, right?

1231
01:10:11,560 --> 01:10:13,670
You are going to build a buffer. 

1232
01:10:16,710 --> 01:10:18,230
But let me ask you this question. 

1233
01:10:18,880 --> 01:10:21,900
Maybe not an answer I see. 

1234
01:10:23,470 --> 01:10:26,370
Now you can block on the consumer exact, 

1235
01:10:28,280 --> 01:10:29,870
let's say that the queue is empty, 

1236
01:10:31,260 --> 01:10:32,620
and the consumer executes, 

1237
01:10:33,390 --> 01:10:34,430
it acquires a lock, 

1238
01:10:37,240 --> 01:10:41,830
and then it executes a while and is stuck, 

1239
01:10:43,680 --> 01:10:45,120
because there is nothing in the buffer. 

1240
01:10:46,120 --> 01:10:49,900
The only one who can put something in the buffer a is a producer. 

1241
01:10:50,620 --> 01:10:51,900
But in order for the producer, 

1242
01:10:51,910 --> 01:10:54,500
but something is a buffer, is to acquire the log.

1243
01:10:57,570 --> 01:10:59,890
But it cannot acquire the log because owned by the brasilia. 

1244
01:10:59,900 --> 01:11:03,130
So your hand, 

1245
01:11:08,990 --> 01:11:09,670
you don't work. 

1246
01:11:15,840 --> 01:11:16,870
How can you do it? 

1247
01:11:18,300 --> 01:11:20,160
One solution is to release a lock. 

1248
01:11:23,490 --> 01:11:24,990
If the buffer is full, 

1249
01:11:27,170 --> 01:11:29,930
we need to release a look if the buffer is full to give a chance

1250
01:11:29,940 --> 01:11:31,690
to the consumer to consume from the rough, 

1251
01:11:36,100 --> 01:11:36,450
right? 

1252
01:11:40,190 --> 01:11:41,400
And then acquire the buffer. 

1253
01:11:42,110 --> 01:11:42,270
Right? 

1254
01:11:42,280 --> 01:11:43,710
You see what you done here. 

1255
01:11:44,790 --> 01:11:45,180
Right? 

1256
01:11:46,220 --> 01:11:48,740
You acquired before you check again whether the buffer is full. 

1257
01:11:49,270 --> 01:11:51,710
You release this to give a chance to consumer to execute. 

1258
01:11:52,050 --> 01:11:56,000
You acquire the buffer back to check back whether the buffer is for the loop. 

1259
01:12:05,650 --> 01:12:07,770
What happens when one is waiting for the other? 

1260
01:12:08,840 --> 01:12:14,860
Like I said in this thing will be

1261
01:12:19,670 --> 01:12:24,870
it could work for multiple clock. 

1262
01:12:24,880 --> 01:12:26,550
Orders will discuss this a little bit later. 

1263
01:12:28,210 --> 01:12:29,160
Let me just, 

1264
01:12:36,620 --> 01:12:41,790
then there are other things we can do here. 

1265
01:12:41,800 --> 01:12:42,750
And this, right?

1266
01:12:42,760 --> 01:12:46,150
Abstraction of synchronizing threads that share memory. 

1267
01:12:47,000 --> 01:12:48,250
Locks is an abstraction, 

1268
01:12:59,850 --> 01:13:01,180
but it's not the only abstraction. 

1269
01:13:03,790 --> 01:13:06,280
And let me just see it's a question here. 

1270
01:13:10,870 --> 01:13:12,620
Let me go back, 

1271
01:13:12,630 --> 01:13:15,260
and it's important to understand that. 

1272
01:13:17,160 --> 01:13:18,430
The question here, 

1273
01:13:21,920 --> 01:13:24,750
it's what happens when one is waiting for? 

1274
01:13:24,760 --> 01:13:27,550
The why do we need to acquire the law? 

1275
01:13:28,460 --> 01:13:29,500
We need to acquire the log, 

1276
01:13:29,510 --> 01:13:33,240
because here what happens in the while loop? 

1277
01:13:34,190 --> 01:13:35,220
In the y loop, 

1278
01:13:35,230 --> 01:13:36,580
it's an empty instruction. 

1279
01:13:37,230 --> 01:13:39,060
You need to repeat the you repeatedly. 

1280
01:13:39,070 --> 01:13:39,900
What you want is this. 

1281
01:13:39,910 --> 01:13:40,260
Why? 

1282
01:13:40,790 --> 01:13:46,230
You repeatedly check whether buffer is full and been between the checks, 

1283
01:13:46,670 --> 01:13:48,300
you release and acquire the buffer. 

1284
01:13:48,870 --> 01:13:52,010
We need to be in critical section through check the buffer, 

1285
01:13:52,020 --> 01:13:56,050
because you don't want to be the buffer to be modified while you

1286
01:13:56,060 --> 01:13:59,950
are checking about checking whether is full that has to be

1287
01:13:59,960 --> 01:14:00,750
critical section. 

1288
01:14:01,710 --> 01:14:03,350
But between multiple checks, 

1289
01:14:03,850 --> 01:14:05,000
you want to release the lock. 

1290
01:14:05,510 --> 01:14:06,900
So the consumer can consume. 

1291
01:14:08,330 --> 01:14:10,770
That's right. 

1292
01:14:14,030 --> 01:14:20,520
So another way to do it is a more generally using some of us. 

1293
01:14:21,010 --> 01:14:22,550
We did this summer force. 

1294
01:14:22,560 --> 01:14:25,030
We learn slightly a little bit about them. 

1295
01:14:25,250 --> 01:14:27,390
This is just recalling what we learned. 

1296
01:14:27,720 --> 01:14:28,870
There are two similar force, 

1297
01:14:29,440 --> 01:14:34,480
sorry, to primitives on the same time for is p is an atomic operation,

1298
01:14:34,740 --> 01:14:38,990
which waits for the semaphore to become positives and decrement by one. 

1299
01:14:39,550 --> 01:14:40,920
If zero is just, 

1300
01:14:42,390 --> 01:14:43,990
it's weights is blocked. 

1301
01:14:44,480 --> 01:14:50,560
And b we just increment the semaphore and wake up any other thread which

1302
01:14:50,570 --> 01:14:52,320
wasted for which waits for the semester. 

1303
01:14:54,380 --> 01:14:54,690
All right. 

1304
01:14:57,130 --> 01:15:00,220
Some efforts are like integers in the sense that you

1305
01:15:00,230 --> 01:15:01,770
can increment and decrement them, 

1306
01:15:02,070 --> 01:15:03,640
except there are no negative values. 

1307
01:15:04,320 --> 01:15:07,540
The only way you can increment and they could be commanded them is to use

1308
01:15:07,550 --> 01:15:08,640
AP and b function. 

1309
01:15:11,020 --> 01:15:11,320
Right? 

1310
01:15:13,430 --> 01:15:14,580
This operation, 

1311
01:15:14,590 --> 01:15:18,610
December for these operations are atomic. 

1312
01:15:19,070 --> 01:15:20,060
Bnb are atomic. 

1313
01:15:23,950 --> 01:15:25,980
This is a railroad analogy. 

1314
01:15:26,270 --> 01:15:28,710
You can implement, like, for instance, in this case,

1315
01:15:28,720 --> 01:15:30,740
you have two lines, two railroad lines,

1316
01:15:31,790 --> 01:15:32,330
two rails. 

1317
01:15:33,290 --> 01:15:33,620
Right? 

1318
01:15:35,560 --> 01:15:38,360
You increment, you put the value of the semaphore to two.

1319
01:15:39,490 --> 01:15:43,440
So you can have an engine parked on online, 

1320
01:15:44,220 --> 01:15:46,090
then an engine park on second line. 

1321
01:15:46,100 --> 01:15:49,450
You notice that every time I haven't accepted an engine, 

1322
01:15:49,460 --> 01:15:51,210
I decrement the value. 

1323
01:15:51,670 --> 01:15:52,630
Now its value is zero. 

1324
01:15:53,590 --> 01:15:55,020
You have another engine is stopped. 

1325
01:15:55,030 --> 01:15:57,180
It cannot get in because the value is zero. 

1326
01:15:57,920 --> 01:16:03,830
Now, when one leaves is going to increment the semaphore and the slide,

1327
01:16:03,840 --> 01:16:05,510
the third engine can enter, 

1328
01:16:07,200 --> 01:16:07,210
right? 

1329
01:16:07,220 --> 01:16:07,960
And so forth. 

1330
01:16:09,730 --> 01:16:16,580
So you can use some of us to implement which mutual exclusion. 

1331
01:16:17,400 --> 01:16:21,350
This equivalent to having a semaphore is a binary value 01. 

1332
01:16:23,480 --> 01:16:24,590
How do you do that? 

1333
01:16:25,820 --> 01:16:31,530
You do AP on the summer for you initialize the summer for to one and use AP

1334
01:16:32,590 --> 01:16:33,580
so the first thread which

1335
01:16:33,590 --> 01:16:38,850
calls some p is going to enter the critical section because you

1336
01:16:38,860 --> 01:16:40,250
can decrement value to zero. 

1337
01:16:40,260 --> 01:16:42,540
The second one is going to copy. 

1338
01:16:43,470 --> 01:16:45,030
While the first one is the first study, 

1339
01:16:45,040 --> 01:16:49,310
the second in the critical section cannot enter in the critical section, 

1340
01:16:49,400 --> 01:16:50,470
because some are four is zero, 

1341
01:16:52,020 --> 01:16:53,540
where the first summer Ford leaves, 

1342
01:16:53,550 --> 01:16:57,140
the summer critical section is going to increment the summer for. 

1343
01:16:57,150 --> 01:16:58,990
So second one comes. 

1344
01:17:00,000 --> 01:17:00,320
Right? 

1345
01:17:02,230 --> 01:17:02,980
We also say, 

1346
01:17:02,990 --> 01:17:05,940
in this case that the summer for implements scheduling constraints, 

1347
01:17:11,890 --> 01:17:12,960
and also, 

1348
01:17:12,970 --> 01:17:14,040
this is about, 

1349
01:17:14,610 --> 01:17:15,040
sorry, 

1350
01:17:16,910 --> 01:17:20,640
we a second use case which you also learned last time. 

1351
01:17:20,990 --> 01:17:24,230
It was about waiting, 

1352
01:17:24,620 --> 01:17:26,680
a thread waiting for another thread to finish. 

1353
01:17:28,040 --> 01:17:31,810
You need the call, and this was implementing joint operation.

1354
01:17:32,510 --> 01:17:33,710
But I remember this code. 

1355
01:17:35,530 --> 01:17:36,920
You have a thread join. 

1356
01:17:38,760 --> 01:17:40,670
And that's your, 

1357
01:17:43,730 --> 01:17:49,290
you are going to wait for the thread to finish that adjoining. 

1358
01:17:49,800 --> 01:17:52,280
You run a thread and you added for Free to finish, right?

1359
01:17:53,430 --> 01:17:54,340
How you do that? 

1360
01:17:54,700 --> 01:17:57,690
You are going to have a semi for which is initialize to zero. 

1361
01:17:59,300 --> 01:18:00,850
When you start the thread, 

1362
01:18:05,360 --> 01:18:09,850
when you sorry, when you start when you finish a thread,

1363
01:18:10,930 --> 01:18:12,980
you increment the semaphore to one. 

1364
01:18:14,720 --> 01:18:18,040
And then let me take it back. 

1365
01:18:18,460 --> 01:18:19,880
We initialize a thread to zero. 

1366
01:18:22,780 --> 01:18:24,170
When you start the thread, 

1367
01:18:26,230 --> 01:18:27,150
nothing happens. 

1368
01:18:27,450 --> 01:18:31,490
And the main thread is going to wait to execute strategy. 

1369
01:18:32,340 --> 01:18:33,820
And it's going to be blocked, 

1370
01:18:35,580 --> 01:18:36,700
because the summer 40, 

1371
01:18:39,600 --> 01:18:44,040
when the set finishes on for which I'm waiting, 

1372
01:18:45,800 --> 01:18:48,480
then the thread is going to increment the Singapore. 

1373
01:18:49,610 --> 01:18:50,280
And now, 

1374
01:18:51,640 --> 01:18:57,140
the p in the thread join can decline the summer for and can finish. 

1375
01:18:59,600 --> 01:19:01,870
And this is only say we implement scheduling constants. 

1376
01:19:04,270 --> 01:19:04,800
Okay? 

1377
01:19:06,730 --> 01:19:07,720
We are a little bit slow. 

1378
01:19:07,730 --> 01:19:16,400
Let me just go over announcements. 

1379
01:19:18,580 --> 01:19:21,580
Let me find the announcement and we had a going to be done. 

1380
01:19:22,970 --> 01:19:24,040
So announcements, 

1381
01:19:25,280 --> 01:19:27,110
very quick announcements today. 

1382
01:19:28,680 --> 01:19:34,480
Please sign up for design reviews. 

1383
01:19:35,660 --> 01:19:39,450
The design documents also don't forget that due Friday. 

1384
01:19:40,530 --> 01:19:41,030
Next week, 

1385
01:19:41,040 --> 01:19:48,670
you are going to get the feedback on your design documents from your ta you

1386
01:19:48,680 --> 01:19:48,910
need to

1387
01:19:48,920 --> 01:19:51,190
assign for that to schedule that meeting. 

1388
01:19:52,080 --> 01:19:53,830
And the homework one is due today. 

1389
01:19:53,840 --> 01:19:54,910
So good luck with that. 

1390
01:19:56,360 --> 01:19:58,950
So good luck again with the homework, 

1391
01:19:59,480 --> 01:20:02,730
good luck with the design documents and see you all next week. 

1392
01:20:03,650 --> 01:20:04,090
Thank you. 

