1
00:00:20,680 --> 00:00:21,520
Hello, everyone.

2
00:00:23,970 --> 00:00:25,960
Welcome to the 8th lecture. 

3
00:00:27,030 --> 00:00:29,340
This is really an important lecture. 

4
00:00:29,350 --> 00:00:34,810
We are going to learn a lot and continue to learn about synchronization

5
00:00:34,820 --> 00:00:37,090
and how we are going to solve

6
00:00:37,540 --> 00:00:44,500
the problems and ensure a critical provides a critical section abstraction and

7
00:00:45,450 --> 00:00:46,970
and synchronization primitives. 

8
00:00:48,020 --> 00:00:52,420
So let's recall a few things from the last time, in particular,

9
00:00:52,430 --> 00:00:53,300
summer force. 

10
00:00:54,040 --> 00:00:55,110
If you remember, 

11
00:00:55,120 --> 00:00:58,760
some of us are like generalized locks, 

12
00:00:59,170 --> 00:01:01,050
and they are defined many times, 

13
00:01:01,060 --> 00:01:02,130
many years ago, 

14
00:01:02,140 --> 00:01:04,490
like 60 years ago, almost.

15
00:01:04,990 --> 00:01:08,340
And it's it was a main synchronization, 

16
00:01:08,350 --> 00:01:11,600
primitive used in original units. 

17
00:01:11,610 --> 00:01:13,840
And when we are talking here about synchronization, 

18
00:01:13,850 --> 00:01:19,410
we are talking about in the context of implementing a critical section. 

19
00:01:19,420 --> 00:01:21,490
If you remember a critical section, 

20
00:01:22,120 --> 00:01:28,370
a it's a sequence of code as in which only one thread can be

21
00:01:28,380 --> 00:01:29,890
active at a given time. 

22
00:01:30,450 --> 00:01:34,800
Therefore, if one thread is active in a critical section,

23
00:01:35,200 --> 00:01:37,720
the other threads which want to enter the critical section, 

24
00:01:37,730 --> 00:01:40,320
but they could the code they need to wait. 

25
00:01:40,650 --> 00:01:45,050
But I so need a mechanism to synchronize this kind of entrance

26
00:01:45,060 --> 00:01:46,170
to the critical section, 

27
00:01:46,180 --> 00:01:48,730
and then on a thread exit the critical section. 

28
00:01:48,740 --> 00:01:53,160
And as a thread from the waiting ones is going to enter the critical section. 

29
00:01:55,570 --> 00:01:57,280
And there are two primitives, 

30
00:01:57,290 --> 00:02:01,790
b and b b is, 

31
00:02:01,800 --> 00:02:03,070
if the sum of four is zero, 

32
00:02:03,770 --> 00:02:05,370
it be it's waiting. 

33
00:02:05,630 --> 00:02:08,540
If the summer for its greater than zero, it decrement it.

34
00:02:11,290 --> 00:02:13,960
The other one v basically, 

35
00:02:13,970 --> 00:02:16,560
it's just increment a similar follow up by one. 

36
00:02:16,840 --> 00:02:21,150
If the similar for a zero and if it's increment to one, 

37
00:02:21,160 --> 00:02:25,030
then is going to wake up one of this, 

38
00:02:25,510 --> 00:02:27,610
one of the threads, 

39
00:02:27,970 --> 00:02:30,450
which was waiting on a summer for if any. 

40
00:02:32,430 --> 00:02:32,850
Okay. 

41
00:02:33,800 --> 00:02:35,950
These are 2 years of the summer force. 

42
00:02:35,960 --> 00:02:37,710
We went over last time. 

43
00:02:37,720 --> 00:02:39,190
One is mutual exclusion. 

44
00:02:39,560 --> 00:02:42,190
Again, this is about implementing critical sections.

45
00:02:42,900 --> 00:02:43,500
Here. 

46
00:02:45,730 --> 00:02:47,040
It's very simple. 

47
00:02:47,050 --> 00:02:51,610
You are going to initialize the same effort to one. 

48
00:02:52,240 --> 00:02:57,200
And then you put before and after a critical section, 

49
00:02:57,970 --> 00:03:01,670
ap and av the first thread, 

50
00:03:01,680 --> 00:03:06,110
which is going to execute the instruction p that's enough for each one

51
00:03:06,120 --> 00:03:07,230
is going to decrement. 

52
00:03:07,240 --> 00:03:09,230
It is going to enter the critical section. 

53
00:03:09,510 --> 00:03:12,820
If another thread comes and right execute the curve, 

54
00:03:12,830 --> 00:03:14,060
the summer for now is zero. 

55
00:03:14,590 --> 00:03:18,660
It has to wait when the first summer for x is a critical section, 

56
00:03:18,920 --> 00:03:22,310
is calling v and v it's increment in the summer for. 

57
00:03:22,320 --> 00:03:24,110
And therefore, 

58
00:03:24,120 --> 00:03:25,150
as a result, 

59
00:03:25,430 --> 00:03:29,550
we signal the thread who is wiping to enter the critical section. 

60
00:03:30,450 --> 00:03:30,760
Right? 

61
00:03:32,750 --> 00:03:34,940
And it's also the scheduling constraints. 

62
00:03:35,240 --> 00:03:41,520
This is basically we want to signal to wait for a thread or a signal, 

63
00:03:41,530 --> 00:03:42,880
a thread to do something. 

64
00:03:43,770 --> 00:03:45,720
Here, the initial value is zero.

65
00:03:45,730 --> 00:03:50,080
And the classic example is a joint implementation for the thread. 

66
00:03:50,320 --> 00:03:52,910
You remember that with a join, 

67
00:03:52,920 --> 00:03:54,830
the patterns of the thread, 

68
00:03:55,110 --> 00:03:58,150
which execute the joint ways for another step to finish. 

69
00:03:58,540 --> 00:03:59,080
Okay? 

70
00:03:59,600 --> 00:04:01,320
And so basically, the threat,

71
00:04:01,330 --> 00:04:05,670
which way is to finish the join? 

72
00:04:06,070 --> 00:04:07,870
They use to implement this. 

73
00:04:07,880 --> 00:04:11,220
So use the same semaphore. 

74
00:04:11,530 --> 00:04:15,490
So the thread in initialize them for 20, 

75
00:04:15,770 --> 00:04:20,110
and the thread who waits for another thread to join, 

76
00:04:21,400 --> 00:04:24,800
to finish, then it just calling p right?

77
00:04:25,150 --> 00:04:29,120
And if the other thread and the other thread when it finishes, 

78
00:04:29,410 --> 00:04:30,290
is calling me. 

79
00:04:30,620 --> 00:04:32,730
So if the thread hasn't finished, 

80
00:04:33,490 --> 00:04:34,810
the semaphore is zero, 

81
00:04:35,610 --> 00:04:37,410
the join operation will just wait. 

82
00:04:39,010 --> 00:04:42,610
And it will wait until one until the thread. 

83
00:04:42,930 --> 00:04:46,440
We are way it's waiting for its executing this thread finish, 

84
00:04:46,680 --> 00:04:49,830
which calls v is increment in the summer for the one, 

85
00:04:49,840 --> 00:04:53,550
which means that and seeing signals a waiting thread

86
00:04:53,560 --> 00:04:57,510
and there's waiting thread now the summer for each one and going to

87
00:04:58,140 --> 00:05:03,780
start executing and decrementing it to zero and finish a code, 

88
00:05:04,620 --> 00:05:06,290
finish the joint operation. 

89
00:05:09,970 --> 00:05:10,860
Any questions? 

90
00:05:13,700 --> 00:05:15,210
Please ask any questions. 

91
00:05:17,750 --> 00:05:25,150
If you have any and then we want to to this bounded buffer. 

92
00:05:25,160 --> 00:05:26,990
So you remember the bounded buffer. 

93
00:05:27,000 --> 00:05:28,720
We have a bunch of producers, 

94
00:05:28,730 --> 00:05:29,880
a bunch of consumers, 

95
00:05:29,890 --> 00:05:31,910
the producer put elements in the buffer. 

96
00:05:32,270 --> 00:05:35,240
The consumers get elements around the buffer. 

97
00:05:37,570 --> 00:05:40,430
You hear, if you look at the constraints,

98
00:05:40,440 --> 00:05:43,990
what we are talking about here is that for the consumer must wait

99
00:05:44,000 --> 00:05:45,910
for the producer to fill the buffer. 

100
00:05:46,060 --> 00:05:47,470
If the buffer is empty, 

101
00:05:47,480 --> 00:05:49,270
then the consumer have to wait. 

102
00:05:49,540 --> 00:05:50,280
On the other hand, 

103
00:05:50,290 --> 00:05:53,710
the producers must wait for the consumer to empty the buffer. 

104
00:05:53,720 --> 00:05:55,270
If the buffer is full, 

105
00:05:55,280 --> 00:05:57,070
then the producer has to wait, 

106
00:05:57,080 --> 00:06:01,520
because there are no place in the buffer doing to put new elements. 

107
00:06:03,130 --> 00:06:05,580
And there is, obviously,

108
00:06:05,590 --> 00:06:09,990
there is the buffer is self manipulating the buffer or the queue. 

109
00:06:10,000 --> 00:06:11,350
It's basically, 

110
00:06:11,360 --> 00:06:12,470
it's a critical section, 

111
00:06:12,480 --> 00:06:17,180
and only one thread is going to manipulate iq right? 

112
00:06:17,890 --> 00:06:23,300
Is that one consumer or one or one producer? 

113
00:06:23,770 --> 00:06:24,110
Right? 

114
00:06:26,410 --> 00:06:27,000
Okay. 

115
00:06:27,380 --> 00:06:31,040
So how we are going to implement it, one implement.

116
00:06:31,050 --> 00:06:32,800
We are going for each of these constraint. 

117
00:06:33,610 --> 00:06:36,310
We are going to use a semaphore. 

118
00:06:36,980 --> 00:06:39,570
We are going to use a semaphore for full buffers. 

119
00:06:39,980 --> 00:06:43,650
This is consumer constraint and empty buffers. 

120
00:06:46,120 --> 00:06:47,470
Basically, each of these singapore,

121
00:06:47,480 --> 00:06:48,670
at a given time, 

122
00:06:48,680 --> 00:06:54,530
will show how many elements are in the buffer full buffers, 

123
00:06:54,840 --> 00:06:57,780
and how many elements you can still put in the buffer. 

124
00:06:58,120 --> 00:07:00,180
Basically, if you add that to this to similar force,

125
00:07:00,190 --> 00:07:04,720
you should get the total number of elements that buffer size. 

126
00:07:05,440 --> 00:07:07,350
Then a mutex are for mutex, 

127
00:07:07,360 --> 00:07:08,630
for the mutual exclusion. 

128
00:07:08,910 --> 00:07:15,840
To make sure that you have only one thread manipulating the queue that is

129
00:07:15,850 --> 00:07:16,880
whether inserting a new

130
00:07:16,890 --> 00:07:19,040
element or removing an element from the queue. 

131
00:07:21,230 --> 00:07:24,750
Let's start full slots is basically zero, 

132
00:07:24,970 --> 00:07:27,360
because initially, 

133
00:07:27,890 --> 00:07:29,440
there is nothing in the queue. 

134
00:07:29,720 --> 00:07:31,180
Empty slots is a buffer size. 

135
00:07:31,460 --> 00:07:34,150
Remember, if you add here full slots with empty slots,

136
00:07:34,160 --> 00:07:36,250
you get the size of the buffer. 

137
00:07:36,730 --> 00:07:38,370
And mutex is one like that. 

138
00:07:40,220 --> 00:07:41,770
No one is in the critical section. 

139
00:07:42,360 --> 00:07:44,480
And the producers and is very simple, right?

140
00:07:44,490 --> 00:07:48,860
It's like, basically, you are waiting for slows to be available.

141
00:07:53,600 --> 00:07:58,640
Then you use a mutex to protect the critical section. 

142
00:07:58,890 --> 00:08:00,490
And then once you are done, 

143
00:08:00,500 --> 00:08:04,800
you are implementing the number of slots or full slots, right?

144
00:08:04,810 --> 00:08:06,250
Because you added on element. 

145
00:08:07,230 --> 00:08:09,270
And the consumer is very similar. 

146
00:08:09,880 --> 00:08:15,770
You are waiting for to full slots to be greater than zero. 

147
00:08:15,780 --> 00:08:18,930
This means as at least one element in the buffer. 

148
00:08:19,300 --> 00:08:21,930
If it's you have more than one element in the buffer, 

149
00:08:21,940 --> 00:08:23,250
you can be cue that element. 

150
00:08:23,680 --> 00:08:26,760
Again, the dq operation is protected by the mutex.

151
00:08:27,460 --> 00:08:30,010
Then once you are done, 

152
00:08:30,020 --> 00:08:32,010
you are going to increment the empty slots, 

153
00:08:32,020 --> 00:08:36,830
because now it's one more available slots in the queue and return the item. 

154
00:08:38,860 --> 00:08:46,150
So that's basically here in use a mutex to protect the critical section. 

155
00:08:46,610 --> 00:08:51,400
Therefore, no two threads at the same time operates on the queue to remove,

156
00:08:51,410 --> 00:08:53,720
to manipulate the pointers, to remove that,

157
00:08:55,220 --> 00:08:57,250
the elements or to add the element to the cure. 

158
00:08:58,140 --> 00:09:02,290
The other one are scheduling constraints of full slots, 

159
00:09:02,520 --> 00:09:04,550
is incremental by the producer, 

160
00:09:04,560 --> 00:09:06,910
and then is diplomatic by the consumer. 

161
00:09:06,920 --> 00:09:08,270
And similarly, 

162
00:09:08,530 --> 00:09:14,050
the empty space is implemented by the consumer and decrement it by the progress. 

163
00:09:21,550 --> 00:09:22,440
Any questions? 

164
00:09:28,250 --> 00:09:29,720
A discussion about solution? 

165
00:09:30,760 --> 00:09:32,910
You can see there is a symmetry, right?

166
00:09:33,940 --> 00:09:41,280
The producer is doing is calling p and then v on empty graph buffers

167
00:09:41,290 --> 00:09:42,360
and full buffers. 

168
00:09:43,000 --> 00:09:48,240
The consumer does the reserve reverse is calling people on the full buffers

169
00:09:48,250 --> 00:09:49,720
and be on the empty buffers, 

170
00:09:49,730 --> 00:09:50,080
right? 

171
00:09:52,190 --> 00:09:53,620
It is this asymmetry. 

172
00:09:53,910 --> 00:09:54,380
Okay. 

173
00:09:55,010 --> 00:09:56,460
It's exactly what to expect, right?

174
00:09:56,470 --> 00:09:59,710
Because the producer has to decrease the number of empty slots and increase

175
00:09:59,720 --> 00:10:00,960
the number of occupy slots. 

176
00:10:02,320 --> 00:10:03,490
And the consumer, 

177
00:10:03,970 --> 00:10:11,620
sorry, the producer has to wait for the producer.

178
00:10:12,100 --> 00:10:12,380
Yeah. 

179
00:10:13,110 --> 00:10:16,120
It's as to wait for empty starts to be available. 

180
00:10:16,130 --> 00:10:17,720
But then once you put the element, 

181
00:10:17,730 --> 00:10:20,400
you decrease the number of empty slots and you increase the numbers

182
00:10:20,410 --> 00:10:21,360
of occupied slots. 

183
00:10:21,580 --> 00:10:23,400
As a consumer is the other way around. 

184
00:10:23,660 --> 00:10:27,850
When there is at least one element in the buffer, 

185
00:10:27,860 --> 00:10:31,630
you decrease the number of occupied slots because you take one element, 

186
00:10:32,070 --> 00:10:35,120
then also this increase the number of empty slots. 

187
00:10:35,570 --> 00:10:35,850
Right? 

188
00:10:37,660 --> 00:10:39,450
Now, this is a question for you.

189
00:10:41,990 --> 00:10:47,010
If there is that you remember in the original code, 

190
00:10:48,740 --> 00:10:54,350
let me guess what this we called first produce that calls first smfop

191
00:10:54,360 --> 00:10:55,630
on the empty slots, 

192
00:10:55,640 --> 00:10:56,910
and then the mutex. 

193
00:10:57,880 --> 00:11:00,250
Now, is that order important?

194
00:11:05,060 --> 00:11:06,330
That's a question for the class. 

195
00:11:08,570 --> 00:11:11,160
Looking forward to your replies to your answers? 

196
00:11:23,720 --> 00:11:24,320
Yes. 

197
00:11:26,340 --> 00:11:27,010
It is. 

198
00:11:30,550 --> 00:11:33,040
If you do this, it can be, we can deadlock.

199
00:11:34,260 --> 00:11:36,680
Can someone explain how you can get the dialogue? 

200
00:11:36,690 --> 00:11:36,980
Here? 

201
00:11:36,990 --> 00:11:37,280
Is? 

202
00:11:42,930 --> 00:11:43,720
Very simple? 

203
00:12:00,760 --> 00:12:01,160
Thank you. 

204
00:12:01,170 --> 00:12:01,560
I don't know. 

205
00:12:01,570 --> 00:12:02,280
Actually. 

206
00:12:04,230 --> 00:12:05,630
Basically, it's very simple, right?

207
00:12:05,640 --> 00:12:06,470
For instance, 

208
00:12:07,090 --> 00:12:09,340
you imagine that he's a producer, 

209
00:12:09,950 --> 00:12:12,900
the empty slots that are now empty slots. 

210
00:12:16,130 --> 00:12:17,040
Empty slots is zero. 

211
00:12:17,690 --> 00:12:18,280
What happens? 

212
00:12:18,890 --> 00:12:21,250
You acquire the mutex for the critical section, 

213
00:12:22,940 --> 00:12:26,180
and then you are going to start waiting, 

214
00:12:26,430 --> 00:12:27,780
because empty stocks is zero. 

215
00:12:29,510 --> 00:12:29,920
Right? 

216
00:12:30,170 --> 00:12:33,930
There is no place in the cure to insert a new element, rather new element.

217
00:12:34,880 --> 00:12:38,240
But now you are going to wait in the critical section. 

218
00:12:40,780 --> 00:12:44,720
And the only way the empty slots can be increment. 

219
00:12:45,210 --> 00:12:46,390
It is by the consumer. 

220
00:12:48,430 --> 00:12:49,900
But in order to do that, 

221
00:12:49,910 --> 00:12:52,100
the consumer has to

222
00:12:58,080 --> 00:13:00,610
the consumer has to be cure and operation. 

223
00:13:00,620 --> 00:13:03,910
But for that, you need to acquire a mutex.

224
00:13:04,800 --> 00:13:05,810
But you own the mutex. 

225
00:13:05,820 --> 00:13:06,970
The producer owns a mutex. 

226
00:13:06,980 --> 00:13:08,810
So you cannot acquire the mutex, 

227
00:13:09,050 --> 00:13:11,960
because you can have only one thread in the critical section. 

228
00:13:12,260 --> 00:13:14,970
So therefore, consumer cannot be cure any element.

229
00:13:15,410 --> 00:13:15,750
Therefore, 

230
00:13:15,760 --> 00:13:21,960
the producer will continue to wait for the empty slots to be implemented, 

231
00:13:22,350 --> 00:13:23,230
which will never happen. 

232
00:13:25,910 --> 00:13:26,340
Very good. 

233
00:13:29,500 --> 00:13:31,090
Is the order of the important. 

234
00:13:31,340 --> 00:13:33,350
I have the answer here is that yeah, 

235
00:13:33,360 --> 00:13:35,310
now because they just do the increment. 

236
00:13:37,620 --> 00:13:39,730
What if you have to produce and to consumers? 

237
00:13:39,740 --> 00:13:43,650
Is this? 

238
00:13:43,980 --> 00:13:50,360
Do you need any changes I to the previous code which is working? 

239
00:13:51,050 --> 00:13:51,970
Not to this one? 

240
00:13:51,980 --> 00:13:58,360
So assuming that some of the end mutex and empty slots are not, 

241
00:13:59,240 --> 00:13:59,800
are you ordered? 

242
00:14:07,520 --> 00:14:10,160
So do you need to make any changes to this code? 

243
00:14:13,440 --> 00:14:15,110
If I have to go to seven to consumers

244
00:14:32,420 --> 00:14:32,970
on ali, 

245
00:14:33,320 --> 00:14:34,540
you are correct now. 

246
00:14:35,570 --> 00:14:41,030
You don't need to do it to do to make any change is going just to work. 

247
00:14:41,370 --> 00:14:42,920
The reason is going to work. 

248
00:14:42,930 --> 00:14:47,940
It's again because no matter how many consumer and producers are going to have, 

249
00:14:48,660 --> 00:14:53,810
you can at its only one of those can be in the critical section. 

250
00:14:58,240 --> 00:14:59,230
Yes, exactly.

251
00:15:01,230 --> 00:15:01,870
Thank you. 

252
00:15:05,950 --> 00:15:06,360
Good. 

253
00:15:11,170 --> 00:15:11,600
It's again. 

254
00:15:11,610 --> 00:15:15,310
So you can see that b and v are the synchronization primitives. 

255
00:15:15,640 --> 00:15:18,330
And now, 

256
00:15:18,340 --> 00:15:21,170
what we are going to do in the rest of these lectures, 

257
00:15:21,180 --> 00:15:25,620
we are going to try to figure out how to implement the synchronization primitives. 

258
00:15:26,330 --> 00:15:30,480
Synchronization, primitive pnb are at the higher level.

259
00:15:30,890 --> 00:15:32,310
But as a low level, 

260
00:15:32,670 --> 00:15:38,340
you have what you have on you up in the when you talk about when you

261
00:15:38,350 --> 00:15:39,540
are talking about the processor, 

262
00:15:41,610 --> 00:15:42,520
what you can do, 

263
00:15:43,240 --> 00:15:45,210
you can execute instructions, 

264
00:15:45,460 --> 00:15:46,710
like load and stores. 

265
00:15:47,350 --> 00:15:49,060
You can disable interacts. 

266
00:15:49,390 --> 00:15:53,220
And then we'll see there are a few other specialized instructions, 

267
00:15:53,230 --> 00:15:54,380
like test and set, 

268
00:15:54,820 --> 00:15:56,180
and compare and swap, 

269
00:15:56,980 --> 00:16:02,710
which it make it much easier to implement higher level synchronization primitives. 

270
00:16:02,950 --> 00:16:04,290
Because like you'll see, 

271
00:16:04,530 --> 00:16:07,400
using just slowed and stored and disabled interrupts, 

272
00:16:07,760 --> 00:16:09,490
they are not ideal solutions. 

273
00:16:10,810 --> 00:16:11,180
Right? 

274
00:16:11,490 --> 00:16:13,600
Then as a higher level, we have blocks.

275
00:16:13,610 --> 00:16:14,760
We discussed last time, 

276
00:16:14,770 --> 00:16:17,370
we are going to discuss more this lecture, 

277
00:16:17,840 --> 00:16:23,160
summer force, and then monitors and send receipts operation.

278
00:16:23,170 --> 00:16:27,560
But money we are going to discuss locks somewhere for their implementation. 

279
00:16:30,170 --> 00:16:34,400
And hopefully you are going to also get to monitors during this lecture. 

280
00:16:36,240 --> 00:16:38,300
And then programs is a higher. 

281
00:16:39,090 --> 00:16:39,870
There are higher. 

282
00:16:39,880 --> 00:16:41,590
Abstraction is a program level, 

283
00:16:42,560 --> 00:16:46,750
and we are not going to talk about them at least this week. 

284
00:16:49,400 --> 00:16:52,040
And here is a motivating example, okay?

285
00:16:52,420 --> 00:16:55,020
If you haven't paid too much attention until now, 

286
00:16:55,030 --> 00:16:57,580
at least from now on for these examples, 

287
00:16:57,590 --> 00:17:00,890
pay attention because it will earn you a lot. 

288
00:17:01,280 --> 00:17:04,300
And remember that next wednesday, 

289
00:17:04,660 --> 00:17:05,790
we have the first meet up. 

290
00:17:07,040 --> 00:17:13,440
And the next lecture are going to be part of the topics covered by the meter. 

291
00:17:15,220 --> 00:17:16,960
So here is a problem. 

292
00:17:17,350 --> 00:17:20,010
And basically, 

293
00:17:20,020 --> 00:17:25,460
the problem is that there are two roommates and both of them like mom, 

294
00:17:25,470 --> 00:17:26,420
they like milk. 

295
00:17:26,980 --> 00:17:31,230
And the the question, 

296
00:17:31,240 --> 00:17:35,500
the problem is that if there is no milk in the fridge, 

297
00:17:35,730 --> 00:17:40,050
then whoever discovers that they are going to go and get milk, 

298
00:17:40,620 --> 00:17:41,020
right? 

299
00:17:41,500 --> 00:17:46,740
And we want the goal here is to not get too much milk. 

300
00:17:46,750 --> 00:17:48,500
And how can you get too much milk? 

301
00:17:48,510 --> 00:17:49,020
Well, 

302
00:17:49,800 --> 00:17:56,190
think about The same sequence of events at 3 o'clock. 

303
00:17:57,530 --> 00:17:58,480
First from my parents, 

304
00:17:59,130 --> 00:18:02,080
let's call her a person a look in the fridge. 

305
00:18:02,090 --> 00:18:07,640
There is no milk leaves to goes to the store at this star. 

306
00:18:08,090 --> 00:18:11,200
And while arriving at the store is a closed door. 

307
00:18:12,080 --> 00:18:17,030
The second roommate called her person b look at the fridge and it's out of milk. 

308
00:18:18,210 --> 00:18:24,780
She's going to do the same thing before store and arrival store. 

309
00:18:25,580 --> 00:18:26,620
During this time, 

310
00:18:26,630 --> 00:18:28,600
the a person a left, 

311
00:18:28,610 --> 00:18:31,160
the store arrive at her home, 

312
00:18:31,170 --> 00:18:32,680
put the milk in the fridge, 

313
00:18:32,890 --> 00:18:35,280
while the person b is at the store buying milk, 

314
00:18:35,720 --> 00:18:38,670
then we are going to get at the end of the day. 

315
00:18:38,680 --> 00:18:41,670
We are going to have 2 bottle of milks in the fridge. 

316
00:18:42,490 --> 00:18:42,880
Okay? 

317
00:18:43,800 --> 00:18:48,580
This solution certainly doesn't do what you wanted and what you

318
00:18:48,590 --> 00:18:50,340
wanted to not buy too much milk. 

319
00:18:55,070 --> 00:18:55,970
How do we do that? 

320
00:18:56,570 --> 00:18:58,720
Obviously, we want to,

321
00:18:59,870 --> 00:19:00,420
we can, 

322
00:19:01,480 --> 00:19:03,220
the problem here is that, 

323
00:19:03,450 --> 00:19:09,690
in some sense, both person a and b execute the same instructions,

324
00:19:10,100 --> 00:19:11,570
and so to speak, 

325
00:19:11,910 --> 00:19:15,790
take the same actions without kind of any coordination, they do.

326
00:19:15,800 --> 00:19:20,630
They execute that kind of code each of them at the same time, right?

327
00:19:21,650 --> 00:19:29,350
What do you you want only one person of the two to go to the to the store

328
00:19:29,360 --> 00:19:30,150
to buy milk. 

329
00:19:30,560 --> 00:19:30,880
Right? 

330
00:19:31,740 --> 00:19:34,990
So basically, you can see now the concept of critical section,

331
00:19:35,000 --> 00:19:39,840
if you think about the program is going to the fridge and going

332
00:19:39,850 --> 00:19:41,880
to the store to buy milk, 

333
00:19:42,290 --> 00:19:44,120
we want only one person to do it. 

334
00:19:45,590 --> 00:19:47,080
One way to prevent that, 

335
00:19:47,090 --> 00:19:48,880
like we learn and we saw. 

336
00:19:48,890 --> 00:19:50,980
So last time is to have locks. 

337
00:19:52,610 --> 00:19:57,120
So you look before entering the critical section, 

338
00:19:57,610 --> 00:19:59,980
you unlock after leaving the critical section. 

339
00:20:01,940 --> 00:20:02,420
Now, 

340
00:20:02,960 --> 00:20:05,960
the one important things which will come over and over again, 

341
00:20:05,970 --> 00:20:13,640
and what makes the implementation of locks challenging

342
00:20:14,360 --> 00:20:21,270
is that any lock implementation or synchronization, 

343
00:20:22,010 --> 00:20:28,550
primitive implementation involve waiting. 

344
00:20:29,380 --> 00:20:30,260
And why is that? 

345
00:20:30,270 --> 00:20:32,020
It should be obvious, right?

346
00:20:32,360 --> 00:20:38,250
Because if many threads wants to enter the same critical section, 

347
00:20:39,500 --> 00:20:41,360
and only one at a time can do it, 

348
00:20:42,750 --> 00:20:48,910
this means that why not go in a critical section and the other ones? 

349
00:20:49,400 --> 00:20:51,030
What they can do, they have to wait.

350
00:20:51,430 --> 00:20:52,390
There is no around it. 

351
00:20:54,770 --> 00:20:55,160
Right? 

352
00:20:56,840 --> 00:20:57,910
So remember the boat. 

353
00:21:00,390 --> 00:21:02,010
So you can, 

354
00:21:02,530 --> 00:21:06,270
one way to do it is to lock all the way, also the fridge.

355
00:21:06,280 --> 00:21:09,500
And basically, you go to,

356
00:21:10,880 --> 00:21:13,790
before you go to the store, you lock the fridge.

357
00:21:14,290 --> 00:21:16,450
If the other person sees come to, 

358
00:21:16,460 --> 00:21:17,690
the fridge is locked, 

359
00:21:17,700 --> 00:21:24,210
but is going to wait for you to unlock the fridge. 

360
00:21:24,640 --> 00:21:29,040
And then this guarantee that it's only one person you're buying the milk. 

361
00:21:29,520 --> 00:21:31,390
But this is not ideal, 

362
00:21:31,400 --> 00:21:37,180
because what if the other person wants something else and milk from the fridge? 

363
00:21:37,690 --> 00:21:41,420
Is so this is kind of very coarse grain solution. 

364
00:21:49,800 --> 00:21:53,370
Let's see how we are going to solve this problem. 

365
00:21:57,910 --> 00:22:00,080
And before doing that, 

366
00:22:00,650 --> 00:22:03,940
again, it's like this is a tricky problem.

367
00:22:03,950 --> 00:22:10,540
And this general these problems when concurrency problems are tricky, 

368
00:22:12,060 --> 00:22:16,590
and they are tricky fundamentally because there are many entities doing

369
00:22:16,600 --> 00:22:18,270
the same things at the same time. 

370
00:22:18,890 --> 00:22:20,190
And it just, 

371
00:22:20,750 --> 00:22:21,670
as a human said, 

372
00:22:21,680 --> 00:22:26,720
we are more used to thinking linearly than thinking about many things

373
00:22:26,730 --> 00:22:27,720
happening at the same time. 

374
00:22:27,730 --> 00:22:29,120
We are not very good at that. 

375
00:22:30,200 --> 00:22:36,140
So that's one of the reason you can very well miss different edges. 

376
00:22:36,460 --> 00:22:42,300
So what you want when you have to deal with this kind of problem, 

377
00:22:43,150 --> 00:22:46,830
actually, you want to do that when you deal with any kind of problem,

378
00:22:46,840 --> 00:22:47,990
programming problem. 

379
00:22:48,200 --> 00:22:50,030
But in particular, this kind of problems,

380
00:22:50,040 --> 00:22:53,230
you need to be very careful and think quite a bit about what you

381
00:22:53,240 --> 00:22:57,780
want to achieve and how to make the development solution to meet those, 

382
00:22:59,430 --> 00:23:00,990
the requirements you want to achieve. 

383
00:23:01,500 --> 00:23:02,000
Okay? 

384
00:23:02,410 --> 00:23:03,720
Don't start to code. 

385
00:23:03,930 --> 00:23:05,770
First, I just think,

386
00:23:06,270 --> 00:23:06,670
first, 

387
00:23:09,010 --> 00:23:13,000
again, the way to think about it is to write down what you want to happen.

388
00:23:13,430 --> 00:23:13,820
Right? 

389
00:23:15,070 --> 00:23:17,150
And what do you want to happen here? 

390
00:23:17,160 --> 00:23:19,190
Or what are the correctness properties? 

391
00:23:21,220 --> 00:23:25,050
You want no more than one person buy some milk at a time, right?

392
00:23:25,060 --> 00:23:26,890
If two person buys milk at a time, 

393
00:23:27,740 --> 00:23:29,220
you end up with the bottle of peace. 

394
00:23:29,230 --> 00:23:32,680
I I at the same time. 

395
00:23:33,010 --> 00:23:34,410
If there is no milk, 

396
00:23:35,480 --> 00:23:38,270
there must be someone buying the milk, 

397
00:23:38,280 --> 00:23:40,670
otherwise you don't get the milk. 

398
00:23:42,320 --> 00:23:42,750
Okay. 

399
00:23:44,590 --> 00:23:51,460
And let's think about if you restrict yourself to just load and store. 

400
00:23:51,470 --> 00:23:56,800
So load and store meaning that you are going to modify some variable

401
00:23:56,810 --> 00:23:57,640
in the memory, 

402
00:23:59,050 --> 00:24:00,280
which can be legal, 

403
00:24:00,290 --> 00:24:02,450
which can be read by any program. 

404
00:24:06,840 --> 00:24:07,790
Here is an example, 

405
00:24:08,360 --> 00:24:16,310
the way we are going to emulate this loud in stores in in this problem is

406
00:24:16,320 --> 00:24:17,030
through notes. 

407
00:24:17,330 --> 00:24:17,720
Right? 

408
00:24:18,030 --> 00:24:21,100
You put an out on the fridge with a message. 

409
00:24:21,110 --> 00:24:24,630
This is basically it's equivalent to studying. 

410
00:24:24,940 --> 00:24:26,580
And you read the note, 

411
00:24:27,060 --> 00:24:35,470
obviously, and it's a cable entries are allowed.

412
00:24:40,300 --> 00:24:42,690
Let's say what we have here. 

413
00:24:43,340 --> 00:24:47,520
We have do notes the kind of notes one, 

414
00:24:47,530 --> 00:24:50,080
and it's, sorry, 1note.

415
00:24:50,820 --> 00:24:53,410
And then what is what is a code? 

416
00:24:53,420 --> 00:24:58,350
One possible power code can be one a possible solution is like, 

417
00:24:58,640 --> 00:25:00,450
if there is no milk, right?

418
00:25:01,280 --> 00:25:02,520
And there is no note, 

419
00:25:02,530 --> 00:25:09,650
we assume here that a note indicates that someone else is going to buy the milk. 

420
00:25:10,730 --> 00:25:14,930
Then you leave note and yourself going to go to buy the milk. 

421
00:25:15,510 --> 00:25:17,590
And when you come back, you remove them out.

422
00:25:18,660 --> 00:25:18,980
Right? 

423
00:25:20,070 --> 00:25:20,750
Simply enough, 

424
00:25:22,920 --> 00:25:23,990
what can happen here? 

425
00:25:24,000 --> 00:25:24,270
Right? 

426
00:25:24,850 --> 00:25:26,200
Do you think is a good solution? 

427
00:25:36,210 --> 00:25:37,310
Let's see, no answer here.

428
00:25:38,120 --> 00:25:39,520
It's not a good solution right? 

429
00:25:39,810 --> 00:25:40,080
In. 

430
00:25:40,650 --> 00:25:41,760
We have an answer, 

431
00:25:47,510 --> 00:25:49,420
not atomic that could cause problems. 

432
00:25:49,990 --> 00:25:52,270
There are problems here. 

433
00:25:52,670 --> 00:25:54,590
And the way to look at, again,

434
00:25:54,600 --> 00:25:55,750
these people this can work. 

435
00:25:55,760 --> 00:25:57,790
But if this is done by machines, 

436
00:25:58,380 --> 00:25:59,340
the machines are myopic. 

437
00:25:59,350 --> 00:26:00,890
They only see this instruction, 

438
00:26:00,900 --> 00:26:02,130
they only nothing else. 

439
00:26:03,780 --> 00:26:05,180
So let's see what can happen. 

440
00:26:05,190 --> 00:26:08,480
And always in these concurrency problems, 

441
00:26:08,800 --> 00:26:14,120
the bad things can happen if somehow the instruction are interleaved

442
00:26:14,130 --> 00:26:15,960
in an unfortunate way. 

443
00:26:17,850 --> 00:26:19,230
So let's see here what can happen? 

444
00:26:19,580 --> 00:26:22,750
Let's say we have thread a and thread b now, 

445
00:26:22,760 --> 00:26:26,250
thread a is looking and check for the milk. 

446
00:26:27,170 --> 00:26:29,860
And then once thread a checks for the milk, 

447
00:26:30,340 --> 00:26:36,620
it's context switched is suspended by the operating system by the scheduler. 

448
00:26:37,120 --> 00:26:40,120
And thread b can start to execute. 

449
00:26:40,840 --> 00:26:42,110
And thread b is, again,

450
00:26:42,120 --> 00:26:43,350
check for no milk. 

451
00:26:43,620 --> 00:26:45,070
And in both cases, 

452
00:26:45,460 --> 00:26:48,440
the answer, it says through there is no milk,

453
00:26:48,940 --> 00:26:49,360
right? 

454
00:26:49,990 --> 00:26:53,400
But after and then thread b is checked for the note. 

455
00:26:54,260 --> 00:26:54,740
Okay? 

456
00:26:55,220 --> 00:26:56,450
There is no note. 

457
00:26:56,870 --> 00:26:59,440
But after checks for the note, 

458
00:26:59,830 --> 00:27:04,930
again, that we contact switch to thread a they check again for the notes,

459
00:27:04,940 --> 00:27:07,030
and there is no note and leaves a note. 

460
00:27:07,850 --> 00:27:08,150
Right? 

461
00:27:09,330 --> 00:27:09,950
Buy milk, 

462
00:27:10,780 --> 00:27:11,620
removed note. 

463
00:27:12,200 --> 00:27:13,900
Thread b is going to do the same thing. 

464
00:27:14,710 --> 00:27:15,020
Right? 

465
00:27:15,550 --> 00:27:16,720
Because from the point of view, 

466
00:27:16,730 --> 00:27:19,560
there is thread b is there is no milk, is there is no note.

467
00:27:20,340 --> 00:27:23,090
From the second point of view of saturday, 

468
00:27:23,100 --> 00:27:26,130
the same as true when you check or it was no milk. 

469
00:27:26,140 --> 00:27:28,690
And when he's checked was there is 00. 

470
00:27:28,700 --> 00:27:37,350
Now, note you have now both thread a and thread b buying milk.

471
00:27:39,630 --> 00:27:40,460
Any questions yet? 

472
00:27:47,520 --> 00:27:48,590
So it's too much milk. 

473
00:27:49,890 --> 00:27:51,430
This happened occasionally, 

474
00:27:52,550 --> 00:27:53,000
right? 

475
00:27:53,330 --> 00:27:57,430
If you don't have this unfortunate order of execution, 

476
00:27:57,900 --> 00:27:59,360
actually, this code will work.

477
00:28:00,540 --> 00:28:07,640
The problem is this what happened occasionally is that you may say

478
00:28:07,650 --> 00:28:08,360
it's good news, 

479
00:28:08,370 --> 00:28:08,720
right? 

480
00:28:08,730 --> 00:28:11,100
It's like, it's only happens from time to time.

481
00:28:11,510 --> 00:28:14,980
But the problem that when this happens is very hard to remember, 

482
00:28:14,990 --> 00:28:17,200
because it's not happen all the time. 

483
00:28:17,940 --> 00:28:18,330
Right? 

484
00:28:20,300 --> 00:28:22,330
That's what also makes these problems. 

485
00:28:23,220 --> 00:28:25,080
All this program frustrating, 

486
00:28:25,460 --> 00:28:27,630
because they are very hard to debug. 

487
00:28:28,730 --> 00:28:32,520
Another reason to think very well before starting took out. 

488
00:28:34,140 --> 00:28:35,780
Okay, so how do you solve this problem?

489
00:28:36,570 --> 00:28:36,860
Right? 

490
00:28:37,850 --> 00:28:41,970
So clearly, this note is not exclusive enough.

491
00:28:43,940 --> 00:28:44,880
And one, good.

492
00:28:44,890 --> 00:28:46,560
So one solution, am I saying,

493
00:28:46,570 --> 00:28:48,840
is because it's not why don't replace a note? 

494
00:28:50,400 --> 00:28:50,810
First, right?

495
00:28:52,030 --> 00:28:53,270
What if we do this code? 

496
00:28:56,040 --> 00:28:56,230
Right? 

497
00:28:56,240 --> 00:28:59,890
Instead of checking for the note, 

498
00:29:01,350 --> 00:29:02,440
leaving the note, 

499
00:29:03,560 --> 00:29:04,600
before buying the milk? 

500
00:29:04,610 --> 00:29:07,740
Let's leave the note even before we check for the milk. 

501
00:29:09,250 --> 00:29:10,190
What about this crowd? 

502
00:29:14,920 --> 00:29:16,350
Any problem with this crowd? 

503
00:29:25,360 --> 00:29:25,960
Yes. 

504
00:29:26,730 --> 00:29:30,040
A actually, 

505
00:29:30,050 --> 00:29:31,440
this is a pretty stupid coach, 

506
00:29:32,410 --> 00:29:34,890
because if you leave that out here, 

507
00:29:37,340 --> 00:29:41,180
then if now it will be always true. 

508
00:29:43,660 --> 00:29:44,170
Right? 

509
00:29:47,980 --> 00:29:48,720
You don't know. 

510
00:29:51,360 --> 00:29:51,860
Sorry. 

511
00:29:52,190 --> 00:29:54,900
If now there will be always false and no one will buy me. 

512
00:29:56,380 --> 00:29:57,890
Let's see if you leave them out. 

513
00:29:58,860 --> 00:29:59,290
Good night. 

514
00:29:59,550 --> 00:30:01,090
If you leave yourselves a note, 

515
00:30:03,300 --> 00:30:04,880
and then you check for the note. 

516
00:30:05,300 --> 00:30:06,070
There is a note. 

517
00:30:06,850 --> 00:30:07,780
So you don't buy milk. 

518
00:30:08,320 --> 00:30:10,380
That's I was saying this is stupid. 

519
00:30:12,820 --> 00:30:14,950
So you don't do a given for one user. 

520
00:30:17,870 --> 00:30:18,160
Okay? 

521
00:30:21,730 --> 00:30:28,090
Let's go to solution to this kind of didn't work. 

522
00:30:28,510 --> 00:30:29,980
Maybe we need to be more sophisticated. 

523
00:30:29,990 --> 00:30:32,230
Maybe we need to have 2 kind two notes, 

524
00:30:33,110 --> 00:30:33,440
right? 

525
00:30:35,370 --> 00:30:36,480
One for each person. 

526
00:30:38,810 --> 00:30:40,760
Let's rewrite the previous code, 

527
00:30:42,070 --> 00:30:49,210
thread a leave note a thread b leave not b and thread a jokes for checks

528
00:30:49,220 --> 00:30:51,250
was a thread b left and out. 

529
00:30:52,100 --> 00:30:55,120
And thread b checks was a thread a left or not. 

530
00:30:59,750 --> 00:31:01,980
Seems more sophisticated, may work, maybe.

531
00:31:02,630 --> 00:31:04,030
What do you think it is going to work? 

532
00:31:17,720 --> 00:31:18,680
Okay, why don't you guess?

533
00:31:18,970 --> 00:31:19,880
You don't need to tell me? 

534
00:31:19,890 --> 00:31:24,070
But whether why is going to work or not? 

535
00:31:24,700 --> 00:31:25,860
Just take a guess. 

536
00:31:36,710 --> 00:31:38,060
Now, good answer.

537
00:31:39,060 --> 00:31:40,980
Ii hope that this answer is not given, 

538
00:31:40,990 --> 00:31:43,100
because you looked at the next slide. 

539
00:31:44,590 --> 00:31:45,540
But anyway, 

540
00:31:46,240 --> 00:31:49,080
so now it doesn't work. 

541
00:31:49,090 --> 00:31:52,600
And here is a reason and another an example. 

542
00:31:54,440 --> 00:31:54,820
Again, 

543
00:31:54,830 --> 00:31:57,940
it's about how this instruction instructions are interleaved

544
00:31:58,480 --> 00:31:59,510
from saturday and saturday. 

545
00:32:00,180 --> 00:32:01,730
B you live now day. 

546
00:32:03,300 --> 00:32:11,220
You leave now be thread a leaves note a then we contact switch to thread b sarah

547
00:32:11,230 --> 00:32:15,160
believes not be is checked for them if there is no day. 

548
00:32:15,700 --> 00:32:18,680
And basically a nowadays. 

549
00:32:18,690 --> 00:32:20,290
So this is false. 

550
00:32:21,070 --> 00:32:23,790
And this is not going to execute it. 

551
00:32:25,580 --> 00:32:26,770
At the same time. 

552
00:32:27,280 --> 00:32:32,550
Said a is looking or there is a node b there is a node be. 

553
00:32:32,560 --> 00:32:34,150
So this is really false. 

554
00:32:34,730 --> 00:32:39,030
So it's not going to execute the if what is under the wave condition. 

555
00:32:39,040 --> 00:32:41,020
And at the end of them, 

556
00:32:41,750 --> 00:32:44,630
at the end, both of them removed them their own notes,

557
00:32:44,640 --> 00:32:46,130
but no one bought the milk. 

558
00:32:53,310 --> 00:32:53,820
Make sense? 

559
00:32:53,830 --> 00:32:54,780
Any questions here? 

560
00:33:04,370 --> 00:33:04,940
Okay? 

561
00:33:05,700 --> 00:33:09,040
It's again possible for neither of the threat to buy milk. 

562
00:33:10,410 --> 00:33:12,280
And again, this is really,

563
00:33:12,290 --> 00:33:16,430
really hard to debug, 

564
00:33:17,250 --> 00:33:18,660
because it happens rarely. 

565
00:33:23,250 --> 00:33:24,360
Now, let me tell you,

566
00:33:24,690 --> 00:33:28,640
I told you something about initially about any synchronization limit. 

567
00:33:28,650 --> 00:33:30,360
You should involve something. 

568
00:33:32,410 --> 00:33:34,640
Actually, even without reading the code,

569
00:33:36,470 --> 00:33:42,860
you could have answered the question where there is a code is correct or not. 

570
00:33:44,800 --> 00:33:49,510
Can you tell me why and how you could have answered this question immediately? 

571
00:33:50,490 --> 00:33:52,100
Whether the code is correct or not? 

572
00:33:55,690 --> 00:33:57,850
Actually, the question is more clearly.

573
00:33:58,220 --> 00:34:02,370
You could have immediately see that the code is not

574
00:34:15,230 --> 00:34:15,700
correct. 

575
00:34:16,530 --> 00:34:17,280
Nicholas, 

576
00:34:18,390 --> 00:34:18,990
that's true. 

577
00:34:19,000 --> 00:34:20,150
There is no wait. 

578
00:34:20,770 --> 00:34:22,290
I told you that fundamentally, 

579
00:34:22,300 --> 00:34:26,170
any of these synchronization primitives has to involve a weight, 

580
00:34:27,100 --> 00:34:29,220
because if someone is in the critical section, 

581
00:34:29,230 --> 00:34:33,230
the other one thread has to wait. 

582
00:34:33,930 --> 00:34:37,220
If it wants to go into the critical section, there is no way around.

583
00:34:37,230 --> 00:34:38,880
It is fundamental. 

584
00:34:39,970 --> 00:34:40,930
But so far, 

585
00:34:40,940 --> 00:34:48,150
none of these codes has a weight instruction or something equivalent. 

586
00:34:49,900 --> 00:34:53,370
So that's how you can immediately say these codes. 

587
00:34:53,680 --> 00:34:55,150
It's not going to work. 

588
00:34:57,530 --> 00:34:58,480
Finally, 

589
00:35:00,650 --> 00:35:01,230
okay. 

590
00:35:02,520 --> 00:35:04,490
So let's go. 

591
00:35:04,870 --> 00:35:05,220
Obviously, 

592
00:35:06,110 --> 00:35:06,620
this, 

593
00:35:07,130 --> 00:35:12,320
if no one gets the milk and this continuous, and obviously,

594
00:35:12,330 --> 00:35:13,720
this is called starvation. 

595
00:35:13,730 --> 00:35:17,040
We're going to learn more about starvation in a few lectures. 

596
00:35:18,660 --> 00:35:19,690
Now, finally,

597
00:35:20,050 --> 00:35:21,710
here is solution three. 

598
00:35:23,450 --> 00:35:24,530
There are turnouts, 

599
00:35:26,360 --> 00:35:27,450
but not yesterday. 

600
00:35:27,770 --> 00:35:30,410
It has ay a while. 

601
00:35:31,280 --> 00:35:32,610
This is a waiting instruction, 

602
00:35:34,550 --> 00:35:42,090
because you wait for the node b if there is a node be, 

603
00:35:43,240 --> 00:35:49,030
then you wait until the node b is removed. 

604
00:35:51,050 --> 00:35:51,580
Okay? 

605
00:35:52,730 --> 00:35:54,090
So in other words, 

606
00:35:54,770 --> 00:35:57,890
thread a will not execute or not buy the milk or not, 

607
00:35:57,900 --> 00:36:00,570
even look at whether there is a milk in the fridge. 

608
00:36:01,300 --> 00:36:09,070
If thread b it's checked and already went to buy milk

609
00:36:22,220 --> 00:36:24,370
testing set as a synchronization. 

610
00:36:24,380 --> 00:36:25,890
So the question is for michael, 

611
00:36:25,900 --> 00:36:28,490
instead of waiting countries keep the critical section, 

612
00:36:28,950 --> 00:36:31,820
do we consider test and set as having a critical section? 

613
00:36:32,740 --> 00:36:33,930
The test is said, 

614
00:36:33,940 --> 00:36:37,230
they are going to be used to implement things like locks. 

615
00:36:38,640 --> 00:36:40,330
That's it, right?

616
00:36:41,290 --> 00:36:44,140
You need to have a while in order to wait on a distance set. 

617
00:36:47,830 --> 00:36:48,660
At shake. 

618
00:36:49,010 --> 00:36:49,970
Answer is correct. 

619
00:36:54,530 --> 00:36:54,690
Right? 

620
00:36:55,060 --> 00:36:56,690
You need test and set alone. 

621
00:36:56,700 --> 00:36:57,970
You need to also have, again,

622
00:36:57,980 --> 00:37:02,650
a while be around you to see that it is going to work. 

623
00:37:02,660 --> 00:37:03,250
Yes. 

624
00:37:04,430 --> 00:37:07,770
How you to convince yourself you see these 2 points, 

625
00:37:07,780 --> 00:37:10,640
x and y in each of these thread programs. 

626
00:37:12,470 --> 00:37:18,490
What you say here is at x if there is no node b

627
00:37:21,620 --> 00:37:23,830
that is safe for a to buy, 

628
00:37:25,860 --> 00:37:26,340
right? 

629
00:37:34,690 --> 00:37:35,990
Say, for a dubai, sorry.

630
00:37:36,580 --> 00:37:37,130
I what i'm doing, 

631
00:37:38,130 --> 00:37:38,580
right? 

632
00:37:39,250 --> 00:37:43,980
Because if there is no node b the thread b will for sure is

633
00:37:43,990 --> 00:37:47,240
outside this section of code. 

634
00:37:48,030 --> 00:37:49,520
For sure, it doesn't thread.

635
00:37:49,530 --> 00:37:50,720
B doesn't buy milk. 

636
00:37:51,610 --> 00:37:55,810
So it's safe for a to buy if there is no milk. 

637
00:37:57,330 --> 00:37:57,880
Now, 

638
00:37:58,650 --> 00:38:01,950
if I am at y if there is no node, 

639
00:38:01,960 --> 00:38:03,590
a is safe for bitter, 

640
00:38:03,600 --> 00:38:05,920
but why? 

641
00:38:06,540 --> 00:38:12,880
Because if there is not a

642
00:38:14,460 --> 00:38:20,190
this means that thread a it's not in exactly in this code. 

643
00:38:20,700 --> 00:38:21,980
So we cannot buy me. 

644
00:38:24,770 --> 00:38:26,410
Here is another way to look at it. 

645
00:38:27,400 --> 00:38:30,760
There are these two actions leave, 

646
00:38:30,770 --> 00:38:32,240
not a and no, 

647
00:38:32,250 --> 00:38:34,160
not a when is checked. 

648
00:38:35,340 --> 00:38:39,300
So if leave node a happens before, 

649
00:38:39,900 --> 00:38:44,910
no node a is checked by the second thread, 

650
00:38:45,920 --> 00:38:46,380
right? 

651
00:38:47,240 --> 00:38:51,340
Then it's obvious that

652
00:38:55,670 --> 00:38:58,590
thread b will not buy milk, 

653
00:39:00,390 --> 00:39:01,630
because there is a nowadays, 

654
00:39:02,540 --> 00:39:04,440
and it's over so obvious, 

655
00:39:05,860 --> 00:39:07,170
at least for now, 

656
00:39:08,000 --> 00:39:13,490
that said a will wait, 

657
00:39:13,500 --> 00:39:15,510
because there is a no b right? 

658
00:39:19,050 --> 00:39:20,590
Now, at this.,

659
00:39:21,480 --> 00:39:23,540
now the thread b is, again,

660
00:39:25,000 --> 00:39:26,110
there is a nowadays, 

661
00:39:26,120 --> 00:39:30,800
so we skip buying milk and then go all the way and buy and removes. 

662
00:39:30,810 --> 00:39:33,800
And i'll be without doing the anything without buying milk. 

663
00:39:34,640 --> 00:39:37,510
But notice now what happened yesterday once? 

664
00:39:39,540 --> 00:39:45,620
Said b removes note b thread a exits the y loop. 

665
00:39:46,680 --> 00:39:50,190
It check whether there is no milk and there is no milk and buy the milks. 

666
00:39:51,090 --> 00:39:51,660
Okay? 

667
00:39:53,490 --> 00:39:54,830
In this particular case, 

668
00:39:55,500 --> 00:39:57,140
thread a bought milk. 

669
00:39:58,220 --> 00:40:08,300
Now, let's assume that if no node a happens after thread b checks,

670
00:40:08,310 --> 00:40:12,110
whether there is no take what happens in this case. 

671
00:40:13,840 --> 00:40:14,250
Right? 

672
00:40:17,050 --> 00:40:25,940
So thread b found no note a there is no milk, 

673
00:40:25,950 --> 00:40:27,300
so is going to buy the milk. 

674
00:40:29,140 --> 00:40:36,900
Then it's removing the node b as in parallel node a

675
00:40:38,250 --> 00:40:45,600
is going to execute while node b and is going to wait

676
00:40:46,060 --> 00:40:54,010
for a to remove node b when that happens and b

677
00:40:54,020 --> 00:40:58,770
no thread b removes no b only after it bought the milk. 

678
00:41:00,020 --> 00:41:03,530
Now, when it be removes not be,

679
00:41:04,450 --> 00:41:09,340
this means that thread a will exceed the while loop, 

680
00:41:11,390 --> 00:41:12,770
and now check for the milk. 

681
00:41:13,870 --> 00:41:15,560
But now there is milk in the fridge, 

682
00:41:16,160 --> 00:41:17,880
because we put the milk in the fridge, 

683
00:41:17,890 --> 00:41:19,120
you bought the milk. 

684
00:41:19,940 --> 00:41:22,240
So therefore, they will not buy milk.

685
00:41:26,500 --> 00:41:28,390
So we are done. 

686
00:41:33,060 --> 00:41:34,230
So you see, in this case,

687
00:41:34,240 --> 00:41:35,430
in both cases, 

688
00:41:35,900 --> 00:41:39,420
only one thread and exactly one thread, but milk.

689
00:41:43,520 --> 00:41:47,710
The solution is easily protects a single critical section piece of code. 

690
00:41:48,310 --> 00:41:49,620
This is the critical section. 

691
00:41:49,630 --> 00:41:51,260
If no milk, you buy milk,

692
00:41:53,790 --> 00:41:55,120
solutions three works, 

693
00:41:55,130 --> 00:41:59,430
but it's as if is not very satisfactory, 

694
00:42:00,290 --> 00:42:02,300
it's pretty complex, right?

695
00:42:02,680 --> 00:42:04,250
Even in this simple example. 

696
00:42:04,920 --> 00:42:06,330
And like you see, 

697
00:42:06,340 --> 00:42:09,010
we got like what five six instructions. 

698
00:42:09,670 --> 00:42:11,500
It still took us like whatever 10, 

699
00:42:11,510 --> 00:42:13,540
15 minutes to convince ourselves that is working. 

700
00:42:14,650 --> 00:42:17,150
And also, a code is different from b code.

701
00:42:17,160 --> 00:42:21,530
What if you have not to stress by three stress of or ten threads? 

702
00:42:23,920 --> 00:42:26,570
Finally, we have a wait here,

703
00:42:26,890 --> 00:42:28,120
but she's busy waiting, 

704
00:42:28,650 --> 00:42:29,050
right? 

705
00:42:29,470 --> 00:42:33,720
This said a consume the superior resources while waiting. 

706
00:42:34,460 --> 00:42:36,100
We don't want that in general. 

707
00:42:37,340 --> 00:42:39,090
So let's look for a better ways. 

708
00:42:42,430 --> 00:42:43,700
Think about locking interface. 

709
00:42:43,710 --> 00:42:48,590
You are considering you want to acquire the lock and release a lock. 

710
00:42:48,600 --> 00:42:49,910
These are the instructions. 

711
00:42:50,150 --> 00:42:51,150
If the lock is taken, 

712
00:42:51,160 --> 00:42:54,750
you are waiting in the choir until someone believes along. 

713
00:42:57,900 --> 00:43:01,710
And then your milk problem is a it's a very simple. 

714
00:43:02,000 --> 00:43:03,090
You acquire the lock. 

715
00:43:03,810 --> 00:43:05,790
If there is no milk, you buy the milk.

716
00:43:06,170 --> 00:43:07,160
I said it really is a lock. 

717
00:43:08,980 --> 00:43:12,590
This is like our very first solution with a lock, right?

718
00:43:12,600 --> 00:43:13,910
A physical lock to the fridge. 

719
00:43:13,920 --> 00:43:20,720
But now imagine that you can put the lock only on a on something

720
00:43:20,730 --> 00:43:23,470
in the fridge were contains only milk, 

721
00:43:25,230 --> 00:43:25,680
right? 

722
00:43:26,340 --> 00:43:28,580
On a container, in the fridge or contains milk.

723
00:43:28,590 --> 00:43:29,420
That's a cuban. 

724
00:43:30,850 --> 00:43:31,170
Right? 

725
00:43:35,920 --> 00:43:37,950
Now, the question is how to implement lock?

726
00:43:38,190 --> 00:43:39,560
This is what we are going to discuss. 

727
00:43:40,220 --> 00:43:44,170
Remember, all synchronization primitive involves wait,

728
00:43:45,180 --> 00:43:47,400
but you don't want to do the waiting, busy, waiting,

729
00:43:48,210 --> 00:43:52,800
just spending the cpu resources while waiting. 

730
00:43:53,760 --> 00:43:56,440
Instead, you want to sleep when you wait,

731
00:43:56,950 --> 00:44:03,490
and you want to be open up when you can acquire the lock and enter

732
00:44:03,500 --> 00:44:04,300
the critical section. 

733
00:44:06,960 --> 00:44:12,270
Solution three from the milk or milk three solution was

734
00:44:12,280 --> 00:44:15,470
basically equivalent to using atomic load and stores, 

735
00:44:16,130 --> 00:44:17,880
again, pretty complex and the opera.

736
00:44:20,150 --> 00:44:25,110
So now the question is about how it does this implement the locks, 

737
00:44:25,120 --> 00:44:27,230
because they saw that if we implement the locks, 

738
00:44:28,670 --> 00:44:29,990
the solution is much easier. 

739
00:44:31,970 --> 00:44:37,510
One way to think about is to implement its in harbor. 

740
00:44:38,540 --> 00:44:40,710
However, if you implement it in hardware,

741
00:44:41,290 --> 00:44:41,790
a lock, 

742
00:44:42,960 --> 00:44:44,950
it turns out that it's pretty complicated. 

743
00:44:46,320 --> 00:44:48,240
And there are some processors doing it. 

744
00:44:49,830 --> 00:44:52,090
But it's, again, the complexity is high,

745
00:44:52,780 --> 00:44:55,060
and it's also slow, 

746
00:44:56,860 --> 00:44:58,450
because the chip is more complex. 

747
00:44:58,460 --> 00:44:59,770
It's actually slow down, 

748
00:45:00,050 --> 00:45:01,130
many other instructions. 

749
00:45:02,930 --> 00:45:07,470
So one simple solution to implement it with what learn so far. 

750
00:45:08,760 --> 00:45:11,490
It's about using the internet. 

751
00:45:13,180 --> 00:45:13,420
Right? 

752
00:45:13,430 --> 00:45:16,790
Remember that we have these external interrupts, 

753
00:45:16,800 --> 00:45:17,910
internal interrupts, 

754
00:45:18,290 --> 00:45:21,010
but fundamentally the interrupts. 

755
00:45:22,230 --> 00:45:23,780
When you execute an interrupt, 

756
00:45:24,710 --> 00:45:30,470
you are you are going to run some code. 

757
00:45:31,090 --> 00:45:38,460
And what we are talking about here is that think about like locker choir

758
00:45:38,470 --> 00:45:39,900
disable all interrupts. 

759
00:45:40,610 --> 00:45:46,560
So this means also there is no contact switching because in order to have

760
00:45:46,570 --> 00:45:48,520
also the context switching, 

761
00:45:48,990 --> 00:45:52,220
you're going to have the timer interrupt, right?

762
00:45:52,230 --> 00:45:54,940
Or they interrupt another interrupt external interrupts to do it. 

763
00:45:55,770 --> 00:45:57,310
And the local release you enable interrupts. 

764
00:45:59,250 --> 00:46:02,800
So it is a problem with this approach is not going to work. 

765
00:46:03,390 --> 00:46:03,850
Right? 

766
00:46:04,400 --> 00:46:06,070
Before we acquire an interrupt. 

767
00:46:06,650 --> 00:46:06,990
Right? 

768
00:46:09,030 --> 00:46:09,620
If you're sorry, 

769
00:46:09,630 --> 00:46:13,100
if you do acquire a lock and you disable all the interrupts, 

770
00:46:13,630 --> 00:46:18,600
then you do something like a while through your hank computer hanks, 

771
00:46:18,810 --> 00:46:20,200
again, it cannot be interrupted.

772
00:46:20,990 --> 00:46:21,380
Right? 

773
00:46:23,350 --> 00:46:27,020
You need to do something like ill to voluntarily provide give access

774
00:46:27,390 --> 00:46:31,070
to the scheduler in order to the kernel, 

775
00:46:31,080 --> 00:46:32,310
to schedule another thread. 

776
00:46:32,990 --> 00:46:35,290
But this code will lock the entire computer. 

777
00:46:36,280 --> 00:46:37,430
It's very risky. 

778
00:46:42,690 --> 00:46:43,680
You don't want to do that. 

779
00:46:43,690 --> 00:46:46,640
And there are many other reasons like for real time systems, 

780
00:46:46,650 --> 00:46:48,360
there is no guarantee of timing, 

781
00:46:48,990 --> 00:46:51,940
because the critical section can be arbitrary long. 

782
00:46:54,050 --> 00:46:57,670
Obviously, what happens when there are very important io events?

783
00:47:04,010 --> 00:47:10,320
So let's think about a better implementation of the locks by disabling interrupts. 

784
00:47:10,800 --> 00:47:11,690
So here it is on. 

785
00:47:13,640 --> 00:47:18,660
Basically, you maintain is a way to think about.

786
00:47:18,670 --> 00:47:21,640
You use a lock to implement a lock. 

787
00:47:22,360 --> 00:47:22,850
Right? 

788
00:47:23,330 --> 00:47:30,720
What you want is that when the segment that you want to minimize the

789
00:47:30,730 --> 00:47:37,500
code between disable interrupt and enable interrupts, 

790
00:47:37,510 --> 00:47:39,790
that's what you want to do. 

791
00:47:39,800 --> 00:47:40,230
Okay? 

792
00:47:41,930 --> 00:47:44,730
Because the problem is the previous in the previous case, 

793
00:47:44,740 --> 00:47:49,020
the problem is that you disable interrupts and you enter the critical section, 

794
00:47:49,400 --> 00:47:52,110
then the critical section can be arbitrary along. 

795
00:47:52,970 --> 00:47:53,320
Right? 

796
00:47:54,160 --> 00:47:55,300
Depends on the application. 

797
00:47:56,430 --> 00:47:56,810
Right? 

798
00:47:57,670 --> 00:47:58,470
But in this case, 

799
00:47:58,480 --> 00:48:04,790
we are going to implement the lock with a disable interrupt and enable, 

800
00:48:04,800 --> 00:48:05,270
interrupts, 

801
00:48:05,900 --> 00:48:10,980
and then expose acquire lock and release lock to the application, 

802
00:48:12,850 --> 00:48:15,410
implemented under the hood by the disabled interrupt. 

803
00:48:15,650 --> 00:48:16,500
But notice here, 

804
00:48:17,350 --> 00:48:19,510
the disabled interrupts and enable interrupts. 

805
00:48:20,030 --> 00:48:21,950
You have a very small piece of code here. 

806
00:48:22,470 --> 00:48:24,140
It's going to run very quickly. 

807
00:48:27,270 --> 00:48:33,130
Ideally, what you do for the choir say the value is a lock value.

808
00:48:35,410 --> 00:48:37,100
It's either free or busy. 

809
00:48:38,570 --> 00:48:39,740
So to acquire it, 

810
00:48:39,750 --> 00:48:41,500
if you disable the interrupt, 

811
00:48:41,510 --> 00:48:42,900
to manipulate this value, 

812
00:48:44,140 --> 00:48:45,510
if the value is busy, 

813
00:48:46,150 --> 00:48:46,900
what did we say? 

814
00:48:46,910 --> 00:48:47,940
We want to sleep. 

815
00:48:48,680 --> 00:48:51,390
So put thread on the wait list and go to sleep, 

816
00:48:51,860 --> 00:48:54,330
and somehow you want to enable interrupts. 

817
00:48:56,190 --> 00:49:00,980
So as I said can execute alice, 

818
00:49:01,720 --> 00:49:04,080
you acquire the lock value is busy and enable, 

819
00:49:04,090 --> 00:49:08,040
interrupts and for relieves, 

820
00:49:08,940 --> 00:49:10,450
you disable interrupts. 

821
00:49:11,110 --> 00:49:15,260
You look, if there is only anyone on the whale queue waiting for the lock.

822
00:49:16,030 --> 00:49:20,880
If it is, you give the lock to one of the thread or from the way queue.

823
00:49:21,690 --> 00:49:23,610
And you play the thread on the ready queue, 

824
00:49:24,870 --> 00:49:28,050
that thread can execute a critical section. 

825
00:49:28,060 --> 00:49:32,070
If there is no one on the way q the value is free and you enable the interests. 

826
00:49:36,370 --> 00:49:37,990
You see here the way it happens, 

827
00:49:38,000 --> 00:49:39,230
because you put the thread, 

828
00:49:39,240 --> 00:49:40,710
we're waiting on the waiting queue. 

829
00:49:41,950 --> 00:49:47,600
And then you you'd get that you take that thread from the waiting queue when

830
00:49:50,480 --> 00:49:52,610
another thread released the lock. 

831
00:49:54,240 --> 00:49:55,190
Any questions here? 

832
00:50:01,690 --> 00:50:03,560
Now, it's against what I was saying.

833
00:50:03,570 --> 00:50:07,120
You inclement input in increment a lock by used by another lock. 

834
00:50:08,940 --> 00:50:11,810
The reason for that because the second lock you are going to use, 

835
00:50:11,820 --> 00:50:15,280
you can use disable and enable interacts by making

836
00:50:15,290 --> 00:50:19,780
sure that the critical section protected by disabling and enable

837
00:50:19,790 --> 00:50:21,490
interrupts is very short. 

838
00:50:22,140 --> 00:50:24,450
This can be implemented by the operating system. 

839
00:50:25,160 --> 00:50:28,590
You have control about on the length of the critical section protecting

840
00:50:28,600 --> 00:50:29,430
by the interrupt, 

841
00:50:29,440 --> 00:50:30,910
disabling and enabling. 

842
00:50:34,170 --> 00:50:37,710
So that's the main difference from using disable, 

843
00:50:37,720 --> 00:50:39,750
interrupts and enable interrupts directly. 

844
00:50:44,380 --> 00:50:45,860
With this design, 

845
00:50:45,870 --> 00:50:50,050
the users can take as long as they want in the critical section, 

846
00:50:52,440 --> 00:50:55,360
because their critical section is not protecting by disable interrupt

847
00:50:55,370 --> 00:50:56,320
or enable interrupt. 

848
00:51:02,240 --> 00:51:03,800
Now, what is a big problem?

849
00:51:05,190 --> 00:51:06,310
Here is a big problem. 

850
00:51:06,990 --> 00:51:13,080
We need to enable interacts when we put the thread on the wake you, 

851
00:51:13,680 --> 00:51:17,400
because we need to allow as a threat to execute in particular, 

852
00:51:17,410 --> 00:51:19,140
the strategies in the critical section. 

853
00:51:22,420 --> 00:51:23,550
But the question is, 

854
00:51:23,560 --> 00:51:25,870
where do you need to install to enable the interrupts? 

855
00:51:28,070 --> 00:51:29,630
There are three possibilities. 

856
00:51:29,640 --> 00:51:35,820
One is here before putting the thread on the way it is correct. 

857
00:51:49,530 --> 00:51:57,880
That's it's not because the release can check the cure and not waken

858
00:51:57,890 --> 00:51:58,480
up the thread. 

859
00:52:00,010 --> 00:52:00,400
Right? 

860
00:52:00,910 --> 00:52:04,110
So enable upon in inputs of enabling traps here. 

861
00:52:05,620 --> 00:52:07,620
Before the study sponsor put on the weight queue, 

862
00:52:07,990 --> 00:52:09,260
you do contact switch, 

863
00:52:09,510 --> 00:52:13,740
the current context switch to the thread, another thread,

864
00:52:13,750 --> 00:52:15,380
which is executing the release. 

865
00:52:17,420 --> 00:52:17,880
Right? 

866
00:52:19,390 --> 00:52:23,460
The release is going to look at the if there is any set on the wave queue, 

867
00:52:24,470 --> 00:52:25,470
and there is none, 

868
00:52:26,810 --> 00:52:30,370
because acquire was didn't have a chance to play the set on the way. 

869
00:52:30,380 --> 00:52:33,340
So the threat will not be awkward. 

870
00:52:35,370 --> 00:52:40,350
What if you put the name the enable interrupts before go to? 

871
00:52:45,640 --> 00:52:46,380
These are corner? 

872
00:52:57,830 --> 00:53:03,970
Does if so here is a question michael from michael does if have

873
00:53:03,980 --> 00:53:05,290
to be replaced with wild? 

874
00:53:06,190 --> 00:53:08,250
Now i'll let you know why, 

875
00:53:08,260 --> 00:53:13,050
because let me go through this slide and i'll tell you why after that. 

876
00:53:14,850 --> 00:53:17,130
Now, because this is not correct,

877
00:53:17,140 --> 00:53:20,830
either because the release put the thread on the ridicule, 

878
00:53:23,730 --> 00:53:25,870
but the threat still think it needs to go to sleep. 

879
00:53:27,600 --> 00:53:29,300
So you put the threat on the waiting queue. 

880
00:53:30,840 --> 00:53:32,660
You enable, interrupts,

881
00:53:34,100 --> 00:53:37,620
now assumes as a release of their from the other side is executed. 

882
00:53:38,890 --> 00:53:39,250
Right? 

883
00:53:40,220 --> 00:53:47,330
And here the release is looking on the way q and you have a set on the way

884
00:53:47,340 --> 00:53:47,770
to q

885
00:53:48,320 --> 00:53:50,770
and take that thread to execute it. 

886
00:53:53,190 --> 00:53:56,240
But then when the australians executed, 

887
00:53:56,250 --> 00:54:00,050
it goes to sleep. 

888
00:54:01,910 --> 00:54:03,850
So you don't execute. 

889
00:54:04,620 --> 00:54:05,670
Now it is a question. 

890
00:54:06,320 --> 00:54:12,960
I said that it's a busy that we need to have some waiting for any synchronization, 

891
00:54:12,970 --> 00:54:13,520
primitive. 

892
00:54:13,780 --> 00:54:14,770
You need to have waiting. 

893
00:54:17,150 --> 00:54:18,790
Why we don't have a while here? 

894
00:54:20,690 --> 00:54:23,310
The reason we don't have a while here is very simple, 

895
00:54:25,580 --> 00:54:26,300
like I mentioned, 

896
00:54:26,310 --> 00:54:32,500
but probably I was not very clear is because of waiting here happens

897
00:54:33,550 --> 00:54:36,440
implicitly by acquire. 

898
00:54:36,780 --> 00:54:38,770
If the value, if the lock is busy,

899
00:54:39,860 --> 00:54:42,170
you put the thread on the waiting queue, 

900
00:54:42,870 --> 00:54:44,310
putting the thread of the waiting queue. 

901
00:54:44,320 --> 00:54:46,590
That act means waiting. 

902
00:54:48,330 --> 00:54:48,580
Right? 

903
00:54:48,590 --> 00:54:51,490
It doesn't happen in the program. 

904
00:54:51,920 --> 00:54:54,870
It happens in the kernel. 

905
00:54:55,340 --> 00:54:55,690
Right? 

906
00:54:58,170 --> 00:54:59,650
You put the thread on the waiting queue, 

907
00:54:59,660 --> 00:55:03,210
and the thread will wait until the release is going to be exactly. 

908
00:55:04,690 --> 00:55:05,900
And here's a lock is at least, 

909
00:55:09,620 --> 00:55:11,900
anyway, in order to solve the problem,

910
00:55:13,080 --> 00:55:15,940
you need to put to lisa log after going to sleep. 

911
00:55:18,270 --> 00:55:19,380
But how you do it? 

912
00:55:20,720 --> 00:55:21,840
Because the thread is sleeping. 

913
00:55:21,850 --> 00:55:28,550
So how can execute an instruction to enable the interrupts? 

914
00:55:32,640 --> 00:55:32,870
Any

915
00:55:42,660 --> 00:55:42,730
suggestions? 

916
00:55:43,660 --> 00:55:45,140
So the problem is very simple. 

917
00:55:46,080 --> 00:55:51,620
It's like I want logically to enable the interrupts after I go to sleep. 

918
00:55:52,690 --> 00:55:54,100
But how can I do that? 

919
00:55:54,340 --> 00:55:55,190
Because I am sleeping, 

920
00:55:59,700 --> 00:56:01,240
modify sleep instruction, 

921
00:56:01,660 --> 00:56:03,060
obviously functional. 

922
00:56:03,790 --> 00:56:04,450
That's good. 

923
00:56:06,260 --> 00:56:12,260
But I need to how you modify that's not easy. 

924
00:56:19,840 --> 00:56:23,730
You can try it, but you'll see that it's not easy,

925
00:56:23,740 --> 00:56:26,050
because you still have a bunch of instruction. 

926
00:56:26,060 --> 00:56:30,260
And you'll see the same problem like you have here. 

927
00:56:32,620 --> 00:56:34,230
Have the kernel do it for now. 

928
00:56:35,910 --> 00:56:37,860
You can have the kernel do it for now. 

929
00:56:38,270 --> 00:56:39,550
But how do you do it? 

930
00:56:40,600 --> 00:56:43,360
You do it on whenever you lose your sleep. 

931
00:56:48,740 --> 00:56:49,460
That's not good, 

932
00:56:50,570 --> 00:56:50,940
right? 

933
00:56:52,170 --> 00:56:58,000
Because you can call a sleep for many other cases. 

934
00:57:02,890 --> 00:57:04,910
So actually the solution is quite brilliant. 

935
00:57:05,660 --> 00:57:06,730
In my opinion, 

936
00:57:13,460 --> 00:57:22,690
if the threat which go to sleep cannot enable the interrupts, 

937
00:57:26,510 --> 00:57:28,390
the solution is that another thread, 

938
00:57:30,010 --> 00:57:32,290
which wakes up is going to enable the interests. 

939
00:57:35,360 --> 00:57:37,060
So you do it on contact switching. 

940
00:57:38,580 --> 00:57:41,090
In some sense, you can argue this is done by the kernel.

941
00:57:41,480 --> 00:57:42,710
You can do that in the kernel. 

942
00:57:44,230 --> 00:57:47,200
But this is a solution here. 

943
00:57:47,900 --> 00:57:48,320
Right? 

944
00:57:52,100 --> 00:57:54,410
The nice thing about the solution is, again, is like,

945
00:57:55,690 --> 00:57:59,770
if the thread which goes to sleep cannot enable the interrupt because

946
00:57:59,780 --> 00:58:00,810
already went to sleep, 

947
00:58:00,820 --> 00:58:05,800
the solution is for the next thread, 

948
00:58:06,910 --> 00:58:11,020
which when you return from the sleep to enable the interrupts. 

949
00:58:12,510 --> 00:58:12,850
Right? 

950
00:58:13,450 --> 00:58:19,390
You have another strategy able to interrupt. 

951
00:58:19,400 --> 00:58:22,340
So this is pretty nice. 

952
00:58:22,350 --> 00:58:23,580
So when you wake up, 

953
00:58:26,720 --> 00:58:35,610
you enable interrupts some announcements, 

954
00:58:36,220 --> 00:58:37,470
design, review schedule,

955
00:58:37,600 --> 00:58:40,030
as soon as possible you haven't done already. 

956
00:58:41,330 --> 00:58:44,690
The review is your da needs to be done by this thursday, 

957
00:58:44,700 --> 00:58:49,550
so you have 2 days and show up on time listed. 

958
00:58:49,560 --> 00:58:51,270
There is no vertical time we have. 

959
00:58:52,870 --> 00:58:56,090
Now 10 minutes after meter, 

960
00:58:56,100 --> 00:59:00,180
it will be between 7:00 and 9:00 pm 8 days from now. 

961
00:59:01,490 --> 00:59:03,990
We is going to cover everything up, 

962
00:59:04,730 --> 00:59:05,090
two. 

963
00:59:05,550 --> 00:59:07,200
And including the next lecture, 

964
00:59:07,210 --> 00:59:11,860
there will be a midterm review of monday, 

965
00:59:13,230 --> 00:59:14,290
37and 9. 

966
00:59:15,190 --> 00:59:21,040
And for logistics on profiting policies and so forth, shit.

967
00:59:22,010 --> 00:59:24,200
Look out for the boss. 

968
00:59:40,150 --> 00:59:44,180
Let me see, sorry, it's 29.

969
00:59:44,420 --> 00:59:45,300
What i'm saying? 

970
00:59:47,470 --> 00:59:48,870
Wednesday 9:29, 

971
00:59:48,880 --> 00:59:50,910
thanks for catching. 

972
00:59:52,140 --> 00:59:55,580
So question here was how do you can contact switch? 

973
00:59:56,680 --> 00:59:59,690
Because here, 

974
01:00:00,450 --> 01:00:03,050
everything disabled that the interrupts are disabled. 

975
01:00:03,330 --> 01:00:08,330
So here we are not talking about contact switching based on the timer event. 

976
01:00:08,340 --> 01:00:09,730
We are talking about here. 

977
01:00:09,740 --> 01:00:10,650
This is here. 

978
01:00:10,660 --> 01:00:12,090
Let me just see all the code. 

979
01:00:16,380 --> 01:00:17,330
This is a code. 

980
01:00:19,070 --> 01:00:24,750
You see this part where if anyone on the waiting queue, 

981
01:00:24,760 --> 01:00:26,390
so when you do this, 

982
01:00:27,220 --> 01:00:33,330
you go to sleep by the go to sleep means you yield the control to the kernel. 

983
01:00:37,500 --> 01:00:38,690
And the kernel, 

984
01:00:41,510 --> 01:00:42,150
the interrupts, 

985
01:00:43,240 --> 01:00:48,210
you are going to execute this instruction

986
01:00:51,830 --> 01:00:53,870
and take the thread of the wake queue. 

987
01:00:53,880 --> 01:00:54,990
And when you do this, 

988
01:00:55,000 --> 01:00:57,240
you enable the interrupts again. 

989
01:00:58,550 --> 01:01:00,270
So this enable interrupts from here. 

990
01:01:00,280 --> 01:01:06,120
I hope that you are seeing what i'm highlighting is going to have. 

991
01:01:06,970 --> 01:01:08,660
It's going to happen here. 

992
01:01:09,400 --> 01:01:13,000
You take the thread of the wake you and you are going to you return

993
01:01:13,010 --> 01:01:17,170
from the this means you return from the sleep, 

994
01:01:18,190 --> 01:01:21,380
and you are going to enable the interrupts just before place on the ready. 

995
01:01:30,020 --> 01:01:31,380
Hopefully it answers the question. 

996
01:01:34,000 --> 01:01:39,890
So let's see how here and we have another 20 minutes. 

997
01:01:39,900 --> 01:01:43,540
So here this give you a sense about how this is working, 

998
01:01:44,110 --> 01:01:45,970
doing a kind of assimilation. 

999
01:01:49,290 --> 01:01:51,100
So here is local choir. 

1000
01:01:51,110 --> 01:01:52,260
We have a release. 

1001
01:01:52,960 --> 01:01:53,870
This is a code. 

1002
01:01:54,630 --> 01:01:57,940
We have two strides executing the code saturday and said each of them

1003
01:01:57,950 --> 01:01:58,940
is doing local choir, 

1004
01:01:58,950 --> 01:02:00,980
go to the critical section, local release.

1005
01:02:01,680 --> 01:02:05,540
Let's say, said they acquire it is able the instruction,

1006
01:02:06,310 --> 01:02:07,930
it is able to interrupt, sorry,

1007
01:02:09,130 --> 01:02:10,090
the value. 

1008
01:02:14,240 --> 01:02:16,940
So in this particular case, 

1009
01:02:20,540 --> 01:02:26,470
someone doesn't anyone has a critical sector? 

1010
01:02:27,200 --> 01:02:28,470
This is the first thread, 

1011
01:02:28,480 --> 01:02:31,160
a we look executive choir. 

1012
01:02:31,970 --> 01:02:34,570
There is no one using the critical section. 

1013
01:02:34,700 --> 01:02:35,530
The value is zero. 

1014
01:02:36,170 --> 01:02:37,410
Increment, the value to one,

1015
01:02:37,420 --> 01:02:39,440
which means that it acquires a lock, 

1016
01:02:40,580 --> 01:02:42,050
and it enables the interrupts. 

1017
01:02:42,060 --> 01:02:47,310
And now you are in critical section. 

1018
01:02:48,000 --> 01:02:48,390
Right? 

1019
01:02:49,530 --> 01:02:50,710
This is what happened, right?

1020
01:02:52,040 --> 01:02:53,260
At the same time, 

1021
01:02:56,200 --> 01:02:59,630
let's assume that while you are in the critical section, thread,

1022
01:02:59,640 --> 01:03:00,990
b is starting to be executed. 

1023
01:03:01,960 --> 01:03:04,470
Again, while you are in a critical executive section,

1024
01:03:05,720 --> 01:03:06,950
the interrupts are enabled. 

1025
01:03:13,120 --> 01:03:20,040
Thread b is going to start running saturday in the same in the meantime, 

1026
01:03:20,050 --> 01:03:21,000
it seems a ridicule. 

1027
01:03:21,010 --> 01:03:22,840
This is just contact switching, 

1028
01:03:22,850 --> 01:03:24,040
traditional contact switching. 

1029
01:03:25,580 --> 01:03:26,860
You do the local choir, 

1030
01:03:27,730 --> 01:03:28,880
execute local choir. 

1031
01:03:30,280 --> 01:03:33,310
But now you look, and what you can see is a value each one,

1032
01:03:33,320 --> 01:03:36,830
because the lock is acquired by thread a you cannot acquire the lock. 

1033
01:03:37,930 --> 01:03:39,690
A beard cannot acquire the lock as well. 

1034
01:03:39,700 --> 01:03:41,580
So you go to sleep. 

1035
01:03:43,490 --> 01:03:43,760
Right? 

1036
01:03:43,930 --> 01:03:45,920
You are going thread is going to be waiting, 

1037
01:03:45,930 --> 01:03:47,200
it's going to be on the wake you. 

1038
01:03:49,080 --> 01:03:49,520
Okay? 

1039
01:03:52,620 --> 01:03:59,620
And now you are going to start executing thread a because it's ready to execute. 

1040
01:03:59,630 --> 01:04:04,770
And this thread b went to sleep and thread b 111 is going to sleep, 

1041
01:04:05,050 --> 01:04:11,030
is going to voluntarily release the cpo

1042
01:04:15,660 --> 01:04:19,870
the kernel is going to start executing saturday, 

1043
01:04:19,880 --> 01:04:25,770
resuming the exhibition of saturday in the critical section ends, 

1044
01:04:26,820 --> 01:04:29,770
and then is releasing the lock. 

1045
01:04:33,260 --> 01:04:36,320
And now, if anyone waste on the waiting queue,

1046
01:04:36,330 --> 01:04:38,490
is anyone waiting on the waiting queue? 

1047
01:04:38,810 --> 01:04:41,480
It's thread b right? 

1048
01:04:43,930 --> 01:04:47,520
Thread b is placed on the ridicule from the waiting queue on the ridicule. 

1049
01:04:48,920 --> 01:04:50,650
And now you enable the interrupts. 

1050
01:04:51,490 --> 01:04:52,260
You are done. 

1051
01:04:52,670 --> 01:04:54,570
Thread b is ready to execute. 

1052
01:04:56,380 --> 01:04:57,290
And then, 

1053
01:04:58,930 --> 01:05:02,870
next time you are going to execute thread, 

1054
01:05:06,920 --> 01:05:15,400
instead be executes acquire the locks and continue and enter the critical session. 

1055
01:05:21,980 --> 01:05:26,650
So please go and try to go carefully through this example. 

1056
01:05:28,050 --> 01:05:28,880
Any questions? 

1057
01:05:47,440 --> 01:05:48,520
So what is the problem? 

1058
01:05:48,530 --> 01:05:49,800
So it is working. 

1059
01:05:50,420 --> 01:05:51,340
Yes, he's working.

1060
01:05:53,120 --> 01:05:54,670
But there are several issues. 

1061
01:05:55,000 --> 01:05:57,310
You cannot give lock implementation to users. 

1062
01:05:57,360 --> 01:05:58,870
They are going to make mistakes. 

1063
01:06:00,320 --> 01:06:01,040
Now, 

1064
01:06:02,220 --> 01:06:04,530
you can solve that by saying, operate,

1065
01:06:04,540 --> 01:06:05,610
the kernel can do it. 

1066
01:06:06,710 --> 01:06:08,730
And that's a very valid answer. 

1067
01:06:09,440 --> 01:06:10,560
But the other problem, 

1068
01:06:10,570 --> 01:06:11,960
especially with the interrupts, 

1069
01:06:12,670 --> 01:06:15,830
is that it doesn't work well on multiprocessors. 

1070
01:06:17,430 --> 01:06:19,910
You have multiple cars which execute in parallel. 

1071
01:06:20,850 --> 01:06:24,570
And all cars can access a memory. 

1072
01:06:25,030 --> 01:06:26,460
Therefore, the value of the lock.

1073
01:06:29,150 --> 01:06:32,900
When you need to disable interrupts on all the course, 

1074
01:06:32,910 --> 01:06:34,740
you need to send messages between course, 

1075
01:06:35,390 --> 01:06:35,950
to do it, 

1076
01:06:37,920 --> 01:06:41,170
to disable interrupts or enable interrupts which is very expensive. 

1077
01:06:42,940 --> 01:06:45,780
The alternative to this is to have atomic instructions, 

1078
01:06:47,910 --> 01:06:48,190
right? 

1079
01:06:49,200 --> 01:06:51,170
And typically what they do, 

1080
01:06:51,510 --> 01:06:54,610
they read a value and write a value atomically. 

1081
01:06:55,090 --> 01:06:55,510
So instead, 

1082
01:06:55,520 --> 01:07:00,120
loading stores only is reading a value is atomic and writing a value is atomic. 

1083
01:07:01,230 --> 01:07:03,030
But this adds another element. 

1084
01:07:03,740 --> 01:07:05,620
The read you can have a read and write, 

1085
01:07:06,340 --> 01:07:10,260
which is our atomic like one operation. 

1086
01:07:11,180 --> 01:07:12,280
These are great. 

1087
01:07:12,290 --> 01:07:15,990
They are working both only processor and multiprocessors. 

1088
01:07:17,230 --> 01:07:23,840
And they are quite simple. 

1089
01:07:24,530 --> 01:07:25,710
And here are a few of them. 

1090
01:07:26,600 --> 01:07:28,200
The first one is test and set. 

1091
01:07:29,360 --> 01:07:29,880
Okay? 

1092
01:07:30,470 --> 01:07:32,320
What is doing best and set? 

1093
01:07:32,850 --> 01:07:35,500
Read a value of a particular memory, 

1094
01:07:36,000 --> 01:07:38,040
a a particular, 

1095
01:07:38,690 --> 01:07:43,750
the value at a particular address and returns it, 

1096
01:07:45,170 --> 01:07:47,890
and also at the same time set it to one. 

1097
01:07:49,780 --> 01:07:51,210
So reading the value, 

1098
01:07:51,870 --> 01:07:53,050
setting it to one, 

1099
01:07:53,550 --> 01:07:58,170
and returning the previous values of value before us at one original value. 

1100
01:07:58,540 --> 01:07:59,100
It's atomic. 

1101
01:08:00,290 --> 01:08:00,960
That's it. 

1102
01:08:01,850 --> 01:08:02,930
That's atomic instruction. 

1103
01:08:03,060 --> 01:08:05,690
You see, there are multiple operations in this, which are atomic,

1104
01:08:05,980 --> 01:08:08,500
which are in this atomic instruction. 

1105
01:08:10,190 --> 01:08:11,110
Then it's a swap. 

1106
01:08:12,800 --> 01:08:15,490
And a swap is basically what is doing. 

1107
01:08:16,780 --> 01:08:17,200
Right? 

1108
01:08:18,750 --> 01:08:19,820
You get a value. 

1109
01:08:21,840 --> 01:08:22,350
You sorry, 

1110
01:08:26,030 --> 01:08:27,760
you put a value in a register. 

1111
01:08:29,720 --> 01:08:36,870
That value put in the register is going to be swapped with the value

1112
01:08:38,020 --> 01:08:39,180
at a particular address. 

1113
01:08:43,120 --> 01:08:43,840
This is what it is. 

1114
01:08:44,560 --> 01:08:48,190
So you shall give a value in a register, 

1115
01:08:48,200 --> 01:08:52,310
which is going to be swapped with a value at a particular address. 

1116
01:08:53,230 --> 01:08:54,920
Finally, it's compare and swap.

1117
01:08:55,250 --> 01:08:56,560
It's a little bit more complicated. 

1118
01:08:56,570 --> 01:08:59,500
You give two registers here. 

1119
01:09:00,160 --> 01:09:03,680
It was a memory address is still equally registered, 

1120
01:09:04,530 --> 01:09:06,760
is still equal with register one. 

1121
01:09:07,170 --> 01:09:10,340
Then you put the memory value and register to. 

1122
01:09:10,350 --> 01:09:12,260
Otherwise, you don't change the memory.

1123
01:09:15,860 --> 01:09:18,310
These are exactly six. 

1124
01:09:18,320 --> 01:09:19,540
Obviously, it's intel.

1125
01:09:19,920 --> 01:09:22,420
6,800 was a very popular chip, 

1126
01:09:22,930 --> 01:09:28,380
motorola chip, which was the cheap for used by apple, early apple,

1127
01:09:28,390 --> 01:09:29,420
and macintosh. 

1128
01:09:29,990 --> 01:09:30,760
Computers. 

1129
01:09:31,520 --> 01:09:34,310
Testing said it's actually in most architectures today. 

1130
01:09:37,260 --> 01:09:40,970
Here is an example about how to use, 

1131
01:09:41,500 --> 01:09:42,460
compare and swap. 

1132
01:09:46,140 --> 01:09:51,750
And this is about how you are going to use to insert atomically. 

1133
01:09:53,180 --> 01:09:55,920
A new element is ahead of a queue. 

1134
01:09:56,950 --> 01:09:58,300
This is what you want to do it. 

1135
01:09:58,980 --> 01:10:00,050
This is n cube operation. 

1136
01:10:00,330 --> 01:10:00,590
Insert. 

1137
01:10:00,600 --> 01:10:02,750
A new element is ahead of the queue. 

1138
01:10:06,690 --> 01:10:07,640
Here, how do you do it?

1139
01:10:09,000 --> 01:10:10,680
First of all, you have a while.

1140
01:10:11,060 --> 01:10:12,350
Do you see do until? 

1141
01:10:13,740 --> 01:10:13,980
Right? 

1142
01:10:13,990 --> 01:10:14,660
It's a loop. 

1143
01:10:17,560 --> 01:10:21,110
And in the low in the condition breaks it from this slope. 

1144
01:10:21,680 --> 01:10:25,290
You can tell and stop at one and object. 

1145
01:10:26,420 --> 01:10:26,790
Right? 

1146
01:10:27,240 --> 01:10:29,510
Object is the object identifier, 

1147
01:10:29,520 --> 01:10:30,530
r one. 

1148
01:10:31,410 --> 01:10:34,560
You can see is a route address. 

1149
01:10:36,560 --> 01:10:36,910
Okay? 

1150
01:10:40,120 --> 01:10:41,230
It's your original route. 

1151
01:10:42,050 --> 01:10:42,280
Right? 

1152
01:10:42,290 --> 01:10:45,440
So what happens here is basically, 

1153
01:10:46,310 --> 01:10:52,450
you are going to wait until what you do here. 

1154
01:10:52,460 --> 01:10:58,490
You set the route to the new object. 

1155
01:11:01,620 --> 01:11:02,110
Okay? 

1156
01:11:07,630 --> 01:11:13,260
And then you are waiting until the route is pointing. 

1157
01:11:14,190 --> 01:11:14,680
Sorry. 

1158
01:11:15,020 --> 01:11:16,360
What you do is the following thing. 

1159
01:11:17,150 --> 01:11:25,000
You set the next the object to point to the first element in the queue. 

1160
01:11:25,680 --> 01:11:26,170
This one. 

1161
01:11:28,710 --> 01:11:29,530
This is what you do. 

1162
01:11:31,370 --> 01:11:31,790
Right? 

1163
01:11:32,090 --> 01:11:35,690
This is you get the pointer from the root, 

1164
01:11:35,700 --> 01:11:38,130
which is the point of the first element in the queue. 

1165
01:11:38,910 --> 01:11:42,430
Then you set the next, 

1166
01:11:45,320 --> 01:11:51,170
the new object to point to the old first object in the queue. 

1167
01:11:52,000 --> 01:11:57,800
Then you are going to use a compare and swap to move the pointer

1168
01:11:57,810 --> 01:11:59,440
of the route to the new object. 

1169
01:12:00,030 --> 01:12:01,260
You wait until that is done. 

1170
01:12:05,350 --> 01:12:06,560
So that's what happens here. 

1171
01:12:09,900 --> 01:12:12,540
Now, how we implement lock switch test and test.

1172
01:12:13,400 --> 01:12:17,290
Test and set is very easy acquire. 

1173
01:12:19,080 --> 01:12:21,390
You will set up the value to zero here. 

1174
01:12:23,080 --> 01:12:24,390
Acquire it's, 

1175
01:12:24,760 --> 01:12:31,130
you just wait for test and set to be one, 

1176
01:12:33,850 --> 01:12:37,770
then release you just set value to zero. 

1177
01:12:38,990 --> 01:12:39,940
What happens here? 

1178
01:12:40,280 --> 01:12:43,100
Remember, what does test and set is doing?

1179
01:12:43,970 --> 01:12:51,310
The test and set is going to read to return the

1180
01:12:51,320 --> 01:12:56,980
value and set it to one in one instruction. 

1181
01:12:59,230 --> 01:13:00,360
If the value is zero, 

1182
01:13:01,070 --> 01:13:07,680
you return as a value to while while is going to exit and set value to one. 

1183
01:13:08,840 --> 01:13:09,390
It's great. 

1184
01:13:09,680 --> 01:13:11,350
Lock is not busy acquired as a lock. 

1185
01:13:12,610 --> 01:13:13,990
If the lock is busy, 

1186
01:13:14,000 --> 01:13:15,630
so value will be one. 

1187
01:13:17,170 --> 01:13:19,170
You are going to set the value to one. 

1188
01:13:19,180 --> 01:13:19,970
It's already one. 

1189
01:13:20,100 --> 01:13:21,970
Nothing will happen, but you return one.

1190
01:13:22,850 --> 01:13:26,480
You are going to be stuck in the while loop until the release

1191
01:13:26,490 --> 01:13:32,170
is going to be executed and the value set to zero. 

1192
01:13:32,820 --> 01:13:33,730
It's quite elegant. 

1193
01:13:38,060 --> 01:13:38,500
Obviously, 

1194
01:13:38,510 --> 01:13:42,020
the problem here you have the while you do the while in the program. 

1195
01:13:42,640 --> 01:13:42,890
Right? 

1196
01:13:42,900 --> 01:13:43,890
So very inefficient. 

1197
01:13:47,170 --> 01:13:47,540
Right? 

1198
01:13:49,640 --> 01:13:50,590
You don't want to do that. 

1199
01:13:51,370 --> 01:13:53,120
But this is a correct implementation, 

1200
01:13:53,130 --> 01:13:54,480
very simple implementation. 

1201
01:13:54,490 --> 01:14:00,180
So you see our test and set allows us a very simple implementation of a lot. 

1202
01:14:01,390 --> 01:14:01,680
Right? 

1203
01:14:02,080 --> 01:14:04,750
And again, the testing set very easy to remember.

1204
01:14:05,340 --> 01:14:06,380
You do two things, 

1205
01:14:06,870 --> 01:14:09,090
return the value and set this one. 

1206
01:14:09,710 --> 01:14:10,070
That's all

1207
01:14:19,390 --> 01:14:20,870
the problem is busy waiting, 

1208
01:14:22,080 --> 01:14:22,670
busy waiting. 

1209
01:14:22,680 --> 01:14:24,350
Again, it's a correct implementation.

1210
01:14:24,360 --> 01:14:26,590
The machine can still receive, interrupts.

1211
01:14:28,260 --> 01:14:31,980
The user code can still use a lock work on multiprocessor, 

1212
01:14:32,500 --> 01:14:36,930
all positives, but you don't want this busy week.

1213
01:14:38,820 --> 01:14:39,760
It's inefficient. 

1214
01:14:40,090 --> 01:14:42,700
Also can result in what we call priority inversion. 

1215
01:14:43,410 --> 01:14:43,800
Right? 

1216
01:14:44,260 --> 01:14:47,360
If the busy waiting thread has a higher priority than the thread holding

1217
01:14:47,370 --> 01:14:47,880
the lock, 

1218
01:14:49,470 --> 01:14:49,930
right? 

1219
01:14:50,320 --> 01:14:53,210
This is a another way to think about it. 

1220
01:14:57,780 --> 01:14:58,090
Oops. 

1221
01:15:00,400 --> 01:15:03,700
Another way to think about it is like you have two threads, 

1222
01:15:04,260 --> 01:15:05,310
one has higher priorities, 

1223
01:15:05,320 --> 01:15:08,550
and the other one higher priority is going to be always executed

1224
01:15:08,560 --> 01:15:09,360
before the other. 

1225
01:15:09,840 --> 01:15:11,640
The one is a low priority. 

1226
01:15:12,250 --> 01:15:18,920
Now, the thread is a low priority is going to have the lock.

1227
01:15:19,800 --> 01:15:21,820
If the third is a lower priority has a lock, 

1228
01:15:22,550 --> 01:15:25,500
the third is a higher priority will be stuck because it's going to be stuck

1229
01:15:25,830 --> 01:15:27,570
in the while loop. 

1230
01:15:28,120 --> 01:15:30,030
The thread is allowed priority cannot execute, 

1231
01:15:30,400 --> 01:15:32,090
because the surveys are our higher priority, 

1232
01:15:32,100 --> 01:15:34,890
but because the thread is a lower priority cannot execute. 

1233
01:15:35,150 --> 01:15:37,840
It cannot exit the critical section. 

1234
01:15:37,850 --> 01:15:38,880
It cannot release a lock. 

1235
01:15:41,350 --> 01:15:42,500
This is priority inversion. 

1236
01:15:44,160 --> 01:15:45,980
And this happened in many cases. 

1237
01:15:50,900 --> 01:15:53,890
So that's the problem, right?

1238
01:15:54,610 --> 01:16:02,130
And so we really want because we don't want us as

1239
01:16:02,410 --> 01:16:06,260
to this busy waiting, 

1240
01:16:07,090 --> 01:16:11,250
we need to find another solution. 

1241
01:16:12,260 --> 01:16:13,270
And in general, 

1242
01:16:13,780 --> 01:16:17,370
when you have the homework problem or exams solution, 

1243
01:16:17,380 --> 01:16:19,530
unless as always specified, 

1244
01:16:21,030 --> 01:16:22,320
you should avoid busy waiting. 

1245
01:16:24,320 --> 01:16:24,750
Okay? 

1246
01:16:27,410 --> 01:16:29,720
Now let's see for the next couple of minutes, 

1247
01:16:29,730 --> 01:16:32,960
think about maybe better logs using test and set. 

1248
01:16:33,950 --> 01:16:40,670
The question cannot use the sunset to implement locks without busy waiting. 

1249
01:16:43,790 --> 01:16:45,210
And this answer here, 

1250
01:16:45,720 --> 01:16:51,390
we cannot, but we can minimize a busy waiting section.

1251
01:16:53,990 --> 01:16:56,660
And again, the solution here is like with,

1252
01:16:58,170 --> 01:17:00,360
if you remember, with interrupts,

1253
01:17:02,810 --> 01:17:05,110
we use a lock to implement a lock. 

1254
01:17:05,790 --> 01:17:06,530
In some sense, 

1255
01:17:07,850 --> 01:17:12,040
the local and implement is is called value. 

1256
01:17:14,140 --> 01:17:15,570
And then what we do, 

1257
01:17:17,000 --> 01:17:23,810
we protect the critical section of the acquire

1258
01:17:25,050 --> 01:17:28,350
and release the critical section being the one, 

1259
01:17:28,360 --> 01:17:29,710
which modifies the lock, 

1260
01:17:30,390 --> 01:17:33,290
which is value by a test and set. 

1261
01:17:36,450 --> 01:17:40,540
So use a testing set to implement and protect these critical sections

1262
01:17:40,550 --> 01:17:41,940
in acquiring release. 

1263
01:17:43,720 --> 01:17:45,070
The solution is very simple. 

1264
01:17:45,080 --> 01:17:48,490
We have define another variable. 

1265
01:17:48,500 --> 01:17:49,690
It is called guard. 

1266
01:17:50,440 --> 01:17:56,570
This ensures a mature mutual exclusion for these critical sections, 

1267
01:17:57,130 --> 01:17:58,640
which are in the acquire and release. 

1268
01:17:59,500 --> 01:17:59,840
Okay? 

1269
01:18:02,150 --> 01:18:03,600
While we initialize to zero, 

1270
01:18:04,210 --> 01:18:05,190
while god, 

1271
01:18:06,810 --> 01:18:08,750
if god is zero, 

1272
01:18:09,920 --> 01:18:14,810
then you are going to acquire the lock. 

1273
01:18:16,260 --> 01:18:17,400
So I will exit, 

1274
01:18:19,250 --> 01:18:19,710
right? 

1275
01:18:20,510 --> 01:18:21,190
Because remember, 

1276
01:18:21,200 --> 01:18:27,400
testing set returns the current value of water that is zero and satisfying. 

1277
01:18:29,010 --> 01:18:30,160
You exit the y loop, 

1278
01:18:31,140 --> 01:18:33,360
and then you set up the value. 

1279
01:18:33,960 --> 01:18:34,640
But what do you know? 

1280
01:18:36,480 --> 01:18:40,000
And the release is a sense. 

1281
01:18:40,850 --> 01:18:44,170
Again, you protect the critical section by test and set.

1282
01:18:45,830 --> 01:18:51,450
Here you have the same problem like with the release interrupts. 

1283
01:18:51,830 --> 01:18:55,000
When you go to sleep, you also need to put set a guard to zero,

1284
01:18:55,010 --> 01:18:56,870
then when you need to set up it. 

1285
01:18:57,680 --> 01:18:58,080
Right? 

1286
01:18:59,190 --> 01:19:00,480
But this will be much easier

1287
01:19:07,800 --> 01:19:12,280
when sleep has to be sure to resell the guard value. 

1288
01:19:17,020 --> 01:19:19,890
We are going to end up here this lecture. 

1289
01:19:19,900 --> 01:19:21,150
On this note. 

1290
01:19:21,160 --> 01:19:22,990
We are going to continue next time. 

1291
01:19:25,380 --> 01:19:27,570
You should think a little bit about this code. 

1292
01:19:28,050 --> 01:19:29,570
And there is a question here. 

1293
01:19:30,960 --> 01:19:31,800
Why? 

1294
01:19:34,360 --> 01:19:35,270
Let me see. 

1295
01:19:44,200 --> 01:19:46,950
I'm going to stop here, because for some reason,

1296
01:19:47,360 --> 01:19:50,750
I lost my pointer, so I cannot see my pointer on the screen.

1297
01:19:52,520 --> 01:19:55,190
So there is a question at the end of the previous slide, 

1298
01:19:55,200 --> 01:20:00,620
please think about it until the next time without looking at the next slide. 

1299
01:20:01,390 --> 01:20:05,890
And that is, 

1300
01:20:08,690 --> 01:20:10,770
yeah, that there is a question here.

1301
01:20:14,590 --> 01:20:19,870
If while test and so we are the lecture is done. 

1302
01:20:19,880 --> 01:20:22,800
I am going to try to ask the last question, 

1303
01:20:23,350 --> 01:20:24,670
which was on the chat. 

1304
01:20:25,280 --> 01:20:26,430
We'll meet next time. 

1305
01:20:26,440 --> 01:20:30,410
So for people who want to hear the answer can stick around. 

1306
01:20:31,480 --> 01:20:36,700
And the question here is that from Michael is well test and set ball, 

1307
01:20:37,410 --> 01:20:40,510
you yield critical section. 

1308
01:20:42,780 --> 01:20:44,300
Then while is zero, 

1309
01:20:45,390 --> 01:20:46,940
then you set up all to zero. 

1310
01:21:01,890 --> 01:21:02,810
Yeah, 

1311
01:21:11,690 --> 01:21:18,700
I think that should work. 

1312
01:21:20,700 --> 01:21:21,510
So, 

1313
01:21:25,250 --> 01:21:25,530
yeah, 

1314
01:21:27,090 --> 01:21:31,280
if you that should work, 

1315
01:21:32,070 --> 01:21:33,790
the problem here is all that. 

1316
01:21:34,120 --> 01:21:35,210
If you yield, 

1317
01:21:38,740 --> 01:21:41,550
then you are still going, 

1318
01:21:41,960 --> 01:21:43,700
you yield the processor. 

1319
01:21:45,640 --> 01:21:50,400
You are still going to be wake woken up before the lock. 

1320
01:21:50,860 --> 01:21:51,890
It's available. 

1321
01:21:53,350 --> 01:21:54,460
For instance, you again,

1322
01:21:54,470 --> 01:21:56,040
it's like you go, 

1323
01:21:56,770 --> 01:21:58,670
you yield the processor to. 

1324
01:21:58,680 --> 01:22:00,150
And for another thread, 

1325
01:22:00,360 --> 01:22:01,590
the threat can execute. 

1326
01:22:01,600 --> 01:22:02,710
It may not be necessary. 

1327
01:22:02,720 --> 01:22:05,030
The threat who acquire, who has a lock.

1328
01:22:05,830 --> 01:22:07,550
When that thread finishes on, 

1329
01:22:07,560 --> 01:22:09,150
a time quantity finishes, 

1330
01:22:09,410 --> 01:22:12,440
we are going to be open again and so forth. 

1331
01:22:13,910 --> 01:22:15,950
So it's still not as efficient. 

1332
01:22:15,960 --> 01:22:19,340
It's better than just doing busy wait, 

1333
01:22:19,970 --> 01:22:24,950
but it's not as good as putting the thread on the wake you and being woken

1334
01:22:24,960 --> 01:22:28,420
up only when the lock was released. 

1335
01:22:29,520 --> 01:22:32,120
In this case, you are going to be open up multiple times.

1336
01:22:35,520 --> 01:22:39,010
So is that i'll see you next time. 

1337
01:22:40,170 --> 01:22:41,110
Thanks, everyone.

