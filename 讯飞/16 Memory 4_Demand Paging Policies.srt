1
00:00:07,270 --> 00:00:08,670
Hello, everyone.

2
00:00:09,040 --> 00:00:16,850
So today we are going to talk about demand beijing and before starting

3
00:00:16,860 --> 00:00:18,050
thanks a lot, 

4
00:00:18,060 --> 00:00:23,600
everyone for filling in the survey about the class great feedback. 

5
00:00:24,310 --> 00:00:26,870
And we are going to try to act on it. 

6
00:00:30,090 --> 00:00:35,270
Before let me start with the same figure, 

7
00:00:35,280 --> 00:00:38,670
which I think you went over last lecture. 

8
00:00:39,920 --> 00:00:41,390
But let me do it again, 

9
00:00:41,400 --> 00:00:43,350
because it's a very important figure, 

10
00:00:43,360 --> 00:00:45,810
because with everything together, 

11
00:00:45,820 --> 00:00:48,710
all the memory related concepts, 

12
00:00:49,140 --> 00:00:50,730
we have learned so far. 

13
00:00:51,950 --> 00:00:54,320
As always, if you have any questions,

14
00:00:54,330 --> 00:00:56,360
please do not hesitate to, 

15
00:00:56,370 --> 00:00:57,380
let me know. 

16
00:00:58,950 --> 00:01:02,980
So here we have the virtual address on the left. 

17
00:01:03,430 --> 00:01:08,410
And you remember the virtual address is what the programs and what

18
00:01:08,420 --> 00:01:10,480
the processor sees. 

19
00:01:10,910 --> 00:01:12,180
On the right hand side, 

20
00:01:12,190 --> 00:01:13,700
you have the physical, 

21
00:01:13,710 --> 00:01:15,020
the memory address. 

22
00:01:17,130 --> 00:01:18,240
What we learn, we learn,

23
00:01:18,330 --> 00:01:22,800
we learn about the address translation in which these virtual addresses

24
00:01:23,690 --> 00:01:26,260
are translated to physical addresses. 

25
00:01:27,080 --> 00:01:36,750
And one way we did that is through page multi level page. 

26
00:01:37,570 --> 00:01:41,840
In this example, we are showing two level beijing.

27
00:01:42,740 --> 00:01:47,390
And therefore the virtual address have consist of three fields. 

28
00:01:47,760 --> 00:01:48,920
The last one, 

29
00:01:48,930 --> 00:01:51,880
the blue is blue in this figure is the offset. 

30
00:01:52,940 --> 00:01:54,410
The offset, the beating,

31
00:01:54,420 --> 00:01:57,370
the offset remains unchanged in the physical address. 

32
00:01:59,690 --> 00:02:02,720
Then the first field of the visual address, 

33
00:02:02,730 --> 00:02:08,670
it's an index to the first level in the first level bay stable. 

34
00:02:10,730 --> 00:02:13,840
And at that address, in the first day,

35
00:02:13,850 --> 00:02:16,160
at that location in the first page table, 

36
00:02:16,170 --> 00:02:20,780
you find the address of another page table at the second level. 

37
00:02:21,860 --> 00:02:28,120
The second field in the address of ritual between index denoted here. 

38
00:02:29,830 --> 00:02:33,670
It's an index to the second level page table, 

39
00:02:34,150 --> 00:02:39,030
which is referenced from the first label level page label. 

40
00:02:41,580 --> 00:02:46,010
At the corresponding location in the second level page table. 

41
00:02:47,230 --> 00:02:50,690
You have the physical page number. 

42
00:02:52,070 --> 00:02:55,630
And now your concatenate is a physical page number with the offset. 

43
00:02:56,400 --> 00:03:01,370
You got the physical others is the physical page number, 

44
00:03:01,380 --> 00:03:02,650
as you see here, 

45
00:03:02,660 --> 00:03:03,960
the big did. 

46
00:03:04,310 --> 00:03:08,890
And the offset represent the offset within that page. 

47
00:03:11,260 --> 00:03:13,070
So this is virtual address, 

48
00:03:13,730 --> 00:03:18,920
the address translation from virtual addresses to physical addresses using

49
00:03:19,460 --> 00:03:20,440
two level pages. 

50
00:03:23,650 --> 00:03:29,440
In addition, what you also learn about is about translation.

51
00:03:29,690 --> 00:03:30,960
Look aside buffers. 

52
00:03:33,950 --> 00:03:39,550
Can someone tell me why do we need a translation? 

53
00:03:39,560 --> 00:03:42,160
Look aside buffer or tlb for sure? 

54
00:03:45,190 --> 00:03:46,520
What problem does it solve? 

55
00:03:50,990 --> 00:03:51,710
It's exact. 

56
00:03:51,720 --> 00:03:53,510
Thanks, allison and gilbert.

57
00:03:53,520 --> 00:03:54,950
You are correct. 

58
00:03:55,970 --> 00:03:57,470
So fundamentally, 

59
00:03:58,020 --> 00:03:59,080
as you see, 

60
00:03:59,590 --> 00:04:02,110
with the page two level page tables, 

61
00:04:02,620 --> 00:04:05,380
you need in order to do the translation, 

62
00:04:05,390 --> 00:04:11,660
you need to do multiple memory access is we need to get a location

63
00:04:11,670 --> 00:04:13,380
from the first page, 

64
00:04:14,340 --> 00:04:17,460
from the first level page table, 

65
00:04:17,470 --> 00:04:20,260
then to access the second level page table, 

66
00:04:20,630 --> 00:04:24,630
a bunch, this means a bunch of memory access is,

67
00:04:25,130 --> 00:04:25,430
right. 

68
00:04:26,430 --> 00:04:28,580
When you are going to look to a physical, 

69
00:04:29,790 --> 00:04:32,480
to try to just look a location in memory, 

70
00:04:32,710 --> 00:04:35,310
to fetch an instruction or to access data, 

71
00:04:35,800 --> 00:04:40,560
you have to do multiple memory axis, which is very slow.

72
00:04:42,280 --> 00:04:45,410
So translation look aside buffer, solve this problem.

73
00:04:45,420 --> 00:04:47,110
So it's a small table, 

74
00:04:47,520 --> 00:04:53,350
which takes a virtual address that takes the first two fields

75
00:04:54,210 --> 00:04:55,480
in the virtual address, 

76
00:04:56,480 --> 00:05:03,880
which contains a page information and maps that to the physical page number. 

77
00:05:06,540 --> 00:05:07,690
And this is happening. 

78
00:05:07,700 --> 00:05:08,530
It's in harder. 

79
00:05:08,540 --> 00:05:10,370
So the translation is very quick. 

80
00:05:11,220 --> 00:05:12,850
This still be in the processor. 

81
00:05:17,130 --> 00:05:20,600
Then what is the other way we are going try to improve the performance? 

82
00:05:20,610 --> 00:05:24,320
Because even if we make one access to the ramp to the memory, 

83
00:05:25,280 --> 00:05:31,260
that the time to make that access a latency is much larger than accessing, 

84
00:05:31,270 --> 00:05:31,780
say, 

85
00:05:32,070 --> 00:05:35,450
registers or in the processor. 

86
00:05:35,750 --> 00:05:36,780
Its order of mind, 

87
00:05:36,790 --> 00:05:40,300
you slower to access physical memory. 

88
00:05:42,130 --> 00:05:43,200
To solve this problem, 

89
00:05:43,210 --> 00:05:45,320
what you learned last lecture, we can.

90
00:05:45,330 --> 00:05:48,240
And also at 61 c earlier on, 

91
00:05:48,730 --> 00:05:50,430
it's about you are using cash, 

92
00:05:52,010 --> 00:05:52,200
right? 

93
00:05:52,210 --> 00:05:52,720
A cash. 

94
00:05:53,530 --> 00:05:55,710
So cash, it's a smaller memory.

95
00:05:56,470 --> 00:05:57,870
And because it's smaller, 

96
00:05:58,440 --> 00:05:59,710
it can be either closer, 

97
00:05:59,720 --> 00:06:03,120
or it can be directly on the chip, on the processor.

98
00:06:04,210 --> 00:06:04,880
Therefore, 

99
00:06:04,890 --> 00:06:10,650
the latency to access this cache is much lower than the latency to access

100
00:06:10,660 --> 00:06:11,530
the physical memory. 

101
00:06:12,630 --> 00:06:14,650
If the data you are looking for, 

102
00:06:14,660 --> 00:06:15,810
it's already in cash, 

103
00:06:16,280 --> 00:06:17,890
the access will be much quicker. 

104
00:06:19,340 --> 00:06:23,890
And here we show set associative cache. 

105
00:06:23,900 --> 00:06:26,210
You remember that the set associative cache, 

106
00:06:26,220 --> 00:06:34,220
you have multiple sets of this kind of multiple

107
00:06:34,230 --> 00:06:38,780
sets of of blocks. 

108
00:06:39,380 --> 00:06:46,120
And each of them is identified by a tag with any set you

109
00:06:46,130 --> 00:06:47,400
can associate with me, 

110
00:06:49,130 --> 00:06:50,290
identify. 

111
00:06:50,980 --> 00:06:55,150
One of this is here is represented by a line. 

112
00:06:56,510 --> 00:06:58,360
One of these arose. 

113
00:07:02,240 --> 00:07:03,270
How do you do that? 

114
00:07:04,070 --> 00:07:05,480
So now, 

115
00:07:06,980 --> 00:07:14,290
the cash is addressed with a physical address. 

116
00:07:15,180 --> 00:07:20,550
So the physical address now is divided into other three fields, 

117
00:07:20,880 --> 00:07:23,930
which is very tag index and byte. 

118
00:07:24,870 --> 00:07:27,140
And the index. 

119
00:07:28,500 --> 00:07:34,390
If you have a memory set associated as set associated cash, 

120
00:07:34,860 --> 00:07:41,080
the index points to a particular set of such rows. 

121
00:07:43,070 --> 00:07:48,490
And then the tag is going to identify a row in the set. 

122
00:07:52,110 --> 00:07:53,290
And finally, 

123
00:07:56,420 --> 00:07:58,880
or in a bite, 

124
00:07:59,260 --> 00:08:04,350
will specify an index of the byte you are looking for in that row. 

125
00:08:05,390 --> 00:08:08,690
We also refer it as a block to these cells. 

126
00:08:14,910 --> 00:08:15,620
This is it. 

127
00:08:17,220 --> 00:08:23,690
You have address translation to speed up the address translation. 

128
00:08:23,700 --> 00:08:29,720
You use atlb which maps in hardware, 

129
00:08:29,730 --> 00:08:37,530
the virtual pace number to

130
00:08:37,540 --> 00:08:39,810
the physical pace number. 

131
00:08:41,120 --> 00:08:44,040
And then to farther speed up the access to the memory, 

132
00:08:44,990 --> 00:08:54,830
we use a cache and to locate the data in the cache, 

133
00:08:56,050 --> 00:08:57,450
we use these three fields, 

134
00:08:58,210 --> 00:08:59,660
tag index and buy. 

135
00:09:02,560 --> 00:09:03,430
Any questions? 

136
00:09:09,100 --> 00:09:18,090
Just remember that the tlb you address atlb with a virtual page number, 

137
00:09:18,100 --> 00:09:21,250
and you address a cache with a physical address. 

138
00:09:30,600 --> 00:09:31,450
So now, 

139
00:09:32,650 --> 00:09:33,690
the one question, 

140
00:09:33,700 --> 00:09:34,770
if you remember, 

141
00:09:35,350 --> 00:09:41,050
is there is a virtual address space can be larger than the physical address. 

142
00:09:41,700 --> 00:09:42,120
Also, 

143
00:09:42,130 --> 00:09:46,690
you have multiple virtual address spaces which are going to multiplex

144
00:09:46,700 --> 00:09:48,050
the same physical others, 

145
00:09:48,820 --> 00:09:53,590
because each process has its own virtual address space. 

146
00:09:56,800 --> 00:09:59,730
This means that at a given time, 

147
00:09:59,930 --> 00:10:05,650
you may not be able to store all the virtual address, 

148
00:10:05,660 --> 00:10:09,670
all the data in the virtual address space, 

149
00:10:09,860 --> 00:10:12,090
across all process processes, 

150
00:10:12,540 --> 00:10:13,730
in the physical memory. 

151
00:10:16,180 --> 00:10:17,510
And if you cannot do that, 

152
00:10:18,330 --> 00:10:19,960
some of these pages, 

153
00:10:20,280 --> 00:10:21,480
you need to put somewhere else. 

154
00:10:22,630 --> 00:10:29,740
Typically, somewhere else is on the disk or ssd now,

155
00:10:29,750 --> 00:10:32,780
the question is about when you need a page, 

156
00:10:34,490 --> 00:10:36,790
which is not in the memory, it's on the disk.

157
00:10:39,030 --> 00:10:43,170
How do you go about getting that page in memory? 

158
00:10:46,650 --> 00:10:53,330
That's what we are going to learn and focus on is the remaining of this lecture. 

159
00:10:55,700 --> 00:10:58,230
And when we are going to access a page, 

160
00:10:58,780 --> 00:11:00,720
which is not in physical memory, 

161
00:11:01,610 --> 00:11:03,240
what it called, you, it,

162
00:11:04,270 --> 00:11:05,540
then what happens? 

163
00:11:05,880 --> 00:11:07,290
You have a page four. 

164
00:11:12,760 --> 00:11:15,430
And the way this is indicated, 

165
00:11:15,440 --> 00:11:18,470
remember that when you do the batteries translation, 

166
00:11:18,710 --> 00:11:20,950
you look in the page table, in the page table,

167
00:11:20,960 --> 00:11:23,350
you find a page table entry corresponding to that page. 

168
00:11:24,770 --> 00:11:27,120
So that page table entry has a bit, 

169
00:11:28,490 --> 00:11:30,250
which is saying, for instance,

170
00:11:30,870 --> 00:11:31,860
it's invalid bit. 

171
00:11:32,560 --> 00:11:34,170
And if that be dissect, 

172
00:11:34,780 --> 00:11:40,900
this means that the page is not present in the physical memory. 

173
00:11:42,600 --> 00:11:43,130
Okay? 

174
00:11:43,640 --> 00:11:45,680
Now a baseball will occur. 

175
00:11:46,240 --> 00:11:47,510
And what happens? 

176
00:11:49,910 --> 00:11:51,280
So on baseball, 

177
00:11:51,790 --> 00:11:54,550
you have to engage the operating system, 

178
00:11:54,890 --> 00:11:58,810
and the operating system will make sure to bring the right page

179
00:11:59,030 --> 00:12:00,640
from the disk to memory. 

180
00:12:00,650 --> 00:12:05,780
So then you are going to be able to continue the execution of the program

181
00:12:09,210 --> 00:12:13,650
to bring a page from the disk to the physical memory. 

182
00:12:13,980 --> 00:12:15,690
You need to find a place to put it. 

183
00:12:18,330 --> 00:12:19,550
If you have free space, 

184
00:12:20,560 --> 00:12:21,310
you bring it down. 

185
00:12:23,190 --> 00:12:24,500
If you don't have free space, 

186
00:12:24,510 --> 00:12:29,870
they need to take an existing page and replace it with a new page. 

187
00:12:29,880 --> 00:12:30,910
You want to bring in memory. 

188
00:12:33,310 --> 00:12:36,310
Now, if that page you want to replace has been written,

189
00:12:36,320 --> 00:12:37,550
has been modified, 

190
00:12:38,930 --> 00:12:40,210
then you need to put it on the disk, 

191
00:12:41,980 --> 00:12:42,850
save it on the disk. 

192
00:12:43,550 --> 00:12:45,340
Before you replace it is on your page. 

193
00:12:50,970 --> 00:12:51,720
That's what it is. 

194
00:12:52,010 --> 00:12:56,000
We are going to go through this process several times during this lecture, 

195
00:12:56,720 --> 00:13:00,320
to make sure that the concepts are clear. 

196
00:13:02,100 --> 00:13:04,110
And before going forward, 

197
00:13:04,120 --> 00:13:13,020
notice that a it's a fundamental inversion here that you have the hardware. 

198
00:13:13,030 --> 00:13:15,840
It causes a page fault in this case, 

199
00:13:15,850 --> 00:13:19,840
because the invalid bit or in the page table entry set, 

200
00:13:20,460 --> 00:13:23,630
which then this fall is treated in software, 

201
00:13:24,550 --> 00:13:24,870
right? 

202
00:13:25,990 --> 00:13:32,800
As opposed to interrupts where the interacts are treated in hardware. 

203
00:13:33,160 --> 00:13:36,230
And then once you select the handle of the internet, only,

204
00:13:36,240 --> 00:13:37,310
then you go into software. 

205
00:13:43,400 --> 00:13:45,150
Again, to put things into perspective.

206
00:13:45,160 --> 00:13:45,910
Right now, 

207
00:13:46,440 --> 00:13:51,260
this is you have different levels of memory or storage. 

208
00:13:52,230 --> 00:13:54,050
You have our own cheap cash. 

209
00:13:55,380 --> 00:13:56,410
Here is a processor. 

210
00:13:56,420 --> 00:13:57,610
And in today's processors, 

211
00:13:57,620 --> 00:14:02,270
you actually have multiple cash cashes level of cash is even known

212
00:14:02,280 --> 00:14:03,410
as single processor, 

213
00:14:04,580 --> 00:14:08,310
because you may have a cache for each core. 

214
00:14:08,680 --> 00:14:10,830
And then you may have a unified cache, 

215
00:14:11,170 --> 00:14:12,860
which is across all course. 

216
00:14:14,710 --> 00:14:16,470
Then you have second level cache. 

217
00:14:17,370 --> 00:14:19,120
It's a main memory. 

218
00:14:19,780 --> 00:14:22,070
Then is this like secondary storage? 

219
00:14:22,730 --> 00:14:23,300
Of course, 

220
00:14:23,310 --> 00:14:27,650
you can even have tertiary storage tape or some kind of storage in the cloud. 

221
00:14:39,450 --> 00:14:40,320
What is the key here? 

222
00:14:40,330 --> 00:14:40,640
You like? 

223
00:14:41,730 --> 00:14:44,400
What we are trying to do is catching with everything else. 

224
00:14:44,680 --> 00:14:46,160
We're trying to do something very simple. 

225
00:14:46,330 --> 00:14:51,920
We want to try to have the cake and eat it too. 

226
00:14:53,290 --> 00:14:54,620
So we want to have, 

227
00:14:57,170 --> 00:15:04,530
we want to build a system which behaves like it has a storage of the largest

228
00:15:05,680 --> 00:15:08,360
storage device. 

229
00:15:08,650 --> 00:15:11,510
It has access to, 

230
00:15:11,520 --> 00:15:15,890
but the latency to access that storage. 

231
00:15:16,490 --> 00:15:20,570
It's the same as accessing zone, cheap cash.

232
00:15:21,390 --> 00:15:22,390
That's a holy great. 

233
00:15:23,590 --> 00:15:23,910
Right? 

234
00:15:27,450 --> 00:15:28,640
And again, 

235
00:15:28,650 --> 00:15:33,560
at the key here is that at every level, 

236
00:15:34,140 --> 00:15:37,130
the key technique is a cash is using cash. 

237
00:15:37,570 --> 00:15:39,920
You catch the data from the next level, 

238
00:15:39,930 --> 00:15:42,080
and you hope that for the mass, 

239
00:15:42,090 --> 00:15:44,360
most of the vast majority of time, 

240
00:15:44,650 --> 00:15:49,810
the program will only use the data in that cache. 

241
00:15:49,820 --> 00:15:53,010
You don't go to the next level. 

242
00:15:56,830 --> 00:15:59,730
And if the program exhibit locality, 

243
00:16:00,520 --> 00:16:00,860
therefore, 

244
00:16:00,870 --> 00:16:06,750
he spends most of the time in a reasonably small portion of the code

245
00:16:06,760 --> 00:16:09,360
or touching small portion of the data. 

246
00:16:09,620 --> 00:16:10,490
You are in luck, 

247
00:16:10,500 --> 00:16:15,940
because as long as you put this heavily accessed a region of memory

248
00:16:15,950 --> 00:16:17,860
of a program in the cache, 

249
00:16:18,140 --> 00:16:18,670
you are fine. 

250
00:16:22,000 --> 00:16:23,960
And the last point to make here, 

251
00:16:24,270 --> 00:16:27,210
the way to think about the main memory, 

252
00:16:27,220 --> 00:16:30,650
it as a cash for the secondary storage, for the disk.

253
00:16:31,590 --> 00:16:33,430
But it's, again, at each level,

254
00:16:33,440 --> 00:16:36,480
you can think it's a cache for the next level. 

255
00:16:39,260 --> 00:16:41,140
But we don't call it cash, 

256
00:16:41,150 --> 00:16:42,220
we call it paging. 

257
00:16:46,040 --> 00:16:47,120
So here is, again,

258
00:16:47,820 --> 00:16:53,840
another figure showing user baseball to what I described earlier. 

259
00:16:53,850 --> 00:16:54,680
In words, 

260
00:16:55,100 --> 00:17:01,110
this is using some animation to drive the point how so have say you have

261
00:17:01,120 --> 00:17:03,350
an instruction and you do the instruction fetch, 

262
00:17:04,110 --> 00:17:06,380
then you go to the memory management, 

263
00:17:06,390 --> 00:17:07,780
you need the memory management, 

264
00:17:07,790 --> 00:17:10,100
you need to handle the base table, 

265
00:17:10,330 --> 00:17:13,880
tlb and all of these great stuff to do address translation. 

266
00:17:16,070 --> 00:17:17,500
Now, you go,

267
00:17:17,510 --> 00:17:21,580
you find the page table entry. 

268
00:17:23,600 --> 00:17:25,870
And then from the patient, the entries,

269
00:17:25,880 --> 00:17:29,120
we are going to have the page number and the offset. 

270
00:17:34,920 --> 00:17:37,110
The offset keep coming from the virtual address. 

271
00:17:37,400 --> 00:17:40,210
The page number comes after translation. 

272
00:17:42,850 --> 00:17:46,570
But now let's assume that you do when you execute the next instruction, 

273
00:17:48,140 --> 00:17:49,820
you go to the page table, 

274
00:17:49,830 --> 00:17:54,640
but the entry doesn't exist or it existed by and it's invalid. 

275
00:17:56,240 --> 00:17:58,400
So then you have a page fault. 

276
00:17:59,490 --> 00:18:02,780
You go to the operating system to take care of things. 

277
00:18:05,720 --> 00:18:07,280
The page table, as i'm sorry,

278
00:18:07,290 --> 00:18:09,280
the operating system on fault, 

279
00:18:11,340 --> 00:18:19,400
is going to do what is going basically too loud to locate the page on the disk, 

280
00:18:20,950 --> 00:18:22,590
which is required by the program. 

281
00:18:22,850 --> 00:18:25,400
Load that page in the physical memory, 

282
00:18:27,300 --> 00:18:29,510
and then update the page table entry. 

283
00:18:31,580 --> 00:18:33,620
Finally, you restart the program,

284
00:18:35,600 --> 00:18:38,050
and the program will retry the previous instruction, 

285
00:18:38,060 --> 00:18:39,330
which calls a page fault. 

286
00:18:40,120 --> 00:18:40,310
Now, 

287
00:18:40,320 --> 00:18:45,650
the previous instruction is going to have the same look to do the same page

288
00:18:45,660 --> 00:18:47,090
from the same virtual address. 

289
00:18:47,730 --> 00:18:48,780
But now, 

290
00:18:49,470 --> 00:18:51,220
the page it's already in the memory, 

291
00:18:51,230 --> 00:18:56,340
so you are going to access that page and continue execution. 

292
00:18:57,980 --> 00:18:58,900
Is that clear? 

293
00:19:01,620 --> 00:19:02,540
Any questions? 

294
00:19:09,990 --> 00:19:13,580
So now we just said that the main page beijing is like cash, 

295
00:19:14,400 --> 00:19:21,000
the memory act as a cash for the persistent storage like these courses or sst

296
00:19:22,880 --> 00:19:28,360
now let's look from the. of your the cashing as from the point of

297
00:19:28,370 --> 00:19:30,660
view of a cash and characterize

298
00:19:31,070 --> 00:19:32,140
demand beijing. 

299
00:19:33,430 --> 00:19:36,140
First of all, what is the block size?

300
00:19:36,150 --> 00:19:38,240
What is the cash granada? 

301
00:19:39,650 --> 00:19:40,790
The block size? 

302
00:19:41,880 --> 00:19:44,240
It's basically, in this case, you,

303
00:19:44,250 --> 00:19:45,560
as a joke. 

304
00:19:45,570 --> 00:19:47,670
Now, it's 1 page,

305
00:19:48,650 --> 00:19:49,720
which is, say,

306
00:19:49,730 --> 00:19:52,600
four kilobytes between one kilobytes and 16 kilobytes. 

307
00:19:53,660 --> 00:19:54,120
Typically, 

308
00:19:55,780 --> 00:19:58,370
what is the organization of the cash? 

309
00:19:59,370 --> 00:20:01,430
We learned about direct map cache, 

310
00:20:02,110 --> 00:20:04,020
fully associative set associated. 

311
00:20:09,560 --> 00:20:16,710
The answer here is that it's fully associated provides you the most

312
00:20:21,450 --> 00:20:24,670
is the most efficient in using the cash. 

313
00:20:25,190 --> 00:20:25,910
If you remember, 

314
00:20:26,460 --> 00:20:31,860
why Why is a fully associative memory, 

315
00:20:32,910 --> 00:20:40,130
the most effective in using the cash storage? 

316
00:20:51,690 --> 00:20:54,250
You can place it anywhere. 

317
00:20:54,790 --> 00:20:56,300
There are no conflicts, 

318
00:20:56,310 --> 00:20:58,020
there are no conflict misses. 

319
00:20:59,200 --> 00:21:01,610
Like you remember his direct map cash, 

320
00:21:01,620 --> 00:21:02,970
you have conflict misses. 

321
00:21:03,330 --> 00:21:08,470
You don't have conflict misses here with the associative cash. 

322
00:21:17,860 --> 00:21:18,860
There is a question here. 

323
00:21:18,870 --> 00:21:23,230
So the page fault we see in the error message happen on the demand, 

324
00:21:23,240 --> 00:21:27,380
beijing does not save the program. 

325
00:21:34,170 --> 00:21:36,410
Maybe you can ask again the question. 

326
00:21:36,420 --> 00:21:40,950
I am afraid I do not understand whatever we are talking about here. 

327
00:21:40,960 --> 00:21:45,800
We are talking about the please ask the question again, 

328
00:21:46,660 --> 00:21:47,830
and i'll be happy to answer. 

329
00:21:52,240 --> 00:21:53,870
Now, how do you locate the page?

330
00:21:54,850 --> 00:21:58,680
First to check the dlb then you do the page traversal if it's

331
00:21:58,690 --> 00:22:01,660
not in the tlb right? 

332
00:22:01,670 --> 00:22:03,100
Is how you locate the page. 

333
00:22:04,340 --> 00:22:06,030
What is the page replacement policy? 

334
00:22:07,620 --> 00:22:08,580
As you'll see, 

335
00:22:09,150 --> 00:22:11,230
it's we want allah you, 

336
00:22:13,390 --> 00:22:15,380
at least recently used, 

337
00:22:16,390 --> 00:22:17,430
as there are others. 

338
00:22:17,900 --> 00:22:20,630
We are going to look at other replacement policies, 

339
00:22:21,720 --> 00:22:25,030
but typically, we try to have an approximation of al rego.

340
00:22:25,960 --> 00:22:28,750
We have to have an approximation of area, 

341
00:22:28,760 --> 00:22:31,930
because you just implementing area can be too expensive. 

342
00:22:34,180 --> 00:22:35,450
We learn about that. 

343
00:22:36,580 --> 00:22:37,590
What happened on a miss? 

344
00:22:37,600 --> 00:22:38,230
You saw that. 

345
00:22:38,620 --> 00:22:39,000
Right? 

346
00:22:40,040 --> 00:22:41,310
When there is a miss, 

347
00:22:41,850 --> 00:22:47,770
you are going to find the page on the disk and bring the page in the memory. 

348
00:22:50,100 --> 00:22:51,290
What happens on the right? 

349
00:22:51,980 --> 00:22:57,110
Remember that the cache is a copy of the data from memory. 

350
00:22:59,190 --> 00:23:01,620
If you modify the data in the cache, 

351
00:23:02,550 --> 00:23:07,270
you need also to modify as the copy of that data in memory. 

352
00:23:08,360 --> 00:23:10,310
And there are two ways to modify it. 

353
00:23:11,270 --> 00:23:13,290
One is right through. 

354
00:23:14,000 --> 00:23:18,810
This means that as soon as you update the cash, 

355
00:23:19,740 --> 00:23:21,380
also you update the main memory. 

356
00:23:21,390 --> 00:23:27,030
The second method is right back. 

357
00:23:27,990 --> 00:23:32,240
You just update the cash when you really want to replace the data

358
00:23:32,250 --> 00:23:36,160
in the cache with some other data from to bring it in, 

359
00:23:37,130 --> 00:23:44,830
then you are going to write the data from the cache to the

360
00:23:44,840 --> 00:23:47,450
memory before replacing it. 

361
00:23:49,060 --> 00:23:52,200
In this case, we are talking about memory and the disk.

362
00:23:52,890 --> 00:23:56,200
We are definitely talking about right back. 

363
00:23:57,040 --> 00:23:58,820
Why did I arrive back in this case? 

364
00:24:00,320 --> 00:24:02,710
Tell me why don't we do right through? 

365
00:24:21,030 --> 00:24:21,700
Excellent. 

366
00:24:21,710 --> 00:24:24,470
So allison and tyro. 

367
00:24:24,890 --> 00:24:32,580
So this is because it's very expensive to read the data from the disk. 

368
00:24:33,940 --> 00:24:36,640
It can be order of magnitude more expensive. 

369
00:24:37,620 --> 00:24:39,020
Just to give you a sense, 

370
00:24:40,310 --> 00:24:47,730
the latency to memory

371
00:24:48,240 --> 00:24:51,920
is maybe between 15 nanoseconds and 100 nanoseconds. 

372
00:24:53,490 --> 00:24:58,150
The latency to read and write from a disk can be 1 million seconds. 

373
00:24:59,900 --> 00:25:02,370
What is 34, or that are minded?

374
00:25:05,970 --> 00:25:07,140
So it's huge difference. 

375
00:25:07,930 --> 00:25:09,310
So that's how you avoid. 

376
00:25:09,940 --> 00:25:15,900
You try to minimize the number of times you write data back to the storage

377
00:25:16,210 --> 00:25:16,730
to the risk. 

378
00:25:20,830 --> 00:25:27,170
I see, so this is a question.

379
00:25:27,180 --> 00:25:30,690
It seems like when the baseball happens for the first time, 

380
00:25:31,180 --> 00:25:34,380
it tries a program again after the man paging instead of killing

381
00:25:34,390 --> 00:25:35,540
the program right away. 

382
00:25:35,890 --> 00:25:38,570
But on in zimbabwe often see page fold message, 

383
00:25:39,440 --> 00:25:43,710
the painful message you are seeing when you are debugging is different. 

384
00:25:44,560 --> 00:25:45,640
That is, for instance,

385
00:25:45,650 --> 00:25:51,040
when you are going to try to access some invalid region in the memory, 

386
00:25:51,600 --> 00:25:53,040
like something you didn't allocate, 

387
00:25:54,130 --> 00:25:54,770
for instance, 

388
00:25:55,260 --> 00:26:03,090
then you have faithful that is like you just have an address which

389
00:26:03,100 --> 00:26:06,190
doesn't belong to and to read or write to another address, 

390
00:26:06,200 --> 00:26:07,630
which doesn't belong to the program, 

391
00:26:07,640 --> 00:26:09,190
because it's not allocated yet. 

392
00:26:11,680 --> 00:26:12,400
So that's different. 

393
00:26:13,160 --> 00:26:18,000
The special fault I was talking about is not visible to the program. 

394
00:26:18,620 --> 00:26:19,890
This happens under the hood. 

395
00:26:21,370 --> 00:26:23,270
And what you said is correct. 

396
00:26:23,950 --> 00:26:26,190
That is on this page fault happens. 

397
00:26:26,740 --> 00:26:28,860
Yes, you are going to do a trap,

398
00:26:30,920 --> 00:26:33,160
an exception trap to the operating system, 

399
00:26:33,170 --> 00:26:34,360
the operating system, 

400
00:26:35,730 --> 00:26:37,190
get the page from the disk, 

401
00:26:37,200 --> 00:26:38,350
put in the memory. 

402
00:26:38,960 --> 00:26:44,120
And then you retry it and you restart the program from the same instruction. 

403
00:26:53,030 --> 00:26:53,910
But remember, 

404
00:26:55,180 --> 00:26:57,940
we want to provide with the virtual memory, 

405
00:26:57,950 --> 00:27:01,000
the illusion of infinite physical memory. 

406
00:27:02,120 --> 00:27:03,470
This is one example. 

407
00:27:03,480 --> 00:27:05,670
Virtual memory is huge, is for your byte,

408
00:27:05,680 --> 00:27:07,430
you have 32 bits addresses. 

409
00:27:08,980 --> 00:27:10,420
But now most of the machines, 

410
00:27:10,750 --> 00:27:13,100
even including your phone, has 64 bits.

411
00:27:14,380 --> 00:27:17,170
So it's a huge amount of memory of virtual memory. 

412
00:27:17,510 --> 00:27:19,960
There is no way you can have a physical memory, 

413
00:27:19,970 --> 00:27:24,530
large enough of all the entire visual memory of an application. 

414
00:27:25,870 --> 00:27:29,860
Then you map this kind of pages from the visual memory using the page table

415
00:27:29,870 --> 00:27:31,100
to the physical memory. 

416
00:27:31,880 --> 00:27:34,150
Then some of the page are, 

417
00:27:34,410 --> 00:27:37,870
which are the not fitting the physical memory are going to be on the disk. 

418
00:27:40,670 --> 00:27:41,180
Why is that? 

419
00:27:41,190 --> 00:27:43,140
Because the disk is much higher, 

420
00:27:43,150 --> 00:27:47,470
even sst is much harder than a physical memory. 

421
00:27:47,560 --> 00:27:49,270
You have a lot of more space. 

422
00:27:57,970 --> 00:28:01,560
It's, again, going to the disk and getting the pace.

423
00:28:01,570 --> 00:28:03,900
So demand beijing happen, 

424
00:28:03,910 --> 00:28:08,130
transparent is not visible to the application. 

425
00:28:08,400 --> 00:28:12,430
The only way the application may notice is that it's a little bit slower, 

426
00:28:13,240 --> 00:28:16,220
because you need, instead of getting the data directly from memory,

427
00:28:16,230 --> 00:28:18,180
you have to go first the disk, 

428
00:28:18,450 --> 00:28:20,460
move the data into memory, and then get the data.

429
00:28:31,290 --> 00:28:32,790
This is a page table entry. 

430
00:28:32,800 --> 00:28:35,990
If you remember, from two lectures ago,

431
00:28:36,620 --> 00:28:38,070
you have the page frame number, 

432
00:28:38,080 --> 00:28:40,590
the first 32 beats addresses address, 

433
00:28:41,170 --> 00:28:43,930
the first page, the page frame number.

434
00:28:43,940 --> 00:28:47,110
This represent the surface20 bits. 

435
00:28:47,680 --> 00:28:50,020
The last 12, 20 bits,

436
00:28:50,030 --> 00:28:53,790
12 bits are some a bunch of bits of

437
00:28:57,830 --> 00:29:00,460
each bit has a different semantics. 

438
00:29:00,470 --> 00:29:03,140
And for the purpose of this lecture, 

439
00:29:03,700 --> 00:29:05,370
we care about 2 bits. 

440
00:29:05,860 --> 00:29:11,070
One is p which is called present or valid. 

441
00:29:11,730 --> 00:29:19,680
This basically says that the corresponding page is in memory. 

442
00:29:22,260 --> 00:29:24,130
If p is zero, the bit is zero,

443
00:29:24,140 --> 00:29:26,730
then the page is not in memory somewhere on the disk. 

444
00:29:28,490 --> 00:29:34,310
And d is a dirty bit. 

445
00:29:34,960 --> 00:29:38,040
And this says, as a patient has been modified recently,

446
00:29:38,050 --> 00:29:42,390
this has been modified since it was brought in memory. 

447
00:29:43,630 --> 00:29:44,720
For instance, for example,

448
00:29:49,840 --> 00:29:52,390
this means that why do you think, 

449
00:29:52,700 --> 00:29:54,690
how do you think you are going to use a dirty bit? 

450
00:30:03,770 --> 00:30:04,930
Why do we need it? 

451
00:30:11,400 --> 00:30:19,220
It's exactly is to determine it's if you need to write the page back, 

452
00:30:20,270 --> 00:30:22,260
if we have to replace that page, 

453
00:30:22,630 --> 00:30:27,570
because we no longer have room in the physical memory to bring a new page, 

454
00:30:28,210 --> 00:30:33,300
then if the page we want to replace has been modified, 

455
00:30:33,310 --> 00:30:34,940
we need first to write to the disk, 

456
00:30:34,950 --> 00:30:36,100
not with the information. 

457
00:30:40,430 --> 00:30:41,240
That's great. 

458
00:30:48,000 --> 00:30:48,790
This is a demand. 

459
00:30:48,800 --> 00:30:50,710
Paging mechanism is very simple. 

460
00:30:50,720 --> 00:30:56,860
Again, it's like repeating it.

461
00:30:58,030 --> 00:31:02,620
You look at the pde baseball entry of the page. 

462
00:31:02,630 --> 00:31:10,320
If the bit of the pd is valid than the means that the page in memories, 

463
00:31:10,330 --> 00:31:13,200
you go and access the data from the memory. 

464
00:31:13,520 --> 00:31:14,710
If it's not valid, 

465
00:31:15,210 --> 00:31:19,150
then this means that the page is not in memory. 

466
00:31:19,160 --> 00:31:19,990
It's on the disk. 

467
00:31:20,780 --> 00:31:23,460
And when you do that, 

468
00:31:23,470 --> 00:31:27,060
you these results in a trap, 

469
00:31:28,410 --> 00:31:29,480
it's a page fault. 

470
00:31:30,030 --> 00:31:31,730
And 1 page fault, 

471
00:31:32,140 --> 00:31:35,020
you choose an old page to replace. 

472
00:31:35,030 --> 00:31:38,770
If you don't have enough room in the memory. 

473
00:31:40,370 --> 00:31:43,410
If that old page has a dirty bit set, 

474
00:31:43,420 --> 00:31:46,740
this means that you have to write that page to the disk. 

475
00:31:47,780 --> 00:31:49,410
Then once you are done with that, 

476
00:31:49,870 --> 00:31:54,340
you also need to add to invalidate the pt entry for the page, 

477
00:31:54,350 --> 00:31:58,390
because now you are going to remove from the you are going to remove it

478
00:31:58,400 --> 00:32:00,190
from the memory. 

479
00:32:00,510 --> 00:32:03,790
And also you need to invalidate the tlb entry for that page. 

480
00:32:04,480 --> 00:32:06,270
Once you are done with it, 

481
00:32:06,280 --> 00:32:12,450
you are going to bring the new page from the disk to memory in place

482
00:32:12,780 --> 00:32:13,650
of the old page. 

483
00:32:14,960 --> 00:32:16,570
And once you bring the new page, 

484
00:32:17,160 --> 00:32:20,880
your update to the pdu of the new page. 

485
00:32:21,570 --> 00:32:25,010
And you are ready to go. 

486
00:32:32,290 --> 00:32:32,930
And by the way, 

487
00:32:32,940 --> 00:32:40,650
when this happens and operating system is doing all this kind of work

488
00:32:41,140 --> 00:32:44,000
to bring the page from the disk to memory, 

489
00:32:45,100 --> 00:32:48,510
it's a lot of io and in the meantime, 

490
00:32:48,950 --> 00:32:54,700
you try to scandal and run other processes which are not blocked. 

491
00:32:58,890 --> 00:33:03,280
So at those origins of the beijing and the origin of the beijing is states

492
00:33:03,290 --> 00:33:06,400
long time ago from 70s and in 70s. 

493
00:33:07,390 --> 00:33:14,030
It was a time before everyone has a personal computer and what you have a terminal. 

494
00:33:15,280 --> 00:33:17,400
It looks like a computer, but it's just a terminal.

495
00:33:17,870 --> 00:33:19,520
And they are connected to the computers. 

496
00:33:19,530 --> 00:33:23,630
You have many people running their programs on the same computer. 

497
00:33:23,920 --> 00:33:26,990
And they are using the computer from these terminals. 

498
00:33:28,910 --> 00:33:31,340
Now, because you have so many users,

499
00:33:31,830 --> 00:33:34,470
and the physical memory was quite small. 

500
00:33:34,820 --> 00:33:38,480
Again, not all the users programs could fit in the memory.

501
00:33:38,490 --> 00:33:46,480
So now you need to do you need the ability to

502
00:33:46,490 --> 00:33:50,530
swap and to put some of these a pages of these pages, 

503
00:33:50,540 --> 00:33:52,910
which are not used often, 

504
00:33:52,920 --> 00:33:56,890
or they haven't used for a while to put them on the disk. 

505
00:33:57,580 --> 00:33:57,750
Right? 

506
00:33:57,960 --> 00:34:00,200
This is what happened early on. 

507
00:34:01,040 --> 00:34:01,930
That's why you have paid. 

508
00:34:18,010 --> 00:34:20,120
This is basically the model you have, 

509
00:34:20,130 --> 00:34:23,200
we should we are going to have in mind, 

510
00:34:23,210 --> 00:34:28,090
and we are going to continue to discuss the image, pay,

511
00:34:28,500 --> 00:34:30,370
demand, paging for the rest of the lecture.

512
00:34:31,930 --> 00:34:38,460
Now, what happens when the pieces with the personal computers?

513
00:34:38,740 --> 00:34:39,760
Actually, it's personal computers.

514
00:34:39,770 --> 00:34:40,060
Initially. 

515
00:34:40,070 --> 00:34:41,560
You don't have visual memory. 

516
00:34:41,570 --> 00:34:45,130
You have one program only running a on a machine, 

517
00:34:45,620 --> 00:34:48,050
and that program taking the entire physical memory. 

518
00:34:49,190 --> 00:34:49,580
However, 

519
00:34:49,590 --> 00:34:53,300
as personal computers became more and more sophisticated and you run

520
00:34:53,310 --> 00:34:55,580
multiple programs on the same computer, 

521
00:34:56,010 --> 00:34:56,760
now you're still, 

522
00:34:57,410 --> 00:34:59,000
you are back in square one, 

523
00:34:59,340 --> 00:35:02,370
because like we discussed several times, 

524
00:35:02,740 --> 00:35:07,070
the aggregate memory required by all processes, 

525
00:35:07,080 --> 00:35:12,080
all the application running at a given time exceeds the physical memory. 

526
00:35:13,330 --> 00:35:15,360
Again, what is a solution here?

527
00:35:15,370 --> 00:35:17,740
Individualize them as a memo, the memory.

528
00:35:18,170 --> 00:35:24,350
And you need to keep some of these memory of this application on the disk. 

529
00:35:24,870 --> 00:35:27,660
The memory, hopefully, which is not accessed very often,

530
00:35:31,340 --> 00:35:31,890
all these. 

531
00:35:31,900 --> 00:35:37,010
And now machines are connected to the cloud, 

532
00:35:37,820 --> 00:35:41,160
all of your phones and laptops. 

533
00:35:41,560 --> 00:35:46,500
And you have the same situation in the the cloud. 

534
00:35:46,510 --> 00:35:48,420
You have very powerful computers, 

535
00:35:48,900 --> 00:35:51,210
and they run a lot of applications. 

536
00:35:51,560 --> 00:35:52,690
And they also, 

537
00:35:52,700 --> 00:35:54,090
obviously with virtual members. 

538
00:35:59,000 --> 00:35:59,910
This is, again,

539
00:36:00,480 --> 00:36:02,670
if you look at one machine, 

540
00:36:03,100 --> 00:36:05,580
if you do the ps program status, 

541
00:36:05,590 --> 00:36:07,680
this is kind of what you get. 

542
00:36:08,680 --> 00:36:14,040
And here i'm just showing the memory in this particular case is pretty utilized. 

543
00:36:14,050 --> 00:36:18,380
I say that you have 13 gigabytes of memory. 

544
00:36:18,390 --> 00:36:21,630
It's used, and only 2.7 is not used.

545
00:36:21,640 --> 00:36:24,030
So it's more than 80% it's used. 

546
00:36:24,800 --> 00:36:28,160
And some of them is shared memory. 

547
00:36:28,170 --> 00:36:33,640
Remember that different application can share memory. 

548
00:36:33,650 --> 00:36:36,280
For instance, if they use the same libraries,

549
00:36:36,690 --> 00:36:38,580
they share the code of those libraries, 

550
00:36:38,590 --> 00:36:44,180
because it doesn't make sense to make a copy of the same code for each

551
00:36:44,190 --> 00:36:45,110
of the application. 

552
00:36:50,230 --> 00:36:53,560
So there are many uses of ritual memory and demand beijing. 

553
00:36:55,870 --> 00:36:59,990
I remember that in the virtual memory or one segment, 

554
00:37:00,000 --> 00:37:01,390
you have is a stack. 

555
00:37:02,460 --> 00:37:07,780
The stack grows downwards from the high addresses to the lower addresses, 

556
00:37:08,400 --> 00:37:11,460
as you allocate and to push more data on the stack, 

557
00:37:12,060 --> 00:37:13,680
you may have to extend the stack. 

558
00:37:14,510 --> 00:37:17,070
So this is how you are going to do it. 

559
00:37:17,400 --> 00:37:19,830
If you are going to want to expand the stack, 

560
00:37:20,290 --> 00:37:22,760
then it's, again, what will happen?

561
00:37:22,770 --> 00:37:23,800
You have a page fault. 

562
00:37:24,820 --> 00:37:26,850
You are going to go to the operating system, 

563
00:37:26,860 --> 00:37:30,290
and the operating system is going to increase the side of the stack, 

564
00:37:31,560 --> 00:37:33,590
ok and allocate more memory for the stack. 

565
00:37:34,750 --> 00:37:37,300
Another way is process fork. 

566
00:37:37,310 --> 00:37:38,500
We discuss about that. 

567
00:37:38,510 --> 00:37:38,780
Here. 

568
00:37:38,790 --> 00:37:40,580
We are going to re discuss again. 

569
00:37:41,560 --> 00:37:43,650
When you do a fork, 

570
00:37:43,660 --> 00:37:50,190
you remember that the child process has the same code as the same in science. 

571
00:37:50,630 --> 00:37:54,430
And it has the same resources as a parent process. 

572
00:37:57,830 --> 00:37:59,930
But because you have the same code, 

573
00:38:00,490 --> 00:38:03,520
one simple solution will be your copies, 

574
00:38:03,530 --> 00:38:05,750
the entire code, 

575
00:38:06,620 --> 00:38:10,650
and the data from the parent process to the child process before you

576
00:38:10,660 --> 00:38:12,090
can start the child process. 

577
00:38:12,920 --> 00:38:15,190
The problem is that it will take a lot of time. 

578
00:38:16,260 --> 00:38:22,500
So instead, what you do here is that when you create the child process,

579
00:38:22,510 --> 00:38:30,170
you create it immediately and you have it.to all the memory of the parent process. 

580
00:38:30,180 --> 00:38:31,730
So they share the same memory. 

581
00:38:32,230 --> 00:38:42,000
The only difference is that from the point of view of the child process, 

582
00:38:42,490 --> 00:38:47,700
all the memory is marked as read only no rights. 

583
00:38:48,730 --> 00:38:49,140
Right? 

584
00:38:50,170 --> 00:38:53,280
Now when you read everything is perfect, right?

585
00:38:53,290 --> 00:38:55,360
Because you are going to read the same content, 

586
00:38:56,150 --> 00:39:01,840
which is not modified as not modified as from the parrot. 

587
00:39:03,360 --> 00:39:03,700
But now, 

588
00:39:04,640 --> 00:39:08,150
if the child wants to modify a piece of data, 

589
00:39:08,600 --> 00:39:12,740
then because the pages are read only, 

590
00:39:13,110 --> 00:39:18,700
then it's going to cause aa trap and exception is going to be intercepted

591
00:39:18,710 --> 00:39:20,100
by the operating system. 

592
00:39:20,490 --> 00:39:25,090
And the operating system now is going to copy the page. 

593
00:39:25,490 --> 00:39:29,460
Read on the only page is going to create another copy now for the child. 

594
00:39:29,890 --> 00:39:35,830
Now is going to give access to write to its own copy of that page to the child. 

595
00:39:42,060 --> 00:39:43,170
When you exec, 

596
00:39:43,180 --> 00:39:46,450
you only bring in parts of the binary inactive use, 

597
00:39:46,460 --> 00:39:50,780
you just brings few pages in the memory or don't bring, 

598
00:39:50,790 --> 00:39:54,320
cause I am tired program into memory, 

599
00:39:54,330 --> 00:39:59,000
because that can be too big and sample some parts of the program you may know, 

600
00:39:59,010 --> 00:40:00,920
but never touch when you are running it. 

601
00:40:02,180 --> 00:40:03,610
The similarly with a stack, 

602
00:40:03,620 --> 00:40:06,570
you can extend the heap so forth. 

603
00:40:08,490 --> 00:40:15,540
This is another example about an animation about what happens

604
00:40:16,360 --> 00:40:20,070
when it's an end to an example and show you what happens. 

605
00:40:20,330 --> 00:40:23,650
When you start a new program, 

606
00:40:24,150 --> 00:40:25,290
you have a new program. 

607
00:40:25,300 --> 00:40:26,730
The program is on the disk. 

608
00:40:28,570 --> 00:40:30,800
It's not exact, is an extension.

609
00:40:31,220 --> 00:40:32,410
You have the code, 

610
00:40:32,420 --> 00:40:34,210
you have some data, static data,

611
00:40:34,220 --> 00:40:36,010
and then for some other information, 

612
00:40:37,240 --> 00:40:38,460
you need to bring that in memory. 

613
00:40:38,470 --> 00:40:40,740
You need to bring the code in memory in order to run. 

614
00:40:41,360 --> 00:40:42,800
And when you are going to start, 

615
00:40:43,260 --> 00:40:45,530
you are going to bring some part of the code in memory. 

616
00:40:45,540 --> 00:40:48,290
And then you are going to bring some data in memory. 

617
00:40:48,300 --> 00:40:53,770
And then you are going to allocate heap and the stack for that particular program. 

618
00:40:55,060 --> 00:40:58,890
This is the view from the virtual address space. 

619
00:40:58,900 --> 00:41:03,480
Bus stands for virtual address space of the process which was

620
00:41:03,490 --> 00:41:05,280
instantiate to run the program. 

621
00:41:06,210 --> 00:41:08,470
And let's see. 

622
00:41:09,930 --> 00:41:15,580
Then you obviously are going to back all these virtual addresses, 

623
00:41:15,590 --> 00:41:17,680
everything in the virtual address, 

624
00:41:17,960 --> 00:41:19,560
which is used by the program. 

625
00:41:19,830 --> 00:41:22,400
You are going to be backed to the disk. 

626
00:41:24,490 --> 00:41:29,390
Finally, between the virtual address and the memory, you need to do,

627
00:41:30,280 --> 00:41:32,310
the translation is done with the page table. 

628
00:41:32,820 --> 00:41:39,050
Some entry from the page table are going to.2 pages in the physical memory. 

629
00:41:40,120 --> 00:41:43,220
And if a base table, 

630
00:41:44,070 --> 00:41:46,710
it's invalid, 

631
00:41:48,050 --> 00:41:49,800
that doesn't exist in memory, 

632
00:41:50,080 --> 00:41:55,150
use a corresponding page table entry is going to point to the location

633
00:41:55,160 --> 00:41:56,430
of that page on the disk. 

634
00:42:05,770 --> 00:42:09,320
Fundamentally, what you need to do if that page is on the disk,

635
00:42:09,330 --> 00:42:11,240
is to have a function, something like that.

636
00:42:11,250 --> 00:42:13,520
It's a fine blog which takes an argument, 

637
00:42:13,530 --> 00:42:17,190
the process id and the patient number of that. 

638
00:42:19,440 --> 00:42:23,630
And and then for that paid number and the process, 

639
00:42:23,640 --> 00:42:29,890
you are going to get a disk location of on the disk where you can find

640
00:42:29,900 --> 00:42:30,510
that page. 

641
00:42:34,430 --> 00:42:38,200
So this is very similarly the paste table concept, 

642
00:42:39,860 --> 00:42:43,520
but it is purely done purely in software. 

643
00:42:44,870 --> 00:42:47,390
No, dld no, nothing like that.

644
00:42:52,710 --> 00:42:57,810
Why do you take the pid why do you take the argument? 

645
00:42:57,820 --> 00:42:59,490
Is the pid argument here? 

646
00:43:13,340 --> 00:43:13,890
Anyone? 

647
00:43:17,990 --> 00:43:22,280
Because the virtual address space is per process. 

648
00:43:24,710 --> 00:43:26,790
The base tables are per process. 

649
00:43:28,470 --> 00:43:32,510
If I give you only the page number is not well defined, 

650
00:43:33,440 --> 00:43:34,810
because multiple processes, 

651
00:43:34,820 --> 00:43:36,530
I can have a the same page numbers, 

652
00:43:38,320 --> 00:43:38,440
right? 

653
00:43:38,450 --> 00:43:43,660
Because a patient number represents something in their virtual address space. 

654
00:43:44,480 --> 00:43:46,900
And each of them has a different virtual address space. 

655
00:43:50,100 --> 00:43:53,340
So that's why you need to give the person the process identifier

656
00:43:54,800 --> 00:43:56,440
to identify the virtual address space. 

657
00:44:02,080 --> 00:44:03,000
Where do you store it? 

658
00:44:03,330 --> 00:44:05,260
Obviously, you want to study the memory if you,

659
00:44:05,270 --> 00:44:10,780
because if you store it on the disks and you need to bring it from the disk, 

660
00:44:10,790 --> 00:44:11,980
is going to be one slower. 

661
00:44:16,000 --> 00:44:17,070
That's pretty much it. 

662
00:44:32,300 --> 00:44:33,220
Any questions? 

663
00:44:39,130 --> 00:44:41,450
By the way, like, in the case of the shared memory,

664
00:44:42,840 --> 00:44:51,070
you also can share the disk between different applications processes. 

665
00:44:51,770 --> 00:44:53,330
So, for instance, and I like,

666
00:44:53,340 --> 00:44:54,450
i'll show you next, 

667
00:44:56,220 --> 00:44:58,490
the way i'll show you that is like, for instance,

668
00:44:58,500 --> 00:45:01,910
here against his virtual address space for on process. 

669
00:45:02,250 --> 00:45:05,050
And you can have another process and another process will have

670
00:45:05,060 --> 00:45:08,300
its own visual address space is owned by page labels. 

671
00:45:10,430 --> 00:45:17,190
Here, it's about the stack and the heap and the data of the second process.

672
00:45:17,850 --> 00:45:20,680
And assume that the second process is the first process. 

673
00:45:21,030 --> 00:45:25,470
Running the same program are just two instances of the same program. 

674
00:45:26,130 --> 00:45:27,320
In this particular case, 

675
00:45:27,330 --> 00:45:28,360
as you can see, 

676
00:45:28,650 --> 00:45:29,800
the code is shared, 

677
00:45:30,230 --> 00:45:31,350
because the code is read. 

678
00:45:31,360 --> 00:45:34,430
You remember, it's read only so it doesn't change.

679
00:45:34,970 --> 00:45:41,240
So if you have to programs which uses out of instances, 

680
00:45:41,450 --> 00:45:41,680
sorry, 

681
00:45:41,690 --> 00:45:44,740
it's you have two instances of the same program

682
00:45:45,010 --> 00:45:49,300
than the virtual address space of the two, 

683
00:45:50,670 --> 00:45:51,950
the two instances, 

684
00:45:51,960 --> 00:45:53,240
the two processes. 

685
00:45:53,500 --> 00:45:58,080
They can share the same code on the disk. 

686
00:45:59,100 --> 00:46:01,010
They said, share the same code, obviously,

687
00:46:01,020 --> 00:46:02,370
and you can share also, 

688
00:46:02,840 --> 00:46:06,670
we can share the same old code also in the physical memory. 

689
00:46:09,970 --> 00:46:10,500
Make sense? 

690
00:46:13,060 --> 00:46:13,840
Any questions? 

691
00:46:18,950 --> 00:46:19,480
Okay. 

692
00:46:23,040 --> 00:46:23,430
Again, 

693
00:46:24,920 --> 00:46:26,350
this page table, 

694
00:46:26,360 --> 00:46:27,780
the second process, 

695
00:46:27,790 --> 00:46:30,220
some of the pages have been memory, some of them,

696
00:46:30,860 --> 00:46:32,940
the one which are not in memories are backed on this. 

697
00:46:37,260 --> 00:46:38,890
Now say the process active, 

698
00:46:38,900 --> 00:46:40,530
the first process is active. 

699
00:46:41,030 --> 00:46:47,420
Then if you are going to have fetched an instruction on access

700
00:46:47,430 --> 00:46:49,180
and physical memory, 

701
00:46:49,660 --> 00:46:53,580
then you look in the base table. 

702
00:46:53,590 --> 00:46:55,980
If, say the base table entry is invalid,

703
00:46:56,390 --> 00:47:01,040
then you have a page fold as the operating system locates a block

704
00:47:01,400 --> 00:47:03,320
on the disk which contains a page, 

705
00:47:03,670 --> 00:47:09,740
and then move it to the memory. 

706
00:47:11,940 --> 00:47:16,730
Is another summary step by step of handling a baseball. 

707
00:47:17,440 --> 00:47:19,110
Again, you access a memory,

708
00:47:21,490 --> 00:47:23,170
mutual memory, physically,

709
00:47:23,180 --> 00:47:26,090
the and it's step one. 

710
00:47:26,470 --> 00:47:30,940
Say, the program, the associated page table entries invalid,

711
00:47:31,490 --> 00:47:36,940
these results in a trap baseball with the operating system, 

712
00:47:42,820 --> 00:47:46,180
locate the block where the page is stored on the disk, 

713
00:47:46,790 --> 00:47:48,630
bring the page in memory, 

714
00:47:48,980 --> 00:47:50,200
in a free frame, 

715
00:47:50,210 --> 00:47:52,640
page frame updates, 

716
00:47:52,650 --> 00:47:53,840
a page table entries, 

717
00:47:53,850 --> 00:47:55,000
and restart the instruction. 

718
00:47:59,270 --> 00:48:03,360
A few announcements the hallmark for has been released. 

719
00:48:05,420 --> 00:48:06,430
This week. 

720
00:48:06,440 --> 00:48:09,920
Please understand the design reviews. 

721
00:48:10,220 --> 00:48:13,860
Remember, the design review starts at the hour.

722
00:48:14,730 --> 00:48:16,410
They are not on the berkeley time. 

723
00:48:17,530 --> 00:48:17,980
Please. 

724
00:48:19,600 --> 00:48:21,620
So you give time to everyone. 

725
00:48:22,320 --> 00:48:30,260
They can get the feedback from the ta in mind that you need to participate

726
00:48:30,270 --> 00:48:32,020
during design reviews. 

727
00:48:32,600 --> 00:48:34,750
A part of your grade is based on that. 

728
00:48:35,750 --> 00:48:37,070
And other than that, 

729
00:48:37,720 --> 00:48:40,390
I know that there are now many deadlines. 

730
00:48:40,660 --> 00:48:42,710
There are no deadlines for the next 2 weeks, 

731
00:48:43,090 --> 00:48:46,810
but the next following weeks of november 1st will be pretty brutal. 

732
00:48:47,450 --> 00:48:48,780
So as such, 

733
00:48:49,160 --> 00:48:56,470
please make progress on homework for a project to and start studying

734
00:48:56,480 --> 00:48:57,430
about meter to, 

735
00:48:58,040 --> 00:49:01,320
which is mostly the materials we are learning. 

736
00:49:03,470 --> 00:49:06,310
We have been learned since the first meter. 

737
00:49:06,810 --> 00:49:10,190
So meter two will still have some of, 

738
00:49:10,960 --> 00:49:12,090
like, maybe 10,

739
00:49:12,100 --> 00:49:15,080
20% from the materials of mid term one. 

740
00:49:15,850 --> 00:49:22,800
But this means that 1890% of the materials will be from the lectures

741
00:49:23,070 --> 00:49:25,210
since midterm one. 

742
00:49:36,450 --> 00:49:44,670
Now let's switch the gears and answer the following key question. 

743
00:49:46,240 --> 00:49:47,560
During a page fault, 

744
00:49:49,440 --> 00:49:54,200
you need to bring a page from the disk to the memory. 

745
00:49:57,260 --> 00:50:01,580
How do you find room for that page? 

746
00:50:08,940 --> 00:50:11,130
If there is no room like we discussed, 

747
00:50:11,530 --> 00:50:14,960
we are going to find a page before it's dirty, 

748
00:50:14,970 --> 00:50:17,520
save it on the disk and replace it with a new page. 

749
00:50:18,960 --> 00:50:20,780
But typically this is quite expensive. 

750
00:50:22,300 --> 00:50:25,450
Writing page bring up beijing is very expensive. 

751
00:50:26,270 --> 00:50:29,790
What many operating systems do in the background? 

752
00:50:30,560 --> 00:50:34,780
They kick off some of the right back, 

753
00:50:35,560 --> 00:50:39,130
some of the dirty pages to the disk. 

754
00:50:39,950 --> 00:50:41,920
If you need to replace one, 

755
00:50:42,130 --> 00:50:44,150
then you don't need to write it back. 

756
00:50:45,500 --> 00:50:47,190
This is kind of periodically, 

757
00:50:47,200 --> 00:50:55,040
it's a cleaning process to reduce the overhead of the demand paging. 

758
00:50:57,240 --> 00:51:06,180
Now, but even if you have this background mechanism,

759
00:51:06,550 --> 00:51:09,140
you still need to answer the following question, 

760
00:51:09,150 --> 00:51:12,380
which pages are you going to write to the disk? 

761
00:51:12,720 --> 00:51:13,290
For each pages? 

762
00:51:13,300 --> 00:51:16,090
You are going to evict to bring a new beijing. 

763
00:51:20,980 --> 00:51:27,430
And the way we you think about that by now, 

764
00:51:27,440 --> 00:51:29,510
when you talk about scheduling and so forth, 

765
00:51:29,520 --> 00:51:31,310
you need to come up with a policy. 

766
00:51:31,930 --> 00:51:37,450
When you come up with a policy to dictate which guides which pages

767
00:51:37,460 --> 00:51:41,470
are written back or are evicted from the main moment memory. 

768
00:51:43,150 --> 00:51:48,430
There are certain properties you need you think about about utilization. 

769
00:51:48,440 --> 00:51:52,130
You want to have high utilization of the memory. 

770
00:51:52,330 --> 00:51:54,380
That's because it's a scarce resource. 

771
00:51:54,730 --> 00:52:02,380
You may want fairness between different processes or immune to enforce priority. 

772
00:52:06,850 --> 00:52:11,360
So that's kind of you keep in mind that we are not going to implement

773
00:52:11,370 --> 00:52:13,500
different policies here. 

774
00:52:13,510 --> 00:52:18,240
But this is for you to keep in mind that is a typical questions you

775
00:52:18,250 --> 00:52:23,040
are going to be faced with when you are going to design a base replacement

776
00:52:23,050 --> 00:52:23,440
policy. 

777
00:52:29,820 --> 00:52:32,420
So is a key model. 

778
00:52:32,430 --> 00:52:36,820
You have in mind when you run a program, 

779
00:52:36,830 --> 00:52:38,340
11of these models, 

780
00:52:38,350 --> 00:52:40,520
it's about the working set. 

781
00:52:41,720 --> 00:52:47,450
So that what is a a working set, roughly speaking,

782
00:52:47,900 --> 00:52:55,670
is the set of addresses whose content, 

783
00:52:56,030 --> 00:52:58,070
if you have in the physical memory, 

784
00:52:58,410 --> 00:53:00,580
then the programs works well. 

785
00:53:01,200 --> 00:53:03,270
There are very few baseballs. 

786
00:53:04,650 --> 00:53:05,090
If any, 

787
00:53:05,810 --> 00:53:06,100
right? 

788
00:53:06,980 --> 00:53:14,160
And this tried to show a depiction of a this is for a program. 

789
00:53:14,690 --> 00:53:16,310
On the x axis, you have the time.

790
00:53:17,220 --> 00:53:19,050
And on the y axis, you have the address.

791
00:53:19,640 --> 00:53:23,810
And each rectangle is the height of the rectangle represent. 

792
00:53:24,010 --> 00:53:29,550
What addresses are accessed at a given time by the program. 

793
00:53:29,970 --> 00:53:36,220
And the length represent for how long you access content from these addresses. 

794
00:53:37,400 --> 00:53:37,660
Right? 

795
00:53:38,440 --> 00:53:40,000
So this is, 

796
00:53:40,010 --> 00:53:41,920
and as you can see here, 

797
00:53:41,930 --> 00:53:43,520
this is execution. 

798
00:53:43,530 --> 00:53:44,240
The thread. 

799
00:53:44,580 --> 00:53:46,680
Stuff is execution of the program. 

800
00:53:47,070 --> 00:53:48,730
And at different times, 

801
00:53:49,100 --> 00:53:50,720
you have different working sets. 

802
00:53:50,730 --> 00:53:54,160
So working set here is that if you, 

803
00:53:55,060 --> 00:53:59,900
if you draw a vertical line at a given time, 

804
00:53:59,910 --> 00:54:01,750
then everything, 

805
00:54:03,200 --> 00:54:06,950
all the blue rectangle it enters this line, 

806
00:54:08,190 --> 00:54:09,830
intersects represent the working set, 

807
00:54:10,460 --> 00:54:16,320
represent the addresses whose content should be in the physical memory, 

808
00:54:16,650 --> 00:54:20,620
so that we do not have page faults. 

809
00:54:22,710 --> 00:54:23,830
And the working set. 

810
00:54:24,280 --> 00:54:25,910
One property, in general,

811
00:54:25,920 --> 00:54:31,890
is that is much smaller than the entire address space of the program, 

812
00:54:32,280 --> 00:54:34,040
and also is changing over time. 

813
00:54:37,290 --> 00:54:41,520
Obviously, if you can keep all the working set in memory or in the cache,

814
00:54:42,570 --> 00:54:44,120
then is great. 

815
00:54:44,130 --> 00:54:45,400
The heat rate will be one. 

816
00:54:47,470 --> 00:54:49,720
If you cannot, then the hit rate will not be on.

817
00:54:49,730 --> 00:54:51,790
And you are going to have also some mistake. 

818
00:54:54,240 --> 00:54:58,800
This also shows the cache size, 

819
00:54:58,810 --> 00:55:05,430
how much of the program is stored in the cash for this previous example. 

820
00:55:05,980 --> 00:55:07,980
And you start with very little, 

821
00:55:08,360 --> 00:55:10,640
and you have here a lot of come, 

822
00:55:10,810 --> 00:55:12,880
and the hit rate is also very low. 

823
00:55:15,730 --> 00:55:16,090
Sorry, 

824
00:55:16,780 --> 00:55:17,890
let me back that here. 

825
00:55:18,620 --> 00:55:21,490
When the x axis here is a cache size, 

826
00:55:22,340 --> 00:55:25,230
you are looking here at caches of different sites. 

827
00:55:25,880 --> 00:55:26,880
On the y axis, 

828
00:55:26,890 --> 00:55:28,480
you have the hit rate. 

829
00:55:29,160 --> 00:55:32,030
If the cache says is infinite, 

830
00:55:32,380 --> 00:55:34,110
the heat rate will be one. 

831
00:55:34,120 --> 00:55:35,760
So when the cast size, 

832
00:55:36,050 --> 00:55:37,300
or in other words, 

833
00:55:37,820 --> 00:55:42,050
on the cast size is larger than the working set, 

834
00:55:42,540 --> 00:55:44,570
what is the working set is in the cash? 

835
00:55:44,830 --> 00:55:45,910
Then the hit ladies. 

836
00:55:46,900 --> 00:55:49,490
And then, as if the cast,

837
00:55:49,500 --> 00:55:51,130
I say it's very small, 

838
00:55:51,520 --> 00:55:53,880
then the heat rate will be very little, 

839
00:55:54,130 --> 00:56:00,370
because probably all the working set will be doesn't fit in the cash. 

840
00:56:00,940 --> 00:56:01,220
Right? 

841
00:56:01,470 --> 00:56:03,600
Any fetch of an instruction, 

842
00:56:03,610 --> 00:56:07,220
every access of the data will result on. 

843
00:56:09,360 --> 00:56:12,490
It is going to result in a miss. 

844
00:56:12,990 --> 00:56:13,340
Right? 

845
00:56:22,840 --> 00:56:24,110
Any questions here? 

846
00:56:38,130 --> 00:56:44,230
So if the cash it's a shared between different processes, 

847
00:56:44,570 --> 00:56:46,350
like, is a second level cash,

848
00:56:47,730 --> 00:56:52,150
then you need to feed multiple working set in the same cache. 

849
00:56:53,330 --> 00:56:55,520
And actually, this figure shows,

850
00:56:55,800 --> 00:56:58,520
when you have multiple working sets in the same cache, 

851
00:56:58,530 --> 00:57:02,380
each of these inflection points is when a new working set is

852
00:57:02,390 --> 00:57:03,460
fitting in the cache, 

853
00:57:08,430 --> 00:57:11,860
obviously are going to have a very similar behavior for demand painting. 

854
00:57:11,870 --> 00:57:13,620
Again, demand painting is as cash.

855
00:57:18,540 --> 00:57:21,030
Now, when we are talking about the working set,

856
00:57:21,040 --> 00:57:23,270
we have this kind of nice model, like I mentioned,

857
00:57:23,280 --> 00:57:27,550
that actually the program is spending most of the time or all the time, 

858
00:57:28,050 --> 00:57:31,640
a in a relatively small region of the other space. 

859
00:57:32,170 --> 00:57:35,010
And this makes the cash very effective. 

860
00:57:36,380 --> 00:57:42,920
However, there are other models for locality like ziff and distribution.

861
00:57:45,190 --> 00:57:46,350
In this case, 

862
00:57:48,060 --> 00:57:50,790
you do have this is, for instance,

863
00:57:50,800 --> 00:57:53,230
on this figure, what you see.

864
00:57:53,640 --> 00:57:54,670
Here it's a rank. 

865
00:57:54,920 --> 00:57:56,430
This represent, say,

866
00:57:56,440 --> 00:57:58,310
think about each of this is a page. 

867
00:57:59,890 --> 00:58:03,440
There are pages are ranking the decreasing order of their popularity

868
00:58:03,450 --> 00:58:06,270
about how often they are accessed. 

869
00:58:06,920 --> 00:58:09,880
The popularity of access is on the y axis. 

870
00:58:11,200 --> 00:58:16,440
They say that the first page is accessed20% of the time. 

871
00:58:16,970 --> 00:58:18,880
You access a memory, 

872
00:58:18,890 --> 00:58:20,080
access the first page. 

873
00:58:21,870 --> 00:58:22,790
This is what it says. 

874
00:58:23,780 --> 00:58:24,060
Right? 

875
00:58:25,600 --> 00:58:25,840
Now, 

876
00:58:25,850 --> 00:58:29,200
the problem with this distribution and this popularity is shown

877
00:58:31,960 --> 00:58:32,750
by the blue line. 

878
00:58:33,470 --> 00:58:36,710
The problem with this one is that with this distribution is

879
00:58:36,720 --> 00:58:38,310
a very challenging distribution, 

880
00:58:38,840 --> 00:58:42,080
is that it also has a long tail, 

881
00:58:44,190 --> 00:58:44,960
mostly axis. 

882
00:58:44,970 --> 00:58:48,040
Most of the axis are on a very few pages. 

883
00:58:48,740 --> 00:58:58,650
But there is some a lot a huge amount of pages are accessed infrequent. 

884
00:59:04,160 --> 00:59:05,930
And this creates problems, 

885
00:59:05,940 --> 00:59:08,820
because no matter, 

886
00:59:09,350 --> 00:59:10,880
even if you have a big cash, 

887
00:59:11,790 --> 00:59:15,770
we are still going to have misses because of these very rare items. 

888
00:59:18,380 --> 00:59:22,290
But what this shows you is that even if you have a small cash, 

889
00:59:22,620 --> 00:59:27,090
you get quite a bit of value because a few pages are responsible for most taxes. 

890
00:59:29,180 --> 00:59:33,260
The second thing is that if you have a very large cash, 

891
00:59:35,640 --> 00:59:36,870
it's a diminishing return. 

892
00:59:36,880 --> 00:59:38,390
It may not benefit a lot. 

893
00:59:38,400 --> 00:59:40,310
You still have substantial misses. 

894
00:59:41,770 --> 00:59:42,720
Questions? 

895
00:59:50,780 --> 00:59:51,770
I don't know that video, 

896
00:59:51,780 --> 00:59:56,450
but there are many situations in which you are going. 

897
00:59:56,460 --> 00:59:58,290
This distribution is very common. 

898
00:59:58,770 --> 01:00:00,340
One, it's our web pages.

899
01:00:01,230 --> 01:00:02,750
I'm talking about web pages, right?

900
01:00:02,760 --> 01:00:03,950
When you access the web pages, 

901
01:00:03,960 --> 01:00:05,430
they have as if we are distribution. 

902
01:00:07,280 --> 01:00:10,710
And is very common, 

903
01:00:11,330 --> 01:00:13,620
is a population of cities. 

904
01:00:14,140 --> 01:00:17,500
There are a few cities with very large population and a few of them. 

905
01:00:17,770 --> 01:00:21,910
But there are many of them with a smaller population. 

906
01:00:24,430 --> 01:00:31,010
It's a very common distribution model. 

907
01:00:31,800 --> 01:00:36,440
Again, what we care about is estimated access time.

908
01:00:37,110 --> 01:00:41,390
And the estimated access time is a hit rate times hit time. 

909
01:00:41,560 --> 01:00:44,030
It's a latency to access the data in memory, 

910
01:00:45,370 --> 01:00:47,540
plus miss rate plus the miss time. 

911
01:00:47,550 --> 01:00:52,110
And the miss time is the time it takes to bring the data in memory

912
01:00:52,120 --> 01:00:54,070
from the disk if it's not there. 

913
01:00:55,870 --> 01:01:01,200
And it's not there, because they missed the heat rate plaza,

914
01:01:01,210 --> 01:01:03,240
miss rate is one. 

915
01:01:04,260 --> 01:01:07,610
You can also rewrite the equation by having this penalty, 

916
01:01:08,350 --> 01:01:09,950
by denoting, miss time,

917
01:01:09,960 --> 01:01:11,910
my minus hit time. 

918
01:01:12,280 --> 01:01:14,980
This is the overhead where to miss. 

919
01:01:15,580 --> 01:01:16,940
This is miss penalty. 

920
01:01:17,600 --> 01:01:22,310
You can realize the equation at hit time plus miss rate times miss penalty. 

921
01:01:24,360 --> 01:01:26,210
Here is a very simple example. 

922
01:01:26,220 --> 01:01:32,460
Memory access time is 200 nanoseconds average page for service time. 

923
01:01:32,470 --> 01:01:36,720
So bringing the page from the disk into memory. 

924
01:01:37,170 --> 01:01:38,400
It's 8 million seconds. 

925
01:01:40,710 --> 01:01:44,430
Let's say p is the probability of miss one minus ps and the probability of hit. 

926
01:01:45,890 --> 01:01:53,080
This means that we are using the same the second equation. 

927
01:01:53,500 --> 01:01:57,270
The access time is made like this time is 200 and seconds

928
01:01:57,280 --> 01:02:01,190
plus p times 8 million nanoseconds. 

929
01:02:04,170 --> 01:02:09,090
If just one out of 1,000 pages, 

930
01:02:09,100 --> 01:02:10,810
page axis is a fault, 

931
01:02:11,990 --> 01:02:13,510
this is 0.1%. 

932
01:02:14,560 --> 01:02:19,020
The access time is of over eight micro seconds or 40 times

933
01:02:19,030 --> 01:02:21,120
more than just accessing the memory. 

934
01:02:22,370 --> 01:02:23,830
So the slowdown is huge. 

935
01:02:24,520 --> 01:02:29,420
If you want to slow to have a slowdown only by ten per or to 10% slow down, 

936
01:02:30,090 --> 01:02:33,530
then you can physics in the equation. 

937
01:02:34,680 --> 01:02:41,890
And the p is a probability of miss should be lower

938
01:02:42,380 --> 01:02:47,180
than 1 page in 400,000 axis. 

939
01:02:50,020 --> 01:02:53,750
That gives you a sense about how important is

940
01:02:53,760 --> 01:02:58,920
a patient replacement policies in minimizing the miss, 

941
01:02:58,930 --> 01:02:59,360
right? 

942
01:02:59,960 --> 01:03:01,090
And that's how you use. 

943
01:03:01,630 --> 01:03:03,280
This is right here. 

944
01:03:03,290 --> 01:03:09,030
It's an example of why here was a demand. 

945
01:03:09,040 --> 01:03:11,430
Beijing is fully associative, 

946
01:03:12,120 --> 01:03:12,550
right? 

947
01:03:12,830 --> 01:03:17,530
Because you just want to avoid any misses are at any cost. 

948
01:03:27,480 --> 01:03:29,700
Or it's a question here. 

949
01:03:29,710 --> 01:03:34,870
What is the intuition behind why the hit rate is higher for the lower ranks? 

950
01:03:40,300 --> 01:03:41,370
It's all here, right?

951
01:03:41,660 --> 01:03:42,390
Let me see. 

952
01:03:44,640 --> 01:03:49,480
Actually, a it's a rank of popularity.

953
01:03:50,790 --> 01:03:51,150
Right? 

954
01:03:51,160 --> 01:03:51,870
So actually, 

955
01:03:51,880 --> 01:03:58,730
these pages are ordered in the decreasing order of their popularity. 

956
01:03:59,760 --> 01:04:01,440
So that I get to go is a popularity. 

957
01:04:01,450 --> 01:04:03,660
So there is nothing subtle here. 

958
01:04:05,120 --> 01:04:05,580
Okay? 

959
01:04:06,590 --> 01:04:11,220
That doesn't mean anything else and being pop a major of popularity. 

960
01:04:15,730 --> 01:04:16,850
Okay, again,

961
01:04:16,860 --> 01:04:18,610
see you remember about catching, 

962
01:04:19,600 --> 01:04:21,350
what are the type of misses, 

963
01:04:21,750 --> 01:04:23,150
compulsory misses, 

964
01:04:23,580 --> 01:04:25,890
pages that have never been paid into memory? 

965
01:04:25,900 --> 01:04:27,650
This is when you start a program, 

966
01:04:27,930 --> 01:04:31,080
you need to read the code, right?

967
01:04:31,090 --> 01:04:31,920
For instance, 

968
01:04:34,490 --> 01:04:35,660
capacity misses. 

969
01:04:35,940 --> 01:04:37,450
You don't have enough memory. 

970
01:04:37,460 --> 01:04:38,690
What do you doing this? 

971
01:04:38,700 --> 01:04:39,770
In this case? 

972
01:04:40,860 --> 01:04:42,830
Obviously, you can increase a number,

973
01:04:42,840 --> 01:04:44,150
increase the memory size. 

974
01:04:45,940 --> 01:04:53,760
Or if you can share the memory between processes and

975
01:04:53,770 --> 01:04:58,920
give each process certain amount of memory. 

976
01:04:59,530 --> 01:05:00,690
Or in some cases, 

977
01:05:00,700 --> 01:05:01,770
as you'll see, 

978
01:05:02,380 --> 01:05:05,690
one solution is to kill one of the processes. 

979
01:05:06,180 --> 01:05:07,340
The remaining processes, 

980
01:05:08,030 --> 01:05:13,440
they have enough physical memory conflict misses. 

981
01:05:14,010 --> 01:05:15,730
You don't have those slides, technically,

982
01:05:15,740 --> 01:05:18,410
because a it's a fully associative cash, 

983
01:05:19,020 --> 01:05:19,410
right? 

984
01:05:19,920 --> 01:05:21,110
And policy misses, 

985
01:05:21,120 --> 01:05:24,630
it's about depends on the replacement policy we are going to use. 

986
01:05:27,190 --> 01:05:31,870
Here we just want a better replacement policy to minimize the misses. 

987
01:05:34,580 --> 01:05:35,180
Okay? 

988
01:05:36,310 --> 01:05:37,950
So pay deployment policies. 

989
01:05:40,410 --> 01:05:41,200
It's again, 

990
01:05:42,120 --> 01:05:45,790
those you learn a few of them last time. 

991
01:05:47,120 --> 01:05:48,950
The same similar are here, 

992
01:05:53,490 --> 01:05:54,060
54. 

993
01:05:56,360 --> 01:05:57,430
First in, first out,

994
01:05:58,060 --> 01:06:04,910
you throw out the oldest page or a big the oldest page is some degree

995
01:06:04,920 --> 01:06:07,870
of fairness in terms of the access. 

996
01:06:10,210 --> 01:06:12,550
But it can be also bad. 

997
01:06:13,240 --> 01:06:17,440
Why when it's five or bad is when you have a very popular page which is

998
01:06:17,450 --> 01:06:18,560
access over and over. 

999
01:06:19,840 --> 01:06:20,190
Right? 

1000
01:06:21,880 --> 01:06:27,140
This is also one of the pages which are going to be the oldest in the

1001
01:06:28,210 --> 01:06:30,880
could be the oldest on the program started. 

1002
01:06:31,860 --> 01:06:33,370
It loaded this page, 

1003
01:06:33,690 --> 01:06:35,060
like, for instance,

1004
01:06:35,590 --> 01:06:38,110
the code like for these powerpoint slides, 

1005
01:06:38,930 --> 01:06:47,000
the code which go is responsible for going from one slide and displaying

1006
01:06:47,010 --> 01:06:47,680
the next slide. 

1007
01:06:48,310 --> 01:06:49,030
This is, 

1008
01:06:50,470 --> 01:06:55,410
I am a using that code from the beginning of the lecture. 

1009
01:06:55,820 --> 01:07:00,090
That was one of the first pieces of code which was loaded in memory. 

1010
01:07:00,790 --> 01:07:02,120
But if I use 54, 

1011
01:07:02,390 --> 01:07:05,410
that will be also a piece of code should be evicted. 

1012
01:07:06,420 --> 01:07:07,620
And if you evicted, 

1013
01:07:08,070 --> 01:07:11,430
it just to be loaded again next time, I went on,

1014
01:07:11,440 --> 01:07:16,110
i'm turning to the next slide at random is very simple. 

1015
01:07:18,820 --> 01:07:23,460
So they are very fast to implement also in hardware. 

1016
01:07:23,900 --> 01:07:28,020
Typically, you have this is still be when you need to be super fast.

1017
01:07:29,970 --> 01:07:31,540
Or the downside is random, 

1018
01:07:31,550 --> 01:07:32,650
it's not predictable. 

1019
01:07:35,290 --> 01:07:36,120
It's minimum. 

1020
01:07:36,130 --> 01:07:37,380
And the minimum. 

1021
01:07:40,560 --> 01:07:43,490
It's the optimal one. 

1022
01:07:43,840 --> 01:07:44,260
Right? 

1023
01:07:44,510 --> 01:07:46,300
What is the optimal replacement policy? 

1024
01:07:47,230 --> 01:07:47,390
Right? 

1025
01:07:47,400 --> 01:07:48,670
You should know that from cash, 

1026
01:07:49,370 --> 01:07:50,990
what is the optimal replacement policy? 

1027
01:07:52,490 --> 01:07:55,750
You want to replace the page, 

1028
01:07:56,330 --> 01:07:59,150
which won't be used for the longest time. 

1029
01:08:00,320 --> 01:08:01,290
It's as simple as that. 

1030
01:08:01,670 --> 01:08:05,080
The problem with this is that you need to predict the future and you don't know. 

1031
01:08:06,010 --> 01:08:12,130
And the way around it is to use the past as a good predictor of the future. 

1032
01:08:12,850 --> 01:08:17,330
That is, if a page has not been used for a while,

1033
01:08:17,810 --> 01:08:22,010
then the page will not assume that the page will not be, again,

1034
01:08:22,020 --> 01:08:23,050
access for a while. 

1035
01:08:24,580 --> 01:08:27,690
If the page was just used before recently, 

1036
01:08:28,370 --> 01:08:30,850
it's going to be likely used again in the future. 

1037
01:08:33,410 --> 01:08:34,410
Any questions here? 

1038
01:08:42,590 --> 01:08:47,750
This is approximation is the least recently used. 

1039
01:08:48,690 --> 01:08:48,890
Right? 

1040
01:08:48,900 --> 01:08:51,410
Just replays a page that hasn't been used for the longest time. 

1041
01:08:54,570 --> 01:08:56,440
If the programs have every locality, 

1042
01:08:56,450 --> 01:08:59,460
this is a pretty good policy. 

1043
01:09:01,670 --> 01:09:02,620
How we implement it. 

1044
01:09:03,230 --> 01:09:03,900
One, 

1045
01:09:05,240 --> 01:09:06,730
you can simply implement it. 

1046
01:09:07,340 --> 01:09:09,430
You can keep a list of pages. 

1047
01:09:10,100 --> 01:09:19,150
And you a when you access a page, 

1048
01:09:19,720 --> 01:09:24,070
you put it as a head of you move it to the head of the queue. 

1049
01:09:25,020 --> 01:09:27,430
And the pages as the last in this, 

1050
01:09:28,100 --> 01:09:34,030
least, is a page which hasn't been accessed for the longest time.

1051
01:09:38,080 --> 01:09:38,640
Okay. 

1052
01:09:45,180 --> 01:09:46,260
It's a great question. 

1053
01:09:46,270 --> 01:09:52,380
Is there anything you can do when you are writing code to help decrease

1054
01:09:52,390 --> 01:09:53,180
page misses? 

1055
01:09:53,190 --> 01:09:55,820
This is a great question. 

1056
01:09:56,260 --> 01:09:57,850
Yes, you can do it.

1057
01:09:57,860 --> 01:09:59,530
I'll give you one example, 

1058
01:10:01,980 --> 01:10:03,050
like, for instance,

1059
01:10:03,060 --> 01:10:07,810
and this is used and known by people do high performance computing. 

1060
01:10:09,360 --> 01:10:14,060
Say, you have a matrix and say,

1061
01:10:14,070 --> 01:10:17,420
you want to multiply the matrix or do some operation on the matrix. 

1062
01:10:18,300 --> 01:10:20,320
You can iterate on browse, 

1063
01:10:20,620 --> 01:10:22,270
or you to iterate on columns. 

1064
01:10:24,280 --> 01:10:31,380
Now is very important about how this matrix is stored in memory. 

1065
01:10:31,990 --> 01:10:33,430
Typically start row by row. 

1066
01:10:33,440 --> 01:10:35,150
You start first row, 

1067
01:10:35,160 --> 01:10:36,910
then the next row and the next row. 

1068
01:10:39,900 --> 01:10:42,090
If the matrix is large, 

1069
01:10:42,930 --> 01:10:43,250
right? 

1070
01:10:43,610 --> 01:10:44,820
If I want to greet, say,

1071
01:10:44,830 --> 01:10:46,660
to all the elements of the matrix, 

1072
01:10:47,410 --> 01:10:52,060
if I can, i'm going to italy by row is going to have a good cash locality.

1073
01:10:52,860 --> 01:10:56,820
Because I start to with the first row matrix, 

1074
01:10:56,830 --> 01:10:59,100
i'm already going to start to bring. 

1075
01:11:00,150 --> 01:11:04,890
The first page contains a lot of elements from the first row. 

1076
01:11:04,900 --> 01:11:09,770
So they are going to be all already in the cache when I am going to access them. 

1077
01:11:12,460 --> 01:11:15,080
Now say, I am going to write the same program,

1078
01:11:15,090 --> 01:11:16,820
but i'm going to access columns. 

1079
01:11:16,830 --> 01:11:20,370
I am going to access the first element. 

1080
01:11:21,070 --> 01:11:22,380
I'm going to bring a page. 

1081
01:11:23,840 --> 01:11:27,640
Now, the next element i'm going to access is going to be from the next row,

1082
01:11:29,070 --> 01:11:30,020
not in the same row. 

1083
01:11:30,800 --> 01:11:36,100
The next row that can result in another miss. 

1084
01:11:36,510 --> 01:11:39,850
And I need to bring another page just to access only one element

1085
01:11:39,860 --> 01:11:41,910
from that page and so forth. 

1086
01:11:42,320 --> 01:11:47,160
By the time I go back to access the second element from the first row, 

1087
01:11:47,170 --> 01:11:48,600
that page may be already gone, 

1088
01:11:49,580 --> 01:11:49,660
right? 

1089
01:11:49,670 --> 01:11:53,260
Because may not all the pages may fit in cash. 

1090
01:11:54,140 --> 01:11:55,150
So that's what you can do. 

1091
01:11:55,910 --> 01:11:57,760
Like that's an example you want. 

1092
01:11:58,190 --> 01:12:01,100
Or the dldr here, 

1093
01:12:01,450 --> 01:12:04,450
you want to write your program to preserve locality, 

1094
01:12:06,420 --> 01:12:09,370
another things which kind of destroy locality. 

1095
01:12:09,630 --> 01:12:11,890
If you have goals, if you write a program,

1096
01:12:11,900 --> 01:12:13,330
he jumps around to go to. 

1097
01:12:13,710 --> 01:12:15,360
That destroys a code locality. 

1098
01:12:21,020 --> 01:12:24,610
I know that a large number of random access is on the hip is

1099
01:12:24,620 --> 01:12:26,650
generally bad for cash hit rates. 

1100
01:12:27,300 --> 01:12:33,350
That's the same generally applies to minimize page misses. 

1101
01:12:36,500 --> 01:12:38,980
I again, 

1102
01:12:38,990 --> 01:12:42,520
it's like random. 

1103
01:12:44,810 --> 01:12:48,280
It's not going, you will use random because it's fast.

1104
01:12:48,990 --> 01:12:50,960
But in this particular case, 

1105
01:12:50,970 --> 01:12:57,050
because it's so costly to the baseball is so costly, 

1106
01:12:57,950 --> 01:13:00,260
you really want to avoid random. 

1107
01:13:04,640 --> 01:13:08,840
We still plb use random because you want to be extremely fast, right?

1108
01:13:10,600 --> 01:13:12,000
That happens actually in hardware. 

1109
01:13:12,940 --> 01:13:15,630
Hopefully, I I answered this question if I didn't answer,

1110
01:13:16,960 --> 01:13:17,910
ask it again. 

1111
01:13:18,350 --> 01:13:20,580
And maybe rephrase, what do you think?

1112
01:13:20,590 --> 01:13:23,460
I I I may have missed from your question. 

1113
01:13:24,760 --> 01:13:25,630
Wouldn't this mean? 

1114
01:13:25,640 --> 01:13:28,310
We have to take a software fault on every axis? 

1115
01:13:29,220 --> 01:13:29,930
This, I think,

1116
01:13:29,940 --> 01:13:36,610
is refers to the examples I gave you about matrices going by columns. 

1117
01:13:37,220 --> 01:13:38,490
In the worst case, 

1118
01:13:38,770 --> 01:13:46,130
this means that you can take us a baseball on every access to a record. 

1119
01:13:55,120 --> 01:13:56,020
No, is allah.

1120
01:13:56,030 --> 01:13:56,820
You're not. 

1121
01:13:58,790 --> 01:14:01,900
It's again, it's like,

1122
01:14:02,610 --> 01:14:06,600
if you have something which is used very often, 

1123
01:14:08,550 --> 01:14:11,000
then every time when you access it, 

1124
01:14:12,200 --> 01:14:13,670
you are going to, again,

1125
01:14:13,680 --> 01:14:16,220
when you put here in this example. 

1126
01:14:17,170 --> 01:14:17,570
Sorry. 

1127
01:14:18,120 --> 01:14:19,680
When you put here in this example, 

1128
01:14:20,450 --> 01:14:22,310
is, again, if I access space seven,

1129
01:14:22,990 --> 01:14:27,530
I am going to put it as ahead of the queue or the head of the list. 

1130
01:14:27,840 --> 01:14:28,840
Accessing page on. 

1131
01:14:28,850 --> 01:14:31,760
I'm going to put it ahead of the list, assessing page two.

1132
01:14:31,770 --> 01:14:33,680
Now the pastry is going to head off the list. 

1133
01:14:37,020 --> 01:14:40,110
If I access something very often, 

1134
01:14:40,600 --> 01:14:44,360
then they are going to be close to the head of the list. 

1135
01:14:44,370 --> 01:14:45,880
So they are not going to be removed. 

1136
01:14:45,890 --> 01:14:47,200
They are not going to be available. 

1137
01:15:01,270 --> 01:15:01,550
Question, 

1138
01:15:01,560 --> 01:15:06,480
does that mean that we have to work all pts and scan the valley beats? 

1139
01:15:06,990 --> 01:15:08,560
Every so often begins the list? 

1140
01:15:09,060 --> 01:15:09,980
That's a great. 

1141
01:15:13,290 --> 01:15:15,070
Access fits, use, beats, they use, beats.

1142
01:15:15,080 --> 01:15:17,110
You refer, you are referring to the use beats.

1143
01:15:19,430 --> 01:15:20,280
That's a good point. 

1144
01:15:20,290 --> 01:15:21,280
You could do that. 

1145
01:15:21,950 --> 01:15:23,920
As we are going to see. 

1146
01:15:25,130 --> 01:15:25,800
Next, 

1147
01:15:29,110 --> 01:15:32,220
this is a precise implementation of the list, 

1148
01:15:32,230 --> 01:15:33,780
at least recently used, 

1149
01:15:34,320 --> 01:15:41,590
but it's expensive to implement what we are going to implement. 

1150
01:15:41,600 --> 01:15:43,390
It's an approximation of allergy, 

1151
01:15:44,830 --> 01:15:45,140
right? 

1152
01:15:45,990 --> 01:15:47,290
That's what you are going to implement. 

1153
01:15:52,750 --> 01:15:54,340
But before it goes there, 

1154
01:15:54,350 --> 01:15:59,420
and we are going to show how we are going to implement an approximation of allergy. 

1155
01:16:00,050 --> 01:16:00,280
Again, 

1156
01:16:00,290 --> 01:16:03,120
we want to implement and as approximation ideal because we

1157
01:16:03,130 --> 01:16:07,800
don't want to manipulate point that is to do many memory access is

1158
01:16:08,300 --> 01:16:13,450
whenever we access a page before that, 

1159
01:16:13,790 --> 01:16:17,150
let's look at a few other replacement policies. 

1160
01:16:17,630 --> 01:16:18,580
This is 54. 

1161
01:16:19,290 --> 01:16:21,440
And here we have a cash, 

1162
01:16:22,090 --> 01:16:26,900
or which has three slots, 

1163
01:16:27,930 --> 01:16:30,110
or you have three frames. 

1164
01:16:30,870 --> 01:16:35,340
And this is your order in which we access the sequence. 

1165
01:16:35,350 --> 01:16:36,820
We access these pages. 

1166
01:16:37,400 --> 01:16:39,640
As the pages are denoted abc ds, 

1167
01:16:39,650 --> 01:16:40,760
there are 4 pages. 

1168
01:16:41,620 --> 01:16:48,040
I'm going to first access a's and b's, 

1169
01:16:48,050 --> 01:16:49,160
and c and so forth. 

1170
01:16:50,810 --> 01:16:52,760
Let's access a initially, 

1171
01:16:52,770 --> 01:16:56,300
the cache or memory is empty. 

1172
01:16:57,090 --> 01:17:03,640
We are going to save use the first page frame

1173
01:17:06,630 --> 01:17:13,850
to start a then b still have you available slot available frames? 

1174
01:17:13,860 --> 01:17:18,550
I'm going to use the second one and to use and then use the server. 

1175
01:17:20,870 --> 01:17:22,650
Now, things become interesting here.

1176
01:17:23,510 --> 01:17:29,490
Now I am going to come to access a again and a it's already in, 

1177
01:17:29,500 --> 01:17:30,290
so it's fine. 

1178
01:17:30,300 --> 01:17:30,970
I'm happy. 

1179
01:17:31,280 --> 01:17:32,710
I'm not going to do anything. 

1180
01:17:32,720 --> 01:17:34,060
I'm going to access it. 

1181
01:17:34,070 --> 01:17:35,140
It's already in memory. 

1182
01:17:36,130 --> 01:17:36,880
B is the same. 

1183
01:17:37,980 --> 01:17:41,880
But now is b d is not in the memory. 

1184
01:17:43,090 --> 01:17:44,200
What do I need to do? 

1185
01:17:44,740 --> 01:17:45,840
And the memory is full. 

1186
01:17:45,850 --> 01:17:47,700
So I need to make room for it. 

1187
01:17:48,410 --> 01:17:52,110
Each page i'm going to evict here is in first out. 

1188
01:17:52,700 --> 01:17:54,850
So i'm going to evict the page, 

1189
01:17:55,360 --> 01:17:56,480
which was the first, 

1190
01:18:03,010 --> 01:18:04,840
the first, which was brought in the memory,

1191
01:18:06,380 --> 01:18:06,440
right? 

1192
01:18:06,450 --> 01:18:11,810
Which is a I'm going to replace cpcd now, 

1193
01:18:11,820 --> 01:18:14,720
after d it's a well, 

1194
01:18:15,130 --> 01:18:17,570
now a is against this. 

1195
01:18:18,750 --> 01:18:19,430
The memory is full. 

1196
01:18:19,440 --> 01:18:28,910
So I need to pick a page to ab and I'm going to pick which on b now, 

1197
01:18:28,920 --> 01:18:31,250
the next one is the, again,

1198
01:18:31,930 --> 01:18:33,870
it's in memory, not only to do anything.

1199
01:18:33,880 --> 01:18:38,040
Then b now I don't have b in memory. 

1200
01:18:38,050 --> 01:18:41,840
I have only ac and d right? 

1201
01:18:43,760 --> 01:18:45,310
I need to replace one, 

1202
01:18:45,850 --> 01:18:48,560
which one was the oldest? 

1203
01:18:49,280 --> 01:18:49,850
We see, 

1204
01:18:53,970 --> 01:18:54,400
I am. 

1205
01:18:54,410 --> 01:18:57,920
And then ci am going to replace d with. 

1206
01:18:58,050 --> 01:18:59,760
And then finally, 

1207
01:18:59,770 --> 01:19:03,550
BB is already here. 

1208
01:19:03,560 --> 01:19:04,950
How many page folds I had? 

1209
01:19:05,210 --> 01:19:07,620
1234. 

1210
01:19:10,890 --> 01:19:13,860
These are capacities. 

1211
01:19:14,480 --> 01:19:15,740
And in addition to that, 

1212
01:19:15,750 --> 01:19:19,580
I have three, other.

1213
01:19:20,910 --> 01:19:21,350
Mrs. 

1214
01:19:21,360 --> 01:19:30,320
And these are what kind of misses are those compulsory misses? 

1215
01:19:30,930 --> 01:19:32,720
So I have three compulsory misses. 

1216
01:19:33,170 --> 01:19:34,460
Four capacity misses, 

1217
01:19:34,710 --> 01:19:35,850
seven faults, 

1218
01:19:36,660 --> 01:19:38,290
seven misses. 

1219
01:19:40,840 --> 01:19:49,210
And here just noticed that this was a bad decision to replace a when we

1220
01:19:49,220 --> 01:19:50,810
brought the d in, 

1221
01:19:50,820 --> 01:19:53,810
because the next axis was there. 

1222
01:19:53,820 --> 01:19:55,190
So let's keep this in mind. 

1223
01:19:55,450 --> 01:19:56,260
And with that, 

1224
01:19:57,250 --> 01:19:58,440
i'll stop here. 

1225
01:19:59,200 --> 01:20:04,350
We are going to continue to discuss about the patriots placement policies

1226
01:20:04,840 --> 01:20:05,580
next lecture. 

1227
01:20:07,230 --> 01:20:07,690
Thank you. 

