1
00:00:07,270 --> 00:00:08,670
Hello, everyone.
大家好。

2
00:00:09,040 --> 00:00:16,850
So today we are going to talk about demand beijing and before starting
今天我们要讨论需求北京，在开始之前

3
00:00:16,860 --> 00:00:18,050
thanks a lot,
非常感谢。

4
00:00:18,060 --> 00:00:23,600
everyone for filling in the survey about the class great feedback.
感谢大家填写关于课程的调查问卷，提供了很好的反馈。

5
00:00:24,310 --> 00:00:26,870
And we are going to try to act on it.
我们将尝试采取行动。

6
00:00:30,090 --> 00:00:35,270
Before let me start with the same figure,
在让我开始之前，让我先解释一下相同的图表。

7
00:00:35,280 --> 00:00:38,670
which I think you went over last lecture.
我认为这是你在上一堂课上讲过的内容。

8
00:00:39,920 --> 00:00:41,390
But let me do it again,
但是让我再试一次，

9
00:00:41,400 --> 00:00:43,350
because it's a very important figure,
因为这是一个非常重要的数字，

10
00:00:43,360 --> 00:00:45,810
because with everything together,
因为一切都在一起，

11
00:00:45,820 --> 00:00:48,710
all the memory related concepts,
所有与内存相关的概念

12
00:00:49,140 --> 00:00:50,730
we have learned so far.
我们目前已经学到了。

13
00:00:51,950 --> 00:00:54,320
As always, if you have any questions,
如常，如果你有任何问题，

14
00:00:54,330 --> 00:00:56,360
please do not hesitate to,
请不要犹豫，

15
00:00:56,370 --> 00:00:57,380
let me know.
请告诉我。

16
00:00:58,950 --> 00:01:02,980
So here we have the virtual address on the left.
这里我们左边是虚拟地址。

17
00:01:03,430 --> 00:01:08,410
And you remember the virtual address is what the programs and what
你记得虚拟地址是程序和操作系统使用的地址吗？

18
00:01:08,420 --> 00:01:10,480
the processor sees.
处理器所看到的。

19
00:01:10,910 --> 00:01:12,180
On the right hand side,
在右侧

20
00:01:12,190 --> 00:01:13,700
you have the physical,
你拥有物理资源，

21
00:01:13,710 --> 00:01:15,020
the memory address.
内存地址。

22
00:01:17,130 --> 00:01:18,240
What we learn, we learn,
我们所学的，我们就学到了。

23
00:01:18,330 --> 00:01:22,800
we learn about the address translation in which these virtual addresses
我们学习了地址转换，其中包括虚拟地址。

24
00:01:23,690 --> 00:01:26,260
are translated to physical addresses.
被翻译成物理地址。

25
00:01:27,080 --> 00:01:36,750
And one way we did that is through page multi level page.
我们通过多级页表的方式来实现这一点。

26
00:01:37,570 --> 00:01:41,840
In this example, we are showing two level beijing.
在这个例子中，我们展示了两层的北京。

27
00:01:42,740 --> 00:01:47,390
And therefore the virtual address have consist of three fields.
因此，虚拟地址由三个字段组成。

28
00:01:47,760 --> 00:01:48,920
The last one,
最后一个，

29
00:01:48,930 --> 00:01:51,880
the blue is blue in this figure is the offset.
这个图中的蓝色是偏移量。

30
00:01:52,940 --> 00:01:54,410
The offset, the beating,
偏移量，跳动，

31
00:01:54,420 --> 00:01:57,370
the offset remains unchanged in the physical address.
偏移量在物理地址中保持不变。

32
00:01:59,690 --> 00:02:02,720
Then the first field of the visual address,
然后是视觉地址的第一个字段，

33
00:02:02,730 --> 00:02:08,670
it's an index to the first level in the first level bay stable.
这是指向第一层的索引，位于第一层货架稳定区。

34
00:02:10,730 --> 00:02:13,840
And at that address, in the first day,
在那个地址上，第一天，

35
00:02:13,850 --> 00:02:16,160
at that location in the first page table,
在第一个页表的那个位置上，

36
00:02:16,170 --> 00:02:20,780
you find the address of another page table at the second level.
你在第二级找到了另一个页表的地址。

37
00:02:21,860 --> 00:02:28,120
The second field in the address of ritual between index denoted here.
这里所指的地址中的第二个字段是索引之间的仪式。

38
00:02:29,830 --> 00:02:33,670
It's an index to the second level page table,
这是指向二级页表的索引。

39
00:02:34,150 --> 00:02:39,030
which is referenced from the first label level page label.
这是从第一个标签级别页面标签引用的。

40
00:02:41,580 --> 00:02:46,010
At the corresponding location in the second level page table.
在二级页表中相应的位置。

41
00:02:47,230 --> 00:02:50,690
You have the physical page number.
你有物理页号。

42
00:02:52,070 --> 00:02:55,630
And now your concatenate is a physical page number with the offset.
现在你的连接操作是将物理页号与偏移量拼接在一起。

43
00:02:56,400 --> 00:03:01,370
You got the physical others is the physical page number,
你得到的是物理地址，而其他的是物理页号。

44
00:03:01,380 --> 00:03:02,650
as you see here,
正如你在这里看到的，

45
00:03:02,660 --> 00:03:03,960
the big did.
大事发生了。

46
00:03:04,310 --> 00:03:08,890
And the offset represent the offset within that page.
偏移量表示在该页内的偏移位置。

47
00:03:11,260 --> 00:03:13,070
So this is virtual address,
这是虚拟地址。

48
00:03:13,730 --> 00:03:18,920
the address translation from virtual addresses to physical addresses using
使用虚拟地址到物理地址的地址转换

49
00:03:19,460 --> 00:03:20,440
two level pages.
两级页表。

50
00:03:23,650 --> 00:03:29,440
In addition, what you also learn about is about translation.
此外，你还会学习关于翻译的内容。

51
00:03:29,690 --> 00:03:30,960
Look aside buffers.
旁路缓冲区

52
00:03:33,950 --> 00:03:39,550
Can someone tell me why do we need a translation?
有人可以告诉我为什么我们需要翻译吗？

53
00:03:39,560 --> 00:03:42,160
Look aside buffer or tlb for sure?
是选择旁路缓冲器还是转译后备缓冲器？

54
00:03:45,190 --> 00:03:46,520
What problem does it solve?
它解决了什么问题？

55
00:03:50,990 --> 00:03:51,710
It's exact.
没问题。

56
00:03:51,720 --> 00:03:53,510
Thanks, allison and gilbert.
谢谢，Allison和Gilbert。

57
00:03:53,520 --> 00:03:54,950
You are correct.
你是正确的。

58
00:03:55,970 --> 00:03:57,470
So fundamentally,
从根本上说，

59
00:03:58,020 --> 00:03:59,080
as you see,
正如你所看到的，

60
00:03:59,590 --> 00:04:02,110
with the page two level page tables,
使用两级页表

61
00:04:02,620 --> 00:04:05,380
you need in order to do the translation,
为了进行翻译，您需要

62
00:04:05,390 --> 00:04:11,660
you need to do multiple memory access is we need to get a location
你需要进行多次内存访问是因为我们需要获取一个位置。

63
00:04:11,670 --> 00:04:13,380
from the first page,
从第一页开始，

64
00:04:14,340 --> 00:04:17,460
from the first level page table,
从一级页表开始，

65
00:04:17,470 --> 00:04:20,260
then to access the second level page table,
然后访问第二级页表。

66
00:04:20,630 --> 00:04:24,630
a bunch, this means a bunch of memory access is,
一大堆，这意味着大量的内存访问。

67
00:04:25,130 --> 00:04:25,430
right.
好的。

68
00:04:26,430 --> 00:04:28,580
When you are going to look to a physical,
当你要进行体检时，

69
00:04:29,790 --> 00:04:32,480
to try to just look a location in memory,
尝试仅查看内存中的一个位置

70
00:04:32,710 --> 00:04:35,310
to fetch an instruction or to access data,
获取指令或访问数据，

71
00:04:35,800 --> 00:04:40,560
you have to do multiple memory axis, which is very slow.
你需要执行多次内存访问，这会非常慢。

72
00:04:42,280 --> 00:04:45,410
So translation look aside buffer, solve this problem.
翻译查找缓冲区，解决这个问题。

73
00:04:45,420 --> 00:04:47,110
So it's a small table,
所以这是一个小表格，

74
00:04:47,520 --> 00:04:53,350
which takes a virtual address that takes the first two fields
该函数接受一个虚拟地址，其中包含了前两个字段。

75
00:04:54,210 --> 00:04:55,480
in the virtual address,
在虚拟地址中，

76
00:04:56,480 --> 00:05:03,880
which contains a page information and maps that to the physical page number.
其中包含页面信息，并将其映射到物理页面编号。

77
00:05:06,540 --> 00:05:07,690
And this is happening.
而且这正在发生。

78
00:05:07,700 --> 00:05:08,530
It's in harder.
这更难一些。

79
00:05:08,540 --> 00:05:10,370
So the translation is very quick.
翻译非常迅速。

80
00:05:11,220 --> 00:05:12,850
This still be in the processor.
这仍然在处理器中。

81
00:05:17,130 --> 00:05:20,600
Then what is the other way we are going try to improve the performance?
那么我们还打算尝试哪种方式来提高性能呢？

82
00:05:20,610 --> 00:05:24,320
Because even if we make one access to the ramp to the memory,
因为即使我们只对内存中的斜坡进行一次访问，

83
00:05:25,280 --> 00:05:31,260
that the time to make that access a latency is much larger than accessing,
访问时间使得访问延迟比访问本身要大得多。

84
00:05:31,270 --> 00:05:31,780
say,
说,

85
00:05:32,070 --> 00:05:35,450
registers or in the processor.
寄存器或处理器中的寄存器。

86
00:05:35,750 --> 00:05:36,780
Its order of mind,
它的思维方式，

87
00:05:36,790 --> 00:05:40,300
you slower to access physical memory.
你访问物理内存的速度较慢。

88
00:05:42,130 --> 00:05:43,200
To solve this problem,
要解决这个问题，

89
00:05:43,210 --> 00:05:45,320
what you learned last lecture, we can.
上节课我们学到了什么，我们可以。

90
00:05:45,330 --> 00:05:48,240
And also at 61 c earlier on,
之前也在61摄氏度。

91
00:05:48,730 --> 00:05:50,430
it's about you are using cash,
这是关于您使用现金的事情。

92
00:05:52,010 --> 00:05:52,200
right?
对的？

93
00:05:52,210 --> 00:05:52,720
A cash.
现金。

94
00:05:53,530 --> 00:05:55,710
So cash, it's a smaller memory.
所以缓存，它是一个较小的内存。

95
00:05:56,470 --> 00:05:57,870
And because it's smaller,
而且因为它更小，

96
00:05:58,440 --> 00:05:59,710
it can be either closer,
它可以是更接近的，

97
00:05:59,720 --> 00:06:03,120
or it can be directly on the chip, on the processor.
或者它可以直接在芯片上，即处理器上。

98
00:06:04,210 --> 00:06:04,880
Therefore,
因此，

99
00:06:04,890 --> 00:06:10,650
the latency to access this cache is much lower than the latency to access
访问该缓存的延迟远低于访问的延迟。

100
00:06:10,660 --> 00:06:11,530
the physical memory.
物理内存。

101
00:06:12,630 --> 00:06:14,650
If the data you are looking for,
如果你要查找的数据，

102
00:06:14,660 --> 00:06:15,810
it's already in cash,
已经是现金了

103
00:06:16,280 --> 00:06:17,890
the access will be much quicker.
访问速度将会更快。

104
00:06:19,340 --> 00:06:23,890
And here we show set associative cache.
这里我们展示了集合关联缓存。

105
00:06:23,900 --> 00:06:26,210
You remember that the set associative cache,
你记得集合关联缓存，

106
00:06:26,220 --> 00:06:34,220
you have multiple sets of this kind of multiple
你有多个这种类型的多个集合。

107
00:06:34,230 --> 00:06:38,780
sets of of blocks.
一组块。

108
00:06:39,380 --> 00:06:46,120
And each of them is identified by a tag with any set you
每个集合中的每个元素都由一个标签进行标识。

109
00:06:46,130 --> 00:06:47,400
can associate with me,
可以与我联系吗？

110
00:06:49,130 --> 00:06:50,290
identify.
识别。

111
00:06:50,980 --> 00:06:55,150
One of this is here is represented by a line.
这里的一个代表通过一条线表示。

112
00:06:56,510 --> 00:06:58,360
One of these arose.
其中之一出现了。

113
00:07:02,240 --> 00:07:03,270
How do you do that?
你是如何做到的？

114
00:07:04,070 --> 00:07:05,480
So now,
所以现在，

115
00:07:06,980 --> 00:07:14,290
the cash is addressed with a physical address.
现金使用物理地址进行标识。

116
00:07:15,180 --> 00:07:20,550
So the physical address now is divided into other three fields,
所以现在物理地址被分成了另外三个字段，

117
00:07:20,880 --> 00:07:23,930
which is very tag index and byte.
这是非常标签索引和字节。

118
00:07:24,870 --> 00:07:27,140
And the index.
还有索引。

119
00:07:28,500 --> 00:07:34,390
If you have a memory set associated as set associated cash,
如果你有一个与缓存关联的内存集合，

120
00:07:34,860 --> 00:07:41,080
the index points to a particular set of such rows.
索引指向一组特定的行。

121
00:07:43,070 --> 00:07:48,490
And then the tag is going to identify a row in the set.
然后标签将用于标识集合中的一行。

122
00:07:52,110 --> 00:07:53,290
And finally,
最后，

123
00:07:56,420 --> 00:07:58,880
or in a bite,
简而言之，

124
00:07:59,260 --> 00:08:04,350
will specify an index of the byte you are looking for in that row.
将在该行中指定要查找的字节的索引。

125
00:08:05,390 --> 00:08:08,690
We also refer it as a block to these cells.
我们也将这些单元格称为块。

126
00:08:14,910 --> 00:08:15,620
This is it.
就是这样了。

127
00:08:17,220 --> 00:08:23,690
You have address translation to speed up the address translation.
你可以使用地址转换来加速地址转换过程。

128
00:08:23,700 --> 00:08:29,720
You use atlb which maps in hardware,
你使用的是硬件映射的ATLB。

129
00:08:29,730 --> 00:08:37,530
the virtual pace number to
虚拟页号

130
00:08:37,540 --> 00:08:39,810
the physical pace number.
物理页码编号。

131
00:08:41,120 --> 00:08:44,040
And then to farther speed up the access to the memory,
为了进一步加快对内存的访问速度，

132
00:08:44,990 --> 00:08:54,830
we use a cache and to locate the data in the cache,
我们使用缓存来定位缓存中的数据。

133
00:08:56,050 --> 00:08:57,450
we use these three fields,
我们使用这三个字段，

134
00:08:58,210 --> 00:08:59,660
tag index and buy.
标签索引和购买。

135
00:09:02,560 --> 00:09:03,430
Any questions?
有任何问题吗？

136
00:09:09,100 --> 00:09:18,090
Just remember that the tlb you address atlb with a virtual page number,
请记住，TLB是通过虚拟页号来寻址的。

137
00:09:18,100 --> 00:09:21,250
and you address a cache with a physical address.
你使用物理地址来访问缓存。

138
00:09:30,600 --> 00:09:31,450
So now,
所以现在，

139
00:09:32,650 --> 00:09:33,690
the one question,
一个问题，

140
00:09:33,700 --> 00:09:34,770
if you remember,
如果你记得的话，

141
00:09:35,350 --> 00:09:41,050
is there is a virtual address space can be larger than the physical address.
虚拟地址空间可以比物理地址空间更大吗？

142
00:09:41,700 --> 00:09:42,120
Also,
另外，

143
00:09:42,130 --> 00:09:46,690
you have multiple virtual address spaces which are going to multiplex
你有多个虚拟地址空间，它们将进行多路复用。

144
00:09:46,700 --> 00:09:48,050
the same physical others,
相同的物理特征，其他方面不同。

145
00:09:48,820 --> 00:09:53,590
because each process has its own virtual address space.
因为每个进程都有自己的虚拟地址空间。

146
00:09:56,800 --> 00:09:59,730
This means that at a given time,
这意味着在某个特定的时间，

147
00:09:59,930 --> 00:10:05,650
you may not be able to store all the virtual address,
你可能无法存储所有的虚拟地址。

148
00:10:05,660 --> 00:10:09,670
all the data in the virtual address space,
虚拟地址空间中的所有数据，

149
00:10:09,860 --> 00:10:12,090
across all process processes,
在所有进程中，

150
00:10:12,540 --> 00:10:13,730
in the physical memory.
在物理内存中。

151
00:10:16,180 --> 00:10:17,510
And if you cannot do that,
如果你不能做到的话，

152
00:10:18,330 --> 00:10:19,960
some of these pages,
其中一些页面，

153
00:10:20,280 --> 00:10:21,480
you need to put somewhere else.
你需要把它放在别的地方。

154
00:10:22,630 --> 00:10:29,740
Typically, somewhere else is on the disk or ssd now,
通常，现在的数据通常存储在磁盘或固态硬盘上。

155
00:10:29,750 --> 00:10:32,780
the question is about when you need a page,
这个问题是关于何时需要一个页面的。

156
00:10:34,490 --> 00:10:36,790
which is not in the memory, it's on the disk.
这个数据不在内存中，而是在磁盘上。

157
00:10:39,030 --> 00:10:43,170
How do you go about getting that page in memory?
你如何将那个页面加载到内存中？

158
00:10:46,650 --> 00:10:53,330
That's what we are going to learn and focus on is the remaining of this lecture.
我们将在本讲座的剩余部分学习和关注的就是这个。

159
00:10:55,700 --> 00:10:58,230
And when we are going to access a page,
当我们要访问一个页面时，

160
00:10:58,780 --> 00:11:00,720
which is not in physical memory,
不在物理内存中的

161
00:11:01,610 --> 00:11:03,240
what it called, you, it,
你叫什么名字？你是什么东西？

162
00:11:04,270 --> 00:11:05,540
then what happens?
然后会发生什么？

163
00:11:05,880 --> 00:11:07,290
You have a page four.
你有一页是第四页。

164
00:11:12,760 --> 00:11:15,430
And the way this is indicated,
这是通过以下方式表示的，

165
00:11:15,440 --> 00:11:18,470
remember that when you do the batteries translation,
请记住，在进行电池翻译时，

166
00:11:18,710 --> 00:11:20,950
you look in the page table, in the page table,
你查看页表，在页表中，

167
00:11:20,960 --> 00:11:23,350
you find a page table entry corresponding to that page.
你找到了与该页面对应的页表项。

168
00:11:24,770 --> 00:11:27,120
So that page table entry has a bit,
所以这个页表项有一个位，

169
00:11:28,490 --> 00:11:30,250
which is saying, for instance,
例如，这句话是说，

170
00:11:30,870 --> 00:11:31,860
it's invalid bit.
这是无效位。

171
00:11:32,560 --> 00:11:34,170
And if that be dissect,
如果要进行解剖的话，

172
00:11:34,780 --> 00:11:40,900
this means that the page is not present in the physical memory.
这意味着页面不在物理内存中。

173
00:11:42,600 --> 00:11:43,130
Okay?
好的？

174
00:11:43,640 --> 00:11:45,680
Now a baseball will occur.
现在将进行一场棒球比赛。

175
00:11:46,240 --> 00:11:47,510
And what happens?
发生了什么事情？

176
00:11:49,910 --> 00:11:51,280
So on baseball,
关于棒球，

177
00:11:51,790 --> 00:11:54,550
you have to engage the operating system,
你需要调用操作系统。

178
00:11:54,890 --> 00:11:58,810
and the operating system will make sure to bring the right page
操作系统将确保将正确的页面调入内存

179
00:11:59,030 --> 00:12:00,640
from the disk to memory.
从磁盘到内存。

180
00:12:00,650 --> 00:12:05,780
So then you are going to be able to continue the execution of the program
那么你将能够继续执行程序。

181
00:12:09,210 --> 00:12:13,650
to bring a page from the disk to the physical memory.
将页面从磁盘调入物理内存。

182
00:12:13,980 --> 00:12:15,690
You need to find a place to put it.
你需要找一个地方放它。

183
00:12:18,330 --> 00:12:19,550
If you have free space,
如果你有空闲空间，

184
00:12:20,560 --> 00:12:21,310
you bring it down.
你把它放下来。

185
00:12:23,190 --> 00:12:24,500
If you don't have free space,
如果你没有空闲空间，

186
00:12:24,510 --> 00:12:29,870
they need to take an existing page and replace it with a new page.
他们需要将现有的页面替换为新页面。

187
00:12:29,880 --> 00:12:30,910
You want to bring in memory.
你想将其加载到内存中。

188
00:12:33,310 --> 00:12:36,310
Now, if that page you want to replace has been written,
现在，如果你想要替换的页面已经被编写完成，

189
00:12:36,320 --> 00:12:37,550
has been modified,
已经被修改了。

190
00:12:38,930 --> 00:12:40,210
then you need to put it on the disk,
那么你需要将它存储到磁盘上。

191
00:12:41,980 --> 00:12:42,850
save it on the disk.
将其保存在磁盘上。

192
00:12:43,550 --> 00:12:45,340
Before you replace it is on your page.
在你替换之前，它在你的页面上。

193
00:12:50,970 --> 00:12:51,720
That's what it is.
就是这样。

194
00:12:52,010 --> 00:12:56,000
We are going to go through this process several times during this lecture,
在本次讲座中，我们将多次进行这个过程。

195
00:12:56,720 --> 00:13:00,320
to make sure that the concepts are clear.
为了确保概念清晰。

196
00:13:02,100 --> 00:13:04,110
And before going forward,
在继续之前，

197
00:13:04,120 --> 00:13:13,020
notice that a it's a fundamental inversion here that you have the hardware.
请注意，这里存在一个基本的颠倒，即硬件是你拥有的。

198
00:13:13,030 --> 00:13:15,840
It causes a page fault in this case,
在这种情况下会引发页面错误。

199
00:13:15,850 --> 00:13:19,840
because the invalid bit or in the page table entry set,
因为页表项中设置了无效位或无效标志位，

200
00:13:20,460 --> 00:13:23,630
which then this fall is treated in software,
然后在本学期中，这将在软件中进行处理。

201
00:13:24,550 --> 00:13:24,870
right?
对的？

202
00:13:25,990 --> 00:13:32,800
As opposed to interrupts where the interacts are treated in hardware.
与中断不同，交互是在硬件中处理的。

203
00:13:33,160 --> 00:13:36,230
And then once you select the handle of the internet, only,
然后一旦你选择了互联网的句柄，只有这个，

204
00:13:36,240 --> 00:13:37,310
then you go into software.
然后你进入软件领域。

205
00:13:43,400 --> 00:13:45,150
Again, to put things into perspective.
再次，为了让事情更清晰明了。

206
00:13:45,160 --> 00:13:45,910
Right now,
现在，

207
00:13:46,440 --> 00:13:51,260
this is you have different levels of memory or storage.
这是指计算机系统中存在不同层次的内存或存储器。

208
00:13:52,230 --> 00:13:54,050
You have our own cheap cash.
你有自己的廉价现金。

209
00:13:55,380 --> 00:13:56,410
Here is a processor.
这是一个处理器。

210
00:13:56,420 --> 00:13:57,610
And in today's processors,
在当今的处理器中，

211
00:13:57,620 --> 00:14:02,270
you actually have multiple cash cashes level of cash is even known
你实际上有多个现金缓存层级，甚至有些现金层级是已知的。

212
00:14:02,280 --> 00:14:03,410
as single processor,
作为单处理器，

213
00:14:04,580 --> 00:14:08,310
because you may have a cache for each core.
因为每个核心可能都有自己的缓存。

214
00:14:08,680 --> 00:14:10,830
And then you may have a unified cache,
然后你可以拥有一个统一的缓存。

215
00:14:11,170 --> 00:14:12,860
which is across all course.
这适用于所有课程。

216
00:14:14,710 --> 00:14:16,470
Then you have second level cache.
然后你有第二级缓存。

217
00:14:17,370 --> 00:14:19,120
It's a main memory.
这是主内存。

218
00:14:19,780 --> 00:14:22,070
Then is this like secondary storage?
这是否类似于辅助存储？

219
00:14:22,730 --> 00:14:23,300
Of course,
当然可以。

220
00:14:23,310 --> 00:14:27,650
you can even have tertiary storage tape or some kind of storage in the cloud.
你甚至可以拥有三级存储磁带或云存储。

221
00:14:39,450 --> 00:14:40,320
What is the key here?
这里的关键是什么？

222
00:14:40,330 --> 00:14:40,640
You like?
你喜欢吗？

223
00:14:41,730 --> 00:14:44,400
What we are trying to do is catching with everything else.
我们正在努力赶上其他一切。

224
00:14:44,680 --> 00:14:46,160
We're trying to do something very simple.
我们正在尝试做一些非常简单的事情。

225
00:14:46,330 --> 00:14:51,920
We want to try to have the cake and eat it too.
我们想要尽量两全其美。

226
00:14:53,290 --> 00:14:54,620
So we want to have,
所以我们想要有，

227
00:14:57,170 --> 00:15:04,530
we want to build a system which behaves like it has a storage of the largest
我们想要构建一个系统，它的行为就像拥有最大存储空间一样。

228
00:15:05,680 --> 00:15:08,360
storage device.
存储设备。

229
00:15:08,650 --> 00:15:11,510
It has access to,
它具有访问权限，

230
00:15:11,520 --> 00:15:15,890
but the latency to access that storage.
但是访问该存储的延迟。

231
00:15:16,490 --> 00:15:20,570
It's the same as accessing zone, cheap cash.
这与访问区域和廉价现金相同。

232
00:15:21,390 --> 00:15:22,390
That's a holy great.
太棒了！

233
00:15:23,590 --> 00:15:23,910
Right?
对吗？

234
00:15:27,450 --> 00:15:28,640
And again,
再次，

235
00:15:28,650 --> 00:15:33,560
at the key here is that at every level,
关键在于，在每个层次上，

236
00:15:34,140 --> 00:15:37,130
the key technique is a cash is using cash.
关键技术是使用现金。

237
00:15:37,570 --> 00:15:39,920
You catch the data from the next level,
你从下一层捕获数据，

238
00:15:39,930 --> 00:15:42,080
and you hope that for the mass,
你希望对于大众来说，

239
00:15:42,090 --> 00:15:44,360
most of the vast majority of time,
大部分时间，绝大多数时间，

240
00:15:44,650 --> 00:15:49,810
the program will only use the data in that cache.
该程序只会使用缓存中的数据。

241
00:15:49,820 --> 00:15:53,010
You don't go to the next level.
你没有进入下一关。

242
00:15:56,830 --> 00:15:59,730
And if the program exhibit locality,
如果程序表现出局部性，

243
00:16:00,520 --> 00:16:00,860
therefore,
因此，

244
00:16:00,870 --> 00:16:06,750
he spends most of the time in a reasonably small portion of the code
他在代码的一个相对较小的部分花费了大部分的时间

245
00:16:06,760 --> 00:16:09,360
or touching small portion of the data.
或者只是触及数据的一小部分。

246
00:16:09,620 --> 00:16:10,490
You are in luck,
你很幸运，

247
00:16:10,500 --> 00:16:15,940
because as long as you put this heavily accessed a region of memory
因为只要你将这个频繁访问的内存区域放置在

248
00:16:15,950 --> 00:16:17,860
of a program in the cache,
在缓存中的程序

249
00:16:18,140 --> 00:16:18,670
you are fine.
你很好。

250
00:16:22,000 --> 00:16:23,960
And the last point to make here,
最后一个要提到的点是，

251
00:16:24,270 --> 00:16:27,210
the way to think about the main memory,
关于主存储器的思考方式

252
00:16:27,220 --> 00:16:30,650
it as a cash for the secondary storage, for the disk.
它作为二级存储器的现金，用于磁盘。

253
00:16:31,590 --> 00:16:33,430
But it's, again, at each level,
但是，再次强调，在每个层次上，

254
00:16:33,440 --> 00:16:36,480
you can think it's a cache for the next level.
你可以把它看作是下一级的缓存。

255
00:16:39,260 --> 00:16:41,140
But we don't call it cash,
但是我们不称之为现金，

256
00:16:41,150 --> 00:16:42,220
we call it paging.
我们称之为分页。

257
00:16:46,040 --> 00:16:47,120
So here is, again,
这里是，再次，

258
00:16:47,820 --> 00:16:53,840
another figure showing user baseball to what I described earlier.
另一个图示展示了我之前描述的用户棒球情况。

259
00:16:53,850 --> 00:16:54,680
In words,
用文字来描述的话，

260
00:16:55,100 --> 00:17:01,110
this is using some animation to drive the point how so have say you have
这里使用一些动画来强调一下，你要说的是你有什么要说的。

261
00:17:01,120 --> 00:17:03,350
an instruction and you do the instruction fetch,
一条指令，然后你进行指令获取操作。

262
00:17:04,110 --> 00:17:06,380
then you go to the memory management,
然后你进入了内存管理。

263
00:17:06,390 --> 00:17:07,780
you need the memory management,
你需要内存管理。

264
00:17:07,790 --> 00:17:10,100
you need to handle the base table,
你需要处理基本表。

265
00:17:10,330 --> 00:17:13,880
tlb and all of these great stuff to do address translation.
TLB（Translation Lookaside Buffer）和其他一些伟大的东西用于地址转换。

266
00:17:16,070 --> 00:17:17,500
Now, you go,
现在，你可以开始了。

267
00:17:17,510 --> 00:17:21,580
you find the page table entry.
你找到了页表项。

268
00:17:23,600 --> 00:17:25,870
And then from the patient, the entries,
然后从患者那里获取条目，

269
00:17:25,880 --> 00:17:29,120
we are going to have the page number and the offset.
我们将会有页号和偏移量。

270
00:17:34,920 --> 00:17:37,110
The offset keep coming from the virtual address.
偏移量来自虚拟地址。

271
00:17:37,400 --> 00:17:40,210
The page number comes after translation.
翻译后的页码会出现在之后。

272
00:17:42,850 --> 00:17:46,570
But now let's assume that you do when you execute the next instruction,
但是现在假设当你执行下一条指令时，

273
00:17:48,140 --> 00:17:49,820
you go to the page table,
你需要访问页表。

274
00:17:49,830 --> 00:17:54,640
but the entry doesn't exist or it existed by and it's invalid.
但该条目不存在，或者它曾经存在但已失效。

275
00:17:56,240 --> 00:17:58,400
So then you have a page fault.
那么你遇到了一个页面错误。

276
00:17:59,490 --> 00:18:02,780
You go to the operating system to take care of things.
你去操作系统处理事务。

277
00:18:05,720 --> 00:18:07,280
The page table, as i'm sorry,
页表，很抱歉，

278
00:18:07,290 --> 00:18:09,280
the operating system on fault,
操作系统出现故障，

279
00:18:11,340 --> 00:18:19,400
is going to do what is going basically too loud to locate the page on the disk,
这句话的意思是：要做的事情基本上是太吵了，无法定位磁盘上的页面。

280
00:18:20,950 --> 00:18:22,590
which is required by the program.
这是程序所需的。

281
00:18:22,850 --> 00:18:25,400
Load that page in the physical memory,
将该页面加载到物理内存中。

282
00:18:27,300 --> 00:18:29,510
and then update the page table entry.
然后更新页表项。

283
00:18:31,580 --> 00:18:33,620
Finally, you restart the program,
最后，你重新启动程序。

284
00:18:35,600 --> 00:18:38,050
and the program will retry the previous instruction,
程序将会重新尝试之前的指令，

285
00:18:38,060 --> 00:18:39,330
which calls a page fault.
这会引发一个页错误。

286
00:18:40,120 --> 00:18:40,310
Now,
现在，

287
00:18:40,320 --> 00:18:45,650
the previous instruction is going to have the same look to do the same page
前一条指令将具有相同的外观来执行相同的页面。

288
00:18:45,660 --> 00:18:47,090
from the same virtual address.
从相同的虚拟地址。

289
00:18:47,730 --> 00:18:48,780
But now,
但是现在，

290
00:18:49,470 --> 00:18:51,220
the page it's already in the memory,
该页面已经在内存中了。

291
00:18:51,230 --> 00:18:56,340
so you are going to access that page and continue execution.
所以你将访问那个页面并继续执行。

292
00:18:57,980 --> 00:18:58,900
Is that clear?
这清楚吗？

293
00:19:01,620 --> 00:19:02,540
Any questions?
有任何问题吗？

294
00:19:09,990 --> 00:19:13,580
So now we just said that the main page beijing is like cash,
所以现在我们刚刚说过，北京的主要页面就像现金一样。

295
00:19:14,400 --> 00:19:21,000
the memory act as a cash for the persistent storage like these courses or sst
内存充当持久存储（如这些课程或固态存储器）的缓存。

296
00:19:22,880 --> 00:19:28,360
now let's look from the. of your the cashing as from the point of
现在让我们从你的缓存的角度来看。

297
00:19:28,370 --> 00:19:30,660
view of a cash and characterize
现金的视角和特征描述

298
00:19:31,070 --> 00:19:32,140
demand beijing.
需求：北京。

299
00:19:33,430 --> 00:19:36,140
First of all, what is the block size?
首先，块大小是什么？

300
00:19:36,150 --> 00:19:38,240
What is the cash granada?
"现金格拉纳达"是指一种现金奖励或补贴计划。这种计划通常由政府、组织或企业提供，旨在鼓励个人或团体在特定领域或项目中取得成就或达到目标。格拉纳达通常以现金形式提供，可以用于个人消费、投资或其他用途。

301
00:19:39,650 --> 00:19:40,790
The block size?
块大小是多少？

302
00:19:41,880 --> 00:19:44,240
It's basically, in this case, you,
在这种情况下，基本上是你，

303
00:19:44,250 --> 00:19:45,560
as a joke.
作为一个笑话。

304
00:19:45,570 --> 00:19:47,670
Now, it's 1 page,
现在，只有一页。

305
00:19:48,650 --> 00:19:49,720
which is, say,
比如说，

306
00:19:49,730 --> 00:19:52,600
four kilobytes between one kilobytes and 16 kilobytes.
一千六百字节和一千字节之间有四千字节。

307
00:19:53,660 --> 00:19:54,120
Typically,
通常情况下，

308
00:19:55,780 --> 00:19:58,370
what is the organization of the cash?
现金的组织结构是什么？

309
00:19:59,370 --> 00:20:01,430
We learned about direct map cache,
我们学习了直接映射缓存。

310
00:20:02,110 --> 00:20:04,020
fully associative set associated.
完全关联集关联。

311
00:20:09,560 --> 00:20:16,710
The answer here is that it's fully associated provides you the most
这里的答案是完全关联提供给你最多的

312
00:20:21,450 --> 00:20:24,670
is the most efficient in using the cash.
在使用现金方面最高效。

313
00:20:25,190 --> 00:20:25,910
If you remember,
如果你还记得的话，

314
00:20:26,460 --> 00:20:31,860
why Why is a fully associative memory,
为什么全关联存储器是全关联的？

315
00:20:32,910 --> 00:20:40,130
the most effective in using the cash storage?
如何最有效地使用现金储存？

316
00:20:51,690 --> 00:20:54,250
You can place it anywhere.
你可以把它放在任何地方。

317
00:20:54,790 --> 00:20:56,300
There are no conflicts,
没有冲突。

318
00:20:56,310 --> 00:20:58,020
there are no conflict misses.
没有冲突缺失。

319
00:20:59,200 --> 00:21:01,610
Like you remember his direct map cash,
就像你记得他的直接映射缓存一样，

320
00:21:01,620 --> 00:21:02,970
you have conflict misses.
你有冲突缺失。

321
00:21:03,330 --> 00:21:08,470
You don't have conflict misses here with the associative cash.
在这里，使用关联缓存不会出现冲突缺失。

322
00:21:17,860 --> 00:21:18,860
There is a question here.
这里有一个问题。

323
00:21:18,870 --> 00:21:23,230
So the page fault we see in the error message happen on the demand,
所以我们在错误消息中看到的页面错误发生在需求方面。

324
00:21:23,240 --> 00:21:27,380
beijing does not save the program.
北京不保存程序。

325
00:21:34,170 --> 00:21:36,410
Maybe you can ask again the question.
也许你可以再问一遍问题。

326
00:21:36,420 --> 00:21:40,950
I am afraid I do not understand whatever we are talking about here.
很抱歉，我不明白我们在这里讨论的是什么。

327
00:21:40,960 --> 00:21:45,800
We are talking about the please ask the question again,
请再次提出问题，我们正在讨论。

328
00:21:46,660 --> 00:21:47,830
and i'll be happy to answer.
我很乐意回答。

329
00:21:52,240 --> 00:21:53,870
Now, how do you locate the page?
现在，你如何定位页面？

330
00:21:54,850 --> 00:21:58,680
First to check the dlb then you do the page traversal if it's
首先检查dlb，然后进行页面遍历，如果是的话。

331
00:21:58,690 --> 00:22:01,660
not in the tlb right?
不在TLB中吗？

332
00:22:01,670 --> 00:22:03,100
Is how you locate the page.
这是你定位页面的方式。

333
00:22:04,340 --> 00:22:06,030
What is the page replacement policy?
页面置换策略是什么？

334
00:22:07,620 --> 00:22:08,580
As you'll see,
正如你所看到的，

335
00:22:09,150 --> 00:22:11,230
it's we want allah you,
我们希望你全心全意地信仰真主。

336
00:22:13,390 --> 00:22:15,380
at least recently used,
至少最近使用的

337
00:22:16,390 --> 00:22:17,430
as there are others.
因为还有其他人。

338
00:22:17,900 --> 00:22:20,630
We are going to look at other replacement policies,
我们将研究其他的替换策略，

339
00:22:21,720 --> 00:22:25,030
but typically, we try to have an approximation of al rego.
但通常情况下，我们会尽量对所有寄存器进行近似。

340
00:22:25,960 --> 00:22:28,750
We have to have an approximation of area,
我们需要一个面积的近似值。

341
00:22:28,760 --> 00:22:31,930
because you just implementing area can be too expensive.
因为你只是在实现一个区域可能会太昂贵。

342
00:22:34,180 --> 00:22:35,450
We learn about that.
我们已经了解了这个。

343
00:22:36,580 --> 00:22:37,590
What happened on a miss?
在缺失时发生了什么？

344
00:22:37,600 --> 00:22:38,230
You saw that.
你看到了。

345
00:22:38,620 --> 00:22:39,000
Right?
对吗？

346
00:22:40,040 --> 00:22:41,310
When there is a miss,
当发生缺失时，

347
00:22:41,850 --> 00:22:47,770
you are going to find the page on the disk and bring the page in the memory.
你需要在磁盘上找到页面并将页面调入内存。

348
00:22:50,100 --> 00:22:51,290
What happens on the right?
右边发生了什么？

349
00:22:51,980 --> 00:22:57,110
Remember that the cache is a copy of the data from memory.
请记住，缓存是从内存中复制的数据。

350
00:22:59,190 --> 00:23:01,620
If you modify the data in the cache,
如果你修改了缓存中的数据，

351
00:23:02,550 --> 00:23:07,270
you need also to modify as the copy of that data in memory.
你还需要修改内存中的数据副本。

352
00:23:08,360 --> 00:23:10,310
And there are two ways to modify it.
并且有两种方法可以进行修改。

353
00:23:11,270 --> 00:23:13,290
One is right through.
一个是正确的。

354
00:23:14,000 --> 00:23:18,810
This means that as soon as you update the cash,
这意味着一旦你更新现金，

355
00:23:19,740 --> 00:23:21,380
also you update the main memory.
你还需要更新主存储器。

356
00:23:21,390 --> 00:23:27,030
The second method is right back.
第二种方法是右转回来。

357
00:23:27,990 --> 00:23:32,240
You just update the cash when you really want to replace the data
当你真正想要替换数据时，只需更新现金即可。

358
00:23:32,250 --> 00:23:36,160
in the cache with some other data from to bring it in,
将其与其他数据一起放入缓存中，以便将其带入缓存中。

359
00:23:37,130 --> 00:23:44,830
then you are going to write the data from the cache to the
然后你将把数据从缓存写入

360
00:23:44,840 --> 00:23:47,450
memory before replacing it.
在替换之前的内存。

361
00:23:49,060 --> 00:23:52,200
In this case, we are talking about memory and the disk.
在这种情况下，我们正在讨论内存和磁盘。

362
00:23:52,890 --> 00:23:56,200
We are definitely talking about right back.
我们确实在谈论右后卫。

363
00:23:57,040 --> 00:23:58,820
Why did I arrive back in this case?
为什么我又回到了这个情况下？

364
00:24:00,320 --> 00:24:02,710
Tell me why don't we do right through?
告诉我为什么我们不能一直做正确的事情？

365
00:24:21,030 --> 00:24:21,700
Excellent.
非常好。

366
00:24:21,710 --> 00:24:24,470
So allison and tyro.
所以是艾莉森和泰罗。

367
00:24:24,890 --> 00:24:32,580
So this is because it's very expensive to read the data from the disk.
这是因为从磁盘读取数据非常昂贵。

368
00:24:33,940 --> 00:24:36,640
It can be order of magnitude more expensive.
它可能会贵上一个数量级。

369
00:24:37,620 --> 00:24:39,020
Just to give you a sense,
只是为了让你有个概念，

370
00:24:40,310 --> 00:24:47,730
the latency to memory
内存延迟

371
00:24:48,240 --> 00:24:51,920
is maybe between 15 nanoseconds and 100 nanoseconds.
可能在15纳秒到100纳秒之间。

372
00:24:53,490 --> 00:24:58,150
The latency to read and write from a disk can be 1 million seconds.
从磁盘读取和写入的延迟可以达到100万秒。

373
00:24:59,900 --> 00:25:02,370
What is 34, or that are minded?
34是一个数字，表示三十四。"that are minded"这个短语的意思是"有意愿"或"有意识"。

374
00:25:05,970 --> 00:25:07,140
So it's huge difference.
所以这是一个巨大的差异。

375
00:25:07,930 --> 00:25:09,310
So that's how you avoid.
这就是你避免的方法。

376
00:25:09,940 --> 00:25:15,900
You try to minimize the number of times you write data back to the storage
你尽量减少将数据写回存储的次数。

377
00:25:16,210 --> 00:25:16,730
to the risk.
面临风险。

378
00:25:20,830 --> 00:25:27,170
I see, so this is a question.
我明白了，所以这是一个问题。

379
00:25:27,180 --> 00:25:30,690
It seems like when the baseball happens for the first time,
似乎是当棒球首次出现时，

380
00:25:31,180 --> 00:25:34,380
it tries a program again after the man paging instead of killing
在内存分页之后，它会尝试重新运行程序，而不是终止它。

381
00:25:34,390 --> 00:25:35,540
the program right away.
立即运行该程序。

382
00:25:35,890 --> 00:25:38,570
But on in zimbabwe often see page fold message,
但在津巴布韦经常会看到页面折叠的消息。

383
00:25:39,440 --> 00:25:43,710
the painful message you are seeing when you are debugging is different.
当你在调试时看到的痛苦信息是不同的。

384
00:25:44,560 --> 00:25:45,640
That is, for instance,
例如，

385
00:25:45,650 --> 00:25:51,040
when you are going to try to access some invalid region in the memory,
当你尝试访问内存中的无效区域时，

386
00:25:51,600 --> 00:25:53,040
like something you didn't allocate,
像你没有分配的东西一样，

387
00:25:54,130 --> 00:25:54,770
for instance,
例如，

388
00:25:55,260 --> 00:26:03,090
then you have faithful that is like you just have an address which
然后你有一个忠实的对象，就像你只有一个地址一样。

389
00:26:03,100 --> 00:26:06,190
doesn't belong to and to read or write to another address,
不属于并且不能读取或写入另一个地址。

390
00:26:06,200 --> 00:26:07,630
which doesn't belong to the program,
哪个不属于程序。

391
00:26:07,640 --> 00:26:09,190
because it's not allocated yet.
因为它尚未分配。

392
00:26:11,680 --> 00:26:12,400
So that's different.
所以这是不同的。

393
00:26:13,160 --> 00:26:18,000
The special fault I was talking about is not visible to the program.
我所说的特殊故障对程序来说是不可见的。

394
00:26:18,620 --> 00:26:19,890
This happens under the hood.
这是在幕后发生的。

395
00:26:21,370 --> 00:26:23,270
And what you said is correct.
你说的是正确的。

396
00:26:23,950 --> 00:26:26,190
That is on this page fault happens.
这是发生页面错误的地方。

397
00:26:26,740 --> 00:26:28,860
Yes, you are going to do a trap,
是的，你要执行一个陷阱操作。

398
00:26:30,920 --> 00:26:33,160
an exception trap to the operating system,
操作系统的异常陷阱

399
00:26:33,170 --> 00:26:34,360
the operating system,
操作系统

400
00:26:35,730 --> 00:26:37,190
get the page from the disk,
从磁盘获取页面

401
00:26:37,200 --> 00:26:38,350
put in the memory.
存入内存。

402
00:26:38,960 --> 00:26:44,120
And then you retry it and you restart the program from the same instruction.
然后你重试它，并从相同的指令重新启动程序。

403
00:26:53,030 --> 00:26:53,910
But remember,
但是请记住，

404
00:26:55,180 --> 00:26:57,940
we want to provide with the virtual memory,
我们希望提供虚拟内存。

405
00:26:57,950 --> 00:27:01,000
the illusion of infinite physical memory.
无限物理内存的错觉。

406
00:27:02,120 --> 00:27:03,470
This is one example.
这是一个例子。

407
00:27:03,480 --> 00:27:05,670
Virtual memory is huge, is for your byte,
虚拟内存非常庞大，以字节为单位计算。

408
00:27:05,680 --> 00:27:07,430
you have 32 bits addresses.
你有32位地址。

409
00:27:08,980 --> 00:27:10,420
But now most of the machines,
但是现在大多数的机器，

410
00:27:10,750 --> 00:27:13,100
even including your phone, has 64 bits.
即使包括你的手机在内，也只有64位。

411
00:27:14,380 --> 00:27:17,170
So it's a huge amount of memory of virtual memory.
所以这是一个巨大的虚拟内存的数量。

412
00:27:17,510 --> 00:27:19,960
There is no way you can have a physical memory,
你无法拥有物理内存。

413
00:27:19,970 --> 00:27:24,530
large enough of all the entire visual memory of an application.
足够大以容纳应用程序的全部可视内存。

414
00:27:25,870 --> 00:27:29,860
Then you map this kind of pages from the visual memory using the page table
然后你使用页表将这种页面从虚拟内存映射到物理内存。

415
00:27:29,870 --> 00:27:31,100
to the physical memory.
到物理内存。

416
00:27:31,880 --> 00:27:34,150
Then some of the page are,
然后一些页面是，

417
00:27:34,410 --> 00:27:37,870
which are the not fitting the physical memory are going to be on the disk.
无法适应物理内存的部分将被存储在磁盘上。

418
00:27:40,670 --> 00:27:41,180
Why is that?
为什么这样做呢？

419
00:27:41,190 --> 00:27:43,140
Because the disk is much higher,
因为磁盘的速度要快得多，

420
00:27:43,150 --> 00:27:47,470
even sst is much harder than a physical memory.
即使是单一系统图（SST），也比物理内存要困难得多。

421
00:27:47,560 --> 00:27:49,270
You have a lot of more space.
你还有很多空间。

422
00:27:57,970 --> 00:28:01,560
It's, again, going to the disk and getting the pace.
再次，它会访问磁盘并获取数据。

423
00:28:01,570 --> 00:28:03,900
So demand beijing happen,
所以需求发生在北京。

424
00:28:03,910 --> 00:28:08,130
transparent is not visible to the application.
透明对应用程序不可见。

425
00:28:08,400 --> 00:28:12,430
The only way the application may notice is that it's a little bit slower,
应用程序唯一可能注意到的是它变得稍微慢一些，

426
00:28:13,240 --> 00:28:16,220
because you need, instead of getting the data directly from memory,
因为你需要的是从内存中直接获取数据，而不是其他方式获取数据。

427
00:28:16,230 --> 00:28:18,180
you have to go first the disk,
你必须先去磁盘。

428
00:28:18,450 --> 00:28:20,460
move the data into memory, and then get the data.
将数据移入内存，然后获取数据。

429
00:28:31,290 --> 00:28:32,790
This is a page table entry.
这是一个页表项。

430
00:28:32,800 --> 00:28:35,990
If you remember, from two lectures ago,
如果你还记得，两节课之前的内容，

431
00:28:36,620 --> 00:28:38,070
you have the page frame number,
你有页面帧号码。

432
00:28:38,080 --> 00:28:40,590
the first 32 beats addresses address,
前32个位地址地址

433
00:28:41,170 --> 00:28:43,930
the first page, the page frame number.
第一页，页面帧编号。

434
00:28:43,940 --> 00:28:47,110
This represent the surface20 bits.
这表示了20位的表面。

435
00:28:47,680 --> 00:28:50,020
The last 12, 20 bits,
最后的12个、20位。

436
00:28:50,030 --> 00:28:53,790
12 bits are some a bunch of bits of
12位是一串位(bit)的集合。

437
00:28:57,830 --> 00:29:00,460
each bit has a different semantics.
每个位都有不同的语义。

438
00:29:00,470 --> 00:29:03,140
And for the purpose of this lecture,
为了本次讲座的目的，

439
00:29:03,700 --> 00:29:05,370
we care about 2 bits.
我们关心的是2个比特。

440
00:29:05,860 --> 00:29:11,070
One is p which is called present or valid.
其中一个是p，被称为当前或有效。

441
00:29:11,730 --> 00:29:19,680
This basically says that the corresponding page is in memory.
这基本上表示相应的页面已经在内存中。

442
00:29:22,260 --> 00:29:24,130
If p is zero, the bit is zero,
如果p为零，则该位为零。

443
00:29:24,140 --> 00:29:26,730
then the page is not in memory somewhere on the disk.
那么该页面不在磁盘上的某个位置上。

444
00:29:28,490 --> 00:29:34,310
And d is a dirty bit.
而 d 是一个脏位。

445
00:29:34,960 --> 00:29:38,040
And this says, as a patient has been modified recently,
这句话的意思是，由于最近对患者进行了修改，

446
00:29:38,050 --> 00:29:42,390
this has been modified since it was brought in memory.
这个在被加载到内存中之后已经被修改过了。

447
00:29:43,630 --> 00:29:44,720
For instance, for example,
例如，举个例子，比如说，

448
00:29:49,840 --> 00:29:52,390
this means that why do you think,
这意味着你为什么这样认为？

449
00:29:52,700 --> 00:29:54,690
how do you think you are going to use a dirty bit?
你认为如何使用脏位？

450
00:30:03,770 --> 00:30:04,930
Why do we need it?
我们为什么需要它？

451
00:30:11,400 --> 00:30:19,220
It's exactly is to determine it's if you need to write the page back,
这是确定是否需要将页面写回的准确方法。

452
00:30:20,270 --> 00:30:22,260
if we have to replace that page,
如果我们必须替换那个页面，

453
00:30:22,630 --> 00:30:27,570
because we no longer have room in the physical memory to bring a new page,
因为我们的物理内存已经没有足够的空间来加载新的页面了。

454
00:30:28,210 --> 00:30:33,300
then if the page we want to replace has been modified,
那么如果我们要替换的页面已被修改，

455
00:30:33,310 --> 00:30:34,940
we need first to write to the disk,
我们首先需要将数据写入磁盘。

456
00:30:34,950 --> 00:30:36,100
not with the information.
没有相关信息。

457
00:30:40,430 --> 00:30:41,240
That's great.
太好了。

458
00:30:48,000 --> 00:30:48,790
This is a demand.
这是一个要求。

459
00:30:48,800 --> 00:30:50,710
Paging mechanism is very simple.
分页机制非常简单。

460
00:30:50,720 --> 00:30:56,860
Again, it's like repeating it.
再次，就像重复一样。

461
00:30:58,030 --> 00:31:02,620
You look at the pde baseball entry of the page.
你看一下页面上的PDE棒球条目。

462
00:31:02,630 --> 00:31:10,320
If the bit of the pd is valid than the means that the page in memories,
如果页面描述符（pd）的位有效，则意味着页面在内存中。

463
00:31:10,330 --> 00:31:13,200
you go and access the data from the memory.
你去访问内存中的数据。

464
00:31:13,520 --> 00:31:14,710
If it's not valid,
如果不合法，

465
00:31:15,210 --> 00:31:19,150
then this means that the page is not in memory.
这意味着页面不在内存中。

466
00:31:19,160 --> 00:31:19,990
It's on the disk.
它在磁盘上。

467
00:31:20,780 --> 00:31:23,460
And when you do that,
当你这样做的时候，

468
00:31:23,470 --> 00:31:27,060
you these results in a trap,
你把这些结果陷入了一个陷阱中，

469
00:31:28,410 --> 00:31:29,480
it's a page fault.
这是一个页面错误。

470
00:31:30,030 --> 00:31:31,730
And 1 page fault,
并且发生了1次页面错误。

471
00:31:32,140 --> 00:31:35,020
you choose an old page to replace.
你选择了一个旧页面来替换。

472
00:31:35,030 --> 00:31:38,770
If you don't have enough room in the memory.
如果内存空间不足。

473
00:31:40,370 --> 00:31:43,410
If that old page has a dirty bit set,
如果那个旧页面的脏位被设置了，

474
00:31:43,420 --> 00:31:46,740
this means that you have to write that page to the disk.
这意味着你需要将该页面写入磁盘。

475
00:31:47,780 --> 00:31:49,410
Then once you are done with that,
完成后，

476
00:31:49,870 --> 00:31:54,340
you also need to add to invalidate the pt entry for the page,
你还需要添加代码来使页表项失效。

477
00:31:54,350 --> 00:31:58,390
because now you are going to remove from the you are going to remove it
因为现在你要将它移除。

478
00:31:58,400 --> 00:32:00,190
from the memory.
从内存中。

479
00:32:00,510 --> 00:32:03,790
And also you need to invalidate the tlb entry for that page.
还有，你需要使该页面的TLB条目无效化。

480
00:32:04,480 --> 00:32:06,270
Once you are done with it,
完成后，

481
00:32:06,280 --> 00:32:12,450
you are going to bring the new page from the disk to memory in place
你将要将磁盘上的新页面就地加载到内存中。

482
00:32:12,780 --> 00:32:13,650
of the old page.
旧页面的一部分。

483
00:32:14,960 --> 00:32:16,570
And once you bring the new page,
一旦你带来了新页面，

484
00:32:17,160 --> 00:32:20,880
your update to the pdu of the new page.
您对新页面的PDU的更新。

485
00:32:21,570 --> 00:32:25,010
And you are ready to go.
你已经准备好了。

486
00:32:32,290 --> 00:32:32,930
And by the way,
顺便说一下，

487
00:32:32,940 --> 00:32:40,650
when this happens and operating system is doing all this kind of work
当发生这种情况时，操作系统正在进行所有这些工作。

488
00:32:41,140 --> 00:32:44,000
to bring the page from the disk to memory,
将页面从磁盘加载到内存中，

489
00:32:45,100 --> 00:32:48,510
it's a lot of io and in the meantime,
这涉及到很多输入输出操作，同时，

490
00:32:48,950 --> 00:32:54,700
you try to scandal and run other processes which are not blocked.
你试图扫描并运行其他未被阻塞的进程。

491
00:32:58,890 --> 00:33:03,280
So at those origins of the beijing and the origin of the beijing is states
北京的起源可以追溯到古代的国家。

492
00:33:03,290 --> 00:33:06,400
long time ago from 70s and in 70s.
很久以前，从70年代开始，到70年代结束。

493
00:33:07,390 --> 00:33:14,030
It was a time before everyone has a personal computer and what you have a terminal.
这是在每个人都拥有个人电脑之前的时代，你只有一个终端。

494
00:33:15,280 --> 00:33:17,400
It looks like a computer, but it's just a terminal.
它看起来像一台计算机，但实际上只是一个终端。

495
00:33:17,870 --> 00:33:19,520
And they are connected to the computers.
它们与计算机相连接。

496
00:33:19,530 --> 00:33:23,630
You have many people running their programs on the same computer.
你有很多人在同一台计算机上运行他们的程序。

497
00:33:23,920 --> 00:33:26,990
And they are using the computer from these terminals.
他们正在使用这些终端上的计算机。

498
00:33:28,910 --> 00:33:31,340
Now, because you have so many users,
现在，由于你有很多用户，

499
00:33:31,830 --> 00:33:34,470
and the physical memory was quite small.
而且物理内存非常小。

500
00:33:34,820 --> 00:33:38,480
Again, not all the users programs could fit in the memory.
同样，不是所有用户的程序都能够适应内存。

501
00:33:38,490 --> 00:33:46,480
So now you need to do you need the ability to
所以现在你需要做的是你需要有能力

502
00:33:46,490 --> 00:33:50,530
swap and to put some of these a pages of these pages,
交换并将其中一些页面放置在这些页面中。

503
00:33:50,540 --> 00:33:52,910
which are not used often,
很少使用的。

504
00:33:52,920 --> 00:33:56,890
or they haven't used for a while to put them on the disk.
或者他们已经有一段时间没有使用了，将它们存储到磁盘上。

505
00:33:57,580 --> 00:33:57,750
Right?
对吗？

506
00:33:57,960 --> 00:34:00,200
This is what happened early on.
这是早期发生的事情。

507
00:34:01,040 --> 00:34:01,930
That's why you have paid.
这就是你付款的原因。

508
00:34:18,010 --> 00:34:20,120
This is basically the model you have,
这基本上是你所拥有的模型。

509
00:34:20,130 --> 00:34:23,200
we should we are going to have in mind,
我们应该记住的是，

510
00:34:23,210 --> 00:34:28,090
and we are going to continue to discuss the image, pay,
我们将继续讨论镜像和薪资问题。

511
00:34:28,500 --> 00:34:30,370
demand, paging for the rest of the lecture.
剩下的讲座将涉及到需求分页。

512
00:34:31,930 --> 00:34:38,460
Now, what happens when the pieces with the personal computers?
现在，个人电脑的部件会发生什么情况呢？

513
00:34:38,740 --> 00:34:39,760
Actually, it's personal computers.
实际上，这是个人电脑。

514
00:34:39,770 --> 00:34:40,060
Initially.
最初的。

515
00:34:40,070 --> 00:34:41,560
You don't have visual memory.
你没有视觉记忆。

516
00:34:41,570 --> 00:34:45,130
You have one program only running a on a machine,
你只有一个程序在一台机器上运行。

517
00:34:45,620 --> 00:34:48,050
and that program taking the entire physical memory.
并且该程序占用了整个物理内存。

518
00:34:49,190 --> 00:34:49,580
However,
然而，

519
00:34:49,590 --> 00:34:53,300
as personal computers became more and more sophisticated and you run
随着个人电脑变得越来越复杂，你运行的任务也越来越多。

520
00:34:53,310 --> 00:34:55,580
multiple programs on the same computer,
同一台计算机上的多个程序

521
00:34:56,010 --> 00:34:56,760
now you're still,
现在你还静止不动，

522
00:34:57,410 --> 00:34:59,000
you are back in square one,
你又回到了原点，

523
00:34:59,340 --> 00:35:02,370
because like we discussed several times,
因为正如我们多次讨论过的那样，

524
00:35:02,740 --> 00:35:07,070
the aggregate memory required by all processes,
所有进程所需的总内存

525
00:35:07,080 --> 00:35:12,080
all the application running at a given time exceeds the physical memory.
在给定的时间内，所有运行的应用程序超过了物理内存的容量。

526
00:35:13,330 --> 00:35:15,360
Again, what is a solution here?
这里的解决方案是什么？

527
00:35:15,370 --> 00:35:17,740
Individualize them as a memo, the memory.
将它们个性化为备忘录，即内存。

528
00:35:18,170 --> 00:35:24,350
And you need to keep some of these memory of this application on the disk.
你需要将这个应用程序的一部分内存保存在磁盘上。

529
00:35:24,870 --> 00:35:27,660
The memory, hopefully, which is not accessed very often,
希望不经常访问的内存

530
00:35:31,340 --> 00:35:31,890
all these.
所有这些。

531
00:35:31,900 --> 00:35:37,010
And now machines are connected to the cloud,
现在机器与云相连接，

532
00:35:37,820 --> 00:35:41,160
all of your phones and laptops.
你的所有手机和笔记本电脑。

533
00:35:41,560 --> 00:35:46,500
And you have the same situation in the the cloud.
在云端中，你也面临着同样的情况。

534
00:35:46,510 --> 00:35:48,420
You have very powerful computers,
你们有非常强大的计算机。

535
00:35:48,900 --> 00:35:51,210
and they run a lot of applications.
他们运行了很多应用程序。

536
00:35:51,560 --> 00:35:52,690
And they also,
而且他们也，

537
00:35:52,700 --> 00:35:54,090
obviously with virtual members.
显然是使用虚成员。

538
00:35:59,000 --> 00:35:59,910
This is, again,
这是，再次，

539
00:36:00,480 --> 00:36:02,670
if you look at one machine,
如果你只看一台机器，

540
00:36:03,100 --> 00:36:05,580
if you do the ps program status,
如果你执行ps命令来查看程序的状态，

541
00:36:05,590 --> 00:36:07,680
this is kind of what you get.
这差不多就是你得到的东西。

542
00:36:08,680 --> 00:36:14,040
And here i'm just showing the memory in this particular case is pretty utilized.
在这里，我只是展示了在这种特定情况下内存被充分利用的情况。

543
00:36:14,050 --> 00:36:18,380
I say that you have 13 gigabytes of memory.
我说你有13GB的内存。

544
00:36:18,390 --> 00:36:21,630
It's used, and only 2.7 is not used.
它被使用了，只有2.7没有被使用。

545
00:36:21,640 --> 00:36:24,030
So it's more than 80% it's used.
所以它的使用率超过80%。

546
00:36:24,800 --> 00:36:28,160
And some of them is shared memory.
其中一些是共享内存。

547
00:36:28,170 --> 00:36:33,640
Remember that different application can share memory.
请记住，不同的应用程序可以共享内存。

548
00:36:33,650 --> 00:36:36,280
For instance, if they use the same libraries,
例如，如果他们使用相同的库文件，

549
00:36:36,690 --> 00:36:38,580
they share the code of those libraries,
它们共享这些库的代码。

550
00:36:38,590 --> 00:36:44,180
because it doesn't make sense to make a copy of the same code for each
因为为每个相同的代码制作副本是没有意义的。

551
00:36:44,190 --> 00:36:45,110
of the application.
应用程序的一部分。

552
00:36:50,230 --> 00:36:53,560
So there are many uses of ritual memory and demand beijing.
因此，仪式记忆和需求北京有许多用途。

553
00:36:55,870 --> 00:36:59,990
I remember that in the virtual memory or one segment,
我记得在虚拟内存或一个段中，

554
00:37:00,000 --> 00:37:01,390
you have is a stack.
你拥有的是一个栈。

555
00:37:02,460 --> 00:37:07,780
The stack grows downwards from the high addresses to the lower addresses,
栈从高地址向低地址增长。

556
00:37:08,400 --> 00:37:11,460
as you allocate and to push more data on the stack,
当你分配内存并将更多数据推入堆栈时，

557
00:37:12,060 --> 00:37:13,680
you may have to extend the stack.
你可能需要扩展栈。

558
00:37:14,510 --> 00:37:17,070
So this is how you are going to do it.
这就是你要做的方式。

559
00:37:17,400 --> 00:37:19,830
If you are going to want to expand the stack,
如果你想要扩展栈的话，

560
00:37:20,290 --> 00:37:22,760
then it's, again, what will happen?
那么，再次发生什么？

561
00:37:22,770 --> 00:37:23,800
You have a page fault.
你发生了一个页面错误。

562
00:37:24,820 --> 00:37:26,850
You are going to go to the operating system,
你将要学习操作系统。

563
00:37:26,860 --> 00:37:30,290
and the operating system is going to increase the side of the stack,
操作系统将增加栈的大小。

564
00:37:31,560 --> 00:37:33,590
ok and allocate more memory for the stack.
好的，为栈分配更多的内存。

565
00:37:34,750 --> 00:37:37,300
Another way is process fork.
另一种方式是进程分叉（fork）。

566
00:37:37,310 --> 00:37:38,500
We discuss about that.
我们讨论这个问题。

567
00:37:38,510 --> 00:37:38,780
Here.
这里。

568
00:37:38,790 --> 00:37:40,580
We are going to re discuss again.
我们将重新讨论。

569
00:37:41,560 --> 00:37:43,650
When you do a fork,
当你执行fork操作时，

570
00:37:43,660 --> 00:37:50,190
you remember that the child process has the same code as the same in science.
你记得子进程与父进程有相同的代码。

571
00:37:50,630 --> 00:37:54,430
And it has the same resources as a parent process.
它拥有与父进程相同的资源。

572
00:37:57,830 --> 00:37:59,930
But because you have the same code,
但是因为你们有相同的代码，

573
00:38:00,490 --> 00:38:03,520
one simple solution will be your copies,
一个简单的解决方案是复制您的文件。

574
00:38:03,530 --> 00:38:05,750
the entire code,
整个代码

575
00:38:06,620 --> 00:38:10,650
and the data from the parent process to the child process before you
在将数据从父进程传递给子进程之前，

576
00:38:10,660 --> 00:38:12,090
can start the child process.
可以启动子进程。

577
00:38:12,920 --> 00:38:15,190
The problem is that it will take a lot of time.
问题在于这将会花费很多时间。

578
00:38:16,260 --> 00:38:22,500
So instead, what you do here is that when you create the child process,
所以在这里，你所做的是在创建子进程时，

579
00:38:22,510 --> 00:38:30,170
you create it immediately and you have it.to all the memory of the parent process.
你立即创建它，并将其拥有到父进程的所有内存中。

580
00:38:30,180 --> 00:38:31,730
So they share the same memory.
所以它们共享同一块内存。

581
00:38:32,230 --> 00:38:42,000
The only difference is that from the point of view of the child process,
唯一的区别是从子进程的角度来看，

582
00:38:42,490 --> 00:38:47,700
all the memory is marked as read only no rights.
所有的内存都被标记为只读，没有权限。

583
00:38:48,730 --> 00:38:49,140
Right?
对吗？

584
00:38:50,170 --> 00:38:53,280
Now when you read everything is perfect, right?
现在当你读到这一切都完美了，对吗？

585
00:38:53,290 --> 00:38:55,360
Because you are going to read the same content,
因为你将要阅读相同的内容，

586
00:38:56,150 --> 00:39:01,840
which is not modified as not modified as from the parrot.
这个句子的意思是"这个不是从鹦鹉那里修改过的"。

587
00:39:03,360 --> 00:39:03,700
But now,
但是现在，

588
00:39:04,640 --> 00:39:08,150
if the child wants to modify a piece of data,
如果孩子想要修改一段数据，

589
00:39:08,600 --> 00:39:12,740
then because the pages are read only,
因此，由于这些页面是只读的，

590
00:39:13,110 --> 00:39:18,700
then it's going to cause aa trap and exception is going to be intercepted
那么它将引发陷阱并拦截异常。

591
00:39:18,710 --> 00:39:20,100
by the operating system.
由操作系统完成。

592
00:39:20,490 --> 00:39:25,090
And the operating system now is going to copy the page.
操作系统现在要复制页面。

593
00:39:25,490 --> 00:39:29,460
Read on the only page is going to create another copy now for the child.
现在，只读页面将为子进程创建另一个副本。

594
00:39:29,890 --> 00:39:35,830
Now is going to give access to write to its own copy of that page to the child.
现在将允许子进程对自己的页面副本进行写操作。

595
00:39:42,060 --> 00:39:43,170
When you exec,
当你执行exec时，

596
00:39:43,180 --> 00:39:46,450
you only bring in parts of the binary inactive use,
你只需要引入二进制非活动使用的部分。

597
00:39:46,460 --> 00:39:50,780
you just brings few pages in the memory or don't bring,
你只需要将几页内存加载进来或者不加载。

598
00:39:50,790 --> 00:39:54,320
cause I am tired program into memory,
因为我已经很累了，需要将程序加载到内存中。

599
00:39:54,330 --> 00:39:59,000
because that can be too big and sample some parts of the program you may know,
因为这可能会太大，并且只对程序的一部分进行抽样，你可能会了解到一些部分。

600
00:39:59,010 --> 00:40:00,920
but never touch when you are running it.
但在运行时不要触摸它。

601
00:40:02,180 --> 00:40:03,610
The similarly with a stack,
与栈类似，

602
00:40:03,620 --> 00:40:06,570
you can extend the heap so forth.
你可以扩展堆空间等等。

603
00:40:08,490 --> 00:40:15,540
This is another example about an animation about what happens
这是另一个关于发生了什么的动画的例子

604
00:40:16,360 --> 00:40:20,070
when it's an end to an example and show you what happens.
当一个示例结束并展示发生了什么时。

605
00:40:20,330 --> 00:40:23,650
When you start a new program,
当你启动一个新程序时，

606
00:40:24,150 --> 00:40:25,290
you have a new program.
你有一个新的程序。

607
00:40:25,300 --> 00:40:26,730
The program is on the disk.
程序在磁盘上。

608
00:40:28,570 --> 00:40:30,800
It's not exact, is an extension.
这不是完全准确的，而是一个扩展。

609
00:40:31,220 --> 00:40:32,410
You have the code,
你有代码。

610
00:40:32,420 --> 00:40:34,210
you have some data, static data,
你有一些数据，静态数据，

611
00:40:34,220 --> 00:40:36,010
and then for some other information,
然后关于其他信息，

612
00:40:37,240 --> 00:40:38,460
you need to bring that in memory.
你需要将它加载到内存中。

613
00:40:38,470 --> 00:40:40,740
You need to bring the code in memory in order to run.
你需要将代码加载到内存中才能运行。

614
00:40:41,360 --> 00:40:42,800
And when you are going to start,
你什么时候开始？

615
00:40:43,260 --> 00:40:45,530
you are going to bring some part of the code in memory.
你将要将代码的一部分加载到内存中。

616
00:40:45,540 --> 00:40:48,290
And then you are going to bring some data in memory.
然后你将把一些数据加载到内存中。

617
00:40:48,300 --> 00:40:53,770
And then you are going to allocate heap and the stack for that particular program.
然后你将为该特定程序分配堆和栈。

618
00:40:55,060 --> 00:40:58,890
This is the view from the virtual address space.
这是虚拟地址空间的视图。

619
00:40:58,900 --> 00:41:03,480
Bus stands for virtual address space of the process which was
Bus（总线）代表进程的虚拟地址空间，该地址空间是由操作系统分配给进程的。

620
00:41:03,490 --> 00:41:05,280
instantiate to run the program.
实例化以运行程序。

621
00:41:06,210 --> 00:41:08,470
And let's see.
让我们看看。

622
00:41:09,930 --> 00:41:15,580
Then you obviously are going to back all these virtual addresses,
那么显然你将要备份所有这些虚拟地址，

623
00:41:15,590 --> 00:41:17,680
everything in the virtual address,
虚拟地址中的所有内容

624
00:41:17,960 --> 00:41:19,560
which is used by the program.
被程序使用的。

625
00:41:19,830 --> 00:41:22,400
You are going to be backed to the disk.
你将被备份到磁盘上。

626
00:41:24,490 --> 00:41:29,390
Finally, between the virtual address and the memory, you need to do,
最后，在虚拟地址和内存之间，你需要进行以下操作：

627
00:41:30,280 --> 00:41:32,310
the translation is done with the page table.
翻译是通过页表完成的。

628
00:41:32,820 --> 00:41:39,050
Some entry from the page table are going to.2 pages in the physical memory.
页表中的某些条目将占用物理内存中的2个页面。

629
00:41:40,120 --> 00:41:43,220
And if a base table,
如果是一个基本表，

630
00:41:44,070 --> 00:41:46,710
it's invalid,
这是无效的。

631
00:41:48,050 --> 00:41:49,800
that doesn't exist in memory,
这在内存中不存在。

632
00:41:50,080 --> 00:41:55,150
use a corresponding page table entry is going to point to the location
使用相应的页表项将指向该位置

633
00:41:55,160 --> 00:41:56,430
of that page on the disk.
将该页面从磁盘中读取出来。

634
00:42:05,770 --> 00:42:09,320
Fundamentally, what you need to do if that page is on the disk,
基本上，如果页面在磁盘上，你需要做的是：

635
00:42:09,330 --> 00:42:11,240
is to have a function, something like that.
是要有一个函数，类似这样的东西。

636
00:42:11,250 --> 00:42:13,520
It's a fine blog which takes an argument,
这是一篇很好的博客，它提出了一个论点。

637
00:42:13,530 --> 00:42:17,190
the process id and the patient number of that.
进程ID和患者编号。

638
00:42:19,440 --> 00:42:23,630
And and then for that paid number and the process,
然后对于那个已支付的号码和进程，

639
00:42:23,640 --> 00:42:29,890
you are going to get a disk location of on the disk where you can find
你将获得一个磁盘位置，在该位置上可以找到...

640
00:42:29,900 --> 00:42:30,510
that page.
那个页面。

641
00:42:34,430 --> 00:42:38,200
So this is very similarly the paste table concept,
这与粘贴表格的概念非常相似，

642
00:42:39,860 --> 00:42:43,520
but it is purely done purely in software.
但这完全是通过软件来实现的。

643
00:42:44,870 --> 00:42:47,390
No, dld no, nothing like that.
不，没有，没有这样的事情。

644
00:42:52,710 --> 00:42:57,810
Why do you take the pid why do you take the argument?
为什么要获取进程ID？为什么要获取参数？

645
00:42:57,820 --> 00:42:59,490
Is the pid argument here?
这里有pid参数吗？

646
00:43:13,340 --> 00:43:13,890
Anyone?
有人吗？

647
00:43:17,990 --> 00:43:22,280
Because the virtual address space is per process.
因为虚拟地址空间是针对每个进程的。

648
00:43:24,710 --> 00:43:26,790
The base tables are per process.
基本表是每个进程独立的。

649
00:43:28,470 --> 00:43:32,510
If I give you only the page number is not well defined,
如果我只给你页码，这是不明确的。

650
00:43:33,440 --> 00:43:34,810
because multiple processes,
因为有多个进程，

651
00:43:34,820 --> 00:43:36,530
I can have a the same page numbers,
我可以有相同的页码。

652
00:43:38,320 --> 00:43:38,440
right?
对的吗？

653
00:43:38,450 --> 00:43:43,660
Because a patient number represents something in their virtual address space.
因为患者号码在他们的虚拟地址空间中代表着某个东西。

654
00:43:44,480 --> 00:43:46,900
And each of them has a different virtual address space.
每个进程都有不同的虚拟地址空间。

655
00:43:50,100 --> 00:43:53,340
So that's why you need to give the person the process identifier
这就是为什么你需要给这个人提供进程标识符的原因。

656
00:43:54,800 --> 00:43:56,440
to identify the virtual address space.
识别虚拟地址空间。

657
00:44:02,080 --> 00:44:03,000
Where do you store it?
你把它存放在哪里？

658
00:44:03,330 --> 00:44:05,260
Obviously, you want to study the memory if you,
显然，如果你想要研究内存的话，

659
00:44:05,270 --> 00:44:10,780
because if you store it on the disks and you need to bring it from the disk,
因为如果你将数据存储在磁盘上，而且需要从磁盘中读取数据，

660
00:44:10,790 --> 00:44:11,980
is going to be one slower.
会慢一些。

661
00:44:16,000 --> 00:44:17,070
That's pretty much it.
就是这样。

662
00:44:32,300 --> 00:44:33,220
Any questions?
有任何问题吗？

663
00:44:39,130 --> 00:44:41,450
By the way, like, in the case of the shared memory,
顺便提一下，在共享内存的情况下，

664
00:44:42,840 --> 00:44:51,070
you also can share the disk between different applications processes.
你还可以在不同的应用程序进程之间共享磁盘。

665
00:44:51,770 --> 00:44:53,330
So, for instance, and I like,
例如，我喜欢的是，

666
00:44:53,340 --> 00:44:54,450
i'll show you next,
我会向你展示接下来的内容。

667
00:44:56,220 --> 00:44:58,490
the way i'll show you that is like, for instance,
我将向您展示的方式是，例如，

668
00:44:58,500 --> 00:45:01,910
here against his virtual address space for on process.
在这里，针对进程的虚拟地址空间进行操作。

669
00:45:02,250 --> 00:45:05,050
And you can have another process and another process will have
而且你可以有另一个进程，而另一个进程将有

670
00:45:05,060 --> 00:45:08,300
its own visual address space is owned by page labels.
它自己的可视地址空间由页面标签所拥有。

671
00:45:10,430 --> 00:45:17,190
Here, it's about the stack and the heap and the data of the second process.
这里涉及到栈、堆和第二个进程的数据。

672
00:45:17,850 --> 00:45:20,680
And assume that the second process is the first process.
假设第二个进程是第一个进程。

673
00:45:21,030 --> 00:45:25,470
Running the same program are just two instances of the same program.
运行相同的程序只是同一个程序的两个实例。

674
00:45:26,130 --> 00:45:27,320
In this particular case,
在这种特殊情况下，

675
00:45:27,330 --> 00:45:28,360
as you can see,
正如你所看到的，

676
00:45:28,650 --> 00:45:29,800
the code is shared,
代码是共享的，

677
00:45:30,230 --> 00:45:31,350
because the code is read.
因为代码是可读的。

678
00:45:31,360 --> 00:45:34,430
You remember, it's read only so it doesn't change.
你记得，它是只读的，所以不会改变。

679
00:45:34,970 --> 00:45:41,240
So if you have to programs which uses out of instances,
如果你有两个程序使用了超出实例的资源，

680
00:45:41,450 --> 00:45:41,680
sorry,
抱歉，有什么我可以帮助您的吗？

681
00:45:41,690 --> 00:45:44,740
it's you have two instances of the same program
这意味着你有两个相同程序的实例。

682
00:45:45,010 --> 00:45:49,300
than the virtual address space of the two,
比这两个的虚拟地址空间更大

683
00:45:50,670 --> 00:45:51,950
the two instances,
这两个实例，

684
00:45:51,960 --> 00:45:53,240
the two processes.
这两个进程。

685
00:45:53,500 --> 00:45:58,080
They can share the same code on the disk.
它们可以在磁盘上共享相同的代码。

686
00:45:59,100 --> 00:46:01,010
They said, share the same code, obviously,
他们说，共享相同的代码，显然，

687
00:46:01,020 --> 00:46:02,370
and you can share also,
而且你也可以分享，

688
00:46:02,840 --> 00:46:06,670
we can share the same old code also in the physical memory.
我们可以将相同的旧代码也存储在物理内存中。

689
00:46:09,970 --> 00:46:10,500
Make sense?
有意义吗？

690
00:46:13,060 --> 00:46:13,840
Any questions?
有任何问题吗？

691
00:46:18,950 --> 00:46:19,480
Okay.
好的。

692
00:46:23,040 --> 00:46:23,430
Again,
再次，

693
00:46:24,920 --> 00:46:26,350
this page table,
这是一个页表。

694
00:46:26,360 --> 00:46:27,780
the second process,
第二个进程，

695
00:46:27,790 --> 00:46:30,220
some of the pages have been memory, some of them,
一些页面已经被存入内存，其中一些页面，

696
00:46:30,860 --> 00:46:32,940
the one which are not in memories are backed on this.
不在内存中的数据会被备份到这里。

697
00:46:37,260 --> 00:46:38,890
Now say the process active,
现在说一下进程是活动的。

698
00:46:38,900 --> 00:46:40,530
the first process is active.
第一个进程处于活动状态。

699
00:46:41,030 --> 00:46:47,420
Then if you are going to have fetched an instruction on access
那么，如果你要在访问时获取一条指令

700
00:46:47,430 --> 00:46:49,180
and physical memory,
和物理内存，

701
00:46:49,660 --> 00:46:53,580
then you look in the base table.
然后你查看基本表。

702
00:46:53,590 --> 00:46:55,980
If, say the base table entry is invalid,
假设基表项无效，

703
00:46:56,390 --> 00:47:01,040
then you have a page fold as the operating system locates a block
当操作系统定位到一个块时，会发生页面折叠。

704
00:47:01,400 --> 00:47:03,320
on the disk which contains a page,
在包含页面的磁盘上，

705
00:47:03,670 --> 00:47:09,740
and then move it to the memory.
然后将其移动到内存中。

706
00:47:11,940 --> 00:47:16,730
Is another summary step by step of handling a baseball.
处理棒球的另一个逐步摘要。

707
00:47:17,440 --> 00:47:19,110
Again, you access a memory,
再次，你访问了一个内存位置，

708
00:47:21,490 --> 00:47:23,170
mutual memory, physically,
共享内存，物理上，

709
00:47:23,180 --> 00:47:26,090
the and it's step one.
这是第一步。

710
00:47:26,470 --> 00:47:30,940
Say, the program, the associated page table entries invalid,
程序中的相关页表项无效，

711
00:47:31,490 --> 00:47:36,940
these results in a trap baseball with the operating system,
这些结果导致操作系统陷入了一个陷阱。

712
00:47:42,820 --> 00:47:46,180
locate the block where the page is stored on the disk,
定位页面在磁盘上存储的块。

713
00:47:46,790 --> 00:47:48,630
bring the page in memory,
将页面加载到内存中，

714
00:47:48,980 --> 00:47:50,200
in a free frame,
在一个空闲帧中，

715
00:47:50,210 --> 00:47:52,640
page frame updates,
页面帧更新

716
00:47:52,650 --> 00:47:53,840
a page table entries,
页表项

717
00:47:53,850 --> 00:47:55,000
and restart the instruction.
并重新启动指令。

718
00:47:59,270 --> 00:48:03,360
A few announcements the hallmark for has been released.
已发布了一些重要公告。

719
00:48:05,420 --> 00:48:06,430
This week.
本周。

720
00:48:06,440 --> 00:48:09,920
Please understand the design reviews.
请理解设计评审。

721
00:48:10,220 --> 00:48:13,860
Remember, the design review starts at the hour.
请记住，设计审查将在整点开始。

722
00:48:14,730 --> 00:48:16,410
They are not on the berkeley time.
他们不按照伯克利时间。

723
00:48:17,530 --> 00:48:17,980
Please.
请。

724
00:48:19,600 --> 00:48:21,620
So you give time to everyone.
所以你给每个人时间。

725
00:48:22,320 --> 00:48:30,260
They can get the feedback from the ta in mind that you need to participate
你需要参与并牢记TA的反馈意见。

726
00:48:30,270 --> 00:48:32,020
during design reviews.
在设计审查期间。

727
00:48:32,600 --> 00:48:34,750
A part of your grade is based on that.
你的成绩的一部分是基于这个的。

728
00:48:35,750 --> 00:48:37,070
And other than that,
除此之外，

729
00:48:37,720 --> 00:48:40,390
I know that there are now many deadlines.
我知道现在有很多截止日期。

730
00:48:40,660 --> 00:48:42,710
There are no deadlines for the next 2 weeks,
接下来的两周内没有任何截止日期。

731
00:48:43,090 --> 00:48:46,810
but the next following weeks of november 1st will be pretty brutal.
但是11月1日之后的接下来几周将会非常艰难。

732
00:48:47,450 --> 00:48:48,780
So as such,
因此，

733
00:48:49,160 --> 00:48:56,470
please make progress on homework for a project to and start studying
请在项目的作业上取得进展并开始学习。

734
00:48:56,480 --> 00:48:57,430
about meter to,
关于"meter to"的问题，可以理解为将单位从米转换为其他单位的问题。

735
00:48:58,040 --> 00:49:01,320
which is mostly the materials we are learning.
我们主要学习的材料是什么？

736
00:49:03,470 --> 00:49:06,310
We have been learned since the first meter.
我们从第一米开始学习。

737
00:49:06,810 --> 00:49:10,190
So meter two will still have some of,
所以仪表二仍然会有一些

738
00:49:10,960 --> 00:49:12,090
like, maybe 10,
大概10个左右

739
00:49:12,100 --> 00:49:15,080
20% from the materials of mid term one.
期中考试一的材料占总分的20%。

740
00:49:15,850 --> 00:49:22,800
But this means that 1890% of the materials will be from the lectures
但这意味着有1890%的材料将来自讲座内容。

741
00:49:23,070 --> 00:49:25,210
since midterm one.
自期中考以来。

742
00:49:36,450 --> 00:49:44,670
Now let's switch the gears and answer the following key question.
现在让我们转换一下思路，回答以下关键问题。

743
00:49:46,240 --> 00:49:47,560
During a page fault,
在页面错误期间，

744
00:49:49,440 --> 00:49:54,200
you need to bring a page from the disk to the memory.
你需要将磁盘上的一个页面调入内存。

745
00:49:57,260 --> 00:50:01,580
How do you find room for that page?
你如何找到那个页面的空间？

746
00:50:08,940 --> 00:50:11,130
If there is no room like we discussed,
如果没有像我们讨论过的那样的空间，

747
00:50:11,530 --> 00:50:14,960
we are going to find a page before it's dirty,
我们要在页面变脏之前找到它。

748
00:50:14,970 --> 00:50:17,520
save it on the disk and replace it with a new page.
将其保存在磁盘上，并用新页面替换它。

749
00:50:18,960 --> 00:50:20,780
But typically this is quite expensive.
但通常来说这是相当昂贵的。

750
00:50:22,300 --> 00:50:25,450
Writing page bring up beijing is very expensive.
写作页面提到北京非常昂贵。

751
00:50:26,270 --> 00:50:29,790
What many operating systems do in the background?
操作系统在后台做了很多工作。

752
00:50:30,560 --> 00:50:34,780
They kick off some of the right back,
他们将一些右后卫踢出场

753
00:50:35,560 --> 00:50:39,130
some of the dirty pages to the disk.
将一些脏页写回磁盘。

754
00:50:39,950 --> 00:50:41,920
If you need to replace one,
如果你需要更换一个，

755
00:50:42,130 --> 00:50:44,150
then you don't need to write it back.
那么你不需要回复了。

756
00:50:45,500 --> 00:50:47,190
This is kind of periodically,
这是一种周期性的行为。

757
00:50:47,200 --> 00:50:55,040
it's a cleaning process to reduce the overhead of the demand paging.
这是一种清理过程，旨在减少需求分页的开销。

758
00:50:57,240 --> 00:51:06,180
Now, but even if you have this background mechanism,
现在，即使你有这个背景机制，

759
00:51:06,550 --> 00:51:09,140
you still need to answer the following question,
你仍然需要回答以下问题：

760
00:51:09,150 --> 00:51:12,380
which pages are you going to write to the disk?
你打算将哪些页面写入磁盘？

761
00:51:12,720 --> 00:51:13,290
For each pages?
每个页面？

762
00:51:13,300 --> 00:51:16,090
You are going to evict to bring a new beijing.
你将要驱逐以引进一个新的北京。

763
00:51:20,980 --> 00:51:27,430
And the way we you think about that by now,
到目前为止，我们对此的看法是这样的，

764
00:51:27,440 --> 00:51:29,510
when you talk about scheduling and so forth,
当谈到调度等问题时，

765
00:51:29,520 --> 00:51:31,310
you need to come up with a policy.
你需要制定一项政策。

766
00:51:31,930 --> 00:51:37,450
When you come up with a policy to dictate which guides which pages
当你制定一项政策来决定哪个指导哪个页面时

767
00:51:37,460 --> 00:51:41,470
are written back or are evicted from the main moment memory.
被写回或从主内存中驱逐。

768
00:51:43,150 --> 00:51:48,430
There are certain properties you need you think about about utilization.
在考虑利用率时，有一些特定的属性需要您思考。

769
00:51:48,440 --> 00:51:52,130
You want to have high utilization of the memory.
你希望内存的利用率高。

770
00:51:52,330 --> 00:51:54,380
That's because it's a scarce resource.
这是因为它是一种稀缺资源。

771
00:51:54,730 --> 00:52:02,380
You may want fairness between different processes or immune to enforce priority.
您可能希望在不同进程之间实现公平性或强制优先级。

772
00:52:06,850 --> 00:52:11,360
So that's kind of you keep in mind that we are not going to implement
非常感谢您的关注，请记住我们不打算实现这个功能。

773
00:52:11,370 --> 00:52:13,500
different policies here.
这里有不同的政策。

774
00:52:13,510 --> 00:52:18,240
But this is for you to keep in mind that is a typical questions you
但是请你记住，这是一个典型的问题。

775
00:52:18,250 --> 00:52:23,040
are going to be faced with when you are going to design a base replacement
当你设计一个基础替换时，你将面临以下问题：

776
00:52:23,050 --> 00:52:23,440
policy.
政策。

777
00:52:29,820 --> 00:52:32,420
So is a key model.
所以是一个关键模型。

778
00:52:32,430 --> 00:52:36,820
You have in mind when you run a program,
当你运行一个程序时，你会有什么想法。

779
00:52:36,830 --> 00:52:38,340
11of these models,
其中的11个模型，

780
00:52:38,350 --> 00:52:40,520
it's about the working set.
这是关于工作集的内容。

781
00:52:41,720 --> 00:52:47,450
So that what is a a working set, roughly speaking,
工作集（Working Set）大致来说是指在一段时间内，进程或程序所使用的内存页面的集合。

782
00:52:47,900 --> 00:52:55,670
is the set of addresses whose content,
是指内容的地址集合，

783
00:52:56,030 --> 00:52:58,070
if you have in the physical memory,
如果你在物理内存中有的话，

784
00:52:58,410 --> 00:53:00,580
then the programs works well.
那么程序运行正常。

785
00:53:01,200 --> 00:53:03,270
There are very few baseballs.
棒球很少。

786
00:53:04,650 --> 00:53:05,090
If any,
如果有的话，

787
00:53:05,810 --> 00:53:06,100
right?
是的，没错。

788
00:53:06,980 --> 00:53:14,160
And this tried to show a depiction of a this is for a program.
这是一个试图展示一个程序的描述。

789
00:53:14,690 --> 00:53:16,310
On the x axis, you have the time.
在x轴上，你有时间。

790
00:53:17,220 --> 00:53:19,050
And on the y axis, you have the address.
在y轴上，你有地址。

791
00:53:19,640 --> 00:53:23,810
And each rectangle is the height of the rectangle represent.
每个矩形的高度表示该矩形的高度。

792
00:53:24,010 --> 00:53:29,550
What addresses are accessed at a given time by the program.
程序在给定时间访问了哪些地址。

793
00:53:29,970 --> 00:53:36,220
And the length represent for how long you access content from these addresses.
长度表示您从这些地址访问内容的持续时间。

794
00:53:37,400 --> 00:53:37,660
Right?
对吗？

795
00:53:38,440 --> 00:53:40,000
So this is,
所以这是，

796
00:53:40,010 --> 00:53:41,920
and as you can see here,
正如你在这里所看到的，

797
00:53:41,930 --> 00:53:43,520
this is execution.
这是执行。

798
00:53:43,530 --> 00:53:44,240
The thread.
线程。

799
00:53:44,580 --> 00:53:46,680
Stuff is execution of the program.
"Stuff" 是程序的执行。

800
00:53:47,070 --> 00:53:48,730
And at different times,
而在不同的时间，

801
00:53:49,100 --> 00:53:50,720
you have different working sets.
你们有不同的工作集。

802
00:53:50,730 --> 00:53:54,160
So working set here is that if you,
所以这里的工作集是指如果你，

803
00:53:55,060 --> 00:53:59,900
if you draw a vertical line at a given time,
如果你在给定的时间画一条垂直线，

804
00:53:59,910 --> 00:54:01,750
then everything,
那么一切，

805
00:54:03,200 --> 00:54:06,950
all the blue rectangle it enters this line,
所有蓝色矩形都进入这条线。

806
00:54:08,190 --> 00:54:09,830
intersects represent the working set,
交集表示工作集合。

807
00:54:10,460 --> 00:54:16,320
represent the addresses whose content should be in the physical memory,
表示应该在物理内存中存储内容的地址

808
00:54:16,650 --> 00:54:20,620
so that we do not have page faults.
这样我们就不会发生页面错误。

809
00:54:22,710 --> 00:54:23,830
And the working set.
工作集。

810
00:54:24,280 --> 00:54:25,910
One property, in general,
一般来说，有一个属性，

811
00:54:25,920 --> 00:54:31,890
is that is much smaller than the entire address space of the program,
这比程序的整个地址空间要小得多。

812
00:54:32,280 --> 00:54:34,040
and also is changing over time.
而且它也在随着时间的推移而改变。

813
00:54:37,290 --> 00:54:41,520
Obviously, if you can keep all the working set in memory or in the cache,
显然，如果你能将所有的工作集保留在内存或缓存中，

814
00:54:42,570 --> 00:54:44,120
then is great.
那太好了。

815
00:54:44,130 --> 00:54:45,400
The heat rate will be one.
热速率将为1。

816
00:54:47,470 --> 00:54:49,720
If you cannot, then the hit rate will not be on.
如果你不能做到，那么命中率就无法实现。

817
00:54:49,730 --> 00:54:51,790
And you are going to have also some mistake.
而且你也会犯一些错误。

818
00:54:54,240 --> 00:54:58,800
This also shows the cache size,
这也显示了缓存的大小，

819
00:54:58,810 --> 00:55:05,430
how much of the program is stored in the cash for this previous example.
在这个先前的例子中，程序的多少存储在缓存中？

820
00:55:05,980 --> 00:55:07,980
And you start with very little,
而你从一无所有开始，

821
00:55:08,360 --> 00:55:10,640
and you have here a lot of come,
而且你在这里有很多选择。

822
00:55:10,810 --> 00:55:12,880
and the hit rate is also very low.
而且命中率也非常低。

823
00:55:15,730 --> 00:55:16,090
Sorry,
抱歉，

824
00:55:16,780 --> 00:55:17,890
let me back that here.
让我在这里备份一下。

825
00:55:18,620 --> 00:55:21,490
When the x axis here is a cache size,
这里的x轴表示缓存大小，

826
00:55:22,340 --> 00:55:25,230
you are looking here at caches of different sites.
你正在查看不同网站的缓存。

827
00:55:25,880 --> 00:55:26,880
On the y axis,
在y轴上，

828
00:55:26,890 --> 00:55:28,480
you have the hit rate.
你有命中率。

829
00:55:29,160 --> 00:55:32,030
If the cache says is infinite,
如果缓存大小为无限大，

830
00:55:32,380 --> 00:55:34,110
the heat rate will be one.
热速率将为1。

831
00:55:34,120 --> 00:55:35,760
So when the cast size,
当角色的规模增加时，

832
00:55:36,050 --> 00:55:37,300
or in other words,
换句话说，

833
00:55:37,820 --> 00:55:42,050
on the cast size is larger than the working set,
当缓存大小大于工作集时，

834
00:55:42,540 --> 00:55:44,570
what is the working set is in the cash?
在计算机缓存中，工作集是指当前正在被活跃使用的数据和指令的集合。它代表了程序在特定时间段内访问的内存块。工作集通常是根据最近使用的原则来确定，即最近被访问的数据和指令很可能在不久的将来再次被访问。通过将工作集保留在缓存中，可以提高程序的性能，减少对主存的访问次数。

835
00:55:44,830 --> 00:55:45,910
Then the hit ladies.
然后是击中女士们。

836
00:55:46,900 --> 00:55:49,490
And then, as if the cast,
然后，仿佛是演员一样，

837
00:55:49,500 --> 00:55:51,130
I say it's very small,
我觉得它很小。

838
00:55:51,520 --> 00:55:53,880
then the heat rate will be very little,
那么热量传递速率将非常小。

839
00:55:54,130 --> 00:56:00,370
because probably all the working set will be doesn't fit in the cash.
因为很可能整个工作集都无法放入缓存中。

840
00:56:00,940 --> 00:56:01,220
Right?
对吗？

841
00:56:01,470 --> 00:56:03,600
Any fetch of an instruction,
任何指令的取指操作，

842
00:56:03,610 --> 00:56:07,220
every access of the data will result on.
每次对数据的访问都会产生结果。

843
00:56:09,360 --> 00:56:12,490
It is going to result in a miss.
这将导致未命中。

844
00:56:12,990 --> 00:56:13,340
Right?
对吗？

845
00:56:22,840 --> 00:56:24,110
Any questions here?
有什么问题吗？

846
00:56:38,130 --> 00:56:44,230
So if the cash it's a shared between different processes,
那么如果现金是在不同进程之间共享的，

847
00:56:44,570 --> 00:56:46,350
like, is a second level cash,
就像是一个二级缓存，

848
00:56:47,730 --> 00:56:52,150
then you need to feed multiple working set in the same cache.
那么你需要在同一个缓存中存储多个工作集。

849
00:56:53,330 --> 00:56:55,520
And actually, this figure shows,
实际上，这个图表展示了，

850
00:56:55,800 --> 00:56:58,520
when you have multiple working sets in the same cache,
当在同一个缓存中有多个工作集时，

851
00:56:58,530 --> 00:57:02,380
each of these inflection points is when a new working set is
每个拐点都代表一个新的工作集。

852
00:57:02,390 --> 00:57:03,460
fitting in the cache,
适应缓存

853
00:57:08,430 --> 00:57:11,860
obviously are going to have a very similar behavior for demand painting.
显然，对于需求绘制，它们的行为将非常相似。

854
00:57:11,870 --> 00:57:13,620
Again, demand painting is as cash.
再次强调，需求画作是现金。

855
00:57:18,540 --> 00:57:21,030
Now, when we are talking about the working set,
现在，当我们谈论工作集时，

856
00:57:21,040 --> 00:57:23,270
we have this kind of nice model, like I mentioned,
我们有这种很好的模型，就像我之前提到的那样。

857
00:57:23,280 --> 00:57:27,550
that actually the program is spending most of the time or all the time,
实际上，该程序大部分或全部时间都在运行。

858
00:57:28,050 --> 00:57:31,640
a in a relatively small region of the other space.
在另一个空间的相对较小区域中的a。

859
00:57:32,170 --> 00:57:35,010
And this makes the cash very effective.
这使得现金非常有效。

860
00:57:36,380 --> 00:57:42,920
However, there are other models for locality like ziff and distribution.
然而，还有其他关于局部性的模型，例如ziff和分布模型。

861
00:57:45,190 --> 00:57:46,350
In this case,
在这种情况下，

862
00:57:48,060 --> 00:57:50,790
you do have this is, for instance,
你确实有这个，例如，

863
00:57:50,800 --> 00:57:53,230
on this figure, what you see.
在这个图上，你看到了什么。

864
00:57:53,640 --> 00:57:54,670
Here it's a rank.
这是一个排名。

865
00:57:54,920 --> 00:57:56,430
This represent, say,
这表示，比如说，

866
00:57:56,440 --> 00:57:58,310
think about each of this is a page.
将每个页面都视为一个单独的页面。

867
00:57:59,890 --> 00:58:03,440
There are pages are ranking the decreasing order of their popularity
有页面按照它们的受欢迎程度降序排名。

868
00:58:03,450 --> 00:58:06,270
about how often they are accessed.
关于它们被访问的频率。

869
00:58:06,920 --> 00:58:09,880
The popularity of access is on the y axis.
访问的流行度在y轴上。

870
00:58:11,200 --> 00:58:16,440
They say that the first page is accessed20% of the time.
据说第一页被访问的频率为20%。

871
00:58:16,970 --> 00:58:18,880
You access a memory,
你访问了一个内存。

872
00:58:18,890 --> 00:58:20,080
access the first page.
访问第一页。

873
00:58:21,870 --> 00:58:22,790
This is what it says.
这是它的内容。

874
00:58:23,780 --> 00:58:24,060
Right?
对吗？

875
00:58:25,600 --> 00:58:25,840
Now,
现在，

876
00:58:25,850 --> 00:58:29,200
the problem with this distribution and this popularity is shown
这种分发和流行度的问题被展示出来了。

877
00:58:31,960 --> 00:58:32,750
by the blue line.
沿着蓝线走。

878
00:58:33,470 --> 00:58:36,710
The problem with this one is that with this distribution is
这个问题在于这个分布是这样的

879
00:58:36,720 --> 00:58:38,310
a very challenging distribution,
一个非常具有挑战性的分布。

880
00:58:38,840 --> 00:58:42,080
is that it also has a long tail,
它也有一条长尾巴。

881
00:58:44,190 --> 00:58:44,960
mostly axis.
主要是轴。

882
00:58:44,970 --> 00:58:48,040
Most of the axis are on a very few pages.
大多数轴都在很少的页面上。

883
00:58:48,740 --> 00:58:58,650
But there is some a lot a huge amount of pages are accessed infrequent.
但是有一些页面很少被访问。

884
00:59:04,160 --> 00:59:05,930
And this creates problems,
这会引发问题，

885
00:59:05,940 --> 00:59:08,820
because no matter,
因为无论如何，

886
00:59:09,350 --> 00:59:10,880
even if you have a big cash,
即使你有很多现金，

887
00:59:11,790 --> 00:59:15,770
we are still going to have misses because of these very rare items.
由于这些非常罕见的物品，我们仍然会出现遗漏情况。

888
00:59:18,380 --> 00:59:22,290
But what this shows you is that even if you have a small cash,
但这表明即使你只有一点点现金，

889
00:59:22,620 --> 00:59:27,090
you get quite a bit of value because a few pages are responsible for most taxes.
你可以获得相当大的价值，因为只有少数几页负责大部分税收。

890
00:59:29,180 --> 00:59:33,260
The second thing is that if you have a very large cash,
第二件事是，如果你有很多现金，

891
00:59:35,640 --> 00:59:36,870
it's a diminishing return.
这是递减收益。

892
00:59:36,880 --> 00:59:38,390
It may not benefit a lot.
可能没有太多好处。

893
00:59:38,400 --> 00:59:40,310
You still have substantial misses.
你仍然有很多错误。

894
00:59:41,770 --> 00:59:42,720
Questions?
有问题吗？

895
00:59:50,780 --> 00:59:51,770
I don't know that video,
我不知道那个视频。

896
00:59:51,780 --> 00:59:56,450
but there are many situations in which you are going.
但是有很多情况下你会去。

897
00:59:56,460 --> 00:59:58,290
This distribution is very common.
这个分布非常常见。

898
00:59:58,770 --> 01:00:00,340
One, it's our web pages.
一、这是我们的网页。

899
01:00:01,230 --> 01:00:02,750
I'm talking about web pages, right?
我在谈论网页，对吗？

900
01:00:02,760 --> 01:00:03,950
When you access the web pages,
当你访问网页时，

901
01:00:03,960 --> 01:00:05,430
they have as if we are distribution.
他们好像把我们当作分发机构。

902
01:00:07,280 --> 01:00:10,710
And is very common,
这是非常常见的，

903
01:00:11,330 --> 01:00:13,620
is a population of cities.
是一个城市的人口。

904
01:00:14,140 --> 01:00:17,500
There are a few cities with very large population and a few of them.
有几个人口非常庞大的城市，其中有一些。

905
01:00:17,770 --> 01:00:21,910
But there are many of them with a smaller population.
但是有许多国家的人口较少。

906
01:00:24,430 --> 01:00:31,010
It's a very common distribution model.
这是一个非常常见的分发模型。

907
01:00:31,800 --> 01:00:36,440
Again, what we care about is estimated access time.
我们关心的是估计的访问时间。

908
01:00:37,110 --> 01:00:41,390
And the estimated access time is a hit rate times hit time.
估计的访问时间是命中率乘以命中时间。

909
01:00:41,560 --> 01:00:44,030
It's a latency to access the data in memory,
访问内存中的数据会产生延迟。

910
01:00:45,370 --> 01:00:47,540
plus miss rate plus the miss time.
加上缺失率再加上缺失时间。

911
01:00:47,550 --> 01:00:52,110
And the miss time is the time it takes to bring the data in memory
而"miss time"是将数据加载到内存中所需的时间。

912
01:00:52,120 --> 01:00:54,070
from the disk if it's not there.
如果磁盘上没有找到，就从磁盘中获取。

913
01:00:55,870 --> 01:01:01,200
And it's not there, because they missed the heat rate plaza,
这是因为他们错过了热量率广场，所以它不在那里。

914
01:01:01,210 --> 01:01:03,240
miss rate is one.
缺失率为1。

915
01:01:04,260 --> 01:01:07,610
You can also rewrite the equation by having this penalty,
你也可以通过引入这个惩罚项来重新改写方程。

916
01:01:08,350 --> 01:01:09,950
by denoting, miss time,
通过表示，错过时间

917
01:01:09,960 --> 01:01:11,910
my minus hit time.
我的减法击中时间。

918
01:01:12,280 --> 01:01:14,980
This is the overhead where to miss.
这是错过的开销。

919
01:01:15,580 --> 01:01:16,940
This is miss penalty.
这是缺失惩罚。

920
01:01:17,600 --> 01:01:22,310
You can realize the equation at hit time plus miss rate times miss penalty.
你可以通过命中时间加上失误率乘以失误惩罚来实现这个方程。

921
01:01:24,360 --> 01:01:26,210
Here is a very simple example.
这是一个非常简单的例子。

922
01:01:26,220 --> 01:01:32,460
Memory access time is 200 nanoseconds average page for service time.
内存访问时间为平均200纳秒每页的服务时间。

923
01:01:32,470 --> 01:01:36,720
So bringing the page from the disk into memory.
将页面从磁盘加载到内存中。

924
01:01:37,170 --> 01:01:38,400
It's 8 million seconds.
这是800万秒。

925
01:01:40,710 --> 01:01:44,430
Let's say p is the probability of miss one minus ps and the probability of hit.
假设 p 是未命中的概率，即 1 减去 p_s 和命中的概率。

926
01:01:45,890 --> 01:01:53,080
This means that we are using the same the second equation.
这意味着我们正在使用相同的第二个方程。

927
01:01:53,500 --> 01:01:57,270
The access time is made like this time is 200 and seconds
访问时间是以此方式表示的，时间为200秒。

928
01:01:57,280 --> 01:02:01,190
plus p times 8 million nanoseconds.
加上 p 乘以 800 万纳秒。

929
01:02:04,170 --> 01:02:09,090
If just one out of 1,000 pages,
如果只有1,000页中的一张，

930
01:02:09,100 --> 01:02:10,810
page axis is a fault,
页轴错误。

931
01:02:11,990 --> 01:02:13,510
this is 0.1%.
这是0.1%。

932
01:02:14,560 --> 01:02:19,020
The access time is of over eight micro seconds or 40 times
访问时间超过八微秒，或者是40倍的时间。

933
01:02:19,030 --> 01:02:21,120
more than just accessing the memory.
不仅仅是访问内存。

934
01:02:22,370 --> 01:02:23,830
So the slowdown is huge.
所以这个减速非常严重。

935
01:02:24,520 --> 01:02:29,420
If you want to slow to have a slowdown only by ten per or to 10% slow down,
如果你想要减速只有百分之十或者减速百分之十

936
01:02:30,090 --> 01:02:33,530
then you can physics in the equation.
然后你可以在方程中加入物理学。

937
01:02:34,680 --> 01:02:41,890
And the p is a probability of miss should be lower
而且p是错过的概率应该更低。

938
01:02:42,380 --> 01:02:47,180
than 1 page in 400,000 axis.
超过400,000个轴的一页以上。

939
01:02:50,020 --> 01:02:53,750
That gives you a sense about how important is
这让你对重要性有了一定的了解

940
01:02:53,760 --> 01:02:58,920
a patient replacement policies in minimizing the miss,
最小化错过的病人替换策略

941
01:02:58,930 --> 01:02:59,360
right?
对的？

942
01:02:59,960 --> 01:03:01,090
And that's how you use.
这就是你如何使用的方法。

943
01:03:01,630 --> 01:03:03,280
This is right here.
就在这里。

944
01:03:03,290 --> 01:03:09,030
It's an example of why here was a demand.
这是一个说明为什么存在需求的例子。

945
01:03:09,040 --> 01:03:11,430
Beijing is fully associative,
北京是完全关联的。

946
01:03:12,120 --> 01:03:12,550
right?
对的？

947
01:03:12,830 --> 01:03:17,530
Because you just want to avoid any misses are at any cost.
因为你只想以任何代价避免任何错误。

948
01:03:27,480 --> 01:03:29,700
Or it's a question here.
或者这里是一个问题。

949
01:03:29,710 --> 01:03:34,870
What is the intuition behind why the hit rate is higher for the lower ranks?
为什么较低级别的命中率较高的直观理解是什么？

950
01:03:40,300 --> 01:03:41,370
It's all here, right?
都在这里了，对吗？

951
01:03:41,660 --> 01:03:42,390
Let me see.
让我看看。

952
01:03:44,640 --> 01:03:49,480
Actually, a it's a rank of popularity.
实际上，这是一个受欢迎程度的排名。

953
01:03:50,790 --> 01:03:51,150
Right?
对吗？

954
01:03:51,160 --> 01:03:51,870
So actually,
实际上，

955
01:03:51,880 --> 01:03:58,730
these pages are ordered in the decreasing order of their popularity.
这些页面按照受欢迎程度递减的顺序排列。

956
01:03:59,760 --> 01:04:01,440
So that I get to go is a popularity.
所以我能去是一种受欢迎的事情。

957
01:04:01,450 --> 01:04:03,660
So there is nothing subtle here.
这里没有什么微妙的地方。

958
01:04:05,120 --> 01:04:05,580
Okay?
好的？

959
01:04:06,590 --> 01:04:11,220
That doesn't mean anything else and being pop a major of popularity.
这并不意味着其他任何事情，也不代表流行度的主要因素。

960
01:04:15,730 --> 01:04:16,850
Okay, again,
好的，再来一次，

961
01:04:16,860 --> 01:04:18,610
see you remember about catching,
记得关于捕获的事情。

962
01:04:19,600 --> 01:04:21,350
what are the type of misses,
缺失的类型有哪些？

963
01:04:21,750 --> 01:04:23,150
compulsory misses,
强制性缺失

964
01:04:23,580 --> 01:04:25,890
pages that have never been paid into memory?
从未被加载到内存中的页面

965
01:04:25,900 --> 01:04:27,650
This is when you start a program,
这是当你启动一个程序时，

966
01:04:27,930 --> 01:04:31,080
you need to read the code, right?
你需要阅读代码，对吗？

967
01:04:31,090 --> 01:04:31,920
For instance,
例如，

968
01:04:34,490 --> 01:04:35,660
capacity misses.
容量不足。

969
01:04:35,940 --> 01:04:37,450
You don't have enough memory.
你的内存不足。

970
01:04:37,460 --> 01:04:38,690
What do you doing this?
你在做什么？

971
01:04:38,700 --> 01:04:39,770
In this case?
在这种情况下？

972
01:04:40,860 --> 01:04:42,830
Obviously, you can increase a number,
显然，你可以增加一个数字。

973
01:04:42,840 --> 01:04:44,150
increase the memory size.
增加内存大小。

974
01:04:45,940 --> 01:04:53,760
Or if you can share the memory between processes and
或者如果你可以在进程之间共享内存，那么

975
01:04:53,770 --> 01:04:58,920
give each process certain amount of memory.
为每个进程分配一定量的内存。

976
01:04:59,530 --> 01:05:00,690
Or in some cases,
在某些情况下，

977
01:05:00,700 --> 01:05:01,770
as you'll see,
正如你所看到的，

978
01:05:02,380 --> 01:05:05,690
one solution is to kill one of the processes.
一个解决方案是终止其中一个进程。

979
01:05:06,180 --> 01:05:07,340
The remaining processes,
剩下的进程，

980
01:05:08,030 --> 01:05:13,440
they have enough physical memory conflict misses.
他们有足够的物理内存冲突缺失。

981
01:05:14,010 --> 01:05:15,730
You don't have those slides, technically,
从技术上讲，你没有那些幻灯片。

982
01:05:15,740 --> 01:05:18,410
because a it's a fully associative cash,
因为它是一个完全关联的高速缓存。

983
01:05:19,020 --> 01:05:19,410
right?
对的？

984
01:05:19,920 --> 01:05:21,110
And policy misses,
以及政策失误，

985
01:05:21,120 --> 01:05:24,630
it's about depends on the replacement policy we are going to use.
这取决于我们将要使用的替换策略。

986
01:05:27,190 --> 01:05:31,870
Here we just want a better replacement policy to minimize the misses.
在这里，我们只是希望有一个更好的替换策略来最小化缺失。

987
01:05:34,580 --> 01:05:35,180
Okay?
好的？

988
01:05:36,310 --> 01:05:37,950
So pay deployment policies.
支付部署政策。

989
01:05:40,410 --> 01:05:41,200
It's again,
又是这样，

990
01:05:42,120 --> 01:05:45,790
those you learn a few of them last time.
上次你学了其中的一些知识。

991
01:05:47,120 --> 01:05:48,950
The same similar are here,
这里有相同的相似之处。

992
01:05:53,490 --> 01:05:54,060
54.
54.

993
01:05:56,360 --> 01:05:57,430
First in, first out,
先进先出 (FIFO)

994
01:05:58,060 --> 01:06:04,910
you throw out the oldest page or a big the oldest page is some degree
你可以选择丢弃最旧的页面，或者丢弃一个较大的最旧页面。

995
01:06:04,920 --> 01:06:07,870
of fairness in terms of the access.
公平性在访问方面的意义。

996
01:06:10,210 --> 01:06:12,550
But it can be also bad.
但它也可能是坏的。

997
01:06:13,240 --> 01:06:17,440
Why when it's five or bad is when you have a very popular page which is
为什么当你的页面非常受欢迎时，它会变得糟糕或不可用？

998
01:06:17,450 --> 01:06:18,560
access over and over.
反复访问

999
01:06:19,840 --> 01:06:20,190
Right?
对吗？

1000
01:06:21,880 --> 01:06:27,140
This is also one of the pages which are going to be the oldest in the
这也是将成为最古老的页面之一之一

1001
01:06:28,210 --> 01:06:30,880
could be the oldest on the program started.
可能是该项目中最古老的开始。

1002
01:06:31,860 --> 01:06:33,370
It loaded this page,
它加载了这个页面。

1003
01:06:33,690 --> 01:06:35,060
like, for instance,
例如，比如说，

1004
01:06:35,590 --> 01:06:38,110
the code like for these powerpoint slides,
这些幻灯片上的代码类似于以下内容：

1005
01:06:38,930 --> 01:06:47,000
the code which go is responsible for going from one slide and displaying
go函数的作用是从一个幻灯片跳转到另一个幻灯片并显示。

1006
01:06:47,010 --> 01:06:47,680
the next slide.
下一张幻灯片。

1007
01:06:48,310 --> 01:06:49,030
This is,
这是，

1008
01:06:50,470 --> 01:06:55,410
I am a using that code from the beginning of the lecture.
我从讲座开始就在使用那段代码。

1009
01:06:55,820 --> 01:07:00,090
That was one of the first pieces of code which was loaded in memory.
这是最早加载到内存中的代码之一。

1010
01:07:00,790 --> 01:07:02,120
But if I use 54,
但是如果我使用54，

1011
01:07:02,390 --> 01:07:05,410
that will be also a piece of code should be evicted.
这也是应该被删除的一段代码。

1012
01:07:06,420 --> 01:07:07,620
And if you evicted,
如果你被驱逐了，

1013
01:07:08,070 --> 01:07:11,430
it just to be loaded again next time, I went on,
下次只需重新加载，我继续进行。

1014
01:07:11,440 --> 01:07:16,110
i'm turning to the next slide at random is very simple.
随机跳转到下一张幻灯片非常简单。

1015
01:07:18,820 --> 01:07:23,460
So they are very fast to implement also in hardware.
因此，它们在硬件上实现起来非常快速。

1016
01:07:23,900 --> 01:07:28,020
Typically, you have this is still be when you need to be super fast.
通常情况下，当你需要非常快速时，你会这样做。

1017
01:07:29,970 --> 01:07:31,540
Or the downside is random,
或者说缺点是随机的，

1018
01:07:31,550 --> 01:07:32,650
it's not predictable.
它是不可预测的。

1019
01:07:35,290 --> 01:07:36,120
It's minimum.
这是最小的。

1020
01:07:36,130 --> 01:07:37,380
And the minimum.
最小值。

1021
01:07:40,560 --> 01:07:43,490
It's the optimal one.
这是最优的选择。

1022
01:07:43,840 --> 01:07:44,260
Right?
对吗？

1023
01:07:44,510 --> 01:07:46,300
What is the optimal replacement policy?
什么是最优的替换策略？

1024
01:07:47,230 --> 01:07:47,390
Right?
对吗？

1025
01:07:47,400 --> 01:07:48,670
You should know that from cash,
你应该知道，从现金支付，

1026
01:07:49,370 --> 01:07:50,990
what is the optimal replacement policy?
什么是最优的替换策略？

1027
01:07:52,490 --> 01:07:55,750
You want to replace the page,
你想要替换页面。

1028
01:07:56,330 --> 01:07:59,150
which won't be used for the longest time.
哪个将不会被使用最长时间。

1029
01:08:00,320 --> 01:08:01,290
It's as simple as that.
就是这么简单。

1030
01:08:01,670 --> 01:08:05,080
The problem with this is that you need to predict the future and you don't know.
这个问题在于你需要预测未来，而你并不知道未来会发生什么。

1031
01:08:06,010 --> 01:08:12,130
And the way around it is to use the past as a good predictor of the future.
解决这个问题的方法是利用过去作为预测未来的良好指标。

1032
01:08:12,850 --> 01:08:17,330
That is, if a page has not been used for a while,
也就是说，如果一个页面在一段时间内没有被使用，

1033
01:08:17,810 --> 01:08:22,010
then the page will not assume that the page will not be, again,
那么页面将不会假设页面不会再次出现。

1034
01:08:22,020 --> 01:08:23,050
access for a while.
暂时访问权限。

1035
01:08:24,580 --> 01:08:27,690
If the page was just used before recently,
如果页面最近刚被使用过，

1036
01:08:28,370 --> 01:08:30,850
it's going to be likely used again in the future.
它很可能在将来再次被使用。

1037
01:08:33,410 --> 01:08:34,410
Any questions here?
这里有什么问题吗？

1038
01:08:42,590 --> 01:08:47,750
This is approximation is the least recently used.
这个近似值是最近最少使用的。

1039
01:08:48,690 --> 01:08:48,890
Right?
对吗？

1040
01:08:48,900 --> 01:08:51,410
Just replays a page that hasn't been used for the longest time.
只需重新加载最长时间未使用的页面即可。

1041
01:08:54,570 --> 01:08:56,440
If the programs have every locality,
如果程序具有良好的局部性，

1042
01:08:56,450 --> 01:08:59,460
this is a pretty good policy.
这是一个非常好的政策。

1043
01:09:01,670 --> 01:09:02,620
How we implement it.
我们如何实现它。

1044
01:09:03,230 --> 01:09:03,900
One,
一,

1045
01:09:05,240 --> 01:09:06,730
you can simply implement it.
你可以简单地实现它。

1046
01:09:07,340 --> 01:09:09,430
You can keep a list of pages.
你可以维护一个页面列表。

1047
01:09:10,100 --> 01:09:19,150
And you a when you access a page,
当你访问一个页面时，

1048
01:09:19,720 --> 01:09:24,070
you put it as a head of you move it to the head of the queue.
你将它放在队列头部，然后将其移动到队列的头部。

1049
01:09:25,020 --> 01:09:27,430
And the pages as the last in this,
并且将这些页面放在最后。

1050
01:09:28,100 --> 01:09:34,030
least, is a page which hasn't been accessed for the longest time.
最少访问的页面是指最长时间没有被访问的页面。

1051
01:09:38,080 --> 01:09:38,640
Okay.
好的。

1052
01:09:45,180 --> 01:09:46,260
It's a great question.
这是一个很好的问题。

1053
01:09:46,270 --> 01:09:52,380
Is there anything you can do when you are writing code to help decrease
在编写代码时，有什么方法可以帮助减少？

1054
01:09:52,390 --> 01:09:53,180
page misses?
页面缺失？

1055
01:09:53,190 --> 01:09:55,820
This is a great question.
这是一个很好的问题。

1056
01:09:56,260 --> 01:09:57,850
Yes, you can do it.
是的，你可以做到。

1057
01:09:57,860 --> 01:09:59,530
I'll give you one example,
我给你举一个例子，

1058
01:10:01,980 --> 01:10:03,050
like, for instance,
例如，比如说，

1059
01:10:03,060 --> 01:10:07,810
and this is used and known by people do high performance computing.
这被人们用于高性能计算，并且被广泛认知。

1060
01:10:09,360 --> 01:10:14,060
Say, you have a matrix and say,
假设你有一个矩阵，假设

1061
01:10:14,070 --> 01:10:17,420
you want to multiply the matrix or do some operation on the matrix.
你想要对矩阵进行乘法运算或者进行一些矩阵操作。

1062
01:10:18,300 --> 01:10:20,320
You can iterate on browse,
你可以在浏览器上进行迭代。

1063
01:10:20,620 --> 01:10:22,270
or you to iterate on columns.
让你迭代列。

1064
01:10:24,280 --> 01:10:31,380
Now is very important about how this matrix is stored in memory.
现在非常重要的是如何将这个矩阵存储在内存中。

1065
01:10:31,990 --> 01:10:33,430
Typically start row by row.
通常按行开始。

1066
01:10:33,440 --> 01:10:35,150
You start first row,
你从第一行开始。

1067
01:10:35,160 --> 01:10:36,910
then the next row and the next row.
然后是下一行和下一行。

1068
01:10:39,900 --> 01:10:42,090
If the matrix is large,
如果矩阵很大，

1069
01:10:42,930 --> 01:10:43,250
right?
对的？

1070
01:10:43,610 --> 01:10:44,820
If I want to greet, say,
如果我想打招呼，比如说，

1071
01:10:44,830 --> 01:10:46,660
to all the elements of the matrix,
对于矩阵的所有元素，

1072
01:10:47,410 --> 01:10:52,060
if I can, i'm going to italy by row is going to have a good cash locality.
如果我能的话，我打算坐船去意大利，那里有很好的现金交易地点。

1073
01:10:52,860 --> 01:10:56,820
Because I start to with the first row matrix,
因为我从第一行矩阵开始。

1074
01:10:56,830 --> 01:10:59,100
i'm already going to start to bring.
我已经准备开始了。

1075
01:11:00,150 --> 01:11:04,890
The first page contains a lot of elements from the first row.
第一页包含了许多来自第一行的元素。

1076
01:11:04,900 --> 01:11:09,770
So they are going to be all already in the cache when I am going to access them.
当我要访问它们时，它们将全部已经在缓存中。

1077
01:11:12,460 --> 01:11:15,080
Now say, I am going to write the same program,
现在假设我要编写相同的程序，

1078
01:11:15,090 --> 01:11:16,820
but i'm going to access columns.
但是我要访问列。

1079
01:11:16,830 --> 01:11:20,370
I am going to access the first element.
我要访问第一个元素。

1080
01:11:21,070 --> 01:11:22,380
I'm going to bring a page.
我要带来一页。

1081
01:11:23,840 --> 01:11:27,640
Now, the next element i'm going to access is going to be from the next row,
现在，我将要访问的下一个元素将来自下一行。

1082
01:11:29,070 --> 01:11:30,020
not in the same row.
不在同一行。

1083
01:11:30,800 --> 01:11:36,100
The next row that can result in another miss.

1084
01:11:36,510 --> 01:11:39,850
And I need to bring another page just to access only one element

1085
01:11:39,860 --> 01:11:41,910
from that page and so forth.

1086
01:11:42,320 --> 01:11:47,160
By the time I go back to access the second element from the first row,

1087
01:11:47,170 --> 01:11:48,600
that page may be already gone,

1088
01:11:49,580 --> 01:11:49,660
right?

1089
01:11:49,670 --> 01:11:53,260
Because may not all the pages may fit in cash.

1090
01:11:54,140 --> 01:11:55,150
So that's what you can do.

1091
01:11:55,910 --> 01:11:57,760
Like that's an example you want.

1092
01:11:58,190 --> 01:12:01,100
Or the dldr here,

1093
01:12:01,450 --> 01:12:04,450
you want to write your program to preserve locality,

1094
01:12:06,420 --> 01:12:09,370
another things which kind of destroy locality.

1095
01:12:09,630 --> 01:12:11,890
If you have goals, if you write a program,

1096
01:12:11,900 --> 01:12:13,330
he jumps around to go to.

1097
01:12:13,710 --> 01:12:15,360
That destroys a code locality.

1098
01:12:21,020 --> 01:12:24,610
I know that a large number of random access is on the hip is

1099
01:12:24,620 --> 01:12:26,650
generally bad for cash hit rates.

1100
01:12:27,300 --> 01:12:33,350
That's the same generally applies to minimize page misses.

1101
01:12:36,500 --> 01:12:38,980
I again,

1102
01:12:38,990 --> 01:12:42,520
it's like random.

1103
01:12:44,810 --> 01:12:48,280
It's not going, you will use random because it's fast.

1104
01:12:48,990 --> 01:12:50,960
But in this particular case,

1105
01:12:50,970 --> 01:12:57,050
because it's so costly to the baseball is so costly,

1106
01:12:57,950 --> 01:13:00,260
you really want to avoid random.

1107
01:13:04,640 --> 01:13:08,840
We still plb use random because you want to be extremely fast, right?

1108
01:13:10,600 --> 01:13:12,000
That happens actually in hardware.

1109
01:13:12,940 --> 01:13:15,630
Hopefully, I I answered this question if I didn't answer,

1110
01:13:16,960 --> 01:13:17,910
ask it again.

1111
01:13:18,350 --> 01:13:20,580
And maybe rephrase, what do you think?

1112
01:13:20,590 --> 01:13:23,460
I I I may have missed from your question.

1113
01:13:24,760 --> 01:13:25,630
Wouldn't this mean?

1114
01:13:25,640 --> 01:13:28,310
We have to take a software fault on every axis?

1115
01:13:29,220 --> 01:13:29,930
This, I think,

1116
01:13:29,940 --> 01:13:36,610
is refers to the examples I gave you about matrices going by columns.

1117
01:13:37,220 --> 01:13:38,490
In the worst case,

1118
01:13:38,770 --> 01:13:46,130
this means that you can take us a baseball on every access to a record.

1119
01:13:55,120 --> 01:13:56,020
No, is allah.

1120
01:13:56,030 --> 01:13:56,820
You're not.

1121
01:13:58,790 --> 01:14:01,900
It's again, it's like,

1122
01:14:02,610 --> 01:14:06,600
if you have something which is used very often,

1123
01:14:08,550 --> 01:14:11,000
then every time when you access it,

1124
01:14:12,200 --> 01:14:13,670
you are going to, again,

1125
01:14:13,680 --> 01:14:16,220
when you put here in this example.

1126
01:14:17,170 --> 01:14:17,570
Sorry.

1127
01:14:18,120 --> 01:14:19,680
When you put here in this example,

1128
01:14:20,450 --> 01:14:22,310
is, again, if I access space seven,

1129
01:14:22,990 --> 01:14:27,530
I am going to put it as ahead of the queue or the head of the list.

1130
01:14:27,840 --> 01:14:28,840
Accessing page on.

1131
01:14:28,850 --> 01:14:31,760
I'm going to put it ahead of the list, assessing page two.

1132
01:14:31,770 --> 01:14:33,680
Now the pastry is going to head off the list.

1133
01:14:37,020 --> 01:14:40,110
If I access something very often,

1134
01:14:40,600 --> 01:14:44,360
then they are going to be close to the head of the list.

1135
01:14:44,370 --> 01:14:45,880
So they are not going to be removed.

1136
01:14:45,890 --> 01:14:47,200
They are not going to be available.

1137
01:15:01,270 --> 01:15:01,550
Question,

1138
01:15:01,560 --> 01:15:06,480
does that mean that we have to work all pts and scan the valley beats?

1139
01:15:06,990 --> 01:15:08,560
Every so often begins the list?

1140
01:15:09,060 --> 01:15:09,980
That's a great.

1141
01:15:13,290 --> 01:15:15,070
Access fits, use, beats, they use, beats.

1142
01:15:15,080 --> 01:15:17,110
You refer, you are referring to the use beats.

1143
01:15:19,430 --> 01:15:20,280
That's a good point.

1144
01:15:20,290 --> 01:15:21,280
You could do that.

1145
01:15:21,950 --> 01:15:23,920
As we are going to see.

1146
01:15:25,130 --> 01:15:25,800
Next,

1147
01:15:29,110 --> 01:15:32,220
this is a precise implementation of the list,

1148
01:15:32,230 --> 01:15:33,780
at least recently used,

1149
01:15:34,320 --> 01:15:41,590
but it's expensive to implement what we are going to implement.

1150
01:15:41,600 --> 01:15:43,390
It's an approximation of allergy,

1151
01:15:44,830 --> 01:15:45,140
right?

1152
01:15:45,990 --> 01:15:47,290
That's what you are going to implement.

1153
01:15:52,750 --> 01:15:54,340
But before it goes there,

1154
01:15:54,350 --> 01:15:59,420
and we are going to show how we are going to implement an approximation of allergy.

1155
01:16:00,050 --> 01:16:00,280
Again,

1156
01:16:00,290 --> 01:16:03,120
we want to implement and as approximation ideal because we

1157
01:16:03,130 --> 01:16:07,800
don't want to manipulate point that is to do many memory access is

1158
01:16:08,300 --> 01:16:13,450
whenever we access a page before that,

1159
01:16:13,790 --> 01:16:17,150
let's look at a few other replacement policies.

1160
01:16:17,630 --> 01:16:18,580
This is 54.

1161
01:16:19,290 --> 01:16:21,440
And here we have a cash,

1162
01:16:22,090 --> 01:16:26,900
or which has three slots,

1163
01:16:27,930 --> 01:16:30,110
or you have three frames.

1164
01:16:30,870 --> 01:16:35,340
And this is your order in which we access the sequence.

1165
01:16:35,350 --> 01:16:36,820
We access these pages.

1166
01:16:37,400 --> 01:16:39,640
As the pages are denoted abc ds,

1167
01:16:39,650 --> 01:16:40,760
there are 4 pages.

1168
01:16:41,620 --> 01:16:48,040
I'm going to first access a's and b's,

1169
01:16:48,050 --> 01:16:49,160
and c and so forth.

1170
01:16:50,810 --> 01:16:52,760
Let's access a initially,

1171
01:16:52,770 --> 01:16:56,300
the cache or memory is empty.

1172
01:16:57,090 --> 01:17:03,640
We are going to save use the first page frame

1173
01:17:06,630 --> 01:17:13,850
to start a then b still have you available slot available frames?

1174
01:17:13,860 --> 01:17:18,550
I'm going to use the second one and to use and then use the server.

1175
01:17:20,870 --> 01:17:22,650
Now, things become interesting here.

1176
01:17:23,510 --> 01:17:29,490
Now I am going to come to access a again and a it's already in,

1177
01:17:29,500 --> 01:17:30,290
so it's fine.

1178
01:17:30,300 --> 01:17:30,970
I'm happy.

1179
01:17:31,280 --> 01:17:32,710
I'm not going to do anything.

1180
01:17:32,720 --> 01:17:34,060
I'm going to access it.

1181
01:17:34,070 --> 01:17:35,140
It's already in memory.

1182
01:17:36,130 --> 01:17:36,880
B is the same.

1183
01:17:37,980 --> 01:17:41,880
But now is b d is not in the memory.

1184
01:17:43,090 --> 01:17:44,200
What do I need to do?

1185
01:17:44,740 --> 01:17:45,840
And the memory is full.

1186
01:17:45,850 --> 01:17:47,700
So I need to make room for it.

1187
01:17:48,410 --> 01:17:52,110
Each page i'm going to evict here is in first out.

1188
01:17:52,700 --> 01:17:54,850
So i'm going to evict the page,

1189
01:17:55,360 --> 01:17:56,480
which was the first,

1190
01:18:03,010 --> 01:18:04,840
the first, which was brought in the memory,

1191
01:18:06,380 --> 01:18:06,440
right?

1192
01:18:06,450 --> 01:18:11,810
Which is a I'm going to replace cpcd now,

1193
01:18:11,820 --> 01:18:14,720
after d it's a well,

1194
01:18:15,130 --> 01:18:17,570
now a is against this.

1195
01:18:18,750 --> 01:18:19,430
The memory is full.

1196
01:18:19,440 --> 01:18:28,910
So I need to pick a page to ab and I'm going to pick which on b now,

1197
01:18:28,920 --> 01:18:31,250
the next one is the, again,

1198
01:18:31,930 --> 01:18:33,870
it's in memory, not only to do anything.

1199
01:18:33,880 --> 01:18:38,040
Then b now I don't have b in memory.

1200
01:18:38,050 --> 01:18:41,840
I have only ac and d right?

1201
01:18:43,760 --> 01:18:45,310
I need to replace one,

1202
01:18:45,850 --> 01:18:48,560
which one was the oldest?

1203
01:18:49,280 --> 01:18:49,850
We see,

1204
01:18:53,970 --> 01:18:54,400
I am.

1205
01:18:54,410 --> 01:18:57,920
And then ci am going to replace d with.

1206
01:18:58,050 --> 01:18:59,760
And then finally,

1207
01:18:59,770 --> 01:19:03,550
BB is already here.

1208
01:19:03,560 --> 01:19:04,950
How many page folds I had?

1209
01:19:05,210 --> 01:19:07,620
1234.

1210
01:19:10,890 --> 01:19:13,860
These are capacities.

1211
01:19:14,480 --> 01:19:15,740
And in addition to that,

1212
01:19:15,750 --> 01:19:19,580
I have three, other.

1213
01:19:20,910 --> 01:19:21,350
Mrs.

1214
01:19:21,360 --> 01:19:30,320
And these are what kind of misses are those compulsory misses?

1215
01:19:30,930 --> 01:19:32,720
So I have three compulsory misses.

1216
01:19:33,170 --> 01:19:34,460
Four capacity misses,

1217
01:19:34,710 --> 01:19:35,850
seven faults,

1218
01:19:36,660 --> 01:19:38,290
seven misses.

1219
01:19:40,840 --> 01:19:49,210
And here just noticed that this was a bad decision to replace a when we

1220
01:19:49,220 --> 01:19:50,810
brought the d in,

1221
01:19:50,820 --> 01:19:53,810
because the next axis was there.

1222
01:19:53,820 --> 01:19:55,190
So let's keep this in mind.

1223
01:19:55,450 --> 01:19:56,260
And with that,

1224
01:19:57,250 --> 01:19:58,440
i'll stop here.

1225
01:19:59,200 --> 01:20:04,350
We are going to continue to discuss about the patriots placement policies

1226
01:20:04,840 --> 01:20:05,580
next lecture.

1227
01:20:07,230 --> 01:20:07,690
Thank you.

