1
00:00:38,860 --> 00:00:39,970
Hello, everyone.

2
00:00:40,380 --> 00:00:44,590
Welcome to the 5th lecture of cs 162. 

3
00:00:45,650 --> 00:00:49,680
Today, we are going to continue with the exciting topic of files.

4
00:00:51,070 --> 00:00:53,940
We are going to start another topic, 

5
00:00:54,970 --> 00:01:00,750
which is on communications between processes or ipc inter process, 

6
00:01:00,760 --> 00:01:01,630
communication, 

7
00:01:01,880 --> 00:01:03,080
techniques and mechanics. 

8
00:01:05,770 --> 00:01:11,780
As always, if you have any questions ask on the q and a let's start.

9
00:01:14,800 --> 00:01:16,630
Not yesterday 2 days ago, 

10
00:01:16,640 --> 00:01:19,390
we discussed about the streams, 

11
00:01:19,870 --> 00:01:24,470
which is a highest level api for the file systems. 

12
00:01:25,090 --> 00:01:30,840
Today, we are going to talk a little bit of a lower level file io api

13
00:01:32,800 --> 00:01:36,030
which is centered around file descriptors. 

14
00:01:37,920 --> 00:01:41,150
Then we are going to talk what is the difference between the high level

15
00:01:41,160 --> 00:01:41,750
and low level? 

16
00:01:41,760 --> 00:01:50,040
Ap is, why do we have to kind of ap is about somehow is a state is

17
00:01:50,050 --> 00:01:53,110
managed across processes, 

18
00:01:54,230 --> 00:01:58,440
especially when you create another process using fork. 

19
00:01:59,540 --> 00:02:03,460
What happens with the file descriptors in the parent and the child? 

20
00:02:04,350 --> 00:02:06,440
And finally, 

21
00:02:06,790 --> 00:02:09,710
two or three common pitfalls, 

22
00:02:10,580 --> 00:02:14,450
you may want to avoid in your projects or homeworks. 

23
00:02:15,840 --> 00:02:18,350
In general, when you are going to write a program,

24
00:02:19,020 --> 00:02:19,970
using this, 

25
00:02:21,150 --> 00:02:23,260
ap is for the file systems. 

26
00:02:24,860 --> 00:02:33,320
First, remember, what we discussed last time is that one unique thing about

27
00:02:34,560 --> 00:02:41,440
unique is that it uses a file systems of a generic abstractions, 

28
00:02:41,650 --> 00:02:43,850
not only to deals or files, 

29
00:02:44,200 --> 00:02:48,540
or on a storage device like a describe, 

30
00:02:49,090 --> 00:02:53,100
but also to deal with different devices, 

31
00:02:53,490 --> 00:02:55,110
like keyboard, 

32
00:02:55,600 --> 00:02:56,750
terminals, 

33
00:02:58,230 --> 00:02:59,630
printer, and so forth.

34
00:03:00,900 --> 00:03:05,230
The second thing is that the abstraction which is provided, 

35
00:03:05,440 --> 00:03:06,790
it's by oriented. 

36
00:03:06,800 --> 00:03:13,370
So by oriented means that you have what you get and you read or you

37
00:03:13,380 --> 00:03:14,450
read and write to the

38
00:03:14,460 --> 00:03:17,600
devices is basically a bunch of bytes. 

39
00:03:18,400 --> 00:03:21,310
And you can think about like a sequence of bytes. 

40
00:03:21,630 --> 00:03:27,030
And you can address it by the index of a particular byte. 

41
00:03:28,110 --> 00:03:32,340
You can identify the bike in the sequence by its index in that sequence. 

42
00:03:35,380 --> 00:03:39,250
The other things we are going to learn more is that when you

43
00:03:39,260 --> 00:03:41,130
are going to do reads and writes, 

44
00:03:42,040 --> 00:03:47,280
these reasons rights are not going to come directly to your application. 

45
00:03:47,290 --> 00:03:50,280
They are going first to be buffered in the operating system. 

46
00:03:50,880 --> 00:03:52,270
As you'll see, also,

47
00:03:52,280 --> 00:03:54,110
with the stream, the high level,

48
00:03:54,120 --> 00:03:55,790
api we talked last time, 

49
00:03:56,030 --> 00:03:58,800
there is also a buffer in the application level. 

50
00:04:01,580 --> 00:04:04,160
Finally, the pattern is very simple.

51
00:04:04,430 --> 00:04:07,550
You open a file, right?

52
00:04:08,250 --> 00:04:12,740
You have to close it at the end and in between your read and write

53
00:04:14,460 --> 00:04:17,720
from that particular file descriptor. 

54
00:04:22,370 --> 00:04:30,260
This is a low level file io api it's quite similar from the one the high level

55
00:04:30,970 --> 00:04:34,650
pilot or api one difference, 

56
00:04:34,980 --> 00:04:35,370
though, 

57
00:04:37,140 --> 00:04:41,670
it's it's similar in the sense that it has an open, 

58
00:04:42,180 --> 00:04:43,330
close, 

59
00:04:43,340 --> 00:04:47,660
and in between like your series and rights is differently, 

60
00:04:47,670 --> 00:04:50,060
provides slightly different semantics. 

61
00:04:50,480 --> 00:04:52,630
And instead of if open, 

62
00:04:52,640 --> 00:04:59,950
like for the high level api you have just opened when you open a file, 

63
00:04:59,960 --> 00:05:01,270
you pass a file name, 

64
00:05:01,280 --> 00:05:02,390
then a bunch of flags, 

65
00:05:02,400 --> 00:05:03,910
which basically says, 

66
00:05:07,780 --> 00:05:09,480
what are the access rights? 

67
00:05:09,860 --> 00:05:13,210
Whether you read, you have the rights to read from the file,

68
00:05:13,220 --> 00:05:14,330
write from the file, 

69
00:05:14,680 --> 00:05:16,820
or read write the file. 

70
00:05:17,990 --> 00:05:24,100
And then there are also a bit vector a with a permission bits, 

71
00:05:25,490 --> 00:05:33,270
which are also who is going to have the rights to access that file. 

72
00:05:33,660 --> 00:05:36,190
And you can have users. 

73
00:05:36,600 --> 00:05:43,100
The users is a is a user who actually runs a program which invokes this api

74
00:05:43,110 --> 00:05:44,260
to open the file. 

75
00:05:45,450 --> 00:05:47,160
Then it's a group. 

76
00:05:47,170 --> 00:05:49,800
This is the concept the user belongs to a group. 

77
00:05:49,810 --> 00:05:51,040
We learn more about that. 

78
00:05:51,770 --> 00:05:58,270
And others means everyone else can access these files. 

79
00:06:02,560 --> 00:06:07,480
Then you have the clouds and you have create when your first time when you

80
00:06:07,490 --> 00:06:08,320
create a heart. 

81
00:06:10,090 --> 00:06:18,330
Now, the important thing here is that open returns you and an integer.

82
00:06:19,840 --> 00:06:22,560
The integer is also called file descriptor. 

83
00:06:23,480 --> 00:06:25,180
The integers are greater than zero. 

84
00:06:25,190 --> 00:06:26,830
If it's less than zero, 

85
00:06:26,840 --> 00:06:28,480
this means that is error. 

86
00:06:31,280 --> 00:06:32,680
It is integer. 

87
00:06:33,100 --> 00:06:41,700
It used to identify the meta data associated with a file. 

88
00:06:41,710 --> 00:06:43,680
You open in, 

89
00:06:43,690 --> 00:06:46,240
and this meta data is stored in the operating system. 

90
00:06:50,810 --> 00:06:54,160
So that's why you are going to have. 

91
00:06:54,690 --> 00:06:56,030
Why do you have. 

92
00:06:56,250 --> 00:07:04,190
Then I integer to identify this kind of this meta data, 

93
00:07:04,830 --> 00:07:06,050
which also, again,

94
00:07:06,440 --> 00:07:07,530
this file descriptor. 

95
00:07:08,950 --> 00:07:14,970
And why do you have a file descriptor specified as an integer than specify

96
00:07:15,100 --> 00:07:15,890
a as a pointer? 

97
00:07:16,490 --> 00:07:17,970
Can anyone answer that question? 

98
00:07:22,710 --> 00:07:24,700
It again, open returns an integer,

99
00:07:24,710 --> 00:07:25,740
is a file descriptor, 

100
00:07:27,530 --> 00:07:33,180
which identifies the meta data associated with that file in the cattle. 

101
00:07:36,150 --> 00:07:37,540
Why not just have a pointer? 

102
00:07:41,320 --> 00:07:42,600
Yes, less dangerous.

103
00:07:43,810 --> 00:07:46,050
One is same memory, not exactly.

104
00:07:46,060 --> 00:07:46,610
It does. 

105
00:07:53,930 --> 00:07:54,880
That's correct. 

106
00:07:55,120 --> 00:08:00,940
Having a point at the canal will allow will mean that will allow the process, 

107
00:08:01,230 --> 00:08:04,620
which is a user process, which opens a file to have access to the camera,

108
00:08:04,980 --> 00:08:05,630
actually. 

109
00:08:05,890 --> 00:08:09,890
But we know that processes are have their own address space, 

110
00:08:09,900 --> 00:08:11,450
which is different from the kernel. 

111
00:08:11,720 --> 00:08:14,830
You cannot have a pointer to the address space of the kernel. 

112
00:08:15,920 --> 00:08:16,350
Right? 

113
00:08:18,130 --> 00:08:19,560
That's why you have an integer, 

114
00:08:19,570 --> 00:08:24,610
because an integer is going when you are going to invoke on this one

115
00:08:24,620 --> 00:08:26,850
of this operation on the file systems, 

116
00:08:28,530 --> 00:08:31,070
then you are going to pass a file descriptor, 

117
00:08:31,450 --> 00:08:32,340
the file descriptor, 

118
00:08:32,350 --> 00:08:37,290
it is going to be an index in a table of the file descriptors, 

119
00:08:38,240 --> 00:08:40,830
which are open at that given time. 

120
00:08:41,090 --> 00:08:46,000
And that index will.out to the meta data are sold or the

121
00:08:46,010 --> 00:08:47,680
state associated with its open file. 

122
00:08:51,240 --> 00:08:58,560
So it's a portable way to identify the file state or the meta data

123
00:08:58,570 --> 00:09:00,640
associated with the open file. 

124
00:09:05,030 --> 00:09:10,430
Now, there are several default files.

125
00:09:11,530 --> 00:09:19,610
File names is like thunder bean thundered out standard file and this, 

126
00:09:19,620 --> 00:09:20,010
sorry, 

127
00:09:20,020 --> 00:09:23,650
decided the standard file descriptors. 

128
00:09:24,210 --> 00:09:24,660
Okay, 

129
00:09:26,590 --> 00:09:27,540
stand up in. 

130
00:09:28,970 --> 00:09:32,770
It's when you want to read from the keyboard standard out when you

131
00:09:32,780 --> 00:09:35,010
are going to write to the keyboard. 

132
00:09:37,340 --> 00:09:40,230
And the other thing, 

133
00:09:40,580 --> 00:09:43,190
it's again, we have high level of the ap is.

134
00:09:43,410 --> 00:09:44,510
Low level ap is, 

135
00:09:44,720 --> 00:09:48,750
the high level ap is or stream ap is, if you remember, from last time,

136
00:09:48,760 --> 00:09:50,350
when you do an f open, 

137
00:09:50,470 --> 00:09:52,620
you return a file, a pointer.

138
00:09:53,260 --> 00:09:58,650
That pointer is actually a pointer to data structures in the user space. 

139
00:09:59,020 --> 00:10:01,450
And in that address, 

140
00:10:02,380 --> 00:10:04,170
in that data, 

141
00:10:04,180 --> 00:10:11,230
structuring the user space has also contains a file descriptors

142
00:10:13,820 --> 00:10:16,250
associated with that open. 

143
00:10:17,740 --> 00:10:18,930
We'll talk more about that, 

144
00:10:18,940 --> 00:10:21,420
but therefore, 

145
00:10:21,430 --> 00:10:25,540
there is a way to go from the file descriptors. 

146
00:10:25,550 --> 00:10:33,350
And that's the pointer which is returned by an of open instructor of open

147
00:10:33,360 --> 00:10:34,980
of system called. 

148
00:10:36,450 --> 00:10:41,250
You remember, if you do fo but you get this pointer, file pointer.

149
00:10:41,980 --> 00:10:46,060
And you can from this file pointer, 

150
00:10:46,460 --> 00:10:48,720
returned by an f open. 

151
00:10:49,160 --> 00:10:55,460
You can get the associated file descriptor by using file. 

152
00:10:55,470 --> 00:10:55,740
Now, 

153
00:10:57,210 --> 00:10:57,630
correction. 

154
00:10:59,070 --> 00:11:06,380
The universe is also true from file descriptor. 

155
00:11:06,730 --> 00:11:08,970
You got, when you open a file,

156
00:11:09,670 --> 00:11:10,790
you can go out. 

157
00:11:11,090 --> 00:11:17,870
You can get the file pointer to that file by specifying

158
00:11:17,880 --> 00:11:21,020
the file descriptors and the open type. 

159
00:11:21,310 --> 00:11:26,800
And now you can use this file descriptors to you to invoke for to invoke

160
00:11:26,810 --> 00:11:27,920
on that file, 

161
00:11:27,930 --> 00:11:31,000
the high level ap is the stream level ap is, 

162
00:11:37,530 --> 00:11:40,250
low level ap is you have forgained, read and write.

163
00:11:40,690 --> 00:11:43,070
But typically here, when you have read and write,

164
00:11:43,570 --> 00:11:50,700
you are going to read a buffer of a certain size. 

165
00:11:51,450 --> 00:11:54,340
You read it into a buffer of a certain size, 

166
00:11:54,610 --> 00:11:57,370
or you write a buffer of a certain size, right?

167
00:11:59,640 --> 00:12:05,670
Will read the elements from the files up to the size of the buffer, 

168
00:12:05,680 --> 00:12:06,910
which is mark size. 

169
00:12:07,260 --> 00:12:10,680
Obviously, when you read, you need to allocate space for the buffer.

170
00:12:13,890 --> 00:12:16,080
The right, it's, again, similar.

171
00:12:16,090 --> 00:12:18,480
You provide the pointer to a buffer, 

172
00:12:19,000 --> 00:12:22,890
which of this of a given size. 

173
00:12:23,380 --> 00:12:28,170
And that will result taking this buffer and writing it to the device. 

174
00:12:30,910 --> 00:12:32,040
In addition, 

175
00:12:32,740 --> 00:12:34,060
the other way to look at, 

176
00:12:34,190 --> 00:12:35,980
in addition, you have this command,

177
00:12:35,990 --> 00:12:37,260
which is l sick. 

178
00:12:38,700 --> 00:12:39,330
Remember, 

179
00:12:39,840 --> 00:12:42,010
the abstraction is byte oriented. 

180
00:12:42,650 --> 00:12:43,810
If you look at the file, 

181
00:12:43,820 --> 00:12:45,050
it's a sequence of bytes. 

182
00:12:46,740 --> 00:12:52,780
If you want, now to read or to write in a file at a particular position.

183
00:12:53,400 --> 00:12:54,460
The one, though,

184
00:12:54,750 --> 00:12:57,750
you can use lc basically, 

185
00:12:57,760 --> 00:12:59,300
you are going to say, 

186
00:12:59,310 --> 00:13:00,850
where do you want to? 

187
00:13:02,200 --> 00:13:05,020
Where do you want offset is from the current position? 

188
00:13:05,740 --> 00:13:07,480
You want to add an offset, 

189
00:13:09,470 --> 00:13:12,960
a to a new location, 

190
00:13:12,970 --> 00:13:15,330
or you want to read from or to write. 

191
00:13:20,260 --> 00:13:22,050
Let me answer some of the question. 

192
00:13:22,930 --> 00:13:25,550
Can we put the powerpoint into presentation mode? 

193
00:13:26,630 --> 00:13:27,030
Thank you. 

194
00:13:27,040 --> 00:13:27,830
Sorry about that. 

195
00:13:30,240 --> 00:13:31,280
Yes, absolutely.

196
00:13:31,290 --> 00:13:32,200
That was an easy one. 

197
00:13:34,080 --> 00:13:37,390
What does mode mean on the open code? 

198
00:13:37,750 --> 00:13:40,380
Does it apply to just the file descriptor? 

199
00:13:40,390 --> 00:13:43,580
Can I share a file descriptor with loser permission? 

200
00:13:44,050 --> 00:13:52,590
Then the file in the fs the mode is, again,

201
00:13:52,600 --> 00:13:59,070
referring who has arrived to access the open file using the file descriptor. 

202
00:13:59,880 --> 00:14:02,830
And it does apply to a file descriptor. 

203
00:14:03,960 --> 00:14:05,040
But a file descriptor, 

204
00:14:05,690 --> 00:14:07,210
can I share a file escape tories, 

205
00:14:07,220 --> 00:14:08,370
loser permissions, 

206
00:14:08,380 --> 00:14:15,720
and the file in the you cannot because

207
00:14:16,370 --> 00:14:24,270
of you if the file the access

208
00:14:24,280 --> 00:14:25,510
rights are, 

209
00:14:25,900 --> 00:14:28,100
like in the name implies, 

210
00:14:28,110 --> 00:14:29,980
are enforced when you access a file. 

211
00:14:31,090 --> 00:14:32,880
If the file, for instance,

212
00:14:32,890 --> 00:14:35,570
when you create it, 

213
00:14:35,580 --> 00:14:41,200
it's you can only read. 

214
00:14:41,210 --> 00:14:43,360
And again, when you are going to create a file,

215
00:14:43,370 --> 00:14:47,910
you are going to basically say something like with these flags. 

216
00:14:49,630 --> 00:14:50,630
All people, for instance,

217
00:14:50,640 --> 00:14:52,870
in my group can access a file. 

218
00:14:52,880 --> 00:14:58,950
So now if you share your file descriptor to someone in the same group, 

219
00:14:59,210 --> 00:15:01,920
they are going to have our rights to access a file. 

220
00:15:03,710 --> 00:15:04,300
If you, 

221
00:15:05,190 --> 00:15:07,140
sherry, someone from other,

222
00:15:07,150 --> 00:15:10,180
was as a outside your group, 

223
00:15:10,580 --> 00:15:12,770
that person cannot access a file, 

224
00:15:13,040 --> 00:15:17,830
because and the operating system is going to look who is going to access a file, 

225
00:15:17,840 --> 00:15:20,110
and this logo is not the same group, 

226
00:15:20,380 --> 00:15:22,550
then is going to procure the axis. 

227
00:15:25,250 --> 00:15:26,440
Why is a buffer? 

228
00:15:26,450 --> 00:15:30,660
This next question is why is a buffer of type void? 

229
00:15:32,320 --> 00:15:36,920
It's basically saying this signify the fact that in that buffer, 

230
00:15:36,930 --> 00:15:38,160
you can have anything, 

231
00:15:39,000 --> 00:15:39,290
right? 

232
00:15:39,890 --> 00:15:40,900
Is for generality. 

233
00:15:41,680 --> 00:15:43,910
But if you put car, for instance,

234
00:15:44,150 --> 00:15:48,100
then he suggests that these are kind of the characters probably in us

235
00:15:48,110 --> 00:15:49,420
for emergency like that. 

236
00:15:49,870 --> 00:15:56,680
Void is basically saying it can be also binary representation. 

237
00:15:57,380 --> 00:15:58,610
It can be anything. 

238
00:16:00,930 --> 00:16:04,670
It's a convention more than anything. 

239
00:16:13,870 --> 00:16:17,460
A this is an example of a simple example. 

240
00:16:18,520 --> 00:16:20,160
You open an existing file, 

241
00:16:24,560 --> 00:16:26,760
you open an existing file, 

242
00:16:27,110 --> 00:16:31,690
and you write the output. 

243
00:16:38,850 --> 00:16:40,760
Here you is read only. 

244
00:16:42,060 --> 00:16:48,490
This is the user is right, 

245
00:16:48,750 --> 00:16:52,160
writing, access and writing access for the user.

246
00:16:52,880 --> 00:16:56,510
And then you read it your clothes, 

247
00:16:59,020 --> 00:17:07,650
you send the you send the output to standard out by number. 

248
00:17:10,110 --> 00:17:16,400
So one question here is about how many bytes these program reads. 

249
00:17:17,150 --> 00:17:18,810
So you can see when you read, 

250
00:17:19,240 --> 00:17:20,680
this is an important instruction. 

251
00:17:20,690 --> 00:17:26,820
You read into a buffer of which you allocated 1,000 bytes. 

252
00:17:28,350 --> 00:17:29,860
How many bytes does this program? 

253
00:17:29,870 --> 00:17:38,820
It should be easy. 

254
00:17:42,750 --> 00:17:43,510
Any answers? 

255
00:17:47,020 --> 00:17:48,330
We have some answers here. 

256
00:17:53,320 --> 00:17:55,840
Size of buffer without some answers, 

257
00:17:56,440 --> 00:17:57,480
$1,000, 

258
00:17:57,490 --> 00:17:58,600
at most on salary. 

259
00:18:01,330 --> 00:18:02,160
That's correct. 

260
00:18:03,190 --> 00:18:05,030
With just a little, 

261
00:18:05,040 --> 00:18:07,900
tiny clarification, 

262
00:18:09,010 --> 00:18:10,050
you read, 

263
00:18:10,800 --> 00:18:15,760
if the size of the file is less than 1,000 bytes, 

264
00:18:16,070 --> 00:18:18,290
you read everything, you read the entire file.

265
00:18:19,200 --> 00:18:23,100
If the size of the file is greater than 1,000 bytes, 

266
00:18:23,110 --> 00:18:26,780
you read the first 1,000 bytes of the file. 

267
00:18:34,220 --> 00:18:36,830
Like I mentioned the design pattern. 

268
00:18:37,160 --> 00:18:38,190
It's open. 

269
00:18:39,580 --> 00:18:40,880
Before you use a file. 

270
00:18:41,350 --> 00:18:42,810
At the end you close it. 

271
00:18:43,250 --> 00:18:50,980
And in between and read and write from the file with a low level, 

272
00:18:51,550 --> 00:18:57,480
ioapi you basically read and write a bunch of bytes. 

273
00:18:57,730 --> 00:19:05,450
That's all you can use lc to reposition in inside a file. 

274
00:19:09,650 --> 00:19:13,210
So one important aspect I mentioned earlier on, 

275
00:19:13,220 --> 00:19:16,330
you also need to think about the buffers. 

276
00:19:16,960 --> 00:19:19,580
When you read something from a file, 

277
00:19:20,160 --> 00:19:23,050
that sink doesn't go, 

278
00:19:23,060 --> 00:19:29,550
that is not red directly to the operating system to this application. 

279
00:19:31,140 --> 00:19:32,300
It reads first. 

280
00:19:34,640 --> 00:19:36,130
The information from a file, 

281
00:19:36,140 --> 00:19:39,280
the data from the file is first thread, 

282
00:19:39,740 --> 00:19:41,620
and is buffered in the kernel. 

283
00:19:43,610 --> 00:19:44,850
The same is right. 

284
00:19:45,790 --> 00:19:46,480
When you write, 

285
00:19:47,270 --> 00:19:49,520
you don't write directly to the device, 

286
00:19:50,180 --> 00:19:52,950
you write to a buffering to the camera. 

287
00:19:53,620 --> 00:19:56,730
And the camera writes after that to the device. 

288
00:19:58,550 --> 00:19:58,980
Okay. 

289
00:20:00,300 --> 00:20:07,180
Now can you think about why would you read and write to a buffer

290
00:20:07,450 --> 00:20:09,990
from and probably to and from a buffer? 

291
00:20:10,210 --> 00:20:12,770
Is a kernel rather directly from the device to

292
00:20:22,990 --> 00:20:24,850
check for malaysia input? 

293
00:20:25,920 --> 00:20:26,010
Faster. 

294
00:20:26,390 --> 00:20:30,550
The devices might not be directly, right?

295
00:20:31,560 --> 00:20:32,110
That's good. 

296
00:20:32,440 --> 00:20:33,470
It's faster, 

297
00:20:33,480 --> 00:20:35,830
and the devices might not be directly ready. 

298
00:20:36,900 --> 00:20:41,090
And think about this way, right?

299
00:20:42,460 --> 00:20:46,940
It's also the fact that the devices, 

300
00:20:48,560 --> 00:20:50,100
when they transferred data, 

301
00:20:50,460 --> 00:20:56,780
they may have a natural granularity, at least a transfer, the date.

302
00:20:57,870 --> 00:20:59,350
So, for instance,

303
00:20:59,360 --> 00:21:02,870
when you read from the disk, 

304
00:21:03,610 --> 00:21:09,020
you read kind of ground like these, like blocks, a few kilobytes.

305
00:21:09,750 --> 00:21:10,190
Right? 

306
00:21:10,670 --> 00:21:13,580
This is what you get from a describe. 

307
00:21:13,590 --> 00:21:15,380
You don't get 1 byte at a time. 

308
00:21:15,390 --> 00:21:16,700
You get a block at a time. 

309
00:21:17,980 --> 00:21:20,530
Even if you ask for on character, you get a block.

310
00:21:20,880 --> 00:21:22,180
You need to put that block summers. 

311
00:21:22,190 --> 00:21:23,510
We are going to put it in, 

312
00:21:23,520 --> 00:21:25,790
though this is how we are going to put in. 

313
00:21:27,180 --> 00:21:28,610
A is a kernel buffer, 

314
00:21:29,110 --> 00:21:29,470
right? 

315
00:21:29,780 --> 00:21:31,790
Otherwise means to throw it away. 

316
00:21:32,080 --> 00:21:35,940
And then if you read the second character from that block, 

317
00:21:35,950 --> 00:21:37,380
you need to bring it again. 

318
00:21:38,310 --> 00:21:43,100
The other thing it's about another situation is that when I write, 

319
00:21:43,720 --> 00:21:46,930
say, a buffer right to the device,

320
00:21:46,940 --> 00:21:48,090
the device may not be ready. 

321
00:21:49,220 --> 00:21:49,610
Right? 

322
00:21:51,100 --> 00:21:53,530
Maybe another right is happening on the device. 

323
00:21:53,540 --> 00:21:55,370
Or simply, if you have a files,

324
00:21:55,380 --> 00:21:57,820
you have at least the like a disk drive. 

325
00:21:58,660 --> 00:21:59,970
You need the disk, 

326
00:21:59,980 --> 00:22:02,130
you need to wait for the disk to rotate, 

327
00:22:02,570 --> 00:22:06,120
says that the head of the disk to be above this, 

328
00:22:06,130 --> 00:22:07,400
the region of the disk, 

329
00:22:07,730 --> 00:22:11,160
or you already which is available as you can write new data. 

330
00:22:12,810 --> 00:22:16,120
Or in that particular case, 

331
00:22:16,450 --> 00:22:18,580
instead of blocking the application, 

332
00:22:18,860 --> 00:22:22,070
then for to wait for that event, 

333
00:22:22,430 --> 00:22:23,830
then instead, 

334
00:22:23,840 --> 00:22:26,200
you are going to write to this kernel buffer, 

335
00:22:26,210 --> 00:22:29,800
and the kernel is going to take care of the rest. 

336
00:22:30,660 --> 00:22:32,430
The same is another, right?

337
00:22:32,810 --> 00:22:34,280
I I if I want, 

338
00:22:34,290 --> 00:22:39,050
if i'm going to write at once a big chunk of data, 

339
00:22:39,060 --> 00:22:45,070
and this is larger than what the network can send at once large as are

340
00:22:45,080 --> 00:22:46,030
not one packet. 

341
00:22:47,100 --> 00:22:52,610
Then what what will happen in that case that you are going to write

342
00:22:52,620 --> 00:22:55,450
all this kind of chunk of data in the kernel? 

343
00:22:55,880 --> 00:23:02,070
The kennel take care to chop how much you want to send in smaller packets

344
00:23:02,080 --> 00:23:04,590
and send packages or each packet at a time. 

345
00:23:06,500 --> 00:23:07,220
So hopefully, 

346
00:23:07,510 --> 00:23:11,720
this is enough to give you a sense about why you need to buffer the data, 

347
00:23:12,990 --> 00:23:16,890
why I need to buffer to have kennel buffers when you read and write. 

348
00:23:23,250 --> 00:23:25,900
Then there is another operation. 

349
00:23:25,910 --> 00:23:28,320
It's, again, there are differences.

350
00:23:28,610 --> 00:23:32,100
While everything is a file that are different between devices, 

351
00:23:32,110 --> 00:23:33,740
like you mentioned last time, 

352
00:23:33,950 --> 00:23:35,570
for instance, from a terminal,

353
00:23:35,580 --> 00:23:36,620
you have terminal, 

354
00:23:36,630 --> 00:23:37,670
it's only output, 

355
00:23:38,770 --> 00:23:40,330
a printer, it's only output,

356
00:23:40,600 --> 00:23:44,060
the keyboard it's only input or the mouse, it's only input.

357
00:23:45,290 --> 00:23:48,360
Like for instance for the yeah, 

358
00:23:49,130 --> 00:23:53,010
and then also you may want to configure the other parameters like a printer

359
00:23:53,020 --> 00:23:55,330
to configure the line speed or things like that. 

360
00:23:55,760 --> 00:24:00,790
What you are going to do when you have this extra parameters to configure

361
00:24:00,800 --> 00:24:05,120
it for which are particular to a partner to a given device, 

362
00:24:05,410 --> 00:24:09,330
then you have this ioctl as a escape batch. 

363
00:24:09,630 --> 00:24:14,100
So that allows you to deal with these specialized particular parameters

364
00:24:14,380 --> 00:24:15,570
for different devices. 

365
00:24:16,910 --> 00:24:20,420
The other one is a double to duplicate the file descriptors. 

366
00:24:20,870 --> 00:24:22,530
And to duplicate you, 

367
00:24:23,140 --> 00:24:24,630
a can open a file. 

368
00:24:25,150 --> 00:24:26,290
You can get a file descriptors. 

369
00:24:27,130 --> 00:24:31,690
And you can, if you want to share that file descriptor to someone else,

370
00:24:32,240 --> 00:24:32,610
right? 

371
00:24:32,930 --> 00:24:34,960
Maybe another thread in the same application, 

372
00:24:35,300 --> 00:24:40,690
or maybe another process for you to another process to operate on the same file, 

373
00:24:40,900 --> 00:24:45,870
then one way to do it is to create another file descriptors to which point

374
00:24:46,560 --> 00:24:50,830
to the same metadata to the same instance of the open file. 

375
00:24:51,620 --> 00:24:53,330
We'll show examples of that. 

376
00:24:54,360 --> 00:24:58,630
The difference between loop two and loop is that we stop to, 

377
00:24:58,640 --> 00:25:02,390
you can actually specify the file descriptors. 

378
00:25:03,230 --> 00:25:08,350
You want to point to the same data structure of open file, 

379
00:25:09,330 --> 00:25:09,620
right? 

380
00:25:10,100 --> 00:25:11,140
With a dupe, 

381
00:25:12,890 --> 00:25:18,680
you'll get back the next lowest number available

382
00:25:21,420 --> 00:25:25,830
step in the file descriptor of the file descriptor numbers, 

383
00:25:26,120 --> 00:25:33,120
the lowest available by it's like, you'll see,

384
00:25:33,130 --> 00:25:36,320
it's a way to communicate between two processes. 

385
00:25:36,550 --> 00:25:38,030
You can think as a cube. 

386
00:25:45,260 --> 00:25:49,320
And we are going to talk about memory mapping, files, file locking,

387
00:25:49,330 --> 00:25:50,120
dancing like that. 

388
00:25:51,710 --> 00:25:52,220
Now, 

389
00:25:53,110 --> 00:25:57,060
an obvious question here is that why do we have high level and low level

390
00:25:57,070 --> 00:26:00,010
like pis why do we have streams? 

391
00:26:00,360 --> 00:26:02,180
And why you have file descriptors? 

392
00:26:02,190 --> 00:26:03,700
Why do you have fo ones? 

393
00:26:04,020 --> 00:26:05,220
And why do you have open? 

394
00:26:05,480 --> 00:26:05,910
Right? 

395
00:26:09,090 --> 00:26:18,860
First of all, this is how they compare here.

396
00:26:18,870 --> 00:26:21,090
It's high level operation, 

397
00:26:21,100 --> 00:26:23,370
which is on streams of bytes. 

398
00:26:23,870 --> 00:26:24,260
Here, 

399
00:26:25,070 --> 00:26:27,860
it's operation which is on a buffer. 

400
00:26:28,310 --> 00:26:28,620
Right? 

401
00:26:30,940 --> 00:26:33,640
And the files, 

402
00:26:34,110 --> 00:26:40,160
the stream of bioap are preceded by f with f letter. 

403
00:26:40,700 --> 00:26:40,920
Obviously, 

404
00:26:41,450 --> 00:26:42,480
as a low level, 

405
00:26:42,490 --> 00:26:46,020
api they don't have any this prefix letter. 

406
00:26:46,030 --> 00:26:48,420
So the middle is the same. 

407
00:26:48,810 --> 00:26:49,280
Right? 

408
00:26:49,290 --> 00:26:54,320
Remember, this are going to be converted to a system call,

409
00:26:54,990 --> 00:26:58,350
because this operation are implemented by the kernel. 

410
00:27:00,050 --> 00:27:01,160
What happens here? 

411
00:27:01,170 --> 00:27:06,350
You are going to call invoke the function it in the operating system

412
00:27:06,360 --> 00:27:08,900
by using this kind of trap

413
00:27:11,600 --> 00:27:14,410
and special drop instruction. 

414
00:27:14,840 --> 00:27:16,090
And before you do that, 

415
00:27:16,360 --> 00:27:20,970
you are going to fill in some registers with the data, 

416
00:27:21,470 --> 00:27:22,630
for the operating systems, 

417
00:27:22,640 --> 00:27:23,710
for the kernel, 

418
00:27:23,720 --> 00:27:26,230
to know which files you are referring. 

419
00:27:27,020 --> 00:27:27,260
Right? 

420
00:27:27,270 --> 00:27:31,460
And what operation you want to perform on that file. 

421
00:27:31,720 --> 00:27:33,110
And for that operation, 

422
00:27:33,120 --> 00:27:34,310
what are the arguments? 

423
00:27:35,240 --> 00:27:39,650
This is what you put in registers here just before the trap instruction. 

424
00:27:40,290 --> 00:27:43,020
And then after it was a stop, 

425
00:27:43,030 --> 00:27:45,420
is after the execute the trap instructions, 

426
00:27:46,040 --> 00:27:47,950
the kernel will take over, 

427
00:27:47,960 --> 00:27:49,030
look at the register. 

428
00:27:49,040 --> 00:27:50,030
If you initialize, 

429
00:27:50,040 --> 00:27:52,950
is figuring out the file descriptor you are referring to, 

430
00:27:53,720 --> 00:27:56,430
figure out what is the operation you want to perform, 

431
00:27:56,440 --> 00:27:58,470
figure out the arguments of the operation, 

432
00:27:58,610 --> 00:27:59,880
which are in other registers, 

433
00:27:59,890 --> 00:28:06,330
perform the operation and then returns back to the users once the operation

434
00:28:06,340 --> 00:28:07,090
is performed. 

435
00:28:07,100 --> 00:28:09,050
And if the return values, 

436
00:28:09,220 --> 00:28:14,490
it's also make sure that put the return value a in the particular register

437
00:28:14,500 --> 00:28:18,750
like ex the only difference is that, 

438
00:28:18,760 --> 00:28:19,770
as you see, 

439
00:28:19,780 --> 00:28:21,250
the afraid, 

440
00:28:22,450 --> 00:28:23,560
so this is the middle part. 

441
00:28:23,570 --> 00:28:24,320
It's identical. 

442
00:28:24,590 --> 00:28:32,070
The only difference is that the ways afraid with a high level ap is you do

443
00:28:32,080 --> 00:28:32,550
a lot

444
00:28:32,560 --> 00:28:35,710
of some work before or after. 

445
00:28:36,010 --> 00:28:38,370
You invokes the operating system, 

446
00:28:38,380 --> 00:28:41,720
you invoke the system call as a user level. 

447
00:28:41,730 --> 00:28:42,640
You do some more work. 

448
00:28:43,160 --> 00:28:43,470
Right? 

449
00:28:43,880 --> 00:28:45,430
That has to do is the fact that, 

450
00:28:45,640 --> 00:28:46,790
as you will see, 

451
00:28:47,520 --> 00:28:49,830
with the high level ap is, 

452
00:28:50,000 --> 00:28:52,250
we have a buffer not only in the kernel, 

453
00:28:52,490 --> 00:28:55,430
but also we have a buffer in the user level. 

454
00:29:02,280 --> 00:29:04,440
This is exactly to illustrate that point. 

455
00:29:04,910 --> 00:29:05,170
Right? 

456
00:29:06,580 --> 00:29:08,590
If there are two examples here, 

457
00:29:08,980 --> 00:29:11,290
we try to achieve mostly the same thing, 

458
00:29:11,300 --> 00:29:12,740
but they have different behavior. 

459
00:29:14,440 --> 00:29:16,760
So in the first case, 

460
00:29:17,820 --> 00:29:19,410
you are going to, 

461
00:29:19,420 --> 00:29:21,090
in both cases, with sprint,

462
00:29:21,100 --> 00:29:24,600
f printer is at the end of the day, 

463
00:29:24,610 --> 00:29:27,590
it's a right operation to the terminal. 

464
00:29:28,780 --> 00:29:29,850
You give a string, 

465
00:29:30,210 --> 00:29:31,450
you bring to the terminal. 

466
00:29:31,960 --> 00:29:37,420
This is a high level api right here. 

467
00:29:37,430 --> 00:29:42,430
We have the the same kind of operation, 

468
00:29:42,440 --> 00:29:44,760
but using the low level ips right? 

469
00:29:45,280 --> 00:29:49,630
To standard out to the to the output, to the terminal.

470
00:29:51,310 --> 00:29:53,060
In both cases, what we do,

471
00:29:53,070 --> 00:29:55,410
we write a string, 

472
00:29:55,650 --> 00:29:58,520
the first part of a string begin offline. 

473
00:29:58,800 --> 00:30:00,440
Then we sleep for 10 seconds. 

474
00:30:00,650 --> 00:30:04,820
And then we ride the second part of the string, 

475
00:30:05,280 --> 00:30:09,670
but which is hence with character, slasher.

476
00:30:11,050 --> 00:30:11,500
Okay. 

477
00:30:12,500 --> 00:30:14,350
What is the difference between that? 

478
00:30:14,360 --> 00:30:16,210
What is the difference in behavior? 

479
00:30:17,130 --> 00:30:20,480
The difference in behaviour is at the first one. 

480
00:30:20,490 --> 00:30:23,880
It brings everything at once souls, although you,

481
00:30:24,030 --> 00:30:25,580
but in beginning of line, 

482
00:30:25,900 --> 00:30:31,580
you don't see anything at the terminal before you also print the end

483
00:30:31,590 --> 00:30:32,750
of the string

484
00:30:33,370 --> 00:30:36,640
which finishes which ends with carriage bitter. 

485
00:30:38,950 --> 00:30:40,170
In the second case, again,

486
00:30:40,180 --> 00:30:41,670
you spring the same thing. 

487
00:30:43,330 --> 00:30:47,380
You are going to see beginning of line printed, 

488
00:30:47,930 --> 00:30:49,070
then slip ten. 

489
00:30:49,650 --> 00:30:50,550
After 10 seconds, 

490
00:30:50,560 --> 00:30:55,060
you are going to see the end what happened under the hood? 

491
00:30:55,070 --> 00:30:57,020
And why do you have this behavior? 

492
00:30:57,930 --> 00:30:58,960
You have the behavior, 

493
00:30:58,970 --> 00:31:00,760
because in the second case, 

494
00:31:01,170 --> 00:31:03,290
you have a buffer and that buffer. 

495
00:31:03,610 --> 00:31:04,430
It is a cara. 

496
00:31:05,370 --> 00:31:06,920
You sent to the colonel, 

497
00:31:06,930 --> 00:31:10,120
this kind of the first 18 beats beginning of line. 

498
00:31:10,860 --> 00:31:13,800
And then the kernel is going to print on the terminal, 

499
00:31:13,810 --> 00:31:16,750
the second one. 

500
00:31:17,110 --> 00:31:20,210
And then when you send the last a 16 beats, 

501
00:31:20,550 --> 00:31:25,240
the colonel beautifully will print the end, right?

502
00:31:25,250 --> 00:31:28,120
Of the of the sentence. 

503
00:31:30,290 --> 00:31:31,480
In contrast, 

504
00:31:31,890 --> 00:31:35,750
with a stream level interface, 

505
00:31:36,260 --> 00:31:37,700
you have another buffer, 

506
00:31:38,100 --> 00:31:39,800
which is in the application level. 

507
00:31:41,000 --> 00:31:47,240
You don't directly write in the back kernel buffer. 

508
00:31:47,550 --> 00:31:49,470
You write in the application buffer. 

509
00:31:50,930 --> 00:31:55,670
And the application buffer is written to the kennel buffer. 

510
00:31:55,900 --> 00:31:57,110
Only when you have, 

511
00:31:57,120 --> 00:31:58,510
in this particular case, 

512
00:31:58,520 --> 00:32:05,280
when you encounter the slash character, 

513
00:32:05,290 --> 00:32:06,640
like the end of line character. 

514
00:32:08,390 --> 00:32:11,220
In this case, he printed beginning of line.

515
00:32:11,470 --> 00:32:13,840
This is going to do application buffer. 

516
00:32:13,850 --> 00:32:16,260
Nothing happens after 10 seconds. 

517
00:32:16,590 --> 00:32:22,040
You at end of line in the application buffer. 

518
00:32:22,300 --> 00:32:25,480
And then only now because you have this kind of line feet. 

519
00:32:26,270 --> 00:32:28,410
So the end of line, 

520
00:32:28,950 --> 00:32:35,620
it's the entire application buffer is is written in the kernel buffer. 

521
00:32:36,080 --> 00:32:42,150
They cannot will the right on the terminal as the entire centers. 

522
00:32:44,090 --> 00:32:44,840
Does it make sense? 

523
00:32:52,690 --> 00:32:53,640
That's what happens. 

524
00:32:54,490 --> 00:32:58,720
Now, what is it the file disk file of into the file?

525
00:32:59,000 --> 00:32:59,830
Data structure? 

526
00:32:59,840 --> 00:33:03,910
Again, this pointer to a file data structure is returned by the high level.

527
00:33:03,920 --> 00:33:05,190
Ap is by f open. 

528
00:33:06,000 --> 00:33:07,350
You have the file descriptors. 

529
00:33:07,360 --> 00:33:11,670
This is the one which is returned by the low level api which is the side integer. 

530
00:33:12,810 --> 00:33:14,880
You have the buffer, like I mentioned,

531
00:33:14,890 --> 00:33:16,600
mister buffer we are talking about, 

532
00:33:16,610 --> 00:33:18,560
you have us at the application level. 

533
00:33:19,160 --> 00:33:20,420
You also have a lock, 

534
00:33:20,430 --> 00:33:24,860
in case there are multiple threads using the file concurrently. 

535
00:33:25,110 --> 00:33:28,180
Then you want to lock and you have only one thread accessing the file

536
00:33:28,190 --> 00:33:29,100
at the same time. 

537
00:33:29,730 --> 00:33:31,730
Remember about the concurrency discussion, 

538
00:33:31,740 --> 00:33:34,850
we had last lecture. 

539
00:33:39,050 --> 00:33:41,290
There are many other things in the file data, 

540
00:33:41,550 --> 00:33:42,790
in the file data structures, 

541
00:33:42,800 --> 00:33:47,090
but this is we are not going to discuss us now. 

542
00:33:47,810 --> 00:33:48,050
Right? 

543
00:33:48,060 --> 00:33:50,170
So now when you call af right? 

544
00:33:50,720 --> 00:33:56,110
Or any kind of high level apia stream, 

545
00:33:56,120 --> 00:34:02,270
api what happens to the data you provide is a following you get to write is

546
00:34:02,280 --> 00:34:03,110
a files buffer, 

547
00:34:03,120 --> 00:34:04,270
this application buffer. 

548
00:34:04,660 --> 00:34:06,000
This is exactly what I mentioned. 

549
00:34:07,820 --> 00:34:09,120
And then you have to fly. 

550
00:34:09,130 --> 00:34:14,150
And then this application buffer or file buffer is written as a kennel buffer. 

551
00:34:14,160 --> 00:34:14,670
Any flushing. 

552
00:34:14,680 --> 00:34:20,950
You have a special inter instruction to flush in the particular case

553
00:34:20,960 --> 00:34:24,480
of the print f it is flashed when you get the line fit. 

554
00:34:27,890 --> 00:34:29,550
So that's basically what it is. 

555
00:34:34,460 --> 00:34:35,330
What does this mean? 

556
00:34:35,580 --> 00:34:36,570
When you write code, 

557
00:34:36,580 --> 00:34:40,490
you make the weakest possible assumption about how data is flushed

558
00:34:41,050 --> 00:34:42,680
from the file buffer. 

559
00:34:42,890 --> 00:34:44,040
We need to make that assumption. 

560
00:34:44,630 --> 00:34:45,870
And why is that important? 

561
00:34:46,380 --> 00:34:50,270
So your application in your application, 

562
00:34:50,280 --> 00:34:52,940
you write yourself, right?

563
00:34:53,720 --> 00:34:54,710
From your point of view, 

564
00:34:54,720 --> 00:34:59,030
you may think that all these data already made it onto the disk. 

565
00:34:59,850 --> 00:35:00,250
Right? 

566
00:35:01,220 --> 00:35:02,470
But that's not the case. 

567
00:35:03,420 --> 00:35:04,750
If you have a failure, 

568
00:35:05,140 --> 00:35:06,520
just after an f right? 

569
00:35:06,800 --> 00:35:10,150
You are not guaranteed as a beta you wrote, is making all the disk.

570
00:35:12,340 --> 00:35:13,350
In order to do that, 

571
00:35:13,360 --> 00:35:15,110
you need to make sure that is flushed. 

572
00:35:15,120 --> 00:35:18,370
The data is flushed to the kernel, and actually,

573
00:35:18,380 --> 00:35:19,530
and then from, 

574
00:35:19,540 --> 00:35:22,730
and then the kernel is going to make sure that it's going to be return

575
00:35:22,740 --> 00:35:23,250
on the risk. 

576
00:35:27,220 --> 00:35:32,620
So need to be careful about that. 

577
00:35:32,630 --> 00:35:39,330
And this is a reminder for you how use a high level cpi

578
00:35:40,610 --> 00:35:42,970
to in this particular case, 

579
00:35:44,480 --> 00:35:47,450
to write and read. 

580
00:35:47,830 --> 00:35:55,720
And this is another important aspect to allow you to understand the

581
00:35:55,730 --> 00:35:58,960
subtleties associated with this high level interface. 

582
00:35:59,500 --> 00:36:01,160
In this code, what you have,

583
00:36:01,170 --> 00:36:07,810
I have a character c and I am going to write it in a file dot text. 

584
00:36:08,370 --> 00:36:11,480
Then i'm going to open the file. 

585
00:36:11,960 --> 00:36:12,720
Again, 

586
00:36:13,590 --> 00:36:16,310
this is another descriptor here, f two.

587
00:36:16,680 --> 00:36:19,430
And i'm going to read from that file. 

588
00:36:20,510 --> 00:36:20,960
Okay? 

589
00:36:21,630 --> 00:36:23,410
You write a character in the file, 

590
00:36:23,850 --> 00:36:28,980
and you are going to read the character from the same file using different files, 

591
00:36:29,270 --> 00:36:29,900
pointers. 

592
00:36:32,920 --> 00:36:34,150
What happens in this case? 

593
00:36:34,900 --> 00:36:35,300
Right? 

594
00:36:38,900 --> 00:36:39,620
That happen? 

595
00:36:51,600 --> 00:36:51,910
Sorry, 

596
00:36:52,840 --> 00:36:57,230
you initialize x here to c and what you're writing the file is b not c sorry, 

597
00:36:57,240 --> 00:37:00,810
ii then the question, what you are going to get,

598
00:37:02,960 --> 00:37:05,270
you are going to get an anatomic behavior. 

599
00:37:07,110 --> 00:37:08,750
When you read here, 

600
00:37:09,100 --> 00:37:15,380
you can have c or you can have b so why is that? 

601
00:37:17,710 --> 00:37:19,260
Can someone say it? 

602
00:37:32,470 --> 00:37:33,540
There are two questions here, 

603
00:37:33,550 --> 00:37:34,900
so please try to, 

604
00:37:37,980 --> 00:37:39,150
yes, that's very good.

605
00:37:40,670 --> 00:37:41,900
So to answer this question, 

606
00:37:41,910 --> 00:37:45,460
and then I there is an answer to my question. 

607
00:37:46,400 --> 00:37:50,030
The answer to my question is that why you can get deterministic behavior? 

608
00:37:50,040 --> 00:37:57,940
Because you don't know any the when the files buffer is flashed to disk. 

609
00:37:58,230 --> 00:37:58,420
Right? 

610
00:37:58,430 --> 00:37:59,340
So what can happen? 

611
00:37:59,350 --> 00:38:00,020
Remember, 

612
00:38:00,460 --> 00:38:04,750
when you are going to write b that b is written in the file buffer

613
00:38:05,080 --> 00:38:05,910
in the file buffer, 

614
00:38:06,650 --> 00:38:08,320
which is associated with effort. 

615
00:38:08,880 --> 00:38:10,450
Now you open f two. 

616
00:38:10,650 --> 00:38:13,360
And now this is going to create another file buffer, 

617
00:38:13,370 --> 00:38:17,640
which is a social reserve to when you read it, 

618
00:38:18,170 --> 00:38:23,600
if this b didn't make it from the file buffer of f one to the kernel buffer

619
00:38:23,610 --> 00:38:24,680
and to the disk, 

620
00:38:25,320 --> 00:38:27,340
what you are going, you are not going to read it.

621
00:38:30,740 --> 00:38:31,870
If it made it, 

622
00:38:32,320 --> 00:38:35,450
then you are going to really be okay. 

623
00:38:36,360 --> 00:38:38,670
Basically, here you write b in a file buffer,

624
00:38:39,410 --> 00:38:41,580
and you are going to read from a different file buffer. 

625
00:38:44,980 --> 00:38:48,860
If b didn't make it from this file buffer or have fun to the disk, 

626
00:38:49,850 --> 00:38:55,540
then it's available when you are going to open the second the file using

627
00:38:55,550 --> 00:38:56,820
another file descriptor, 

628
00:38:57,230 --> 00:39:01,320
you are not going to cb now, 

629
00:39:01,330 --> 00:39:06,840
there are two other questions on the second point. 

630
00:39:07,110 --> 00:39:09,340
Does it mean that if a file buffer is full, 

631
00:39:09,350 --> 00:39:10,540
then the buffer is flushed. 

632
00:39:11,350 --> 00:39:13,300
If the file buffer is full, it is flushed.

633
00:39:14,260 --> 00:39:17,040
There are other policies you have no control of. 

634
00:39:17,630 --> 00:39:22,910
When with a file buffer can be flushed periodically even before it's full. 

635
00:39:23,670 --> 00:39:25,650
After you have data stay too much, 

636
00:39:25,660 --> 00:39:26,690
maybe in the file buffer, 

637
00:39:27,500 --> 00:39:28,780
or you can do it explicitly. 

638
00:39:29,180 --> 00:39:31,930
There is a flash comment like a mesh. 

639
00:39:33,660 --> 00:39:40,010
Why do we have to make the weakest possible assumptions on when file is flushed? 

640
00:39:41,030 --> 00:39:45,220
It's again because you do not know unless you flash it explicitly, 

641
00:39:45,620 --> 00:39:48,980
you do not know when the file buffer is flashed to the kelvin. 

642
00:39:52,390 --> 00:39:52,810
Okay? 

643
00:39:56,810 --> 00:39:57,520
Let me see. 

644
00:39:57,530 --> 00:39:58,840
There are some other questions. 

645
00:40:00,860 --> 00:40:06,550
Is there a way to atomic to do atomic file operations? 

646
00:40:08,390 --> 00:40:13,620
There is no easy way to do atomic file atomic operation. 

647
00:40:13,630 --> 00:40:14,660
You can do that. 

648
00:40:16,440 --> 00:40:18,480
And we are going to learn how to do it. 

649
00:40:20,340 --> 00:40:26,460
But one of the original designs of decision design decision in unix

650
00:40:26,800 --> 00:40:28,310
was to not support

651
00:40:28,320 --> 00:40:31,870
transaction semantics when you update the fast. 

652
00:40:32,450 --> 00:40:33,760
That's where you have database, 

653
00:40:34,560 --> 00:40:35,750
but you say you can do it, 

654
00:40:35,760 --> 00:40:40,080
but you don't have an operation to do it on an f right? 

655
00:40:40,090 --> 00:40:41,360
If the buffer is flushed, 

656
00:40:41,370 --> 00:40:44,400
does the input data go into the newly cleaned buffer? 

657
00:40:44,860 --> 00:40:48,420
Or does it get written to file as part of the flush? 

658
00:40:49,380 --> 00:40:50,960
If it's flashed the flush? 

659
00:40:51,190 --> 00:40:52,360
It's you can think, 

660
00:40:52,370 --> 00:40:53,680
as an atomic operation, 

661
00:40:54,240 --> 00:40:57,370
you flush it, and then you write in the buffer.

662
00:41:06,320 --> 00:41:08,200
Does file buffer have a default size? 

663
00:41:08,210 --> 00:41:10,720
Or does it depend on the size of the file being open? 

664
00:41:12,500 --> 00:41:13,700
That's a great question. 

665
00:41:13,990 --> 00:41:16,180
Ii think i'll check, 

666
00:41:16,190 --> 00:41:17,690
but as far as I know, 

667
00:41:17,700 --> 00:41:19,410
you have a default size, 

668
00:41:20,040 --> 00:41:23,770
which you may be able to recall to configure. 

669
00:41:25,000 --> 00:41:26,590
But from what I remember, 

670
00:41:26,600 --> 00:41:27,870
it's a default size. 

671
00:41:29,830 --> 00:41:30,500
Let's move on. 

672
00:41:30,510 --> 00:41:32,460
We have still a lot of things to cover. 

673
00:41:34,560 --> 00:41:37,260
So writing the correct code is, 

674
00:41:37,270 --> 00:41:38,660
like I mentioned to you, 

675
00:41:39,050 --> 00:41:41,510
is basically you have to flash the data. 

676
00:41:41,860 --> 00:41:44,810
Now, this is the explicit command.

677
00:41:45,350 --> 00:41:47,800
I mentioned to you ff flush. 

678
00:41:48,620 --> 00:41:49,210
Now, 

679
00:41:49,220 --> 00:41:53,120
you are going to flush to force the file buffer being flushed

680
00:41:56,600 --> 00:41:58,020
with the flow level appear. 

681
00:41:58,030 --> 00:42:01,860
We don't have this problem because you are going to write in the buffer

682
00:42:01,870 --> 00:42:03,630
or in the kernel, 

683
00:42:03,840 --> 00:42:05,630
and both the scripters, 

684
00:42:05,640 --> 00:42:10,710
when i'm going to open the file of the descriptor for the same file, 

685
00:42:10,920 --> 00:42:14,260
they are going to see the same kernel buffer. 

686
00:42:16,670 --> 00:42:16,900
Right? 

687
00:42:17,150 --> 00:42:18,860
When you have on a right completes, 

688
00:42:18,870 --> 00:42:20,660
is going to be visible to secrecy, 

689
00:42:20,670 --> 00:42:21,780
subsequent rates. 

690
00:42:23,880 --> 00:42:28,020
Now, the key question, which I expected to get and I didn't,

691
00:42:28,330 --> 00:42:29,990
but it's a very natural question. 

692
00:42:30,620 --> 00:42:32,140
The key question, 

693
00:42:32,350 --> 00:42:37,700
why do you have a buffer in in the user as a user level? 

694
00:42:37,710 --> 00:42:39,540
So why do you have the file buffer? 

695
00:42:39,770 --> 00:42:41,500
When you already have a kernel buffer? 

696
00:42:44,490 --> 00:42:48,710
The answer is one of the answers is performance. 

697
00:42:52,290 --> 00:42:54,330
If you write a character at that time, 

698
00:42:55,770 --> 00:43:01,930
if you use a stream api you are going to write the character in the file buffer. 

699
00:43:02,880 --> 00:43:04,090
This is a user level. 

700
00:43:04,850 --> 00:43:06,290
It's just a function call. 

701
00:43:08,340 --> 00:43:17,760
If you want to write one character using the low level api that's a system call. 

702
00:43:18,390 --> 00:43:25,210
It requires context switching to the kernel and a system called, 

703
00:43:25,490 --> 00:43:28,120
because the contact switching to the kernel is

704
00:43:28,130 --> 00:43:31,850
far more expensive than a local function, 

705
00:43:34,310 --> 00:43:34,710
right? 

706
00:43:35,460 --> 00:43:37,700
Which is 25 times more expensive. 

707
00:43:38,760 --> 00:43:40,960
So let me put it this way, and you should try it.

708
00:43:42,690 --> 00:43:43,550
If you write, 

709
00:43:44,720 --> 00:43:47,180
say, 1,000 characters,

710
00:43:47,190 --> 00:43:49,700
but it was a 10,000 characters. 

711
00:43:52,040 --> 00:43:54,290
If you write it character by character, 

712
00:43:55,330 --> 00:44:03,060
using the high level api will be much faster than writing character by

713
00:44:03,070 --> 00:44:08,830
character using the low level api because in the first case, 

714
00:44:08,840 --> 00:44:13,190
you are going to have a contact switching only when the buffer file buffer

715
00:44:13,200 --> 00:44:13,910
is flashed. 

716
00:44:16,240 --> 00:44:18,160
While in the second case, you have contact switching.

717
00:44:18,510 --> 00:44:21,050
Every time you write a character. 

718
00:44:26,500 --> 00:44:26,890
Sorry. 

719
00:44:32,030 --> 00:44:36,260
The other thing is that you can implement more sophisticated things

720
00:44:36,270 --> 00:44:37,060
as the user level. 

721
00:44:38,490 --> 00:44:38,860
Right? 

722
00:44:43,310 --> 00:44:45,020
The second point here about, I guess,

723
00:44:45,030 --> 00:44:47,100
see what I told you about, 

724
00:44:47,410 --> 00:44:51,800
but I think it also apply about writing, about reading.

725
00:44:52,530 --> 00:44:53,020
Right? 

726
00:44:53,350 --> 00:44:56,180
Because when you read, you can have the entire blog,

727
00:44:56,400 --> 00:44:58,430
which will be transferring the file bar for us. 

728
00:44:58,680 --> 00:45:03,550
And then when you do the fgsc on the next character, 

729
00:45:03,790 --> 00:45:05,460
then to get the next character, 

730
00:45:05,470 --> 00:45:07,500
you are going to be a local call, 

731
00:45:07,510 --> 00:45:10,020
because the block is already in the file buffer. 

732
00:45:10,350 --> 00:45:12,420
If the block is only on the kernel buffer, 

733
00:45:12,650 --> 00:45:16,340
then every time you get the next characters with a low level, 

734
00:45:16,350 --> 00:45:18,440
api is going to be a context such. 

735
00:45:19,950 --> 00:45:22,180
Hopefully, this is clarify a few things.

736
00:45:24,990 --> 00:45:30,100
Aa system called a system cooperation are less kept are system cooperation, 

737
00:45:30,110 --> 00:45:30,940
which is a low level. 

738
00:45:30,950 --> 00:45:32,180
Apis are, in general,

739
00:45:32,950 --> 00:45:34,260
less capable. 

740
00:45:34,490 --> 00:45:37,260
You can have more functions like formatting, right?

741
00:45:37,270 --> 00:45:38,220
As a high level. 

742
00:45:38,610 --> 00:45:43,320
Why it's important is because you want the kernel to be as small as possible. 

743
00:45:43,720 --> 00:45:43,730
Right? 

744
00:45:43,740 --> 00:45:44,310
You aren't, 

745
00:45:44,320 --> 00:45:47,790
because I care anything resident to the always residents in the memory. 

746
00:45:47,800 --> 00:45:51,160
And it's not only that if you have less code, 

747
00:45:51,510 --> 00:45:54,580
it's less chances to introduce box. 

748
00:45:55,190 --> 00:45:55,520
Right? 

749
00:45:57,460 --> 00:46:00,070
So that's why this is another reason for it. 

750
00:46:00,080 --> 00:46:05,900
You have stream api in high level api and low level system. 

751
00:46:05,910 --> 00:46:10,070
Api is because you can add more functionality in the file level, 

752
00:46:10,080 --> 00:46:18,750
api without making the kernel more complex process state for file skippers. 

753
00:46:18,760 --> 00:46:19,980
Let's move quickly. 

754
00:46:21,530 --> 00:46:22,800
Here we are doing, 

755
00:46:23,130 --> 00:46:26,320
let's see how the state is maintained in the kernel. 

756
00:46:26,910 --> 00:46:27,370
Right? 

757
00:46:27,770 --> 00:46:29,790
Recall on a successful code to open, 

758
00:46:29,800 --> 00:46:31,240
you have a file descriptor. 

759
00:46:31,250 --> 00:46:34,150
It's returned to the user and an open, 

760
00:46:35,470 --> 00:46:36,780
open file description. 

761
00:46:36,790 --> 00:46:41,410
So the state associated with that file descriptor is created in the cattle. 

762
00:46:42,230 --> 00:46:42,250
Right? 

763
00:46:42,260 --> 00:46:43,750
When the feature system calls, 

764
00:46:43,760 --> 00:46:48,110
the camera looks to the open file description using the file descriptor. 

765
00:46:48,630 --> 00:46:48,950
Right? 

766
00:46:49,450 --> 00:46:49,940
Okay? 

767
00:46:53,230 --> 00:46:56,760
Is a very simple of far code here. 

768
00:46:57,040 --> 00:46:58,110
This is a code. 

769
00:46:58,120 --> 00:46:59,190
We have two buffers, 

770
00:46:59,470 --> 00:47:00,710
buffer on and buffer two, 

771
00:47:00,720 --> 00:47:07,180
and we are using the system calls a low level calls to read from food or text. 

772
00:47:07,700 --> 00:47:10,910
We want to eat the first 100 bytes in buffalo one, 

773
00:47:10,920 --> 00:47:13,120
the second 51 100 bytes in buffer. 

774
00:47:14,030 --> 00:47:14,310
Right? 

775
00:47:19,710 --> 00:47:21,220
The important.here, 

776
00:47:21,230 --> 00:47:22,340
it's about the lock. 

777
00:47:22,350 --> 00:47:29,720
The current location in the file is kept by in this file description. 

778
00:47:30,170 --> 00:47:30,530
Right? 

779
00:47:30,980 --> 00:47:34,120
That's why if you have consecutive calls or read, 

780
00:47:34,400 --> 00:47:38,390
you are going first to read the first 100 by the next to read the next 100 bytes. 

781
00:47:41,860 --> 00:47:46,980
Here we just a slide showing about files of file description how it looks like. 

782
00:47:47,440 --> 00:47:52,480
This is love is a position of the current position in the file. 

783
00:47:53,870 --> 00:47:56,250
The structure of, I know we are going to talk later.

784
00:47:56,530 --> 00:47:59,300
It's where the file is located on the disk. 

785
00:48:00,280 --> 00:48:04,030
And there are a lot of other information is not important for our discussion, 

786
00:48:04,560 --> 00:48:06,400
but it's important for our discussion. 

787
00:48:06,630 --> 00:48:13,850
It's about, let's see how things are maintained in the memory.

788
00:48:15,840 --> 00:48:17,530
We have here a process. 

789
00:48:17,870 --> 00:48:19,800
And here we have the kernel, right?

790
00:48:20,120 --> 00:48:21,150
Above the dash line, 

791
00:48:21,160 --> 00:48:22,230
it has a process. 

792
00:48:22,470 --> 00:48:23,920
At the below the dash line, 

793
00:48:24,200 --> 00:48:25,810
a a it's a cab. 

794
00:48:26,300 --> 00:48:26,670
Right? 

795
00:48:28,700 --> 00:48:31,160
In the process, you have the address space,

796
00:48:32,400 --> 00:48:33,560
and then you have a thread, 

797
00:48:34,190 --> 00:48:35,640
and you have the thread registers. 

798
00:48:35,650 --> 00:48:38,040
Remember, the thread is a unit of execution.

799
00:48:38,550 --> 00:48:40,360
Every process has at least one thread, 

800
00:48:41,660 --> 00:48:41,950
right? 

801
00:48:42,680 --> 00:48:45,030
Suppose that to execute open food or text, 

802
00:48:45,420 --> 00:48:46,710
and the result is three. 

803
00:48:47,150 --> 00:48:48,190
The file descriptor, 

804
00:48:48,200 --> 00:48:50,290
which is returned by open history, 

805
00:48:52,190 --> 00:48:54,870
you have open file descriptions. 

806
00:48:55,270 --> 00:48:57,090
You have the file which is opened, 

807
00:48:57,100 --> 00:48:59,500
and the position start to be zero. 

808
00:49:01,080 --> 00:49:03,310
This is why the file descriptor points. 

809
00:49:05,570 --> 00:49:06,440
This is what I wanna. 

810
00:49:06,450 --> 00:49:10,200
The open file description is what I mentioned earlier is like the state

811
00:49:10,210 --> 00:49:13,150
of the file for them and the meta data associated with the file. 

812
00:49:16,900 --> 00:49:17,530
What is now? 

813
00:49:17,540 --> 00:49:18,690
So initially, 

814
00:49:18,700 --> 00:49:20,250
you may ask why is three? 

815
00:49:20,710 --> 00:49:25,190
Because the standard being standard out and standard error at 01, 

816
00:49:25,200 --> 00:49:26,930
and two are already taken. 

817
00:49:27,190 --> 00:49:29,490
Remember, this has a default file descriptors.

818
00:49:31,930 --> 00:49:35,230
Next, suppose that you execute read from this file descriptors,

819
00:49:36,110 --> 00:49:38,330
the first 100 bytes in this buffer. 

820
00:49:38,590 --> 00:49:38,910
Right? 

821
00:49:39,230 --> 00:49:40,550
Remember the previous code? 

822
00:49:41,140 --> 00:49:41,510
Right? 

823
00:49:42,460 --> 00:49:44,610
You read that, and once you read it,

824
00:49:45,030 --> 00:49:48,440
the position, notice in the open file description,

825
00:49:48,690 --> 00:49:52,370
it's a set updated to 100. 

826
00:49:56,250 --> 00:49:59,080
Now, suppose that you execute close three,

827
00:49:59,630 --> 00:50:00,910
you execute closely. 

828
00:50:01,440 --> 00:50:05,600
The file descriptor is gone as well as a file description. 

829
00:50:06,760 --> 00:50:07,100
Right? 

830
00:50:07,460 --> 00:50:08,370
So it's simply enough. 

831
00:50:09,050 --> 00:50:09,340
Right? 

832
00:50:11,440 --> 00:50:13,660
But now, instead of closing,

833
00:50:14,650 --> 00:50:17,450
after you read the first 100 bytes, let's say we fork.

834
00:50:19,280 --> 00:50:21,350
Now, if you for, remember,

835
00:50:23,110 --> 00:50:26,180
the entire state in the entire code of the parent process

836
00:50:26,190 --> 00:50:32,490
is going to be copied in the child process. 

837
00:50:33,220 --> 00:50:38,760
So this is going also to have what is going to happen is a file descriptors

838
00:50:38,770 --> 00:50:40,340
are going to be copied. 

839
00:50:40,810 --> 00:50:44,130
Now, you have to the same open file descriptions.

840
00:50:44,410 --> 00:50:46,790
You have two pointers, 

841
00:50:47,420 --> 00:50:49,380
three, both of them are three, obviously,

842
00:50:49,390 --> 00:50:52,890
because that's how you indexing this open file description, 

843
00:50:53,620 --> 00:50:55,820
one from parent process, 

844
00:50:56,530 --> 00:50:57,790
and one from the child process. 

845
00:50:59,420 --> 00:50:59,760
Right? 

846
00:51:00,760 --> 00:51:02,190
You are shared the same state, 

847
00:51:02,200 --> 00:51:04,710
the shared state in the open file description. 

848
00:51:05,580 --> 00:51:05,910
Right? 

849
00:51:06,870 --> 00:51:12,450
Now, if you read from buffer 100 or inform process one,

850
00:51:12,890 --> 00:51:14,530
using the file descriptor three, 

851
00:51:14,540 --> 00:51:16,850
now the position is advanced to hundred. 

852
00:51:17,950 --> 00:51:19,190
Now, if you read,

853
00:51:19,430 --> 00:51:23,050
the process is the charlie process that is from the same file descriptor. 

854
00:51:23,360 --> 00:51:23,980
What happens? 

855
00:51:24,550 --> 00:51:26,860
The position is updated to 300, 

856
00:51:27,250 --> 00:51:27,670
because again, 

857
00:51:27,680 --> 00:51:32,920
both the child and the parent operate on of the same open file description. 

858
00:51:37,310 --> 00:51:39,460
Now, when you closely is apparent,

859
00:51:40,670 --> 00:51:47,410
the file from the that is closed from the perspective of process one, 

860
00:51:47,840 --> 00:51:50,750
but the open file description is not destroyed, 

861
00:51:50,990 --> 00:51:56,360
because it's still referred by the client by the child process. 

862
00:51:57,880 --> 00:52:03,720
So only when the child process is going to close its own, 

863
00:52:04,360 --> 00:52:06,670
the file descriptor three, 

864
00:52:07,070 --> 00:52:10,310
only then open file description associated with the file descriptor three

865
00:52:10,320 --> 00:52:11,910
is going to go away. 

866
00:52:18,060 --> 00:52:19,330
The cool thing about this. 

867
00:52:19,780 --> 00:52:22,250
Now you can have remembered one of the potential, 

868
00:52:22,260 --> 00:52:23,850
and we are going to learn more about that. 

869
00:52:24,210 --> 00:52:28,190
One of the problems, when you have processes, on one hand,

870
00:52:28,200 --> 00:52:33,540
you have strong isolation because each of them comes with own file system

871
00:52:33,630 --> 00:52:35,860
which own other space. 

872
00:52:36,520 --> 00:52:39,840
But you still want to communicate in some cases between the process. 

873
00:52:40,580 --> 00:52:41,930
This is one way to communicate. 

874
00:52:42,760 --> 00:52:42,910
Right? 

875
00:52:42,920 --> 00:52:44,150
You open a file, 

876
00:52:45,240 --> 00:52:46,910
you fork a child, 

877
00:52:47,560 --> 00:52:51,670
then both the child and the parent have access to the fallacy

878
00:52:51,680 --> 00:52:52,710
with the same fallacy. 

879
00:52:53,150 --> 00:52:55,550
You can use file system to exchange the data. 

880
00:53:00,420 --> 00:53:00,690
Again, 

881
00:53:00,700 --> 00:53:06,420
this is the same repeating it that everything or every device

882
00:53:06,780 --> 00:53:09,070
and its abstraction is a file, 

883
00:53:09,370 --> 00:53:11,970
like disks, networking,

884
00:53:12,450 --> 00:53:15,810
and receive some other communication primitives. 

885
00:53:16,160 --> 00:53:18,540
This means that they are going to have a high level

886
00:53:18,550 --> 00:53:21,100
at the same high level api open, 

887
00:53:21,110 --> 00:53:22,260
read, write clothes.

888
00:53:26,030 --> 00:53:31,580
The same thing happened when you have for the first default descriptor, 01,

889
00:53:31,590 --> 00:53:32,180
and 2, 

890
00:53:32,590 --> 00:53:36,090
obviously, they are going to be shared between the child and the parent.

891
00:53:36,830 --> 00:53:37,120
Right? 

892
00:53:37,950 --> 00:53:40,480
So if the child and the parent are going to write, 

893
00:53:41,670 --> 00:53:46,130
you are going to see interleaved the whatever they are writing on the terminal, 

894
00:53:46,450 --> 00:53:47,000
for instance. 

895
00:53:48,620 --> 00:53:49,050
Okay. 

896
00:53:53,520 --> 00:53:54,320
It's a game. 

897
00:53:55,400 --> 00:53:57,430
If one process is concluded standard in, 

898
00:53:57,440 --> 00:54:02,130
this means that you can no longer get an input from the keyboard. 

899
00:54:02,390 --> 00:54:06,900
Then the process the child is the only one which can receive inputs

900
00:54:06,910 --> 00:54:07,980
from the keyboard. 

901
00:54:08,600 --> 00:54:09,900
And that's very important, 

902
00:54:10,120 --> 00:54:12,270
because you may want in your program, 

903
00:54:12,280 --> 00:54:15,850
only the child process to get the input from The keyboard, 

904
00:54:15,860 --> 00:54:18,730
not both across both parents and the child. 

905
00:54:24,830 --> 00:54:28,540
So many of the things we talk about and we are going to talk

906
00:54:28,550 --> 00:54:32,320
in the remaining of the lecture are going to be helpful for you in home

907
00:54:32,330 --> 00:54:34,390
or do when you have to write a shout. 

908
00:54:39,080 --> 00:54:43,620
Therefore could be very useful for metal king because you can handle

909
00:54:43,630 --> 00:54:45,580
each connection in a different process. 

910
00:54:47,620 --> 00:54:51,860
Now there is another way you can share the access to the same file, 

911
00:54:52,280 --> 00:54:54,280
and that is using dupe. 

912
00:54:55,270 --> 00:54:55,780
Okay? 

913
00:54:56,180 --> 00:54:59,570
So what loop is meaning you replicate the file descriptors, 

914
00:54:59,580 --> 00:55:03,810
and the file descriptor is going to point to the same open file description. 

915
00:55:04,670 --> 00:55:07,660
Here you have is that you like think about on an arias, 

916
00:55:08,380 --> 00:55:11,640
but I see if you create it and you open a file, 

917
00:55:11,650 --> 00:55:13,840
you got the file descriptor three. 

918
00:55:15,010 --> 00:55:16,890
Now, if you can call dope on three,

919
00:55:16,900 --> 00:55:18,780
you are going to get a four. 

920
00:55:20,340 --> 00:55:20,560
Now, 

921
00:55:20,570 --> 00:55:25,340
both file descriptor three and four point out to the same open file description. 

922
00:55:27,280 --> 00:55:28,420
There is another instruction, 

923
00:55:28,430 --> 00:55:29,460
which is the tool, 

924
00:55:30,090 --> 00:55:31,410
which has a second argument. 

925
00:55:32,480 --> 00:55:35,500
The second argument is actually saying, 

926
00:55:35,510 --> 00:55:42,350
what is a file descriptor you want to point up to the same open file description, 

927
00:55:42,650 --> 00:55:45,980
like the far the first argument in the call, in this case,

928
00:55:46,270 --> 00:55:47,780
file descriptor three. 

929
00:55:51,620 --> 00:55:52,890
This is useful. 

930
00:55:52,900 --> 00:55:56,210
If, for instance, you have multiple processes of the same application,

931
00:55:56,220 --> 00:55:57,370
you run all of them. 

932
00:55:57,750 --> 00:55:58,940
You have a barrier, 

933
00:55:58,950 --> 00:56:00,440
you have a constant there, 

934
00:56:00,450 --> 00:56:01,940
basically say each of them, 

935
00:56:02,170 --> 00:56:03,580
they should open. 

936
00:56:03,590 --> 00:56:06,940
They should operate on the files descriptor, 

937
00:56:07,440 --> 00:56:08,230
162, 

938
00:56:09,870 --> 00:56:11,060
like one process, 

939
00:56:11,310 --> 00:56:13,080
create a file open, the files,

940
00:56:13,090 --> 00:56:14,360
then it calls stoop. 

941
00:56:14,680 --> 00:56:18,130
And then everyone can operate on that file descriptor. 

942
00:56:21,000 --> 00:56:23,020
We are running a little bit late. 

943
00:56:25,830 --> 00:56:29,140
So here are some based on what they discussed. 

944
00:56:29,510 --> 00:56:32,970
There are some challenges or some things you need to be

945
00:56:32,980 --> 00:56:35,980
careful with when you work with the file systems. 

946
00:56:36,400 --> 00:56:42,980
This is particularly very important to for your homework and projects. 

947
00:56:44,550 --> 00:56:48,890
First, don't fork in a process that already has multiple threads.

948
00:56:51,170 --> 00:56:51,980
Why? 

949
00:56:52,550 --> 00:56:55,990
Because the threads are not for, 

950
00:56:57,740 --> 00:56:58,130
right? 

951
00:56:58,510 --> 00:57:01,090
You for the state of the process that is copied, 

952
00:57:02,050 --> 00:57:05,400
you are going when you copy it a process, 

953
00:57:06,090 --> 00:57:12,020
when you duplicate all the state from the parent to the child. 

954
00:57:13,750 --> 00:57:16,530
The threats are not copied, 

955
00:57:16,770 --> 00:57:18,730
because their executions are ephemeral. 

956
00:57:19,880 --> 00:57:20,260
Right? 

957
00:57:22,790 --> 00:57:24,280
In the second, in the child,

958
00:57:24,290 --> 00:57:25,640
you have only one process, 

959
00:57:26,820 --> 00:57:27,370
one thread. 

960
00:57:29,290 --> 00:57:30,930
All the other cells will disappear. 

961
00:57:33,560 --> 00:57:34,350
So many member, 

962
00:57:35,160 --> 00:57:38,350
only the threat that calls a fog existing the new process. 

963
00:57:41,740 --> 00:57:43,280
This is and remember, 

964
00:57:43,290 --> 00:57:44,480
when you call exact, 

965
00:57:44,900 --> 00:57:48,450
you don't care about it whether there are multiple steps because exact

966
00:57:48,950 --> 00:57:52,530
is basically replace the entire space of the

967
00:57:52,540 --> 00:57:57,990
process who called exec with a program which is going to be executed

968
00:57:59,110 --> 00:58:00,110
in that process. 

969
00:58:01,360 --> 00:58:01,790
Okay? 

970
00:58:04,100 --> 00:58:08,300
Be very mindful when you mix a low level and high level failures. 

971
00:58:12,000 --> 00:58:13,710
It's again, the main reason.

972
00:58:13,950 --> 00:58:19,220
Remember, high level ipoiio has a file pointer and a file buffer.

973
00:58:19,760 --> 00:58:20,660
They have the file buffer. 

974
00:58:21,960 --> 00:58:22,280
That, 

975
00:58:23,270 --> 00:58:24,300
in this case, 

976
00:58:24,840 --> 00:58:25,740
for instance, 

977
00:58:27,360 --> 00:58:31,400
when here a it's a subtly subtle problem. 

978
00:58:32,430 --> 00:58:33,090
In this case, 

979
00:58:33,940 --> 00:58:40,710
you open a file a with a high level api you get file pointer f and then you

980
00:58:40,720 --> 00:58:42,030
get from that file pointer, 

981
00:58:42,040 --> 00:58:43,270
you get the file descriptor. 

982
00:58:44,090 --> 00:58:48,780
Now you call f read on that file and read on that file. 

983
00:58:50,500 --> 00:58:52,770
And the file a file read, you'll get,

984
00:58:53,030 --> 00:58:55,170
you say, I want to read only the first 10 bytes,

985
00:58:56,670 --> 00:58:57,920
and then with a read, 

986
00:58:57,930 --> 00:59:01,220
which is a low level api want to read the next 10 bytes. 

987
00:59:02,440 --> 00:59:05,000
We started expect when you look at this code, 

988
00:59:05,010 --> 00:59:08,020
I say every do will read the file, 

989
00:59:08,030 --> 00:59:09,300
the first 10 bytes, 

990
00:59:10,450 --> 00:59:12,280
read or read the next 10 bytes. 

991
00:59:14,790 --> 00:59:16,030
The problems they may not me, 

992
00:59:16,040 --> 00:59:18,630
maybe that might not happen, 

993
00:59:19,710 --> 00:59:24,680
because every it returns to the applications of first and bytes. 

994
00:59:25,430 --> 00:59:26,810
But from the kernel, 

995
00:59:27,070 --> 00:59:28,670
it may get an entire block, 

996
00:59:29,870 --> 00:59:33,410
which is going to be stored in the file buffer. 

997
00:59:35,060 --> 00:59:38,060
So you may get the first 4,000 bytes from the fire, 

998
00:59:40,920 --> 00:59:43,760
which means that in the kernel, 

999
00:59:44,030 --> 00:59:46,820
in the associated file description, 

1000
00:59:48,020 --> 00:59:50,480
the position now will be 4,000. 

1001
00:59:51,500 --> 00:59:52,990
So when you call the read, 

1002
00:59:53,250 --> 00:59:55,080
this will go directly to the kernel. 

1003
00:59:55,580 --> 00:59:57,450
It will read from the current position. 

1004
00:59:57,730 --> 01:00:05,820
So it may lead the bites from 4,000 to 4,000 before continuing. 

1005
01:00:07,820 --> 01:00:12,260
Actually, let me answer this question on an f right?

1006
01:00:12,270 --> 01:00:13,740
If the buffer is flushed, 

1007
01:00:14,590 --> 01:00:17,670
does the input data go into the newly clean buffer? 

1008
01:00:17,680 --> 01:00:19,550
Or does it get written to the farthest? 

1009
01:00:19,720 --> 01:00:20,990
I answer this question. 

1010
01:00:21,850 --> 01:00:22,290
Right? 

1011
01:00:22,980 --> 01:00:24,150
First, you do the flash.

1012
01:00:24,380 --> 01:00:32,070
Then you are going to arrive in your data announcements. 

1013
01:00:33,120 --> 01:00:35,800
The group da assignments have been released. 

1014
01:00:36,280 --> 01:00:37,700
If you don't know yet. 

1015
01:00:38,050 --> 01:00:39,330
Take on pizza. 

1016
01:00:41,380 --> 01:00:43,300
Project zero is due today. 

1017
01:00:44,670 --> 01:00:46,260
Good luck with a submission. 

1018
01:00:48,170 --> 01:00:51,050
And project one will be released on friday. 

1019
01:00:53,210 --> 01:00:54,280
Other than that, 

1020
01:00:54,920 --> 01:00:56,850
many of you are still online. 

1021
01:00:57,220 --> 01:01:00,490
Please start planning on how your group will collaborate is

1022
01:01:00,500 --> 01:01:01,490
the most effective way. 

1023
01:01:02,440 --> 01:01:03,800
Virtual coffee hours, 

1024
01:01:03,810 --> 01:01:05,560
a regular brainstorming meeting. 

1025
01:01:05,990 --> 01:01:07,710
And again, 

1026
01:01:07,720 --> 01:01:10,110
try to communicate as much as possible. 

1027
01:01:16,140 --> 01:01:18,060
Now we switch the gears, 

1028
01:01:18,920 --> 01:01:26,110
and we are going to talk about how two processes can communicate to each other. 

1029
01:01:31,230 --> 01:01:33,760
One way to communicate is using the networking. 

1030
01:01:34,720 --> 01:01:38,280
This is a very general way to communicate between two processes, 

1031
01:01:38,820 --> 01:01:43,960
because you can do that even when processes run on different measures. 

1032
01:01:46,080 --> 01:01:55,680
And this is can happen when you have your web browser and what if your browser, 

1033
01:01:56,770 --> 01:01:59,490
this is how your browser communicate with a web brow, 

1034
01:01:59,500 --> 01:02:00,570
with a web server. 

1035
01:02:04,970 --> 01:02:08,430
And under the hood use tcpip protocol. 

1036
01:02:09,280 --> 01:02:10,750
We are going to learn about it. 

1037
01:02:11,130 --> 01:02:14,200
For now, we just the suffice to say,

1038
01:02:14,450 --> 01:02:18,450
and to take a look about the api the api is very similar. 

1039
01:02:18,940 --> 01:02:20,450
When you want to send data, 

1040
01:02:21,770 --> 01:02:23,890
you essentially what is called a socket. 

1041
01:02:24,580 --> 01:02:25,850
This is, in some sense,

1042
01:02:25,860 --> 01:02:30,100
think about the equivalent of the file descriptor and the file description

1043
01:02:30,110 --> 01:02:30,940
with the socket. 

1044
01:02:32,810 --> 01:02:35,760
You are going to write to that socket, 

1045
01:02:36,320 --> 01:02:38,560
like you write for a file profile descriptor, 

1046
01:02:38,920 --> 01:02:40,060
but otherwise, 

1047
01:02:40,950 --> 01:02:44,130
the api is the same right? 

1048
01:02:44,140 --> 01:02:46,910
Or file descriptors above a certain length. 

1049
01:02:48,350 --> 01:02:49,610
Then on the receiving side, 

1050
01:02:49,620 --> 01:02:51,170
when you want to get data, 

1051
01:02:51,180 --> 01:02:53,530
you are going to have a read. 

1052
01:02:53,900 --> 01:02:57,300
Again, the same api read from the far less guitar.

1053
01:02:57,660 --> 01:03:04,020
This is the socket descriptor in a buffer of a certain size. 

1054
01:03:07,290 --> 01:03:07,430
Again, 

1055
01:03:07,440 --> 01:03:14,300
we are going to have an entire lecture about the cpip what is the other way

1056
01:03:14,310 --> 01:03:16,540
to communicate between processes? 

1057
01:03:16,550 --> 01:03:18,900
Another way to communicate between processes? 

1058
01:03:19,590 --> 01:03:24,490
Like you'll see that are using pipes and using the shared memory. 

1059
01:03:25,390 --> 01:03:25,790
But, 

1060
01:03:26,540 --> 01:03:28,690
again, taking her back, a step back,

1061
01:03:29,110 --> 01:03:33,550
here, we want fundamentally to punch a hole between the processes,

1062
01:03:35,160 --> 01:03:37,760
because otherwise, the process cannot communicate with each other.

1063
01:03:37,770 --> 01:03:41,910
That's entire idea about processes to be isolated from each other. 

1064
01:03:43,010 --> 01:03:45,130
Each of them has its own other space. 

1065
01:03:45,640 --> 01:03:50,790
They cannot address data from each other's other space. 

1066
01:03:55,980 --> 01:03:57,090
Here is one example. 

1067
01:04:01,960 --> 01:04:03,120
This is about shared memory, 

1068
01:04:03,350 --> 01:04:06,300
but before, let's again, sing again,

1069
01:04:07,720 --> 01:04:11,710
recall a guy about how processes are protected from each other. 

1070
01:04:12,610 --> 01:04:16,120
You have two processes here on the left and the right hand side. 

1071
01:04:16,680 --> 01:04:17,430
Right program. 

1072
01:04:17,440 --> 01:04:20,950
One runs in the first process program during the second process. 

1073
01:04:21,760 --> 01:04:25,250
If then you have each process with its own code, 

1074
01:04:25,540 --> 01:04:27,490
data segment, heap, and stuck.

1075
01:04:29,140 --> 01:04:34,490
Now, both processes share the same physical others,

1076
01:04:34,810 --> 01:04:36,300
physical memory. 

1077
01:04:37,910 --> 01:04:40,130
In the middle, you have the physical memory.

1078
01:04:41,700 --> 01:04:44,140
The physical memory is divided into regions. 

1079
01:04:46,700 --> 01:04:48,550
And this into, 

1080
01:04:49,040 --> 01:04:53,350
and what happens is the operating system or the kernel map, 

1081
01:04:55,340 --> 01:04:56,690
the code, the daytime,

1082
01:04:56,700 --> 01:05:00,560
the heap from different processes in different regions. 

1083
01:05:01,690 --> 01:05:02,020
Right? 

1084
01:05:03,010 --> 01:05:05,280
And these regions are to be joined it. 

1085
01:05:05,960 --> 01:05:06,510
Okay? 

1086
01:05:07,090 --> 01:05:12,330
That's why you cannot address the data from another process. 

1087
01:05:14,570 --> 01:05:16,180
Because in the physical memory, 

1088
01:05:16,560 --> 01:05:22,200
each process owns a the joint pace of others. 

1089
01:05:27,140 --> 01:05:32,670
And the reason the way you achieve that it is through translation. 

1090
01:05:32,680 --> 01:05:34,350
Again, we are going to learn about that.

1091
01:05:34,360 --> 01:05:35,750
That's where the magic happens, 

1092
01:05:36,140 --> 01:05:40,980
and making sure that the processes do not step on each other, those.

1093
01:05:47,610 --> 01:05:51,670
So that's what we have despite of this. 

1094
01:05:51,930 --> 01:05:55,420
And despite this protection and followed by the kernel, 

1095
01:05:55,800 --> 01:05:58,020
we still want to communicate between processes, 

1096
01:05:58,700 --> 01:05:58,900
right? 

1097
01:05:58,910 --> 01:05:59,620
Like we mentioned. 

1098
01:06:03,370 --> 01:06:05,010
So how do we do that? 

1099
01:06:05,020 --> 01:06:07,410
And we already shown some example in the sockets. 

1100
01:06:08,210 --> 01:06:09,180
Another way, 

1101
01:06:09,950 --> 01:06:13,220
you already know, you can use file system,

1102
01:06:14,210 --> 01:06:14,650
right? 

1103
01:06:15,300 --> 01:06:17,730
A file system can write to a file data, 

1104
01:06:17,740 --> 01:06:19,570
and sorry, 

1105
01:06:19,580 --> 01:06:21,850
a process can drive data to a file. 

1106
01:06:22,790 --> 01:06:25,180
The process can read from the same file, 

1107
01:06:25,190 --> 01:06:30,270
the data written by the first process using the read and write primitives. 

1108
01:06:34,550 --> 01:06:34,950
Now, 

1109
01:06:35,760 --> 01:06:36,700
you can do that. 

1110
01:06:37,220 --> 01:06:39,410
However, this is quite expensive,

1111
01:06:40,490 --> 01:06:42,180
because the right or file, 

1112
01:06:42,840 --> 01:06:48,220
it's expensive and reading from a file and slow. 

1113
01:06:49,050 --> 01:06:51,300
And also, in most of the cases,

1114
01:06:51,550 --> 01:06:53,200
you don't need a persistence store. 

1115
01:06:54,330 --> 01:06:55,370
It's an overkill. 

1116
01:06:56,240 --> 01:06:56,740
Okay? 

1117
01:06:57,780 --> 01:07:05,060
Like, think about if you want to go from your client to your web browser,

1118
01:07:05,850 --> 01:07:09,050
you don't need to start every request and every reply. 

1119
01:07:09,810 --> 01:07:12,730
Furthermore, this works only on the same machine.

1120
01:07:14,280 --> 01:07:16,030
Otherwise, you need a distributed file system.

1121
01:07:17,210 --> 01:07:19,650
If the processes are not located on the same machine, 

1122
01:07:23,070 --> 01:07:29,350
one solution is to have ability to have shared memory. 

1123
01:07:30,290 --> 01:07:32,500
And the operating system provides that ability. 

1124
01:07:33,570 --> 01:07:39,940
You can actually create a memory if a process can create a memory and share

1125
01:07:39,950 --> 01:07:41,540
and say that

1126
01:07:41,550 --> 01:07:43,780
memory can be shared with other processes. 

1127
01:07:48,230 --> 01:07:50,330
And therefore, 

1128
01:07:50,740 --> 01:07:51,750
in this case, 

1129
01:07:52,110 --> 01:07:55,260
both processes one and two, 

1130
01:07:55,970 --> 01:08:01,560
they are going to.to share the same share space in the physical memory, 

1131
01:08:01,960 --> 01:08:03,540
which means that within this space, 

1132
01:08:03,550 --> 01:08:05,090
they can share of it. 

1133
01:08:06,080 --> 01:08:06,470
Okay? 

1134
01:08:07,540 --> 01:08:12,010
There is an api there is a way by which you can create shared memory

1135
01:08:12,670 --> 01:08:15,150
and a shared memory regions and

1136
01:08:15,160 --> 01:08:19,710
share that region between two different processes. 

1137
01:08:19,720 --> 01:08:19,790
See? 

1138
01:08:27,260 --> 01:08:28,550
It's a question. 

1139
01:08:29,050 --> 01:08:32,670
What is the benefit to having memory of the individual processes be deterred? 

1140
01:08:33,400 --> 01:08:38,930
The benefit of having the memory of individual processes be designed is

1141
01:08:38,940 --> 01:08:40,220
to ensure protection. 

1142
01:08:41,320 --> 01:08:48,760
You do not want a malicious process to access the memory of another process. 

1143
01:08:49,550 --> 01:08:52,370
What words to access a memory of the cat? 

1144
01:08:56,500 --> 01:08:57,790
Hopefully answers the question. 

1145
01:09:08,430 --> 01:09:09,630
What about the other things? 

1146
01:09:09,990 --> 01:09:15,940
What about if we want to is anything that kernel can provide us

1147
01:09:16,380 --> 01:09:19,110
to facilitate the communication between two processes? 

1148
01:09:27,760 --> 01:09:28,950
By the way, 

1149
01:09:30,180 --> 01:09:32,170
so the asset it is, 

1150
01:09:32,460 --> 01:09:40,190
which I only alluded by providing this kind of socket mechanism, 

1151
01:09:42,060 --> 01:09:44,990
like I when I talk about the cpip right? 

1152
01:09:45,340 --> 01:09:46,940
But fundamentally, it's, again,

1153
01:09:46,950 --> 01:09:48,380
the abstraction you want, 

1154
01:09:48,390 --> 01:09:53,040
which is useful to provide is like a queue, right?

1155
01:09:53,470 --> 01:09:56,420
Because we do not want at least four processes. 

1156
01:09:56,660 --> 01:09:58,210
We run on the same machine. 

1157
01:09:58,470 --> 01:09:59,920
We want to kind of in memory queue. 

1158
01:10:00,300 --> 01:10:00,630
Right? 

1159
01:10:00,970 --> 01:10:06,120
Again, we don't want to build something on top of the storage file storage.

1160
01:10:06,610 --> 01:10:08,500
We said it's too expensive, 

1161
01:10:09,310 --> 01:10:10,130
too slow. 

1162
01:10:16,620 --> 01:10:17,690
What is memory? 

1163
01:10:17,700 --> 01:10:18,130
Cube? 

1164
01:10:18,140 --> 01:10:23,940
Means is basically the semantic is that a process just push the data

1165
01:10:23,950 --> 01:10:24,870
to the cure. 

1166
01:10:25,090 --> 01:10:28,580
And the other is the producer and the consumer read from the queue. 

1167
01:10:29,010 --> 01:10:29,460
Right? 

1168
01:10:29,710 --> 01:10:34,030
And typically, the cues it's in first out,

1169
01:10:34,040 --> 01:10:35,670
there are other kinds of cues, 

1170
01:10:35,910 --> 01:10:37,670
like last in, first out, but typically is,

1171
01:10:37,920 --> 01:10:42,090
in first out, what we are going to talk this in this lecture.

1172
01:10:43,260 --> 01:10:47,420
One abstraction of such fuel is a pipe, is a unique spike.

1173
01:10:49,480 --> 01:10:50,710
So the unique spike, 

1174
01:10:50,950 --> 01:10:53,450
you are the way you can open a pipe. 

1175
01:10:54,060 --> 01:10:57,370
And you can, again, it's like a file, a scripture.

1176
01:10:58,210 --> 01:11:05,450
You can use read and write when you write

1177
01:11:06,030 --> 01:11:13,490
you right at the end of the pipe when you read from the front of the pipe. 

1178
01:11:14,390 --> 01:11:14,890
Okay? 

1179
01:11:15,290 --> 01:11:17,140
That's exactly that you sum up. 

1180
01:11:19,660 --> 01:11:20,050
Now, 

1181
01:11:22,950 --> 01:11:26,410
these five and you have a buffer of a certain size, 

1182
01:11:26,970 --> 01:11:28,130
it's not infinite. 

1183
01:11:29,650 --> 01:11:34,610
If the pipe is full than the right blocks, 

1184
01:11:34,620 --> 01:11:36,410
you can no longer, 

1185
01:11:37,050 --> 01:11:37,800
right, 

1186
01:11:37,810 --> 01:11:44,500
is a bike unless the consumer a process released from the pipe and makes

1187
01:11:44,510 --> 01:11:46,790
room for new data to be returned in the pipe. 

1188
01:11:47,980 --> 01:11:51,950
The same if the pipe is empty and you want to read from the pipe you block

1189
01:11:51,960 --> 01:11:55,420
and it looks until someone put some data in the pipe. 

1190
01:12:04,400 --> 01:12:06,080
When you create a pipe, 

1191
01:12:06,740 --> 01:12:09,060
what you get to file descriptors, 

1192
01:12:09,070 --> 01:12:10,780
like you in my imagine, 

1193
01:12:11,280 --> 01:12:13,180
one file descriptors to, 

1194
01:12:14,130 --> 01:12:14,760
right? 

1195
01:12:14,770 --> 01:12:17,680
2 and 15 is still the descriptor to read from. 

1196
01:12:19,410 --> 01:12:19,770
Right? 

1197
01:12:19,780 --> 01:12:28,370
So five, you have the that file descriptor is to read from file this zero.

1198
01:12:30,310 --> 01:12:34,650
And file descriptor one is the second file descriptor is to write. 

1199
01:12:37,490 --> 01:12:39,060
And it's implemented, like I mentioned,

1200
01:12:39,070 --> 01:12:40,140
as a fixed size two. 

1201
01:12:42,620 --> 01:12:46,700
Right here is how you can use it. 

1202
01:12:48,840 --> 01:12:49,580
You can, 

1203
01:12:50,600 --> 01:12:52,030
you create a file, again,

1204
01:12:52,040 --> 01:12:53,310
kind of a pipe. 

1205
01:12:54,210 --> 01:13:01,320
And then you are going to write to the second file descriptor. 

1206
01:13:01,330 --> 01:13:03,720
You are going to read from the second file, first file descriptors,

1207
01:13:04,520 --> 01:13:08,490
and make sure that when you close both file descriptors, 

1208
01:13:14,090 --> 01:13:15,870
so piled between the processes, 

1209
01:13:16,730 --> 01:13:17,970
Again, here a greater pipe,

1210
01:13:17,980 --> 01:13:20,450
you get the first file descriptor, three and four,

1211
01:13:20,800 --> 01:13:23,060
pointing to read and write from that pipe. 

1212
01:13:23,670 --> 01:13:24,740
Now you do a fork. 

1213
01:13:25,450 --> 01:13:29,710
The file descriptors are copied. 

1214
01:13:30,380 --> 01:13:36,080
And now you also have this file descriptors pointing to the same instance

1215
01:13:36,090 --> 01:13:36,640
of the pipe. 

1216
01:13:37,570 --> 01:13:37,950
Right? 

1217
01:13:39,770 --> 01:13:42,130
So if you want to write to use that, 

1218
01:13:42,690 --> 01:13:45,530
despite to communicate between the parent and the child, 

1219
01:13:46,440 --> 01:13:48,340
then you need also, 

1220
01:13:50,460 --> 01:13:54,570
this is in one direction. 

1221
01:13:55,500 --> 01:13:56,770
In this particular case, 

1222
01:13:56,780 --> 01:13:58,370
I want the parents say, 

1223
01:13:58,380 --> 01:14:03,340
I want the parent to send data to the child, 

1224
01:14:03,990 --> 01:14:04,350
right? 

1225
01:14:07,930 --> 01:14:08,900
I gave the pipe, 

1226
01:14:09,950 --> 01:14:11,090
which is not shown here. 

1227
01:14:12,170 --> 01:14:13,110
And then I fork, 

1228
01:14:14,660 --> 01:14:15,360
remember, 

1229
01:14:17,050 --> 01:14:21,080
if the result of the fork is not zero, 

1230
01:14:21,840 --> 01:14:26,900
this means that I I am the parent when I execute the code. 

1231
01:14:28,160 --> 01:14:31,210
Because the result from the fork is going to be the PIB is

1232
01:14:31,220 --> 01:14:33,010
a process identifier of the child. 

1233
01:14:34,910 --> 01:14:38,040
Then I'm going to write the second descriptor, 

1234
01:14:38,390 --> 01:14:41,960
and I'm going to close the this is a writer, skipper,

1235
01:14:42,540 --> 01:14:44,020
pipe fd of one. 

1236
01:14:44,430 --> 01:14:48,300
And then to close the read descriptor. 

1237
01:14:48,790 --> 01:14:49,310
Why? 

1238
01:14:49,320 --> 01:14:51,030
Because again, in this example,

1239
01:14:51,390 --> 01:14:56,220
I I want only the parent to write to comment to send data to the child. 

1240
01:14:56,920 --> 01:14:59,070
The same for the child. 

1241
01:14:59,590 --> 01:14:59,950
Right? 

1242
01:15:00,290 --> 01:15:02,860
I am going to read from the file, 

1243
01:15:02,870 --> 01:15:04,220
first file descriptors. 

1244
01:15:04,560 --> 01:15:05,870
And I don't want to write, 

1245
01:15:05,880 --> 01:15:08,190
so I'm going to close that I described. 

1246
01:15:09,920 --> 01:15:13,620
So this is what happens closely and close for. 

1247
01:15:13,630 --> 01:15:14,100
Right. 

1248
01:15:14,770 --> 01:15:15,280
Now, 

1249
01:15:15,290 --> 01:15:21,680
the pattern I have is that the pattern process is going to send data

1250
01:15:21,690 --> 01:15:23,980
to the child process survive. 

1251
01:15:28,830 --> 01:15:33,680
If you want to the other way around to get the child to communicate to the parent, 

1252
01:15:34,290 --> 01:15:38,210
you can do the other way around by closing the other file descriptors. 

1253
01:15:46,640 --> 01:15:53,560
When do we get end of file on a pipe after the last Friday? 

1254
01:15:53,570 --> 01:15:55,440
So after the last ride, 

1255
01:15:55,450 --> 01:15:57,440
descriptor is closed to a bike, 

1256
01:15:57,990 --> 01:15:59,060
if you continue to read. 

1257
01:15:59,070 --> 01:16:01,490
So if you continue to read from a pipe, 

1258
01:16:02,120 --> 01:16:04,180
and there is no right descriptor, 

1259
01:16:04,550 --> 01:16:07,890
open for that far for that pipe, 

1260
01:16:08,210 --> 01:16:09,320
you get end of five. 

1261
01:16:12,180 --> 01:16:16,680
If the grid descriptor is closed, 

1262
01:16:17,270 --> 01:16:20,620
and you try to write to a file, you get a sick pipe.

1263
01:16:20,630 --> 01:16:21,500
This is the interact. 

1264
01:16:23,900 --> 01:16:25,610
You can ignore it, 

1265
01:16:26,790 --> 01:16:28,780
but then the right will fail. 

1266
01:16:30,470 --> 01:16:30,740
All right? 

1267
01:16:31,450 --> 01:16:32,130
So here, 

1268
01:16:32,840 --> 01:16:35,080
if you close a ride a scripter, 

1269
01:16:37,380 --> 01:16:40,810
then and you continue to read from that pipe, 

1270
01:16:41,230 --> 01:16:42,470
you are going to get on the file. 

1271
01:16:48,160 --> 01:16:51,320
Now, once you have a communication,

1272
01:16:51,330 --> 01:16:52,640
establish a communication, 

1273
01:16:53,190 --> 01:16:54,080
we need a protocol. 

1274
01:16:54,790 --> 01:17:02,240
The protocol need about how we are going to communicate between two parties. 

1275
01:17:02,890 --> 01:17:03,390
Okay? 

1276
01:17:03,960 --> 01:17:05,870
The protocol will have a syntax, 

1277
01:17:07,930 --> 01:17:08,240
right? 

1278
01:17:08,980 --> 01:17:12,550
Which will specify how you need to specify. 

1279
01:17:12,560 --> 01:17:15,750
You specify the protocol, the format,

1280
01:17:16,500 --> 01:17:18,890
the message order or things like that. 

1281
01:17:19,340 --> 01:17:22,920
How do you send and receive data? 

1282
01:17:22,930 --> 01:17:27,120
And then the semantics is that what communication means? 

1283
01:17:27,890 --> 01:17:28,300
Right? 

1284
01:17:29,090 --> 01:17:33,270
When you make a call to send some data, 

1285
01:17:33,860 --> 01:17:35,120
what actually happens? 

1286
01:17:35,990 --> 01:17:36,340
Right? 

1287
01:17:37,100 --> 01:17:37,570
Okay? 

1288
01:17:38,050 --> 01:17:42,910
Is the data always guaranteed to get to the destination or may be lost? 

1289
01:17:43,730 --> 01:17:44,130
Right? 

1290
01:17:44,480 --> 01:17:50,880
A is a data guarantee to be get is a destination of the receiver guarantee

1291
01:17:50,890 --> 01:17:54,080
to get the data in the same order in your send out. 

1292
01:17:58,690 --> 01:18:00,340
It's also more complicated, 

1293
01:18:01,040 --> 01:18:03,880
because if you communicate over network, 

1294
01:18:04,530 --> 01:18:10,290
different computers make you have different data formats, 

1295
01:18:11,120 --> 01:18:13,780
you need to convert between different formats. 

1296
01:18:16,530 --> 01:18:17,900
This is also part of the product. 

1297
01:18:20,390 --> 01:18:20,910
Okay? 

1298
01:18:21,480 --> 01:18:23,110
This is things and things about, 

1299
01:18:25,060 --> 01:18:26,340
like you talk about telephone, 

1300
01:18:26,990 --> 01:18:27,400
right? 

1301
01:18:27,880 --> 01:18:28,710
You pick up, 

1302
01:18:29,310 --> 01:18:30,470
you dial the number, 

1303
01:18:31,150 --> 01:18:33,420
then you talk with your friend. 

1304
01:18:34,000 --> 01:18:36,470
And then at the end, 

1305
01:18:37,410 --> 01:18:38,780
you end up, right?

1306
01:18:39,560 --> 01:18:40,140
You hang up. 

1307
01:18:43,360 --> 01:18:44,560
But the protocol here, 

1308
01:18:44,980 --> 01:18:52,070
part of the protocol is is about what are the part of the

1309
01:18:52,840 --> 01:18:56,010
protocols like like pick up the phone and open it? 

1310
01:18:56,020 --> 01:18:56,730
It's like an open. 

1311
01:18:58,480 --> 01:19:01,580
Closing the phone is closing the call. 

1312
01:19:02,900 --> 01:19:04,170
It's like a close. 

1313
01:19:04,600 --> 01:19:07,310
And then the break in me in the middle you have read and writes. 

1314
01:19:07,920 --> 01:19:10,280
But what I mean by the protocol here, like, for instance,

1315
01:19:10,290 --> 01:19:13,580
the dial is how you are going to contact the other party. 

1316
01:19:13,850 --> 01:19:14,870
That's part of the protocol. 

1317
01:19:16,640 --> 01:19:17,290
It's a number, 

1318
01:19:17,870 --> 01:19:18,170
right? 

1319
01:19:18,180 --> 01:19:23,010
We need to figure out then is that this kind of part of the total value

1320
01:19:23,020 --> 01:19:24,610
where typically you start with the hello. 

1321
01:19:25,210 --> 01:19:26,530
But I I'm here, 

1322
01:19:27,070 --> 01:19:27,490
right? 

1323
01:19:28,110 --> 01:19:33,380
Also, it's used implicitly to recognize because the other party,

1324
01:19:33,390 --> 01:19:35,460
if your friend is going to recognize your voice, 

1325
01:19:36,620 --> 01:19:40,820
or may be recognized because of the number you see she or he sees. 

1326
01:19:41,550 --> 01:19:42,770
And then before hanging up, 

1327
01:19:42,780 --> 01:19:44,270
you don't just hang up. 

1328
01:19:44,280 --> 01:19:45,170
You say, bye.

1329
01:19:45,530 --> 01:19:50,310
Right, you also that's implicit protocol here on your boss.

1330
01:19:51,070 --> 01:19:53,060
You expect for the other person to talk. 

1331
01:19:53,480 --> 01:19:53,880
Right? 

1332
01:19:54,680 --> 01:19:55,360
So things like that. 

1333
01:19:55,710 --> 01:19:56,160
Okay. 

1334
01:19:58,410 --> 01:20:03,970
Okay, so the website about it,

1335
01:20:03,980 --> 01:20:05,690
this is a very simple example. 

1336
01:20:05,960 --> 01:20:08,170
You also have a high level protocol, 

1337
01:20:08,180 --> 01:20:09,190
its application protocol, 

1338
01:20:09,410 --> 01:20:10,880
which have a request and reply. 

1339
01:20:12,250 --> 01:20:13,840
That's how you are going. 

1340
01:20:15,620 --> 01:20:19,210
You see the results from the websites, 

1341
01:20:19,220 --> 01:20:22,400
from your Facebook account, 

1342
01:20:22,410 --> 01:20:24,920
or when you do a query on Google. 

1343
01:20:25,270 --> 01:20:27,340
This is exactly how things are working. 

1344
01:20:27,350 --> 01:20:28,540
You send a request, 

1345
01:20:28,890 --> 01:20:32,590
you get a reply which is going to be rendered and shown to you in our process. 

1346
01:20:35,620 --> 01:20:37,780
So I'm going to stop here. 

1347
01:20:40,940 --> 01:20:44,470
In the meantime, I'm going to take the last question.

1348
01:20:44,480 --> 01:20:46,120
So we are done. 

1349
01:20:46,130 --> 01:20:48,640
So for people who ask the questions, 

1350
01:20:48,650 --> 01:20:52,170
I'm going to spend a few more minutes to answer this question. 

1351
01:21:04,380 --> 01:21:05,330
This has a question. 

1352
01:21:05,340 --> 01:21:06,770
Actually, I missed recently.

1353
01:21:09,420 --> 01:21:14,460
What happens if the new argument in the dot two function

1354
01:21:14,470 --> 01:21:17,900
is already being used as another file the skater? 

1355
01:21:18,850 --> 01:21:25,800
Great question is the old one is overwritten

1356
01:21:28,690 --> 01:21:36,240
by www why is file io slow? 

1357
01:21:36,250 --> 01:21:43,950
The file io is slow is because every operation like read and write leads

1358
01:21:43,960 --> 01:21:46,150
to context switching to the kernel. 

1359
01:21:46,840 --> 01:21:50,910
It has to be implemented by the is going to be executed by the killer. 

1360
01:21:52,210 --> 01:21:56,610
If you are going to write one character at a time, 

1361
01:21:58,310 --> 01:22:00,100
the low level file, 

1362
01:22:01,430 --> 01:22:06,530
what will cause that for every character, 

1363
01:22:07,490 --> 01:22:12,550
you have a context switch from the user process to the kernel, 

1364
01:22:13,930 --> 01:22:15,640
for the kernel to write the character, 

1365
01:22:15,650 --> 01:22:19,000
you write 1,000 characters, 

1366
01:22:19,510 --> 01:22:20,550
one by one. 

1367
01:22:21,010 --> 01:22:23,250
Then you have 1,000 context switches. 

1368
01:22:24,490 --> 01:22:26,220
And the context switch is expensive. 

1369
01:22:27,650 --> 01:22:32,400
You need to save the state of the process below the state of the operating system. 

1370
01:22:32,710 --> 01:22:33,680
And then go back. 

1371
01:22:35,240 --> 01:22:39,840
Like i've shown you from this data is twelve twenty, 

1372
01:22:39,850 --> 01:22:41,040
no function call, 

1373
01:22:41,570 --> 01:22:50,180
is at least one or remind you faster than a system called to the operating system. 

1374
01:22:52,590 --> 01:22:53,230
So why? 

1375
01:22:53,240 --> 01:22:55,590
So we can buy between any two processes. 

1376
01:22:56,080 --> 01:23:00,650
You can buy between any two processes on the same machine. 

1377
01:23:03,600 --> 01:23:05,390
It's a question from miles. 

1378
01:23:05,400 --> 01:23:08,430
Can a process ever make a Malaysia system call? 

1379
01:23:08,920 --> 01:23:11,920
Can you assume they're relying on the kernel for IPC secure? 

1380
01:23:12,890 --> 01:23:13,920
You can assume, 

1381
01:23:14,370 --> 01:23:17,450
because the operating system is, again, you can,

1382
01:23:17,460 --> 01:23:21,360
on the way you ask the operating system to do something, 

1383
01:23:21,650 --> 01:23:23,480
is to put some data, 

1384
01:23:23,850 --> 01:23:25,280
the system call, 

1385
01:23:25,730 --> 01:23:27,080
and the file descriptor, 

1386
01:23:27,090 --> 01:23:29,520
the argument for the system calls in the registers. 

1387
01:23:31,040 --> 01:23:34,550
The operating system is going to read the context of the registers. 

1388
01:23:35,080 --> 01:23:38,100
This is how is going to execute the system call. 

1389
01:23:38,110 --> 01:23:42,900
And one reading is going to validate the data you put in the registers. 

1390
01:23:44,960 --> 01:23:48,310
You assume that the validation is done correctly. 

1391
01:23:48,590 --> 01:23:49,810
And therefore, 

1392
01:23:50,550 --> 01:23:51,820
by using a system call, 

1393
01:23:51,830 --> 01:23:54,620
you cannot cause any harm to the operating system. 

1394
01:23:58,350 --> 01:24:04,840
Let me see whether there are any other questions on the chat. 

1395
01:24:06,390 --> 01:24:07,060
It's the norm. 

1396
01:24:07,070 --> 01:24:07,780
Last one. 

1397
01:24:07,790 --> 01:24:11,500
It looked like the physical memory of a single process was the joint. 

1398
01:24:11,510 --> 01:24:15,300
I was wondering why not keep the physical memory of each process continuous. 

1399
01:24:15,690 --> 01:24:16,850
That's an excellent question, 

1400
01:24:17,790 --> 01:24:18,710
Jasper. 

1401
01:24:19,780 --> 01:24:24,090
So the reason is you cannot have contiguous, 

1402
01:24:24,100 --> 01:24:29,110
because you do not know as the beginning of the process of a program, 

1403
01:24:29,120 --> 01:24:30,610
how much memory you need. 

1404
01:24:31,600 --> 01:24:35,670
Why a simple reason is, for instance, a stack,

1405
01:24:36,120 --> 01:24:37,600
you don't know how much stack will grow. 

1406
01:24:38,920 --> 01:24:40,760
Another reason is hip. 

1407
01:24:41,380 --> 01:24:43,570
When you allocate dynamically memories, 

1408
01:24:43,580 --> 01:24:45,610
a program allocate dynamically memory, 

1409
01:24:46,750 --> 01:24:50,200
do you know how much a program is going to allocate? 

1410
01:24:52,100 --> 01:24:53,290
Because of this reason? 

1411
01:24:53,300 --> 01:24:58,410
And because the address space in the virtual address space about everything

1412
01:24:58,420 --> 01:25:01,230
that they the user sees can

1413
01:25:01,240 --> 01:25:04,300
be much larger than the physical address space, 

1414
01:25:04,720 --> 01:25:12,560
then there is no way the you cannot allocate a contiguous region. 

1415
01:25:16,570 --> 01:25:17,070
Thank you. 

1416
01:25:18,160 --> 01:25:18,980
Thanks, everyone.

1417
01:25:18,990 --> 01:25:21,630
Good luck with first project. 

1418
01:25:22,310 --> 01:25:28,980
And i'll see you next week. 

