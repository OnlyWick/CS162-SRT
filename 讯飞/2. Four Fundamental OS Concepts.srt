1
00:00:09,960 --> 00:00:12,310
Welcome everyone to the second lecture. 

2
00:00:14,700 --> 00:00:15,890
Today we are going to learn

3
00:00:15,900 --> 00:00:19,970
about the four fundamental oils operating system concepts. 

4
00:00:22,300 --> 00:00:27,090
As always, please ask your questions on q and a channel.

5
00:00:28,820 --> 00:00:32,770
I will stop from time to time to read the questions and answer them. 

6
00:00:34,430 --> 00:00:36,500
First, let me start with some announcements.

7
00:00:36,510 --> 00:00:42,630
So I will have for now one office hours on mondays between noon and 1:00 pm

8
00:00:42,640 --> 00:00:45,990
and there is more demand are going to add more of its hours. 

9
00:00:47,900 --> 00:00:53,750
Next monday, it's in our office towers, actually, that should be monday,

10
00:00:53,760 --> 00:00:54,550
not wednesday. 

11
00:00:55,200 --> 00:00:57,960
It don't be an office hour, memorial day,

12
00:00:57,970 --> 00:00:59,100
and we'll add, 

13
00:00:59,110 --> 00:01:00,680
it will be office hour, 

14
00:01:00,690 --> 00:01:01,840
will be a zoom. 

15
00:01:03,000 --> 00:01:08,740
I will add the link to the zoom on the class web page. 

16
00:01:10,600 --> 00:01:14,670
Just a reminder that the drop deadline is this friday, 

17
00:01:15,410 --> 00:01:16,620
early drop deadline. 

18
00:01:17,400 --> 00:01:17,980
Please. 

19
00:01:21,910 --> 00:01:24,500
If you are thinking about dropping this class, 

20
00:01:24,510 --> 00:01:25,660
do it right away, 

21
00:01:26,310 --> 00:01:31,130
because this will let other people from the waiting list to enroll in the class. 

22
00:01:34,360 --> 00:01:35,790
Finally, please,

23
00:01:35,800 --> 00:01:41,340
after the drop deadline start to sign up for the groups. 

24
00:01:42,500 --> 00:01:43,380
Remember, 

25
00:01:46,430 --> 00:01:55,440
we ask you to have four people in a group and try that all people to attend. 

26
00:01:55,450 --> 00:01:57,320
These are the same sections. 

27
00:01:57,660 --> 00:01:58,960
This is preferable. 

28
00:01:59,660 --> 00:02:01,960
Or maybe if that's not possible, 

29
00:02:01,970 --> 00:02:06,220
if there are two sections taught by the same theory, 

30
00:02:08,130 --> 00:02:12,660
this is in order to have consistent feedback for your projects. 

31
00:02:15,900 --> 00:02:17,660
During the semester. 

32
00:02:35,200 --> 00:02:37,790
Again, there are some quick questions on the chart.

33
00:02:39,270 --> 00:02:44,100
Please ask questions on the q and a channel, not on the chart, but now,

34
00:02:44,740 --> 00:02:47,690
one question is that can we have today's lecture slice, 

35
00:02:47,700 --> 00:02:51,570
firstly to piazza due to website being done? 

36
00:02:51,580 --> 00:02:54,970
Well, hopefully, the website will come back up,

37
00:02:54,980 --> 00:02:56,930
but yes, 

38
00:02:56,940 --> 00:02:58,570
we can pause them on piazza. 

39
00:02:58,580 --> 00:03:00,990
And a second question is, 

40
00:03:01,000 --> 00:03:05,450
when all the pia section preferences form would be released, 

41
00:03:06,470 --> 00:03:10,870
not sure any da happy a rather than if you are. 

42
00:03:12,310 --> 00:03:16,120
Here, please answer this question.

43
00:03:16,130 --> 00:03:16,720
If not, 

44
00:03:18,050 --> 00:03:18,680
alan, 

45
00:03:19,790 --> 00:03:20,850
you ask this question, 

46
00:03:20,860 --> 00:03:23,490
please also proceed and get outside and we get the answer there. 

47
00:03:35,240 --> 00:03:40,470
What do I to section by the same ta so what I mean here is that if not all people, 

48
00:03:40,480 --> 00:03:41,750
if there are t as, 

49
00:03:42,250 --> 00:03:45,420
that would be t as or some of the t as I have two sections. 

50
00:03:47,780 --> 00:03:52,050
If not, all of you in the same group can go to the same section,

51
00:03:52,980 --> 00:03:59,330
pick two sections which are taught by the same pa will the class

52
00:03:59,340 --> 00:04:02,250
expand to get all the people on the wait list? 

53
00:04:03,180 --> 00:04:04,460
This class, again,

54
00:04:04,470 --> 00:04:06,180
although it's online, is limited,

55
00:04:06,190 --> 00:04:13,990
because the ta resources and the staff of the class doesn't actually have

56
00:04:14,000 --> 00:04:21,910
any kind of is not the way we do not decide who is going to get

57
00:04:21,920 --> 00:04:22,870
from the wait list, 

58
00:04:23,600 --> 00:04:26,230
who is going to get in at all in the class. 

59
00:04:27,220 --> 00:04:28,650
Is the department decision? 

60
00:04:30,230 --> 00:04:31,840
Please ask them. 

61
00:04:32,970 --> 00:04:38,680
We can do much about it when I say I refer to the staff of the class, 

62
00:04:40,370 --> 00:04:42,530
myself and the t as and adidas. 

63
00:04:44,340 --> 00:04:45,980
Let's move on. 

64
00:04:50,880 --> 00:04:57,710
And last thing I want to say is that please avoid private piazza posts. 

65
00:04:58,450 --> 00:04:59,760
Because in many cases, 

66
00:04:59,770 --> 00:05:01,920
you are not the only one to have a question, 

67
00:05:01,930 --> 00:05:04,800
many other people who have the or have the same questions. 

68
00:05:05,770 --> 00:05:07,360
If it's a personal questions, 

69
00:05:08,890 --> 00:05:11,230
you should use a private pizza post. 

70
00:05:11,670 --> 00:05:13,710
But otherwise, please try as much as possible,

71
00:05:13,720 --> 00:05:14,870
not to use it. 

72
00:05:20,110 --> 00:05:24,760
So let's go and start with the lecture. 

73
00:05:25,760 --> 00:05:27,070
What is an operating system? 

74
00:05:27,080 --> 00:05:30,630
We discussed a little bit last time during the last lecture. 

75
00:05:31,810 --> 00:05:33,680
This is one slide from the last lecture, 

76
00:05:33,690 --> 00:05:38,690
basically saying that the operating system is a software receipt

77
00:05:38,700 --> 00:05:40,700
between hardware and the applications. 

78
00:05:42,770 --> 00:05:45,970
It's implements and provides to the application. 

79
00:05:45,980 --> 00:05:50,420
A bunch of very useful functionality provides an easy, 

80
00:05:50,430 --> 00:05:53,410
convenient abstraction to the applications. 

81
00:05:53,820 --> 00:05:59,350
So make it much easier to write the applications and using the raw hardware, 

82
00:06:00,200 --> 00:06:04,720
protect access of between the application and between the application

83
00:06:04,730 --> 00:06:07,440
and the operating system to the sharing sources, 

84
00:06:08,630 --> 00:06:13,400
provide security and application and provide communication among logical entities. 

85
00:06:14,450 --> 00:06:16,770
And if you remember, we also have this slide,

86
00:06:18,040 --> 00:06:21,510
which basically says about how you can look at the operating system

87
00:06:21,520 --> 00:06:24,430
between based on the function it provides. 

88
00:06:25,550 --> 00:06:27,670
I wanna on a certain function it provides. 

89
00:06:28,040 --> 00:06:32,340
So in one way to look at is like illusionist, 

90
00:06:32,910 --> 00:06:41,590
this is when the operating system magically abstract the hardware to the application. 

91
00:06:42,430 --> 00:06:50,190
And it provides an illusion that the application use a dedicated machine

92
00:06:51,350 --> 00:06:59,350
with an infinite memory and has access to all the files

93
00:07:00,980 --> 00:07:04,770
and other resources on the same dedicated machines. 

94
00:07:05,840 --> 00:07:09,700
So that's a very convenient abstraction for the users

95
00:07:09,710 --> 00:07:11,300
and for the application developer. 

96
00:07:12,860 --> 00:07:14,010
In reality, 

97
00:07:14,180 --> 00:07:15,290
an application, 

98
00:07:15,340 --> 00:07:17,290
sorry, the system,

99
00:07:17,300 --> 00:07:22,710
the harder is shared between multiple applications and multiple users. 

100
00:07:23,070 --> 00:07:24,520
So therefore, 

101
00:07:24,530 --> 00:07:30,760
you need to arbitrate the access of the resources and share resources

102
00:07:30,770 --> 00:07:32,200
between these applications. 

103
00:07:33,200 --> 00:07:37,750
This is when the operating system plays a role of the referee. 

104
00:07:40,250 --> 00:07:44,860
So he needs to provide isolation between the processes and the applications. 

105
00:07:45,340 --> 00:07:51,240
And you need to protect one process from another and the operating system

106
00:07:51,250 --> 00:07:52,020
from processes. 

107
00:07:52,550 --> 00:07:54,360
And finally, 

108
00:07:54,370 --> 00:07:59,360
this application in these processes often to implement more sophisticated functionality, 

109
00:07:59,370 --> 00:08:02,160
they need to communicate with each other. 

110
00:08:03,350 --> 00:08:04,940
They need to share resources. 

111
00:08:05,290 --> 00:08:12,400
And they need to use stimuli be used as same services. 

112
00:08:12,410 --> 00:08:17,060
And these are all of the operating system to provide the services. 

113
00:08:17,070 --> 00:08:23,570
You can think about providing the glue which keep together and make

114
00:08:23,950 --> 00:08:26,060
this application to work together. 

115
00:08:26,070 --> 00:08:29,240
So it provides a storage, right?

116
00:08:29,730 --> 00:08:33,680
Which can be used by every application it provides within those systems. 

117
00:08:33,990 --> 00:08:35,140
And we provide networking, 

118
00:08:35,150 --> 00:08:38,770
which helps the applications communicate with each other. 

119
00:08:41,840 --> 00:08:44,680
So that's pretty much we are. 

120
00:08:45,320 --> 00:08:47,340
And next, 

121
00:08:47,780 --> 00:08:51,010
let me just stop here to see other than any other questions. 

122
00:08:51,020 --> 00:08:52,610
No new questions. 

123
00:08:57,810 --> 00:09:01,570
And let's go a little bit through the operating system history. 

124
00:09:01,580 --> 00:09:02,090
Again, 

125
00:09:02,100 --> 00:09:07,110
the operating system abstracting away the harder and making the job

126
00:09:07,120 --> 00:09:10,750
of the application developer easier making it much easier to develop

127
00:09:10,760 --> 00:09:11,710
this application. 

128
00:09:12,120 --> 00:09:17,530
This was from very early on since the first computers have been developed. 

129
00:09:18,670 --> 00:09:19,140
Okay? 

130
00:09:19,640 --> 00:09:21,430
There are several distinct phases. 

131
00:09:22,660 --> 00:09:25,050
The first phase, which I alluded last time,

132
00:09:25,480 --> 00:09:29,050
is that when harder was very expensive and human such, it.

133
00:09:29,290 --> 00:09:36,390
So this picture shows a you see a pretty large room that's the room which

134
00:09:36,400 --> 00:09:37,910
hosted the entire computer. 

135
00:09:38,210 --> 00:09:38,430
Right? 

136
00:09:38,440 --> 00:09:39,750
You need a big room, 

137
00:09:41,080 --> 00:09:44,800
almost like a warehouse room to host the entire computer. 

138
00:09:45,220 --> 00:09:45,620
Right? 

139
00:09:46,130 --> 00:09:47,950
These are extremely expensive. 

140
00:09:47,960 --> 00:09:49,950
This very early computers, 

141
00:09:49,960 --> 00:09:53,840
maybe you heard about like any arc in 50s, 

142
00:09:55,460 --> 00:09:59,270
millions or tens of millions of dollars in today's money. 

143
00:10:00,810 --> 00:10:07,500
Then this was a age in which you have very expensive computers and humans

144
00:10:07,510 --> 00:10:09,150
are allowed to be cheap. 

145
00:10:10,180 --> 00:10:11,060
Right? 

146
00:10:13,250 --> 00:10:19,880
What means that is that you want to optimize to use very efficiently as a computer. 

147
00:10:20,320 --> 00:10:24,270
You don't want to necessarily to optimize the time of the humans, 

148
00:10:24,700 --> 00:10:26,020
because they are cheap, remember.

149
00:10:26,290 --> 00:10:26,640
Right? 

150
00:10:27,140 --> 00:10:28,760
So if they need to, 

151
00:10:29,430 --> 00:10:37,430
humans need to to spend more time to optimize their programs and to make

152
00:10:37,440 --> 00:10:41,090
the hardware usage more efficient than so be. 

153
00:10:41,570 --> 00:10:42,600
It is perfectly fine. 

154
00:10:43,810 --> 00:10:45,090
This was, again,

155
00:10:45,100 --> 00:10:48,090
the age when thomas watson, 

156
00:10:48,100 --> 00:10:52,380
the founder and chairman of ibm in 1943, 

157
00:10:53,750 --> 00:10:57,950
was saying that I think there is a world market for maybe five computers. 

158
00:11:04,180 --> 00:11:09,240
Thomas watson also is calls award a greater salesman by the time

159
00:11:09,250 --> 00:11:10,760
of his death in 56. 

160
00:11:12,250 --> 00:11:16,770
Then the next big stage is in 80s, 70s, and 80s,

161
00:11:16,780 --> 00:11:19,600
and is the rise of the personal computer, 

162
00:11:20,160 --> 00:11:20,610
right? 

163
00:11:21,110 --> 00:11:22,990
In mid 70s, 

164
00:11:24,540 --> 00:11:32,540
that when the first apple was released seven and I think it was 76, 

165
00:11:33,870 --> 00:11:41,780
you have ibmp cs and compatible computers being released when hardware

166
00:11:41,790 --> 00:11:44,340
was becoming cheaper and human more expensive. 

167
00:11:44,350 --> 00:11:48,990
Now everyone was having access wanted to a computer. 

168
00:11:49,290 --> 00:11:52,380
And you have a computer on every desk in every home. 

169
00:11:52,800 --> 00:11:55,040
That was a vision of bill gates, 

170
00:11:55,050 --> 00:11:58,420
a founder and of microsoft. 

171
00:11:59,340 --> 00:11:59,770
Finally, 

172
00:11:59,780 --> 00:12:04,490
we are today when the hardware is really cheap and humans are really expensive. 

173
00:12:05,250 --> 00:12:07,440
Here we are talking about, 

174
00:12:08,600 --> 00:12:13,050
you have not only about your phone or tablet of your p cs, 

175
00:12:13,400 --> 00:12:19,600
but we are talking about more and more of devices around you. 

176
00:12:19,890 --> 00:12:22,540
They have they have processors, 

177
00:12:22,550 --> 00:12:27,190
your tv your automotive, 

178
00:12:27,690 --> 00:12:28,700
your car, 

179
00:12:28,980 --> 00:12:35,590
and each of these platforms and devices, 

180
00:12:35,900 --> 00:12:40,670
they do have an operating system on which they will implement, 

181
00:12:40,990 --> 00:12:44,180
or developers implement specialized application in the control

182
00:12:44,190 --> 00:12:47,260
of your thermal state to your tv and so forth. 

183
00:12:51,420 --> 00:12:55,280
The other think what happens? 

184
00:12:55,720 --> 00:13:01,750
And we'll see that this kind of different phases led

185
00:13:01,760 --> 00:13:04,350
to different requirements on the operating systems. 

186
00:13:04,820 --> 00:13:07,690
The other thing it's also was driven, 

187
00:13:07,700 --> 00:13:11,410
and also these distinct phases is by the hardware, 

188
00:13:14,360 --> 00:13:17,670
becoming more and more plentiful, faster, and faster,

189
00:13:17,680 --> 00:13:18,790
and cheaper and cheaper. 

190
00:13:19,830 --> 00:13:27,600
This led to from computers who are hosted in one huge room to compute a

191
00:13:27,610 --> 00:13:30,440
switch can be on your watch, 

192
00:13:30,450 --> 00:13:30,840
right? 

193
00:13:34,800 --> 00:13:38,160
And this lead, 

194
00:13:38,490 --> 00:13:42,320
for instance, when in the early brace of the big computer,

195
00:13:43,790 --> 00:13:46,410
the main way to use them as batch processing. 

196
00:13:47,010 --> 00:13:47,430
Right? 

197
00:13:47,870 --> 00:13:53,400
And what was bash processing means is that you put your job in a cure, 

198
00:13:53,410 --> 00:13:56,840
you can actually have you went there to some punish cards, 

199
00:13:56,950 --> 00:13:58,990
which one is your ipo program? 

200
00:13:59,410 --> 00:14:02,460
And you gives a program to the operators, 

201
00:14:02,470 --> 00:14:05,510
and you come the next day to get the results. 

202
00:14:05,520 --> 00:14:05,730
Right? 

203
00:14:05,740 --> 00:14:11,330
This is what we mean is that from time of the program or is not that important, 

204
00:14:11,340 --> 00:14:12,570
then because it was cheap. 

205
00:14:13,250 --> 00:14:16,740
And the computer time was very expensive. 

206
00:14:17,340 --> 00:14:19,370
You want to have very high utilization. 

207
00:14:19,380 --> 00:14:23,170
And one way to have high utilization is that always you have a program to run, 

208
00:14:23,180 --> 00:14:26,260
so you have a queue of programs which are submitted, 

209
00:14:26,490 --> 00:14:27,900
and you run it one by one, 

210
00:14:27,910 --> 00:14:30,500
and then you are going to get the results and it finished. 

211
00:14:30,750 --> 00:14:33,220
It takes hours for everyone sometime days. 

212
00:14:34,760 --> 00:14:39,190
Then it's going to be multi programming and the multi programming beans. 

213
00:14:39,200 --> 00:14:43,010
Now you have they are a little bit cheaper. 

214
00:14:43,240 --> 00:14:46,550
And then you want to start to use, 

215
00:14:46,790 --> 00:14:49,110
there are computers in a more interactive way. 

216
00:14:52,410 --> 00:14:56,040
Multi programming means now that instead of one program at a time, 

217
00:14:56,050 --> 00:14:59,040
you have multiple programs running at the same time. 

218
00:14:59,050 --> 00:15:00,040
You have that one. 

219
00:15:00,360 --> 00:15:03,880
So the time you wait for the program to finish can be reduced. 

220
00:15:04,760 --> 00:15:06,190
And then it's time sharing, 

221
00:15:06,200 --> 00:15:09,860
which now you are using the computer in a more interactive way. 

222
00:15:10,200 --> 00:15:13,090
But as you have terminals which are connected with the computer, 

223
00:15:13,490 --> 00:15:14,320
and in that case, 

224
00:15:14,650 --> 00:15:20,290
the computer after wait after the human to type to write the program

225
00:15:20,300 --> 00:15:22,210
and then to execute the program, 

226
00:15:23,810 --> 00:15:25,120
you have, obviously,

227
00:15:25,130 --> 00:15:29,240
the personal computer is where you have a computer dedicated per human. 

228
00:15:29,680 --> 00:15:31,150
In that case, 

229
00:15:31,460 --> 00:15:34,770
the computer now is either 99% of the time, 

230
00:15:34,780 --> 00:15:38,590
because it's waiting for you for the humans to take some action, 

231
00:15:39,480 --> 00:15:43,700
so for the computer to respond and so forth. 

232
00:15:43,710 --> 00:15:47,740
And then obiquitous devices are obviously the devices I mentioned rio, 

233
00:15:48,070 --> 00:15:53,400
like your thermostate and devices in your car and things like that. 

234
00:15:54,770 --> 00:15:55,170
Okay? 

235
00:15:59,010 --> 00:16:04,640
The operating system is a huge variety of operating systems in terms of complexity. 

236
00:16:04,940 --> 00:16:10,090
You can imagine that the operating system to control on your thermal state

237
00:16:10,100 --> 00:16:12,880
is probably much simpler than operating system

238
00:16:12,890 --> 00:16:16,030
to control super computer. 

239
00:16:18,840 --> 00:16:22,510
A small lawyers can be just have hundreds of lines of code

240
00:16:22,520 --> 00:16:26,080
while larger ones can have tens of million slides of code. 

241
00:16:26,890 --> 00:16:27,910
And they are very, 

242
00:16:27,920 --> 00:16:34,710
very expensive to develop because of the cost of development or is from scratch. 

243
00:16:35,450 --> 00:16:36,800
It is very high. 

244
00:16:36,810 --> 00:16:39,860
Actually, most modern operating system have a long lineage.

245
00:16:40,290 --> 00:16:40,730
Right? 

246
00:16:41,320 --> 00:16:45,250
You can trace back the lineage long tens of years, 

247
00:16:45,260 --> 00:16:46,990
the decades ago. 

248
00:16:47,200 --> 00:16:50,150
But I saw that in linear means I was there for that. 

249
00:16:51,350 --> 00:16:54,340
Operating system from today are some improved version

250
00:16:54,350 --> 00:16:56,140
of some very old operating systems. 

251
00:16:57,870 --> 00:17:00,180
This is one lineage, 

252
00:17:00,190 --> 00:17:02,020
which is mostly aa stink. 

253
00:17:02,030 --> 00:17:04,240
Now, this was from baltics.

254
00:17:04,250 --> 00:17:10,120
It's so the one of the most the first operating system, 

255
00:17:10,130 --> 00:17:14,620
which was multitasking multi program and time shared. 

256
00:17:17,640 --> 00:17:19,040
This is an ancestor of unix, 

257
00:17:19,050 --> 00:17:22,120
and this is then you have adnt unease. 

258
00:17:22,410 --> 00:17:32,260
Better claim is bsd unique is old critics annoy us in absd then you have actually, 

259
00:17:33,180 --> 00:17:35,330
from mike, he says, michael, ken,

260
00:17:35,340 --> 00:17:37,510
we are going to to learn a little bit about. 

261
00:17:37,520 --> 00:17:41,620
It is still developed by kennedy mellon universities and ips this is

262
00:17:41,630 --> 00:17:44,580
plus unix bsd you see here up. 

263
00:17:44,710 --> 00:17:48,380
This is berkeley standard distribution is what will be as this stands for. 

264
00:17:49,040 --> 00:17:53,980
Then the source used to develop next step. 

265
00:17:53,990 --> 00:17:57,220
I'm not sure how many people heard about next step. 

266
00:17:57,710 --> 00:18:04,170
They saw the company that steve jobs founded after. 

267
00:18:04,600 --> 00:18:11,480
He was pushed Out from apple the first time around. 

268
00:18:12,590 --> 00:18:17,210
And eventually next step was acquired by apple, 

269
00:18:17,220 --> 00:18:18,230
I think, 

270
00:18:18,240 --> 00:18:20,270
in 1997. 

271
00:18:20,650 --> 00:18:23,650
And this is how steve jobs came back to apple. 

272
00:18:24,060 --> 00:18:29,930
And then like they say there is this history and this now is next step is

273
00:18:29,940 --> 00:18:31,930
as a basis of apple or

274
00:18:31,940 --> 00:18:39,840
s ten and iphone ios then is this other a lineage

275
00:18:39,850 --> 00:18:41,560
from in linux? 

276
00:18:41,570 --> 00:18:47,470
The stars developed by andrew tannenbaum from region university

277
00:18:47,480 --> 00:18:49,510
or free university in

278
00:18:50,650 --> 00:18:51,680
amsterdam. 

279
00:18:52,410 --> 00:18:54,160
Again, I think in 80s,

280
00:18:54,790 --> 00:18:58,740
this is engaged and linux and android operating system, 

281
00:18:59,030 --> 00:19:01,820
and many flavor of linux fuel. 

282
00:19:02,970 --> 00:19:04,440
Now, and you use today.

283
00:19:06,140 --> 00:19:07,750
And then, 

284
00:19:08,050 --> 00:19:10,270
finally, this lineage from,

285
00:19:11,910 --> 00:19:17,750
again, this is operating system develop for home computer is very early on.

286
00:19:17,760 --> 00:19:21,500
This is first on acpm again, in 70s,

287
00:19:22,100 --> 00:19:25,170
this is an bolster ms does. 

288
00:19:25,180 --> 00:19:26,450
This is microsoft, 

289
00:19:26,460 --> 00:19:29,520
does is a microsoft first operating system. 

290
00:19:30,100 --> 00:19:34,650
And the reason for why microsoft is a company which is today, 

291
00:19:36,190 --> 00:19:37,530
and then windows, 

292
00:19:38,510 --> 00:19:41,200
this is a lineage, 

293
00:19:41,210 --> 00:19:43,450
microsoft operating system, lineage,

294
00:19:43,910 --> 00:19:47,190
ok it's again, a very few,

295
00:19:47,760 --> 00:19:51,680
obviously, all the operating system are going to work today.

296
00:19:52,170 --> 00:20:01,540
You can track down back to probably two or three ancient operating systems. 

297
00:20:11,640 --> 00:20:12,750
Here is a question. 

298
00:20:13,280 --> 00:20:18,740
What are examples of tasks that computers will be used for in the batch scenarios? 

299
00:20:20,630 --> 00:20:22,650
So even today, 

300
00:20:22,660 --> 00:20:26,090
when some of the supercomputers, which are, again, very expensive,

301
00:20:26,100 --> 00:20:27,890
today they are using the batch mode. 

302
00:20:28,990 --> 00:20:29,620
For instance, 

303
00:20:29,630 --> 00:20:36,780
today you can submit a job which perform a very expensive simulation. 

304
00:20:37,400 --> 00:20:37,940
Fluid dynamics. 

305
00:20:37,950 --> 00:20:41,630
For instance, you want to simulate an airplane engine,

306
00:20:43,050 --> 00:20:47,660
or you can submit a batch to process some huge amount of data which

307
00:20:47,670 --> 00:20:48,620
will take hours. 

308
00:20:49,440 --> 00:20:54,570
These are some examples of batch scenarios. 

309
00:21:02,730 --> 00:21:09,200
This is another figure by physically showing how in time, 

310
00:21:09,250 --> 00:21:13,730
some of the you have on the x axis is a time, 

311
00:21:13,740 --> 00:21:15,470
and then on the y axis, 

312
00:21:15,730 --> 00:21:20,120
going from very large main frames of very large computers

313
00:21:20,130 --> 00:21:24,140
to handheld and obiquitous devices. 

314
00:21:24,720 --> 00:21:25,150
Right? 

315
00:21:25,590 --> 00:21:31,680
You can see here also showing you different functionality provided

316
00:21:31,690 --> 00:21:33,320
by the operating systems

317
00:21:33,530 --> 00:21:39,290
and the progression of the operating system here from olympics to unix. 

318
00:21:43,600 --> 00:21:43,990
Okay? 

319
00:21:45,040 --> 00:21:49,060
So the main thing we are going to learn in this lecture are

320
00:21:49,070 --> 00:21:52,500
these four fundamental operating system constants. 

321
00:21:54,750 --> 00:21:57,100
We alluded to them in the last lecture, 

322
00:21:57,110 --> 00:21:59,300
but now we are going to go in more of that. 

323
00:22:00,750 --> 00:22:02,160
The first one is thread. 

324
00:22:03,920 --> 00:22:10,640
This provides you execution context like it fully describes a program state, 

325
00:22:10,870 --> 00:22:15,070
which means it's all the state which is needed to run the program, 

326
00:22:16,970 --> 00:22:18,400
then is address space. 

327
00:22:19,870 --> 00:22:26,130
The other space is the program, 

328
00:22:26,220 --> 00:22:28,330
the set of others, 

329
00:22:29,410 --> 00:22:34,480
memory addresses within which is a program executed, right?

330
00:22:35,200 --> 00:22:38,110
The code of the program has to be studied in memory. 

331
00:22:38,120 --> 00:22:41,070
The data of the program is going to be started in memory. 

332
00:22:41,250 --> 00:22:43,170
The output has to be stored in memory, 

333
00:22:44,640 --> 00:22:46,150
then is a process. 

334
00:22:47,390 --> 00:22:54,830
A process is basically consisting of this other space and a threat. 

335
00:22:55,560 --> 00:22:55,940
Right? 

336
00:22:57,030 --> 00:23:01,990
But it's consists of all the resources which are required by a program

337
00:23:02,710 --> 00:23:04,110
and all the state, 

338
00:23:04,500 --> 00:23:06,710
which is required by the program to run. 

339
00:23:09,450 --> 00:23:11,210
And finally, the dual mode,

340
00:23:11,220 --> 00:23:13,690
operation and protection, 

341
00:23:14,240 --> 00:23:18,770
this is refers about how is your operating system coexist

342
00:23:18,780 --> 00:23:22,220
on the same hardware with the processes? 

343
00:23:22,530 --> 00:23:28,890
And how is the operating system protecting protective from the processes? 

344
00:23:29,590 --> 00:23:31,060
Because they use their processes. 

345
00:23:31,070 --> 00:23:33,020
If there is no such protection, 

346
00:23:33,030 --> 00:23:35,500
it can change the state of the operating system. 

347
00:23:35,640 --> 00:23:37,880
The operating system can crash, 

348
00:23:37,890 --> 00:23:39,720
so everything hurts like, 

349
00:23:40,250 --> 00:23:41,820
so how you are going to avoid that. 

350
00:23:43,930 --> 00:23:44,470
So, 

351
00:23:46,120 --> 00:23:46,560
sorry, 

352
00:23:46,570 --> 00:23:51,470
so let's look a little bit about all the journey from writing the program

353
00:23:51,480 --> 00:23:52,590
to executing the program. 

354
00:23:54,680 --> 00:23:55,820
You are writing the program. 

355
00:23:55,830 --> 00:24:00,940
This is you already wrote now many programs by now, 

356
00:24:01,710 --> 00:24:02,740
you edit the program, 

357
00:24:02,750 --> 00:24:04,340
use your editor in max, 

358
00:24:04,350 --> 00:24:05,820
or your favorite editor, 

359
00:24:05,830 --> 00:24:08,480
or by charm or visual code, 

360
00:24:08,490 --> 00:24:09,760
or things like that. 

361
00:24:10,260 --> 00:24:12,050
Then you compile is a code. 

362
00:24:12,650 --> 00:24:14,020
And as a code is interpreter, 

363
00:24:14,030 --> 00:24:16,250
interpreted like python. 

364
00:24:16,260 --> 00:24:18,420
But if you have ac code, 

365
00:24:19,360 --> 00:24:22,220
you compile it and you get an executable, 

366
00:24:22,820 --> 00:24:23,240
right? 

367
00:24:24,890 --> 00:24:27,340
Which is a code, executable,

368
00:24:27,690 --> 00:24:30,230
contains a code which can be interpreted. 

369
00:24:30,550 --> 00:24:33,840
And it can be around by the processors understands. 

370
00:24:34,760 --> 00:24:34,990
Right? 

371
00:24:35,000 --> 00:24:41,550
And now this executable is loaded in the memory of the computer. 

372
00:24:42,360 --> 00:24:43,740
And then it's executive. 

373
00:24:44,330 --> 00:24:47,640
But when it's loaded in memory, 

374
00:24:47,650 --> 00:24:53,150
there are several segments of the memory or several partitions of the memory, 

375
00:24:53,400 --> 00:24:56,310
where a different kind of data is stored, 

376
00:24:57,020 --> 00:25:05,250
one as each each one part is where you keep the partitions. 

377
00:25:06,120 --> 00:25:06,670
You sorry, 

378
00:25:07,240 --> 00:25:10,030
where you want partition is where you keep the code, 

379
00:25:10,430 --> 00:25:12,630
the instructions of the program. 

380
00:25:13,310 --> 00:25:16,070
Then you have where you keep the data. 

381
00:25:18,590 --> 00:25:20,380
The data you statistically defined. 

382
00:25:20,390 --> 00:25:22,540
But I for instance, you say,

383
00:25:22,550 --> 00:25:28,950
and when you create of an array or variables, this is,

384
00:25:29,450 --> 00:25:30,610
and it's static, 

385
00:25:31,500 --> 00:25:32,090
then hip. 

386
00:25:32,100 --> 00:25:33,890
It's where you define. 

387
00:25:34,580 --> 00:25:37,420
You create dynamic data structures. 

388
00:25:37,800 --> 00:25:40,370
Like, for instance, this is when you allocate memory,

389
00:25:42,040 --> 00:25:44,860
when you allocate memory, this happens at the run time.

390
00:25:45,180 --> 00:25:46,300
Before the program, 

391
00:25:46,310 --> 00:25:48,500
after the program starts executed. 

392
00:25:49,300 --> 00:25:53,790
Therefore, the heap is going to change during the run time,

393
00:25:53,800 --> 00:25:57,070
depending of how much dynamic memory you are allocating

394
00:25:57,080 --> 00:25:58,870
for your dynamic data structures. 

395
00:26:00,070 --> 00:26:02,190
Finally, you have a stack.

396
00:26:02,200 --> 00:26:04,050
The stack is it's used, 

397
00:26:04,060 --> 00:26:07,170
and you use, for instance,

398
00:26:07,180 --> 00:26:12,030
to store the variables, 

399
00:26:12,040 --> 00:26:14,510
you are going to declare within a function. 

400
00:26:14,990 --> 00:26:19,660
It's also used to store the return address when you call a function. 

401
00:26:20,070 --> 00:26:21,690
After the function is done, 

402
00:26:21,950 --> 00:26:24,620
you need to know where you go back in the program. 

403
00:26:25,730 --> 00:26:26,040
Again, 

404
00:26:26,050 --> 00:26:33,110
we'll discuss a lot of more about each of these different types of data

405
00:26:33,120 --> 00:26:34,230
and memory. 

406
00:26:35,060 --> 00:26:37,820
And finally, here you have the operating system, memory,

407
00:26:38,950 --> 00:26:47,380
ok so that's pretty much it. 

408
00:26:47,390 --> 00:26:56,820
Let me stop and see ok no new questions, please.

409
00:26:56,830 --> 00:26:57,260
Again. 

410
00:26:57,630 --> 00:26:58,830
Keep your question coming. 

411
00:27:02,120 --> 00:27:02,450
Great. 

412
00:27:07,590 --> 00:27:09,060
How you execute the program? 

413
00:27:09,790 --> 00:27:14,180
If you remember, and this is from 61 c if you remember,

414
00:27:14,810 --> 00:27:19,560
you basically have a bunch of instructions which are in memory, 

415
00:27:19,970 --> 00:27:23,930
then you have a program counter calls opc which point

416
00:27:23,940 --> 00:27:28,420
out to the current instruction being executed from memory. 

417
00:27:29,560 --> 00:27:34,440
So what happens when you take the instruction, 

418
00:27:34,670 --> 00:27:37,730
which you fetch the instruction, 

419
00:27:38,120 --> 00:27:40,730
which is pointed to by the program counter, 

420
00:27:41,320 --> 00:27:44,580
and then this instruction is decoded, 

421
00:27:45,060 --> 00:27:46,650
and then it's executed. 

422
00:27:47,280 --> 00:27:49,020
This is basically down here. 

423
00:27:49,030 --> 00:27:51,950
You see the processor, right?

424
00:27:51,960 --> 00:27:53,010
A core. 

425
00:27:53,740 --> 00:28:00,770
And the core typically consists from an alio, 

426
00:28:01,320 --> 00:28:02,730
aromatic logic unit, 

427
00:28:03,120 --> 00:28:06,970
which performs the operation, addition, subtraction, and things like that.

428
00:28:07,320 --> 00:28:08,820
And a bunch of registers, 

429
00:28:09,070 --> 00:28:11,220
where are the arguments of these operations? 

430
00:28:11,640 --> 00:28:12,470
In many cases, 

431
00:28:12,480 --> 00:28:17,710
and registers are very fast to address because they are there very low latency. 

432
00:28:20,150 --> 00:28:23,780
And then while after you execute an instruction, 

433
00:28:23,790 --> 00:28:26,300
the program counter is increment it. 

434
00:28:26,600 --> 00:28:28,060
You are going to the next instruction. 

435
00:28:30,650 --> 00:28:31,320
Very simple. 

436
00:28:34,870 --> 00:28:39,590
This is another review here about on the right hand side, 

437
00:28:39,600 --> 00:28:43,350
you are going to have the memory with a bunch of instructions and a bunch

438
00:28:43,360 --> 00:28:46,100
of data on the right hand side. 

439
00:28:46,330 --> 00:28:47,910
On the left hand side, sorry.

440
00:28:48,470 --> 00:28:52,980
You have what is a processor which is fetching the execution, 

441
00:28:53,420 --> 00:28:56,420
fetching the instruction and execute the instruction? 

442
00:28:56,840 --> 00:28:59,700
And there you have on the left hand side, 

443
00:28:59,710 --> 00:29:03,000
a bunch of registers are zero to our 71. 

444
00:29:03,680 --> 00:29:07,870
And you have another set of register from f zero grab 30. 

445
00:29:08,110 --> 00:29:10,530
The difference typically between the set of registry

446
00:29:10,540 --> 00:29:14,370
because of the second set of register is for floating point operations. 

447
00:29:16,420 --> 00:29:20,170
The r zero to our 31 typically are for fixed point operations. 

448
00:29:20,180 --> 00:29:22,340
And then you have the program count. 

449
00:29:24,360 --> 00:29:27,650
It's, again, you face the instruction at the program counter.

450
00:29:27,660 --> 00:29:29,680
You decoded, you execute it,

451
00:29:29,690 --> 00:29:31,200
possibly using the registers. 

452
00:29:31,430 --> 00:29:34,520
Some of the argument of the instruction can be addressed in memory. 

453
00:29:34,940 --> 00:29:38,350
And when I say results to the registers or memory, 

454
00:29:38,710 --> 00:29:41,790
and then you go to the next instruction and repeat. 

455
00:29:47,090 --> 00:29:49,320
So let me see about questions. 

456
00:29:54,860 --> 00:29:58,810
The question, is there one program counterpart thread?

457
00:29:59,330 --> 00:30:04,960
The program counters is typically a registered in the car in the processor? 

458
00:30:05,450 --> 00:30:08,840
It's typically only one program counters may be true if you have

459
00:30:08,850 --> 00:30:10,000
a user program counter, 

460
00:30:10,010 --> 00:30:10,880
but it's one. 

461
00:30:11,580 --> 00:30:12,250
What happens? 

462
00:30:12,260 --> 00:30:15,690
And we are going to see later in this lecture that when you are going to do

463
00:30:15,700 --> 00:30:16,530
context switching, 

464
00:30:16,540 --> 00:30:20,250
what is called when you go to another to start executing a thread. 

465
00:30:20,640 --> 00:30:25,570
The first traction you do you take is to load the program counter, 

466
00:30:25,870 --> 00:30:29,340
which he says somewhere in memory is a current program counter

467
00:30:29,350 --> 00:30:34,480
of the thread corresponding to the thread into the processor program

468
00:30:34,490 --> 00:30:34,960
account. 

469
00:30:36,010 --> 00:30:36,400
Right? 

470
00:30:37,410 --> 00:30:40,900
But a program counter from the processor point of view, 

471
00:30:41,260 --> 00:30:42,300
it's only one. 

472
00:30:42,310 --> 00:30:43,350
It's not perspective. 

473
00:30:48,910 --> 00:30:56,500
So let me

474
00:30:56,510 --> 00:31:01,920
just the thread of control. 

475
00:31:01,930 --> 00:31:05,910
Again, this contains a state required to run the program.

476
00:31:06,580 --> 00:31:07,650
What does it mean? 

477
00:31:09,100 --> 00:31:10,520
Is basically, 

478
00:31:13,100 --> 00:31:14,030
it contains, 

479
00:31:16,550 --> 00:31:16,910
sorry, 

480
00:31:18,550 --> 00:31:20,430
it contains a program counter, 

481
00:31:20,440 --> 00:31:26,050
and then it contains also pointers to where all these other kinds

482
00:31:26,060 --> 00:31:27,890
of regions in memory start, 

483
00:31:28,410 --> 00:31:32,360
like, for instance, contains for the stack pointer.

484
00:31:32,860 --> 00:31:36,980
The stack pointer is basically where the stack starts from. 

485
00:31:37,500 --> 00:31:39,050
It contains a hip pointer, 

486
00:31:39,060 --> 00:31:41,250
is the address from the world. 

487
00:31:41,260 --> 00:31:43,040
The hip starts growing. 

488
00:31:46,020 --> 00:31:53,240
And it contains also what is in registers that I

489
00:31:53,760 --> 00:31:57,160
because the state in the register is used by the instructions. 

490
00:32:00,150 --> 00:32:01,690
And assert is executing, 

491
00:32:01,700 --> 00:32:03,010
like I mentioned earlier, 

492
00:32:03,020 --> 00:32:05,750
when its resident on the processor, 

493
00:32:05,760 --> 00:32:10,650
when the state is the stress state is loaded in the processor. 

494
00:32:14,260 --> 00:32:15,860
Pc read this program counter, 

495
00:32:16,330 --> 00:32:18,880
all the address of the greatest instruction in the thread. 

496
00:32:19,270 --> 00:32:19,990
And again, 

497
00:32:20,230 --> 00:32:24,520
register whole sum of the root state of the threat is called the state. 

498
00:32:27,480 --> 00:32:31,360
That's kind of the what the thread is about. 

499
00:32:31,370 --> 00:32:36,770
So all the state which is needed to execute that program counter state

500
00:32:36,780 --> 00:32:37,810
of the registers, 

501
00:32:38,530 --> 00:32:45,480
key. for stack pointers and a few others. 

502
00:32:48,670 --> 00:32:57,220
Now, the address space is basically the memory addresses or the memory

503
00:32:57,230 --> 00:33:05,170
regions where the data and the code of the programs

504
00:33:05,180 --> 00:33:05,810
are stored. 

505
00:33:11,540 --> 00:33:17,040
The addresses are typically, 

506
00:33:17,050 --> 00:33:20,090
it's the size of the memory. 

507
00:33:20,100 --> 00:33:23,170
Addressable memories is very important of the size of the memory. 

508
00:33:23,180 --> 00:33:25,530
The man, the size of the addressable memory,

509
00:33:26,670 --> 00:33:30,100
is given by the number of bits of the processor. 

510
00:33:30,110 --> 00:33:30,980
Typically, 

511
00:33:31,590 --> 00:33:38,160
if you have a 30 bits processor that are to power 32 or 4 billion addresses, 

512
00:33:39,580 --> 00:33:44,100
which means4 megabytes of memory. 

513
00:33:45,090 --> 00:33:46,500
If it's byte addressable, 

514
00:33:47,410 --> 00:33:49,860
if it's 64 bits is to power 64, 

515
00:33:49,870 --> 00:33:51,610
which is a huge amount of memory. 

516
00:33:52,050 --> 00:33:52,500
Okay? 

517
00:33:52,790 --> 00:33:54,100
This is addressable memory, 

518
00:33:54,110 --> 00:33:55,340
like we are going to see. 

519
00:33:55,350 --> 00:33:57,340
This is different from the physical memory. 

520
00:33:58,020 --> 00:33:59,790
The physical memory can be

521
00:33:59,800 --> 00:34:04,110
smaller and typically smaller than the addressable memories. 

522
00:34:04,360 --> 00:34:07,310
And but then you are going to have a process. 

523
00:34:07,320 --> 00:34:08,560
You are going to learn. 

524
00:34:08,570 --> 00:34:09,310
It's called visualization. 

525
00:34:10,530 --> 00:34:11,840
And address translation. 

526
00:34:11,850 --> 00:34:15,080
We are going to even talk about this style, this lecture,

527
00:34:15,470 --> 00:34:19,280
which is going to create you the image and the illusion that you have

528
00:34:19,290 --> 00:34:22,960
access to the entire addressable memory in a smaller physical memory. 

529
00:34:28,880 --> 00:34:31,910
What happens when you read or write to an address? 

530
00:34:33,940 --> 00:34:37,590
Maybe nothing, 

531
00:34:38,640 --> 00:34:43,890
or you act like a a regular memory means that you read the value

532
00:34:43,900 --> 00:34:46,860
from that memory and you write the value to that memory. 

533
00:34:47,890 --> 00:34:49,880
But perhaps you can ignore rights. 

534
00:34:49,890 --> 00:34:57,570
For instance, if you if you are processes writing to address,

535
00:34:57,580 --> 00:34:59,490
it doesn't belong to that process, 

536
00:34:59,910 --> 00:35:01,590
then maybe it's going to be ignored. 

537
00:35:02,630 --> 00:35:05,500
Or maybe it causes eye operations. 

538
00:35:06,570 --> 00:35:12,940
As you'll see that other memory mapped input output

539
00:35:14,320 --> 00:35:17,350
designs and architectures in which, 

540
00:35:17,360 --> 00:35:21,190
for instance, if you want to communicate to a device like a keyboard,

541
00:35:21,200 --> 00:35:24,390
you want to read from a keyboard or you want to communicate with a printer. 

542
00:35:24,830 --> 00:35:27,150
There are certain defined, 

543
00:35:27,420 --> 00:35:30,780
pre defined memory addresses where you have to write. 

544
00:35:31,160 --> 00:35:34,470
For instance, it's a pretty fine memory address you read from.

545
00:35:34,480 --> 00:35:37,710
And that's what you are going to get the input from the keyboard, 

546
00:35:38,270 --> 00:35:43,180
or is another pretty defined memory address or a range of addresses

547
00:35:43,190 --> 00:35:44,900
where you can write. 

548
00:35:44,910 --> 00:35:47,430
And that data is going to the reader. 

549
00:35:49,660 --> 00:35:52,600
Or perhaps it causes an exception, 

550
00:35:52,910 --> 00:35:55,660
like an example I gave to you earlier on. 

551
00:35:55,670 --> 00:36:01,550
And you are going to write to a data to address which he doesn't belong to you, 

552
00:36:01,770 --> 00:36:05,390
or say, to the address of an own owned by the operating system.

553
00:36:07,050 --> 00:36:07,970
It can be ignored. 

554
00:36:07,980 --> 00:36:10,450
But in many cases, you get a segmentation fault.

555
00:36:10,460 --> 00:36:12,050
You cannot cause the exception. 

556
00:36:14,520 --> 00:36:20,500
One exception, the offending program is going to basically stop crashed.

557
00:36:26,050 --> 00:36:28,240
Again, you have a bunch of region or segment.

558
00:36:28,890 --> 00:36:30,180
You have the code segment. 

559
00:36:31,140 --> 00:36:35,730
The score segment that already pro mentioned to you contains

560
00:36:35,740 --> 00:36:37,290
the instruction of the program. 

561
00:36:38,170 --> 00:36:40,000
You have the stack segment. 

562
00:36:40,490 --> 00:36:42,720
I told you what, 

563
00:36:42,770 --> 00:36:45,320
again, earlier, what it contains, it contain.

564
00:36:45,330 --> 00:36:50,190
It can contains The variable you are going to declare within a function. 

565
00:36:50,500 --> 00:36:53,920
And also the return addresses from a function. 

566
00:36:55,260 --> 00:37:00,670
And the stack grows from high to low to grow, 

567
00:37:00,680 --> 00:37:01,910
so to speak downwards. 

568
00:37:04,370 --> 00:37:05,640
Because you add, 

569
00:37:05,940 --> 00:37:06,940
when you call a function, 

570
00:37:06,950 --> 00:37:08,220
you are sinks on the stack. 

571
00:37:10,660 --> 00:37:12,170
Then you have the heap, 

572
00:37:12,180 --> 00:37:16,810
which is for dynamic data when you allocate data during the program execution, 

573
00:37:17,180 --> 00:37:21,350
and you're growing from low level of low addresses to high addresses. 

574
00:37:24,220 --> 00:37:26,310
So let's see, 

575
00:37:26,320 --> 00:37:27,870
there are some questions here. 

576
00:37:31,290 --> 00:37:38,860
Where does os save all the state and registered values when changing as task? 

577
00:37:39,940 --> 00:37:41,580
It's a thread control block, 

578
00:37:41,590 --> 00:37:46,110
pcb this is where it said it starts. 

579
00:37:47,260 --> 00:37:53,840
You have a data structure which associated on issue with each thread, 

580
00:37:54,270 --> 00:37:56,500
which is managed by the operating system. 

581
00:37:56,730 --> 00:38:01,450
And in that block or region, 

582
00:38:01,810 --> 00:38:04,680
you save all the state associated with a thread. 

583
00:38:06,710 --> 00:38:09,460
When we say that the process has a virtual address space, 

584
00:38:09,470 --> 00:38:14,600
zero to ff it doesn't imply that it has free reign to write with our services. 

585
00:38:14,610 --> 00:38:14,930
Absolutely. 

586
00:38:20,330 --> 00:38:23,160
Let me there are two views of the memory. 

587
00:38:23,170 --> 00:38:25,260
And again, this is very important to,

588
00:38:26,670 --> 00:38:27,900
and this is about arbitralization. 

589
00:38:28,650 --> 00:38:30,690
It's about creating the illusion. 

590
00:38:31,140 --> 00:38:33,240
It's a memory, it's a physical memory,

591
00:38:33,250 --> 00:38:38,170
and the physical memory is partitioned between different processes. 

592
00:38:40,270 --> 00:38:44,230
Now, there is also what the illusion, actually,

593
00:38:44,240 --> 00:38:45,270
of the process. 

594
00:38:45,880 --> 00:38:50,610
The illusion of the process is that he has an address from 00 to ff he has

595
00:38:50,620 --> 00:38:52,050
an entire outer space. 

596
00:38:53,260 --> 00:38:58,560
And the application, in principle,

597
00:38:58,570 --> 00:39:02,550
can can write at any of these addresses. 

598
00:39:04,390 --> 00:39:04,870
Okay? 

599
00:39:07,440 --> 00:39:08,350
Typically, 

600
00:39:08,360 --> 00:39:14,360
the operating system takes care for cells so that the application does

601
00:39:14,370 --> 00:39:16,010
a shoot in its foot. 

602
00:39:16,310 --> 00:39:16,670
Right? 

603
00:39:17,130 --> 00:39:20,880
For instance, you cannot right on the stack,

604
00:39:20,890 --> 00:39:23,520
because if you can't write on the stack, the program will crash.

605
00:39:24,130 --> 00:39:24,580
Right? 

606
00:39:25,140 --> 00:39:28,630
The operating system will put the only post some restrictions. 

607
00:39:29,340 --> 00:39:31,990
So you don't have a free ray. 

608
00:39:32,310 --> 00:39:33,980
You do see the entire other space. 

609
00:39:33,990 --> 00:39:34,240
Again. 

610
00:39:34,250 --> 00:39:35,540
You don't have free rain, 

611
00:39:35,840 --> 00:39:39,150
but I just come to and to plant the seed. 

612
00:39:39,160 --> 00:39:39,870
Now. 

613
00:39:40,340 --> 00:39:43,290
We are going to do this to say this over and over, 

614
00:39:43,300 --> 00:39:45,290
because there are two views of a memory. 

615
00:39:45,300 --> 00:39:46,930
You have physical memory, 

616
00:39:47,210 --> 00:39:50,300
which is partitioned between different applications. 

617
00:39:50,310 --> 00:39:53,100
They have data code from different applications. 

618
00:39:53,480 --> 00:39:55,990
Residing is a physical memory at the same time. 

619
00:39:56,250 --> 00:39:58,050
And then you have the virtual memory, 

620
00:39:58,280 --> 00:40:03,040
which is basically what is presented to the application. 

621
00:40:03,050 --> 00:40:06,800
And there you create the illusion that each application is process, 

622
00:40:07,030 --> 00:40:09,890
has access to the full address space with some constraints, 

623
00:40:09,900 --> 00:40:10,790
like I explained. 

624
00:40:20,070 --> 00:40:25,310
So so here is exactly what I mentioned earlier about the physical memory. 

625
00:40:25,860 --> 00:40:27,400
You see, on the right hand side,

626
00:40:27,410 --> 00:40:29,700
you have the physical memory in the physical memory. 

627
00:40:29,710 --> 00:40:30,620
As you can see. 

628
00:40:31,360 --> 00:40:33,670
You have, on the left hand side,

629
00:40:33,680 --> 00:40:37,030
you have the operating system with and processes, right?

630
00:40:37,320 --> 00:40:39,480
Green, yellow, orange.

631
00:40:39,980 --> 00:40:41,240
Now, in the physical memory,

632
00:40:41,250 --> 00:40:45,540
you can see that you have instructions, 

633
00:40:45,550 --> 00:40:48,370
a code and data from different processes. 

634
00:40:48,380 --> 00:40:53,080
And they are all is riding in the same physical memory. 

635
00:40:54,990 --> 00:40:58,880
Each of this processing is only going to see only its own data. 

636
00:40:59,170 --> 00:41:02,760
They shouldn't see the other as a process data. 

637
00:41:06,970 --> 00:41:07,080
Now, 

638
00:41:07,090 --> 00:41:10,600
what is the multi programming about multi programming about is about having

639
00:41:10,610 --> 00:41:11,880
different processes? 

640
00:41:12,160 --> 00:41:14,330
Like ii said earlier, 

641
00:41:14,340 --> 00:41:15,450
I said about jobs, 

642
00:41:15,460 --> 00:41:17,930
but the process with the process is the same thing. 

643
00:41:18,190 --> 00:41:22,420
They have different processes running and share running at the same time

644
00:41:22,430 --> 00:41:24,700
on the same on a single machine. 

645
00:41:25,220 --> 00:41:25,670
Right? 

646
00:41:26,070 --> 00:41:27,740
Now, how do you give the illusion?

647
00:41:27,750 --> 00:41:27,940
Right? 

648
00:41:27,950 --> 00:41:31,380
Because so breaking system provides the illusions that despite you have

649
00:41:31,390 --> 00:41:36,060
different processes running at the same time on the same harbor, 

650
00:41:36,070 --> 00:41:39,340
each process believes that it is allowed. 

651
00:41:39,970 --> 00:41:40,380
Right? 

652
00:41:42,870 --> 00:41:45,090
The only way you can give that you have to share, 

653
00:41:45,100 --> 00:41:46,730
you have to multiplex resources. 

654
00:41:47,280 --> 00:41:48,730
And there are multiple resources. 

655
00:41:48,740 --> 00:41:51,700
One is the cpu right? 

656
00:41:52,140 --> 00:41:55,190
And if you have a single processor, 

657
00:41:55,200 --> 00:41:59,390
how do you provide illusion of having multiple processors one for each processor? 

658
00:41:59,970 --> 00:42:02,210
As we discussed last time, 

659
00:42:02,450 --> 00:42:05,270
you split the processors in tank quanta. 

660
00:42:05,670 --> 00:42:07,460
You give it all time slices, 

661
00:42:07,790 --> 00:42:11,470
and you give a time count or a time slice to a different process. 

662
00:42:12,010 --> 00:42:12,440
Right? 

663
00:42:13,070 --> 00:42:14,660
Say it's 10 million seconds. 

664
00:42:15,020 --> 00:42:16,740
The time size is 10 million seconds. 

665
00:42:17,090 --> 00:42:18,130
For 10 million seconds, 

666
00:42:18,140 --> 00:42:19,770
you around process one, 

667
00:42:19,780 --> 00:42:23,240
then we switch to for the next 10 million seconds to process two, 

668
00:42:23,250 --> 00:42:25,920
for the next10 million seconds to process three, 

669
00:42:25,930 --> 00:42:27,240
and then come back to process on. 

670
00:42:28,130 --> 00:42:29,080
This is one way to do it. 

671
00:42:29,750 --> 00:42:30,880
So multiplex it in time. 

672
00:42:32,600 --> 00:42:39,540
And each this kind of ritual cp us needs to hold this program counter, 

673
00:42:39,980 --> 00:42:42,280
start pointer registers and things like that. 

674
00:42:42,550 --> 00:42:45,020
So this is a state was associated with the thread, 

675
00:42:45,640 --> 00:42:48,660
because when you run something on a problem, 

676
00:42:48,670 --> 00:42:50,900
this visual cp us is a threat. 

677
00:42:51,570 --> 00:42:52,030
Right? 

678
00:42:53,160 --> 00:42:53,440
Obviously, 

679
00:42:53,450 --> 00:42:57,790
the question now is about how you switch from a virtual security the next time. 

680
00:42:58,020 --> 00:42:58,410
Right? 

681
00:42:58,640 --> 00:42:59,670
This is what you do, right?

682
00:42:59,680 --> 00:43:03,790
You use you you save the state of the virtual cp us. 

683
00:43:03,800 --> 00:43:08,490
And here on the state of the virtual cpu is the same as a state

684
00:43:08,500 --> 00:43:11,360
of the thread running on that virtual cpu right? 

685
00:43:11,370 --> 00:43:12,880
In that time sliced. 

686
00:43:13,160 --> 00:43:15,670
And you allowed the state for the next mutual secure, 

687
00:43:15,680 --> 00:43:17,830
the next thread you are going to execute. 

688
00:43:19,250 --> 00:43:20,730
And then you execute, 

689
00:43:21,200 --> 00:43:23,500
you run the next thread. 

690
00:43:25,650 --> 00:43:28,960
So it's, again, I just wanted to make sure here it seems i'm not confusing.

691
00:43:28,970 --> 00:43:30,600
You have only once if you, 

692
00:43:30,980 --> 00:43:32,090
in this particular case, 

693
00:43:32,100 --> 00:43:33,770
and you want to multiplex it, 

694
00:43:33,780 --> 00:43:36,290
so you are going to multiplex it in time. 

695
00:43:36,610 --> 00:43:45,780
And that for each process is provided with an illusion that it owns a processor, 

696
00:43:45,790 --> 00:43:47,260
albeit a slower processor. 

697
00:43:47,770 --> 00:43:48,120
Right? 

698
00:43:48,540 --> 00:43:50,590
And by the virtual cpu hearing, 

699
00:43:50,600 --> 00:43:56,790
means that part time partition, 

700
00:43:56,800 --> 00:44:02,560
part of the cpu which is kind of on a by a particular process. 

701
00:44:04,100 --> 00:44:04,380
Right? 

702
00:44:04,880 --> 00:44:07,820
And when you from the process, 

703
00:44:07,830 --> 00:44:09,890
when you have each process, 

704
00:44:09,900 --> 00:44:10,940
if you remember, 

705
00:44:10,950 --> 00:44:11,990
has a thread, 

706
00:44:12,280 --> 00:44:14,040
and again, 

707
00:44:14,050 --> 00:44:15,940
we repeat that soon, 

708
00:44:15,950 --> 00:44:23,230
and that thread is a part which is running on the process processor

709
00:44:23,240 --> 00:44:24,390
or the visual studio. 

710
00:44:27,430 --> 00:44:34,020
Let me you said a program can write on the stack, 

711
00:44:34,030 --> 00:44:35,780
but when you write assembly, 

712
00:44:35,790 --> 00:44:38,340
we often move the stack pointer and write. 

713
00:44:44,030 --> 00:44:44,510
Yes. 

714
00:44:45,160 --> 00:44:45,980
That's true. 

715
00:44:47,680 --> 00:44:49,510
When basically, 

716
00:44:49,520 --> 00:44:51,270
you said the program can write on the stack, 

717
00:44:51,280 --> 00:44:52,510
but when you write assembly, 

718
00:44:52,520 --> 00:44:55,470
you often move the stack pointer and write to the stack. 

719
00:44:56,460 --> 00:44:58,450
You are a bit confused. 

720
00:44:58,460 --> 00:45:02,250
So when you write an assembly, 

721
00:45:02,620 --> 00:45:06,890
you don't go through the compiler so that you don't have anyone to put

722
00:45:07,460 --> 00:45:10,040
any kind of constraints of what you are going to do. 

723
00:45:10,050 --> 00:45:15,520
So you can indeed do almost everything you also need to. 

724
00:45:17,080 --> 00:45:18,270
So you need to do that. 

725
00:45:18,280 --> 00:45:23,150
But when you write a typical program like in high level languages, 

726
00:45:23,500 --> 00:45:24,330
you compile it. 

727
00:45:24,340 --> 00:45:27,530
And the compiler is going to put additional constraints about what you

728
00:45:27,540 --> 00:45:32,540
can do with the program now that the cpu is time partition. 

729
00:45:32,900 --> 00:45:34,280
Now, in general,

730
00:45:37,000 --> 00:45:37,670
no, 

731
00:45:38,290 --> 00:45:41,210
what is exactly slower when in reality, it is multiplex.

732
00:45:42,200 --> 00:45:45,490
What I mean slower is by when I slower, 

733
00:45:45,880 --> 00:45:50,940
I imagine that you have acpu and it's, 

734
00:45:52,320 --> 00:45:59,010
and if the cpu is partitioned between two processes, 

735
00:45:59,270 --> 00:46:00,340
then each process, 

736
00:46:00,350 --> 00:46:01,740
and if each process will, 

737
00:46:01,750 --> 00:46:05,340
alternatively use a 10 millisecond run for 10 millisecond. 

738
00:46:05,960 --> 00:46:09,280
This means that each process will see a processor, 

739
00:46:09,610 --> 00:46:14,480
which is half the speed of the original processor. 

740
00:46:15,470 --> 00:46:15,710
Right? 

741
00:46:16,810 --> 00:46:18,790
Because, for instance, out of one,

742
00:46:19,690 --> 00:46:24,770
second, each process will use acpu only for 500 meters ago.

743
00:46:27,710 --> 00:46:35,090
So it's half cost so half slow as slow as the real cpu

744
00:46:39,400 --> 00:46:42,430
what is done differently for context switching between threads

745
00:46:42,440 --> 00:46:45,230
of the same process versus different processes? 

746
00:46:47,760 --> 00:46:49,710
Again, this is probably too early.

747
00:46:51,940 --> 00:46:52,690
We learn a lot. 

748
00:46:52,700 --> 00:46:58,670
But so in short, 

749
00:46:58,680 --> 00:47:03,040
the answer here is that when you change, 

750
00:47:03,050 --> 00:47:06,340
when you switch content to contact switching between the thread, 

751
00:47:06,350 --> 00:47:09,230
you only need to switch. 

752
00:47:09,580 --> 00:47:11,820
A context switch is a state of the thread, 

753
00:47:12,260 --> 00:47:13,830
which is a bunch of registers. 

754
00:47:15,040 --> 00:47:16,790
And pointers is very light. 

755
00:47:18,050 --> 00:47:23,230
When you are going to switch between different processes, 

756
00:47:23,760 --> 00:47:29,310
you need also to switch the state about all the resources, for instance,

757
00:47:29,680 --> 00:47:30,390
memories. 

758
00:47:30,400 --> 00:47:34,080
There is aa memory table to ensure the translation

759
00:47:34,090 --> 00:47:37,410
between this virtual address space and physical address space. 

760
00:47:39,460 --> 00:47:41,480
There is a file descriptors. 

761
00:47:42,730 --> 00:47:48,280
So it's a lot of more state you need to to switch on your switch between processors, 

762
00:47:49,350 --> 00:47:50,380
between processes. 

763
00:47:52,800 --> 00:47:55,100
Where are these state blocks start? 

764
00:47:55,110 --> 00:47:56,390
So strapped block, 

765
00:47:59,620 --> 00:48:01,380
slight strap control blocks, 

766
00:48:01,390 --> 00:48:07,020
or all this state is stored in the operating system by the operating system

767
00:48:07,840 --> 00:48:09,280
and managed by the operating system. 

768
00:48:10,100 --> 00:48:14,210
Isn't there overhead with switching from on virtual cpu to another? 

769
00:48:15,030 --> 00:48:15,640
Yes. 

770
00:48:17,400 --> 00:48:18,060
Absolutely. 

771
00:48:18,330 --> 00:48:23,520
There is an overhead one switching from one village choice abuse to another, 

772
00:48:23,970 --> 00:48:31,760
because we need to save on low states like the person who asked the

773
00:48:31,770 --> 00:48:35,220
question correctly identified. 

774
00:48:35,700 --> 00:48:39,900
And is it just a necessary inefficiency we accept in order to multiplex? 

775
00:48:39,910 --> 00:48:40,380
Yes. 

776
00:48:41,390 --> 00:48:41,790
It is. 

777
00:48:42,560 --> 00:48:44,840
How about those programs that are time sensitive? 

778
00:48:51,050 --> 00:48:53,610
When the programs are time sensitive? 

779
00:48:54,340 --> 00:48:55,370
Typically, 

780
00:48:56,360 --> 00:48:59,650
you may have an operating system which has real time support

781
00:48:59,980 --> 00:49:02,110
in these operating systems. 

782
00:49:02,520 --> 00:49:08,290
You can specify by when a particular task should be executed, 

783
00:49:08,300 --> 00:49:12,650
and they are going to ensure that task will be executed by that time. 

784
00:49:13,050 --> 00:49:16,660
Or you can other ways you can specify. 

785
00:49:18,420 --> 00:49:22,050
And the operating similar guarantee that you are going to get

786
00:49:22,400 --> 00:49:26,270
a minimum share of the cpu if you get a minimum share of the

787
00:49:26,280 --> 00:49:29,780
cpu then presumably, 

788
00:49:33,210 --> 00:49:38,220
you are guaranteed that you can finish some of the operations

789
00:49:38,230 --> 00:49:41,220
or your operations in time. 

790
00:49:45,740 --> 00:49:48,390
For instance, this is a continuation,

791
00:49:48,400 --> 00:49:50,670
this is question from your friend. 

792
00:49:52,740 --> 00:49:56,010
For example, some programs receive data from network,

793
00:49:56,390 --> 00:50:00,320
wouldn't contact switching the program during the transmission caused trouble. 

794
00:50:03,340 --> 00:50:08,850
Now, you will is the other way around.

795
00:50:08,860 --> 00:50:11,510
Actually, when you get something from the another,

796
00:50:11,520 --> 00:50:12,830
there is an interrupt. 

797
00:50:13,480 --> 00:50:17,960
You are going to interrupt the processes which are

798
00:50:17,970 --> 00:50:20,680
actually application processes which are actually running. 

799
00:50:21,340 --> 00:50:23,280
And then after you do the work, 

800
00:50:23,290 --> 00:50:24,400
you get the data, 

801
00:50:24,410 --> 00:50:25,800
you return from the internet. 

802
00:50:26,140 --> 00:50:28,210
And you are going to continue the processes. 

803
00:50:29,280 --> 00:50:30,110
Typically, 

804
00:50:31,940 --> 00:50:34,250
it's a little bit the other way around. 

805
00:50:34,260 --> 00:50:38,530
It's not like a process interrupted transmission or receiving data. 

806
00:50:39,900 --> 00:50:42,250
Where is the current start block information being stored

807
00:50:42,260 --> 00:50:44,530
for individual cpu like I mentioned, 

808
00:50:44,540 --> 00:50:48,610
this is in the operating system following up on the assembly, 

809
00:50:48,620 --> 00:50:50,130
giving you free ring questions. 

810
00:50:50,140 --> 00:50:51,690
Are the segmentation faults? 

811
00:50:52,000 --> 00:50:56,350
Receipt things, or will you also be prohibitive on the assemble?

812
00:50:56,980 --> 00:50:58,130
Assembly level? 

813
00:50:58,540 --> 00:51:01,410
The segmentation falls are the seas? 

814
00:51:02,350 --> 00:51:06,220
See things as see thing, right?

815
00:51:06,230 --> 00:51:07,740
It's like an assembly level, 

816
00:51:08,130 --> 00:51:12,800
because it gives you a lot of more flexibility, right?

817
00:51:13,510 --> 00:51:16,440
We see you can write all over the place. 

818
00:51:16,450 --> 00:51:18,980
But again, when you have like, for instance,

819
00:51:18,990 --> 00:51:21,020
if you run java or things like that, 

820
00:51:21,670 --> 00:51:22,740
you cannot do it. 

821
00:51:23,630 --> 00:51:25,740
And this is enforced by your compilers. 

822
00:51:26,190 --> 00:51:31,880
It can be type is can if you probably heard about being their type safety, 

823
00:51:33,170 --> 00:51:33,750
type safe, 

824
00:51:34,270 --> 00:51:37,980
then they verify that actually, when you write the program, you cannot,

825
00:51:37,990 --> 00:51:38,860
for instance, 

826
00:51:39,270 --> 00:51:41,460
overwrite on the stack, right on the stack.

827
00:51:41,970 --> 00:51:43,710
In short answer, assembly language,

828
00:51:43,990 --> 00:51:45,300
c language, you can do it.

829
00:51:45,610 --> 00:51:47,680
Higher level languages, you cannot do it.

830
00:51:48,260 --> 00:51:50,300
The compilers will take care of that. 

831
00:51:51,570 --> 00:51:53,220
What is the state block? 

832
00:51:53,230 --> 00:51:54,540
I it is, 

833
00:51:54,780 --> 00:51:56,210
maybe if I say state block it, 

834
00:51:56,900 --> 00:51:59,890
it's this is not the correct term, 

835
00:51:59,900 --> 00:52:03,290
is a thread control block and this process control block. 

836
00:52:04,670 --> 00:52:06,530
And this is, again,

837
00:52:06,540 --> 00:52:09,410
the state control block contains all the state, 

838
00:52:10,380 --> 00:52:12,930
which is associated with a particular threat, 

839
00:52:13,150 --> 00:52:14,960
program counters, stack, pointer,

840
00:52:14,970 --> 00:52:17,180
and addresses and the registers. 

841
00:52:19,770 --> 00:52:25,930
What was the difference between a thread control block and process control block? 

842
00:52:27,070 --> 00:52:27,870
Like I mentioned, 

843
00:52:27,880 --> 00:52:32,530
the process control block has all the state associated with the resources

844
00:52:33,570 --> 00:52:35,460
associated with that process, 

845
00:52:36,310 --> 00:52:36,710
right? 

846
00:52:37,450 --> 00:52:43,230
Like filed a script daughters and based translation information

847
00:52:43,240 --> 00:52:43,870
and things like that. 

848
00:52:46,030 --> 00:52:46,920
Let's move on. 

849
00:52:46,930 --> 00:52:49,320
We are the, but thanks for that question.

850
00:52:49,330 --> 00:52:50,220
This is great. 

851
00:52:51,600 --> 00:52:54,250
And if I don't answer a particular question, 

852
00:52:54,260 --> 00:52:55,650
you can repeat it, 

853
00:52:58,130 --> 00:52:58,510
feel free. 

854
00:53:00,720 --> 00:53:01,390
Let me see. 

855
00:53:02,560 --> 00:53:03,020
Now, 

856
00:53:04,220 --> 00:53:06,790
when you have obviously multi, 

857
00:53:07,120 --> 00:53:11,060
when you have multiple processes running on the same hardware, 

858
00:53:11,530 --> 00:53:13,440
you need to multiply the hardware. 

859
00:53:13,650 --> 00:53:15,160
And the basic problem, 

860
00:53:15,730 --> 00:53:17,160
what is called this concurrency? 

861
00:53:18,630 --> 00:53:20,510
And concurrency meaning, 

862
00:53:20,860 --> 00:53:25,360
again, multiple processes wanting to access the same hardware.

863
00:53:25,940 --> 00:53:26,380
Okay? 

864
00:53:30,260 --> 00:53:36,190
Because you want to multiplex single cpu memory, 

865
00:53:36,840 --> 00:53:39,000
io devices, and things like that.

866
00:53:41,590 --> 00:53:43,150
And remember, again,

867
00:53:43,500 --> 00:53:47,550
the role of the operating system at the same time is to provide

868
00:53:47,560 --> 00:53:51,480
the illusion that each of these processes

869
00:53:52,810 --> 00:53:58,710
own a on a single machine is the only one executing on the machine. 

870
00:53:59,620 --> 00:54:02,760
The operating system is in charge to arbitrate, 

871
00:54:02,770 --> 00:54:03,840
to coordinate, 

872
00:54:04,090 --> 00:54:07,270
to manage all these concurrent activities while providing

873
00:54:07,280 --> 00:54:11,250
this a single machine abstraction to the processors, 

874
00:54:12,330 --> 00:54:13,210
the processes. 

875
00:54:15,910 --> 00:54:17,850
So that's kind of hard. 

876
00:54:20,680 --> 00:54:23,370
So one of the main abstraction, 

877
00:54:24,390 --> 00:54:27,170
one of the main resources needs to be multiplex. 

878
00:54:28,020 --> 00:54:29,650
A is a physical memory. 

879
00:54:31,500 --> 00:54:33,440
The way this is done, 

880
00:54:33,450 --> 00:54:40,360
it's using the concepts of virtual memory. 

881
00:54:40,830 --> 00:54:44,700
And we can extend that concept to the virtual to the machine, 

882
00:54:44,710 --> 00:54:45,900
right to the entire machine. 

883
00:54:46,800 --> 00:54:47,630
What we call, 

884
00:54:47,640 --> 00:54:53,940
when I said that we provide the illusion to a process that it owns

885
00:54:54,410 --> 00:54:55,760
is dedicated machine, 

886
00:54:56,000 --> 00:54:58,710
that machine is called virtual machine. 

887
00:54:59,340 --> 00:55:01,580
Or we also referred to it as a virtual machine. 

888
00:55:02,660 --> 00:55:03,000
Okay? 

889
00:55:06,660 --> 00:55:08,330
Then the question, then,

890
00:55:08,340 --> 00:55:10,970
it's about how to multiply these virtual machines. 

891
00:55:11,430 --> 00:55:13,980
The virtual machines has its virtual skip years, 

892
00:55:14,580 --> 00:55:16,490
virtual memory, and so forth.

893
00:55:18,720 --> 00:55:27,530
The first system doing this was the system short and interesting name. 

894
00:55:28,010 --> 00:55:30,310
It really was a few thousand lines of code, 

895
00:55:32,850 --> 00:55:34,170
the os 360, 

896
00:55:34,180 --> 00:55:41,070
which arguably was one of the first and probably the first commercial, 

897
00:55:41,080 --> 00:55:48,080
successful commercial operating system created by ibm was having at that time, 

898
00:55:48,090 --> 00:55:49,600
1 million slides of code. 

899
00:55:49,610 --> 00:55:50,400
It was huge. 

900
00:55:50,960 --> 00:55:56,530
Today probably you have windows has tens of million slides of code or even more. 

901
00:55:58,870 --> 00:55:59,340
It's again, 

902
00:55:59,350 --> 00:56:01,300
they just show you another data point

903
00:56:01,310 --> 00:56:04,420
about how complex a separating system came

904
00:56:09,610 --> 00:56:10,450
grew over time. 

905
00:56:11,060 --> 00:56:12,840
And this is a funny thing, right?

906
00:56:12,850 --> 00:56:13,840
It's like probably. 

907
00:56:13,850 --> 00:56:19,310
And the number of bugs in os 60 were probably the same or larger

908
00:56:19,320 --> 00:56:22,740
than the number of lines of code in the system. 

909
00:56:34,630 --> 00:56:38,080
So now, 

910
00:56:38,090 --> 00:56:41,040
what are some of the consequences of sharing? 

911
00:56:41,750 --> 00:56:42,120
Right? 

912
00:56:43,160 --> 00:56:45,080
If you have only threats, 

913
00:56:46,170 --> 00:56:49,390
the threads are going to share the same address face, 

914
00:56:51,750 --> 00:56:57,890
which means that the threads can have access to the other threads. 

915
00:56:58,170 --> 00:56:58,940
Data, for instance.

916
00:56:59,970 --> 00:57:00,810
So they can share, 

917
00:57:00,820 --> 00:57:05,290
but these means that they also can change the data of a different threat. 

918
00:57:06,100 --> 00:57:06,540
Right? 

919
00:57:10,320 --> 00:57:13,860
So that's very important to keep in mind. 

920
00:57:13,870 --> 00:57:15,300
And here is a question. 

921
00:57:15,670 --> 00:57:19,030
Can threads overwrite operating system functions? 

922
00:57:21,280 --> 00:57:24,840
We are not in the class to ask the class and people to answer. 

923
00:57:25,370 --> 00:57:32,480
But the answer here is no because the operating system doesn't run

924
00:57:32,490 --> 00:57:34,280
in the same address space. 

925
00:57:36,000 --> 00:57:38,590
But it's, again, all the threads in the same operator,

926
00:57:38,600 --> 00:57:39,910
in the same address space, 

927
00:57:39,920 --> 00:57:41,750
they can see each other beta. 

928
00:57:41,760 --> 00:57:45,360
They can drive read each other a bit as I can write each other a bit. 

929
00:57:47,140 --> 00:57:48,910
And this is, and actually,

930
00:57:48,920 --> 00:57:50,750
there are systems in the past, 

931
00:57:51,100 --> 00:57:55,790
which have this mode like windows 3.1, 

932
00:57:56,470 --> 00:58:02,140
which was most the first really successful windows operating system from microsoft, 

933
00:58:02,670 --> 00:58:05,990
and the early mic miking posh operating systems. 

934
00:58:06,860 --> 00:58:14,610
This is before oil stand in which you have this kind of threads are the

935
00:58:17,050 --> 00:58:19,520
are in the same other space even more. 

936
00:58:20,940 --> 00:58:21,570
They are. 

937
00:58:23,060 --> 00:58:30,770
The operating system didn't actively share the cpu among the applications. 

938
00:58:31,670 --> 00:58:32,210
Okay? 

939
00:58:33,130 --> 00:58:33,960
Instead, 

940
00:58:34,170 --> 00:58:40,160
the application have to use this kind of common yield to relinquish the cpu

941
00:58:40,170 --> 00:58:42,160
so other application can wrap, 

942
00:58:42,680 --> 00:58:43,120
right? 

943
00:58:43,760 --> 00:58:50,750
A misbehaving application who never use yield can monopolize the entire

944
00:58:51,490 --> 00:58:55,060
system and hang every other application. 

945
00:58:59,220 --> 00:59:00,200
This kind of, 

946
00:59:01,200 --> 00:59:02,840
therefore, what do you want?

947
00:59:03,150 --> 00:59:07,890
Though we want to have this product to have protection, right?

948
00:59:08,210 --> 00:59:11,390
We want that we have two processes. 

949
00:59:11,400 --> 00:59:13,350
And this is the concept of process, 

950
00:59:13,670 --> 00:59:15,840
is kind of encapsulate the protection, 

951
00:59:16,240 --> 00:59:19,870
because the thread in each process can see each other data can modify

952
00:59:19,880 --> 00:59:20,870
each other beta, 

953
00:59:20,880 --> 00:59:24,990
but stress from different processes cannot have access to the data

954
00:59:25,910 --> 00:59:27,020
from the other process. 

955
00:59:28,810 --> 00:59:32,210
Because the process contains the address space, 

956
00:59:32,790 --> 00:59:34,280
the address space. 

957
00:59:34,790 --> 00:59:40,700
It's a unit of protection of the address space in the memory. 

958
00:59:42,030 --> 00:59:44,460
And here it's here again, 

959
00:59:44,470 --> 00:59:49,780
you have two programs of two processes as a brown one and the green one, 

960
00:59:49,790 --> 00:59:51,300
process one and process two. 

961
00:59:51,310 --> 00:59:55,940
And here a process to shouldn't have access to the memory of frost, 

962
00:59:55,950 --> 00:59:59,580
swan shouldn't have access to the operating system memory, 

963
00:59:59,840 --> 01:00:03,850
or shouldn't have access to the file descriptor of other processes. 

964
01:00:05,120 --> 01:00:05,510
Okay? 

965
01:00:10,150 --> 01:00:12,660
Typically, when they try to access resources,

966
01:00:12,670 --> 01:00:17,180
they don't own a process to operating system will cause

967
01:00:17,190 --> 01:00:21,780
a segmentation fault and will crash the offending process. 

968
01:00:23,570 --> 01:00:25,040
Let me just, 

969
01:00:26,160 --> 01:00:27,950
if there are a few more questions, 

970
01:00:34,310 --> 01:00:38,930
how are operating system tested in development when the complexity is very high? 

971
01:00:40,420 --> 01:00:43,420
That's why there are so few operating system being developed

972
01:00:43,430 --> 01:00:44,420
a new operating system, 

973
01:00:44,430 --> 01:00:46,780
because it's fundamentally extremely hard. 

974
01:00:50,900 --> 01:00:54,670
It's just good software engineering practices. 

975
01:00:56,560 --> 01:01:01,750
You are very aggressive during the unit testing and then testing and so forth. 

976
01:01:02,400 --> 01:01:04,610
Even so with all of these, 

977
01:01:04,620 --> 01:01:06,460
because they are so complex. 

978
01:01:07,640 --> 01:01:08,990
Many operating systems, 

979
01:01:09,000 --> 01:01:10,310
they still have bugs. 

980
01:01:11,150 --> 01:01:13,310
I'm not sure I have that plot, 

981
01:01:13,320 --> 01:01:21,520
but it is a plot in which you can see like when people debug the operating system, 

982
01:01:23,070 --> 01:01:25,450
your initially you are going to have a lot of bugs. 

983
01:01:25,460 --> 01:01:26,930
And then after a while, 

984
01:01:27,160 --> 01:01:30,590
the box, the rate at which new bucks are occur,

985
01:01:30,600 --> 01:01:31,750
it's reducing. 

986
01:01:32,310 --> 01:01:33,980
This kind of ones are very flat, 

987
01:01:33,990 --> 01:01:35,940
and then you should the operating system. 

988
01:01:36,270 --> 01:01:38,230
This doesn't mean that you have zero box. 

989
01:01:38,240 --> 01:01:41,750
It just seems that the number of boxes rarely enough, 

990
01:01:42,000 --> 01:01:43,870
the operating system is usable. 

991
01:01:50,690 --> 01:01:53,560
All cp us share the same resources. 

992
01:01:53,570 --> 01:01:56,670
It is ii was saying problem, 

993
01:01:56,680 --> 01:02:01,920
he spoke there by saying the question is by saying they all cpu share

994
01:02:01,930 --> 01:02:03,400
the same resources. 

995
01:02:03,740 --> 01:02:06,190
It is referring to stress within a single process

996
01:02:06,200 --> 01:02:08,290
or process sharing resources and so forth. 

997
01:02:10,790 --> 01:02:15,380
I was referring at basically all threads in the same process, 

998
01:02:15,390 --> 01:02:16,740
share the same resources. 

999
01:02:17,320 --> 01:02:22,050
Then all processes also share the same physical resources in terms

1000
01:02:22,060 --> 01:02:26,980
of the cpu and in terms of physical memory. 

1001
01:02:27,720 --> 01:02:28,170
Okay? 

1002
01:02:30,270 --> 01:02:31,940
Power address space is allowed. 

1003
01:02:31,950 --> 01:02:35,820
It seems inefficient to lock a large blocks or have many small blocks. 

1004
01:02:36,730 --> 01:02:42,780
There is a big trade off here between having small blocks and large blocks. 

1005
01:02:43,920 --> 01:02:48,230
You have what is called internal fragmentation or external fragmentation. 

1006
01:02:48,730 --> 01:02:50,320
For instance, with large blocks,

1007
01:02:50,330 --> 01:02:52,560
if you don't use the entire block, 

1008
01:02:52,810 --> 01:02:54,790
you are located, then you wear this memory,

1009
01:02:58,590 --> 01:03:00,820
something like and so, 

1010
01:03:01,540 --> 01:03:04,130
but so you need to be smart about it. 

1011
01:03:04,570 --> 01:03:07,890
Today's operating systems allocate the memory in what? 

1012
01:03:07,900 --> 01:03:10,300
In small blocks or pages, 

1013
01:03:10,310 --> 01:03:12,060
which are a few kilobytes, 

1014
01:03:12,470 --> 01:03:15,390
four kilobytes, 16 kilobytes of 72 kilobytes.

1015
01:03:15,800 --> 01:03:19,840
And then you have many of these small blocks, 

1016
01:03:20,170 --> 01:03:22,740
then you need to manage them efficiently. 

1017
01:03:23,190 --> 01:03:26,060
And we are going to learn how this is done. 

1018
01:03:27,690 --> 01:03:32,480
Ideally, would application use yield when they are performing?

1019
01:03:32,490 --> 01:03:34,080
Absolutely, that's a great..

1020
01:03:34,580 --> 01:03:35,250
Sorry, 

1021
01:03:36,060 --> 01:03:38,730
that to read the full question, ideally,

1022
01:03:38,740 --> 01:03:42,870
what application is yield when they are performing our operations. 

1023
01:03:44,160 --> 01:03:45,350
That's exactly the case. 

1024
01:03:45,360 --> 01:03:47,830
When you are going to send some data, 

1025
01:03:48,300 --> 01:03:53,370
then you can do yelled because you can wait for, excuse me,

1026
01:03:55,890 --> 01:03:58,720
or when you are going to execute the yield, 

1027
01:03:59,390 --> 01:04:03,670
or you can when the interaction on the application is interactive, 

1028
01:04:03,680 --> 01:04:07,510
like an editor on a click on the keyboard, 

1029
01:04:08,350 --> 01:04:11,070
then you see the characters appearing on the screen. 

1030
01:04:11,080 --> 01:04:12,880
In that case, 

1031
01:04:12,890 --> 01:04:19,660
the editor will do yield after each time after he displays a character. 

1032
01:04:20,730 --> 01:04:24,790
And it's going to wait for the next character to be typed into what I

1033
01:04:24,800 --> 01:04:26,290
have to get from the keyboard. 

1034
01:04:29,480 --> 01:04:33,650
What does threads can share instruction mean on the previous slide? 

1035
01:04:42,190 --> 01:04:47,540
This means that again, 

1036
01:04:47,550 --> 01:04:50,180
the threads are in the same address space. 

1037
01:04:50,970 --> 01:04:51,970
And, 

1038
01:04:53,470 --> 01:04:54,380
for instance, 

1039
01:04:56,340 --> 01:04:58,410
even between processes, you can share that.

1040
01:04:58,420 --> 01:05:00,810
But if you have the same user, same libraries,

1041
01:05:01,580 --> 01:05:02,690
and multiple study, 

1042
01:05:02,700 --> 01:05:03,930
the same libraries, 

1043
01:05:04,920 --> 01:05:07,330
you are going to have only one copy of the library, 

1044
01:05:08,090 --> 01:05:12,470
which is going to be shared by the threads. 

1045
01:05:12,480 --> 01:05:13,990
You are not going to have multiple copies. 

1046
01:05:18,380 --> 01:05:22,250
Here is another picture showing the boundary protection boundary, 

1047
01:05:22,260 --> 01:05:27,310
and how the row resources access to the row resources is protected

1048
01:05:27,320 --> 01:05:28,570
from the processes. 

1049
01:05:29,960 --> 01:05:32,390
And like I we discussed last time, 

1050
01:05:32,950 --> 01:05:36,140
I we already said a few times this lecture and this lecture, 

1051
01:05:36,560 --> 01:05:40,030
the os operating system isolate processes from each other, 

1052
01:05:40,410 --> 01:05:44,070
make sure they don't read and write data from each other. 

1053
01:05:44,390 --> 01:05:47,870
The operating system also isolate itself from other processes. 

1054
01:05:49,890 --> 01:05:53,920
Again, the challenge here because all of those run on the same harbor,

1055
01:05:59,570 --> 01:06:01,510
this is, again,

1056
01:06:02,730 --> 01:06:03,240
some, 

1057
01:06:04,560 --> 01:06:07,950
again, summary and repeating what was in the previous slide,

1058
01:06:07,960 --> 01:06:09,670
maybe with a little bit more details. 

1059
01:06:12,010 --> 01:06:15,000
The operating system must protect itself from the user programs, 

1060
01:06:15,010 --> 01:06:16,320
from the user processes. 

1061
01:06:18,100 --> 01:06:21,810
And what does it mean? 

1062
01:06:21,820 --> 01:06:25,780
I need to and why is that needed? 

1063
01:06:26,250 --> 01:06:28,150
Is obviously for security, 

1064
01:06:29,120 --> 01:06:31,270
if the operating system is not protecting, 

1065
01:06:31,280 --> 01:06:35,230
and then it's easier for an application to break into another application. 

1066
01:06:35,730 --> 01:06:38,760
This is the confidential data or private data. 

1067
01:06:40,380 --> 01:06:44,630
I just mentioned about the privacy in the same example. 

1068
01:06:44,960 --> 01:06:48,990
And one of the amazing is reliability, right?

1069
01:06:49,000 --> 01:06:50,630
If the operating system fails, 

1070
01:06:51,160 --> 01:06:57,780
then the computer it's any unusable, 

1071
01:07:00,870 --> 01:07:01,840
the operating system. 

1072
01:07:01,850 --> 01:07:04,060
It better runs at all times. 

1073
01:07:04,890 --> 01:07:07,610
And fairness, 

1074
01:07:07,990 --> 01:07:08,720
it's, again,

1075
01:07:08,730 --> 01:07:13,690
the operating system is the one which ensures that the processes, 

1076
01:07:13,960 --> 01:07:19,800
different processes get a fair access to the harbor program. 

1077
01:07:20,570 --> 01:07:21,700
Like I mentioned, 

1078
01:07:22,090 --> 01:07:26,710
the operating system is to protect user programs from one another. 

1079
01:07:29,120 --> 01:07:33,240
One of the primary mechanisms of protections. 

1080
01:07:33,570 --> 01:07:35,230
It's a translation. 

1081
01:07:36,720 --> 01:07:38,110
And we'll see that next. 

1082
01:07:38,810 --> 01:07:42,990
And the translation ensure that the process can only touch

1083
01:07:43,370 --> 01:07:46,220
its own address space and cannot touch

1084
01:07:47,390 --> 01:07:50,460
the address physical addresses of another process. 

1085
01:07:51,950 --> 01:07:53,460
There are a few of other mechanics, 

1086
01:07:53,470 --> 01:07:55,900
like political edge instruction that can be only executed

1087
01:07:55,910 --> 01:07:57,580
on by the operating system. 

1088
01:07:59,660 --> 01:08:01,450
There are some special registers. 

1089
01:08:01,460 --> 01:08:06,830
Only operating system has access to the circumstances. 

1090
01:08:06,840 --> 01:08:07,190
So far. 

1091
01:08:07,200 --> 01:08:08,550
We talk about threads, 

1092
01:08:08,560 --> 01:08:10,230
we talked about addresses, 

1093
01:08:10,240 --> 01:08:12,350
we also talk quite a bit about processes. 

1094
01:08:12,770 --> 01:08:14,590
This is, again, to make it explicit.

1095
01:08:15,110 --> 01:08:23,970
Once more, the process is basically another space+1 or more threats.

1096
01:08:25,560 --> 01:08:28,330
So processes allocate resources. 

1097
01:08:29,400 --> 01:08:31,910
Then it has a thread, 

1098
01:08:32,260 --> 01:08:34,490
which basically is a unit of execution. 

1099
01:08:38,280 --> 01:08:39,590
Why do you have processes? 

1100
01:08:39,600 --> 01:08:41,670
Because the processes protect from each other? 

1101
01:08:42,190 --> 01:08:44,030
Stress do not protect from each other. 

1102
01:08:44,840 --> 01:08:46,360
They share our same other space. 

1103
01:08:46,370 --> 01:08:50,470
They share all the resources within a process. 

1104
01:08:53,600 --> 01:08:56,040
However, threads are more efficient like we discussed.

1105
01:08:56,400 --> 01:08:58,930
The context switching between the threading the same process is

1106
01:08:58,940 --> 01:09:02,030
much quicker than between threads and different processes. 

1107
01:09:03,210 --> 01:09:08,760
Also, so communication between studies in the same process much faster,

1108
01:09:09,170 --> 01:09:10,510
because you can use share memory. 

1109
01:09:10,520 --> 01:09:14,500
You can use the other space which is already shared between the stress, 

1110
01:09:14,510 --> 01:09:15,900
to communicate, between the stress,

1111
01:09:18,170 --> 01:09:19,520
between processes. 

1112
01:09:20,010 --> 01:09:22,820
You need to communicate through other means, 

1113
01:09:23,300 --> 01:09:25,620
and you need to contact you between the processes, 

1114
01:09:25,890 --> 01:09:26,990
which is far more expensive. 

1115
01:09:29,280 --> 01:09:32,850
And typical in application consist of one or more processes. 

1116
01:09:32,860 --> 01:09:34,170
A process consists of one, 

1117
01:09:34,180 --> 01:09:35,450
more one or more threats. 

1118
01:09:40,800 --> 01:09:42,910
Here, you can see in this figure,

1119
01:09:46,010 --> 01:09:49,440
on the left hand side, you see one process with a single stretch.

1120
01:09:51,110 --> 01:09:51,550
Right? 

1121
01:09:52,170 --> 01:09:54,680
You can see what belongs you have. 

1122
01:09:54,950 --> 01:09:58,780
The process owns is that you have the memory, 

1123
01:09:59,910 --> 01:10:01,430
others, other space.

1124
01:10:01,440 --> 01:10:03,550
You have the code data, file,

1125
01:10:03,560 --> 01:10:04,670
card file, 

1126
01:10:04,680 --> 01:10:07,290
descriptors that I used to stack. 

1127
01:10:10,280 --> 01:10:11,950
This belongs to a process. 

1128
01:10:12,910 --> 01:10:14,300
And now on the right hand side, 

1129
01:10:14,310 --> 01:10:16,140
you have different threading the same process. 

1130
01:10:17,380 --> 01:10:19,850
Here you can see notice at the top, 

1131
01:10:19,860 --> 01:10:22,850
the code and the data and the file descriptors, 

1132
01:10:22,860 --> 01:10:27,770
all these resources are shared across all the threads in the different

1133
01:10:28,260 --> 01:10:29,170
in the same process. 

1134
01:10:29,990 --> 01:10:34,260
What is not shared is the execution state of his thread. 

1135
01:10:34,490 --> 01:10:37,310
So his thread come its own registers from its own stack. 

1136
01:10:38,850 --> 01:10:39,260
Right? 

1137
01:10:39,510 --> 01:10:42,860
Registers includes a program counter as a stack pointer and things like that. 

1138
01:10:43,820 --> 01:10:44,190
Okay? 

1139
01:10:46,240 --> 01:10:50,050
And the address encapsulate protection. 

1140
01:10:50,330 --> 01:10:50,540
Right? 

1141
01:10:50,550 --> 01:10:53,440
It's a passive part of the process. 

1142
01:10:53,950 --> 01:10:54,350
Right? 

1143
01:10:55,860 --> 01:10:57,560
The thread is an active part, 

1144
01:10:58,020 --> 01:10:59,250
concurrent concurrence, 

1145
01:10:59,260 --> 01:11:00,490
encapsulate concurrence. 

1146
01:11:09,000 --> 01:11:09,600
Why? 

1147
01:11:09,610 --> 01:11:13,010
Multiple stress for other space? 

1148
01:11:20,550 --> 01:11:20,860
Too bad? 

1149
01:11:20,870 --> 01:11:21,540
You cannot. 

1150
01:11:21,790 --> 01:11:23,540
It's hard to have this question answering. 

1151
01:11:23,550 --> 01:11:26,730
You have in the class on this web another. 

1152
01:11:29,600 --> 01:11:34,480
But you want to have more because you want to

1153
01:11:37,910 --> 01:11:41,650
build higher performance applications. 

1154
01:11:42,980 --> 01:11:46,670
Like, for instance, if you have an application which is doing,

1155
01:11:46,680 --> 01:11:51,860
you have waiting from the keyboard and they're doing some processing

1156
01:11:51,870 --> 01:11:53,940
like rendering graphics and things like that. 

1157
01:11:54,390 --> 01:12:00,240
You are and a as a result of what are the users? 

1158
01:12:00,250 --> 01:12:02,730
It's users input. 

1159
01:12:03,490 --> 01:12:06,310
Then you are going to have two threads. 

1160
01:12:07,190 --> 01:12:10,980
You want this stress to communicate between others to send the user input

1161
01:12:12,520 --> 01:12:13,630
To the thread, 

1162
01:12:13,640 --> 01:12:14,950
which is being rendering. 

1163
01:12:15,400 --> 01:12:18,030
You want these two threads to be in the same process. 

1164
01:12:18,040 --> 01:12:19,790
If they are not in the same processes, 

1165
01:12:20,230 --> 01:12:22,200
then you're going to be in a different process. 

1166
01:12:22,210 --> 01:12:24,700
You need to incur contact switching and see like that, 

1167
01:12:25,070 --> 01:12:26,890
which is going to be much less efficient. 

1168
01:12:28,890 --> 01:12:29,890
That's one example. 

1169
01:12:32,250 --> 01:12:34,040
Some example, some questions.

1170
01:12:34,050 --> 01:12:34,480
Now, 

1171
01:12:36,020 --> 01:12:39,250
how can application have multiple processes? 

1172
01:12:39,880 --> 01:12:44,070
Is it if it needs multiple instances of a CPU or something? 

1173
01:12:44,740 --> 01:12:46,810
What the practical reasoning for this, 

1174
01:12:46,820 --> 01:12:48,290
I thought it was 1~1. 

1175
01:12:52,150 --> 01:12:53,860
There are many reasons, 

1176
01:12:53,870 --> 01:12:57,780
a multiple and application can have multiple processes. 

1177
01:12:57,790 --> 01:13:00,440
And let me give you an extreme example. 

1178
01:13:00,450 --> 01:13:03,820
And then you can imagine that will happen also on a single machine. 

1179
01:13:03,830 --> 01:13:09,200
An application like Facebook has obviously multiple processes because runs

1180
01:13:09,210 --> 01:13:10,400
on different machines. 

1181
01:13:10,990 --> 01:13:13,390
You have one part which is running on your machine. 

1182
01:13:13,400 --> 01:13:14,430
It's the front end, 

1183
01:13:14,670 --> 01:13:17,580
and then a path which is running on the back end. 

1184
01:13:18,160 --> 01:13:18,530
Right? 

1185
01:13:19,710 --> 01:13:24,860
You can imagine many of these applications like that could be client and server. 

1186
01:13:24,870 --> 01:13:27,750
Some are part of the application is handling, say,

1187
01:13:27,760 --> 01:13:29,300
an access to the database. 

1188
01:13:29,310 --> 01:13:38,130
And some part of the application is handling the front end. 

1189
01:13:38,670 --> 01:13:40,780
Then you can have a multi user application, 

1190
01:13:40,790 --> 01:13:43,580
and then you want to isolate the user from each other

1191
01:13:43,590 --> 01:13:46,940
in the same application for each year that you are going to provide

1192
01:13:46,950 --> 01:13:48,980
the different process, 

1193
01:13:48,990 --> 01:13:49,200
right? 

1194
01:13:49,720 --> 01:13:54,010
Or you want to process to have stronger isolation, like, for instance,

1195
01:13:54,020 --> 01:13:54,850
in your browser, 

1196
01:13:55,470 --> 01:13:57,360
in your browser, you have different taps.

1197
01:13:58,130 --> 01:13:59,840
And if every tap is, 

1198
01:14:01,050 --> 01:14:04,580
you run it in the same process, 

1199
01:14:04,970 --> 01:14:08,590
then you have no protection. 

1200
01:14:09,220 --> 01:14:13,540
Therefore, a misbehaving web page can crash your browser.

1201
01:14:16,320 --> 01:14:19,780
If you have each other process and you have strong isolation between processes. 

1202
01:14:19,790 --> 01:14:21,740
So these are quite a few examples. 

1203
01:14:22,020 --> 01:14:22,520
Now, 

1204
01:14:23,420 --> 01:14:24,860
we are not going in details, 

1205
01:14:24,870 --> 01:14:29,880
but there are more things between processes and threads. 

1206
01:14:30,290 --> 01:14:34,680
There are actually other ways people try to maintain the efficiency

1207
01:14:34,690 --> 01:14:36,520
to preserve the efficiency of the thread, 

1208
01:14:36,870 --> 01:14:41,420
but are some protection which you have for across from processes. 

1209
01:14:41,940 --> 01:14:44,230
We are not going to discuss about this, though,

1210
01:14:45,340 --> 01:14:47,000
but hopefully answer that question, 

1211
01:14:49,150 --> 01:14:51,420
that attack doesn't depend on waiting, 

1212
01:14:51,430 --> 01:14:54,140
can take over while the other is waiting, 

1213
01:14:54,150 --> 01:14:56,140
even if the superior is multiplex. 

1214
01:15:00,940 --> 01:15:02,490
I'm afraid I don't. 

1215
01:15:03,740 --> 01:15:05,430
This is a statement I

1216
01:15:16,940 --> 01:15:17,330
that. 

1217
01:15:17,640 --> 01:15:19,710
But what the statement said is correct. 

1218
01:15:19,720 --> 01:15:21,550
The task which doesn't depend on waiting, 

1219
01:15:21,560 --> 01:15:24,230
can take over the task which depends on waiting. 

1220
01:15:24,430 --> 01:15:29,200
Is it going to be suspended to wait for some part and so on and on a task

1221
01:15:29,210 --> 01:15:32,730
which a process which waits for an event to happen? 

1222
01:15:33,320 --> 01:15:38,690
Like getting an input event from getting some data from the network

1223
01:15:39,220 --> 01:15:43,260
is suspended and waiting for that event to happen. 

1224
01:15:43,270 --> 01:15:45,980
And during that time another process can run. 

1225
01:15:46,230 --> 01:15:48,790
The operating system can takes care of that. 

1226
01:15:53,940 --> 01:15:54,430
Okay? 

1227
01:15:56,090 --> 01:16:00,850
First, finally, the force operating system concept is dual mode operation.

1228
01:16:01,140 --> 01:16:08,880
The old mode operation is fundamentally concern about how you are going to share

1229
01:16:09,270 --> 01:16:11,240
the hardware, 

1230
01:16:11,600 --> 01:16:16,780
the machine between processes, 

1231
01:16:16,790 --> 01:16:18,860
the user processes and the operating system. 

1232
01:16:21,750 --> 01:16:22,580
Typically, this happens.

1233
01:16:22,590 --> 01:16:24,260
You have 2 months for that. 

1234
01:16:24,270 --> 01:16:25,660
You have a user mode, 

1235
01:16:26,570 --> 01:16:29,320
which is used when you run a user process. 

1236
01:16:29,650 --> 01:16:30,960
And the kernel amount, 

1237
01:16:31,170 --> 01:16:33,330
which is used on the operating system runs. 

1238
01:16:33,870 --> 01:16:39,480
The reason for that is the operating system actually has access to a lot

1239
01:16:39,490 --> 01:16:41,640
of more resources and

1240
01:16:41,650 --> 01:16:47,990
even to processes resources during when it is running. 

1241
01:16:48,620 --> 01:16:48,930
Right? 

1242
01:16:50,190 --> 01:16:53,460
The way to differentiate between these two mouths is you have a bit. 

1243
01:16:55,350 --> 01:16:57,680
It's a user system mode beat. 

1244
01:16:58,560 --> 01:17:00,310
When you set to zero, for instance,

1245
01:17:00,320 --> 01:17:01,550
it's a user mode. 

1246
01:17:01,890 --> 01:17:03,490
He said to one is kernel mode, 

1247
01:17:08,020 --> 01:17:15,420
how the transition happened from a user process to a kernel to the happens

1248
01:17:15,880 --> 01:17:17,620
from the user to kernel. 

1249
01:17:17,860 --> 01:17:20,460
You set the system out now, 

1250
01:17:22,840 --> 01:17:25,080
save the user program counters. 

1251
01:17:26,720 --> 01:17:35,270
And all the state of that particular thread execution state. 

1252
01:17:35,280 --> 01:17:36,550
And then from the care number, 

1253
01:17:36,560 --> 01:17:37,710
they use their transition. 

1254
01:17:37,720 --> 01:17:42,780
You clear, the system and restored as an appropriate user program counter.

1255
01:17:43,480 --> 01:17:43,780
Right? 

1256
01:17:44,740 --> 01:17:51,070
And you return from the interrupt. 

1257
01:17:51,410 --> 01:17:54,310
And here how you, 

1258
01:17:54,320 --> 01:17:57,270
as a user mode and the kennel mode interact with each other. 

1259
01:17:57,280 --> 01:17:58,390
So on one hand, 

1260
01:17:58,980 --> 01:18:00,920
from the canon mode, you have exact.

1261
01:18:00,930 --> 01:18:05,760
And this is how you run a process that throw you the kernel. 

1262
01:18:05,770 --> 01:18:09,110
And the operating system is launching a new process. 

1263
01:18:11,770 --> 01:18:14,080
Then when the process exits, 

1264
01:18:14,090 --> 01:18:15,400
you return to the kernel. 

1265
01:18:15,410 --> 01:18:17,960
The kernel is taking care of freeing all the resources, 

1266
01:18:17,970 --> 01:18:19,200
allocated that process. 

1267
01:18:19,210 --> 01:18:21,000
So these processes, these are resources,

1268
01:18:21,500 --> 01:18:23,140
can be used by other processes. 

1269
01:18:23,800 --> 01:18:25,450
Then it's a system call. 

1270
01:18:26,540 --> 01:18:28,650
This is one operating system. 

1271
01:18:28,660 --> 01:18:32,170
I'm sorry, when the user process requires some functionality,

1272
01:18:32,180 --> 01:18:36,380
some services invoke some services from the operating system. 

1273
01:18:37,010 --> 01:18:39,960
Example of some services like accessing a file, 

1274
01:18:40,480 --> 01:18:41,710
sending some data, 

1275
01:18:44,160 --> 01:18:46,790
reading input data from the keyboard. 

1276
01:18:48,430 --> 01:18:49,500
This is return, 

1277
01:18:49,510 --> 01:18:53,300
this is after the operating system satisfies this request, 

1278
01:18:53,840 --> 01:18:56,810
then is returning control back to the user. 

1279
01:18:59,280 --> 01:19:02,160
And then there are user interrupts. 

1280
01:19:03,150 --> 01:19:04,500
The user interacts. 

1281
01:19:05,700 --> 01:19:09,650
One example is basically you can have a secure, 

1282
01:19:09,660 --> 01:19:12,720
you can actually kill a process. 

1283
01:19:15,620 --> 01:19:18,530
That's one example, a of a user interrupt.

1284
01:19:20,680 --> 01:19:21,950
There are also interrupted, 

1285
01:19:21,960 --> 01:19:23,230
come from the hardware, 

1286
01:19:23,650 --> 01:19:26,690
like when packet arrives, 

1287
01:19:27,470 --> 01:19:30,910
when you click on a keyboard, 

1288
01:19:31,530 --> 01:19:33,270
then you have an interrupt. 

1289
01:19:33,630 --> 01:19:36,070
The operator gives a mystery, the symbols.

1290
01:19:37,290 --> 01:19:37,740
Okay? 

1291
01:19:39,050 --> 01:19:40,840
Then you can return from the interrupt. 

1292
01:19:40,850 --> 01:19:41,880
It's a user level interrupt. 

1293
01:19:41,890 --> 01:19:43,920
You return to the internet from the interrupt, 

1294
01:19:43,930 --> 01:19:45,520
the returns, a control,

1295
01:19:45,530 --> 01:19:48,660
eventually to the user. 

1296
01:19:49,450 --> 01:19:52,340
And finally, 

1297
01:19:52,350 --> 01:19:53,740
there are exceptions. 

1298
01:19:53,970 --> 01:20:01,950
And exceptions are when the user of somehow

1299
01:20:01,960 --> 01:20:05,410
the program is doing something which is not allowed, 

1300
01:20:05,750 --> 01:20:08,900
like or for instance, 

1301
01:20:08,910 --> 01:20:10,540
you can have division by zero. 

