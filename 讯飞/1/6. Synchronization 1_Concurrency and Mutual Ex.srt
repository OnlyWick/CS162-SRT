1
00:00:05,110 --> 00:00:06,110
Hello, everyone.
大家好。

2
00:00:07,920 --> 00:00:09,670
Let's start the 6th lecture.
让我们开始第六次讲座。

3
00:00:10,620 --> 00:00:11,050
Today,
今天，

4
00:00:11,060 --> 00:00:15,690
we are going to continue the inter process communication to talk
我们将继续进行进程间通信来交流。

5
00:00:15,700 --> 00:00:18,010
about the inter process communication primitives.
关于进程间通信原语。

6
00:00:18,550 --> 00:00:18,890
In particular,
特别是，

7
00:00:18,900 --> 00:00:24,480
we are going to talk about sockets which allowed to applications
我们将讨论允许应用程序使用的套接字。

8
00:00:24,490 --> 00:00:27,080
to communicate over the network.
进行网络通信。

9
00:00:27,820 --> 00:00:31,100
And then we are going to start talking about concurrency.
然后我们将开始讨论并发性。

10
00:00:33,040 --> 00:00:36,710
This will be a pretty long topic which will go over the pure next,
这将是一个相当长的话题，将详细介绍纯粹的下一个。

11
00:00:36,720 --> 00:00:37,830
a couple of lectures.
几节课程。

12
00:00:38,900 --> 00:00:40,770
As always, if you have any questions,
如常，如果你有任何问题，

13
00:00:40,780 --> 00:00:44,030
please ask in the q and a thread,
请在问答主题中提问。

14
00:00:44,040 --> 00:00:49,280
or i'll try also to check on the chat.
或者我也会尝试在聊天中查看。

15
00:00:53,690 --> 00:00:54,520
Let's start.
让我们开始吧。

16
00:00:56,760 --> 00:00:57,280
So,
那么，

17
00:00:59,510 --> 00:01:03,330
again, like we discussed earlier in this class,
再次，就像我们在这堂课上讨论过的那样，

18
00:01:03,730 --> 00:01:06,840
today, a lot of applications are distributed, right?
是的，现在有很多应用程序是分布式的，对吗？

19
00:01:06,850 --> 00:01:09,760
They are not only running on a single machine on your laptop,
它们不仅在你的笔记本电脑上运行在单台机器上，

20
00:01:10,930 --> 00:01:12,570
but most of them, they have a back end.
但是大多数情况下，它们都有一个后端。

21
00:01:13,150 --> 00:01:18,710
You need to go over the network in order to implement
你需要通过网络来实现。

22
00:01:18,720 --> 00:01:21,290
almost any functionality of the application.
几乎可以实现应用程序的任何功能。

23
00:01:21,800 --> 00:01:24,570
And the exam, your web browser is a great examples.
而且考试中，你的网络浏览器是一个很好的例子。

24
00:01:25,800 --> 00:01:30,750
Anything you are using today almost like many of the applications like facebook,
今天你使用的任何东西几乎都像许多应用程序一样，比如Facebook，

25
00:01:30,760 --> 00:01:31,350
twitter,
Twitter是一个社交媒体平台，用户可以通过发布短消息（推文）与其他用户进行交流和分享信息。用户可以关注其他用户，以便在其发布新推文时收到通知。Twitter也被广泛用于实时新闻报道、舆论交流和社交网络营销。

26
00:01:31,870 --> 00:01:34,650
and google application like google docs.
以及谷歌应用，如谷歌文档。

27
00:01:35,720 --> 00:01:40,280
And obviously google itself as they look this way,
而且显然谷歌自己也是这个样子的，因为他们看起来就是这样的。

28
00:01:40,490 --> 00:01:44,230
you have a piece of code running on the client side, on your machine,
你在客户端上有一段代码在你的机器上运行。

29
00:01:44,240 --> 00:01:45,510
on your phone,
在你的手机上，

30
00:01:45,940 --> 00:01:50,450
and a bigger piece of code which runs on the back end,
还有一个在后端运行的更大的代码片段，

31
00:01:50,770 --> 00:01:53,060
on a bunch of servers in the data centers.
在数据中心的一堆服务器上。

32
00:01:55,800 --> 00:01:59,080
And typically, all these applications, in general,
通常情况下，所有这些应用程序，总的来说，

33
00:01:59,940 --> 00:02:02,130
looks like that, like this.
看起来是这样的，就像这样。

34
00:02:02,790 --> 00:02:04,810
The client sends a request,
客户端发送一个请求，

35
00:02:05,520 --> 00:02:07,240
and it gets a reply back.
然后它收到了一条回复。

36
00:02:08,140 --> 00:02:11,170
The request can be a query and google.
该请求可以是一个查询和谷歌搜索。

37
00:02:11,590 --> 00:02:15,640
The reply can be the answers to that.
回复可以是对那些问题的答案。

38
00:02:16,820 --> 00:02:22,430
The it can be the reply to your search query.
这可能是对你搜索查询的回复。

39
00:02:24,110 --> 00:02:27,640
And for something like that flicks,
对于这样的闪烁问题，

40
00:02:28,350 --> 00:02:29,740
the reply will be,
回复将会是：

41
00:02:29,750 --> 00:02:31,700
as a request will be your clicks.
作为请求，将是您的点击。

42
00:02:32,170 --> 00:02:33,360
Selecting a movie,
选择一部电影，

43
00:02:33,370 --> 00:02:37,120
the reply can be also recommendation of other movies or the movies
回复还可以是其他电影或电视剧的推荐。

44
00:02:37,130 --> 00:02:40,780
start streaming and things like that.
开始流媒体和类似的事情。

45
00:02:45,100 --> 00:02:51,200
And typically you have more than one client talking with the same set
通常情况下，您会有多个客户端与同一组进行通信。

46
00:02:51,210 --> 00:02:52,400
about the same machine.
关于同一台机器。

47
00:02:54,050 --> 00:02:55,320
And like, for instance,
例如，

48
00:02:55,330 --> 00:02:56,800
have many web clients,
有很多网络客户端

49
00:02:56,810 --> 00:02:59,880
and the many of them are talking with the same web server.
而且他们中的许多人都在与同一个网络服务器进行通信。

50
00:03:01,410 --> 00:03:05,000
This is a kind of pattern communication pattern we have to implement
这是一种我们需要实现的通信模式。

51
00:03:05,010 --> 00:03:05,900
under the hood.
在幕后。

52
00:03:14,200 --> 00:03:18,590
So here it's about how also a little bit more and more details
这里是关于如何更详细地了解一些细节的内容。

53
00:03:18,600 --> 00:03:21,510
about how client and the server are similar.
关于客户端和服务器的相似之处。

54
00:03:21,820 --> 00:03:22,970
And even more importantly,
而且更重要的是，

55
00:03:22,980 --> 00:03:24,330
how they are different.
它们有何不同之处。

56
00:03:25,220 --> 00:03:27,170
The client again, sends a request,
客户端再次发送请求，

57
00:03:27,750 --> 00:03:35,610
like get index html this basically specified to get as a content of the web
获取index.html文件，这基本上指定获取网页的内容。

58
00:03:35,620 --> 00:03:40,260
page of a site of the first page of a site to render on your machine.
在您的计算机上渲染一个网站的第一页页面。

59
00:03:42,860 --> 00:03:45,990
And in order to do that,
为了做到这一点，

60
00:03:46,000 --> 00:03:50,390
you need to contact a server which stores the index dot html,
你需要联系一个存储 index.html 的服务器。

61
00:03:50,720 --> 00:03:54,790
this fight, the content of the page you want to render on your machine.
这个问题是关于在你的机器上渲染页面的内容。

62
00:03:56,330 --> 00:04:02,630
One thing obviously need to do is that when we need to know is the address
有一件明显需要做的事情是，当我们需要知道的是地址时。

63
00:04:02,640 --> 00:04:03,320
of that server,
该服务器的

64
00:04:03,330 --> 00:04:03,550
right?
对的？

65
00:04:03,560 --> 00:04:05,160
It's like when you make a call,
就像你打电话时，

66
00:04:05,170 --> 00:04:07,230
you need to know the number you are calling.
你需要知道你要拨打的号码。

67
00:04:09,490 --> 00:04:09,870
Okay?
好的？

68
00:04:10,330 --> 00:04:11,550
So keep in mind that.
请记住这一点。

69
00:04:11,770 --> 00:04:14,320
So you need to know the address of the seller from it.
所以你需要从中得知卖家的地址。

70
00:04:14,330 --> 00:04:15,280
You get the content.
你已经获得了内容。

71
00:04:16,100 --> 00:04:18,860
And now the server,
现在是服务器的回合，

72
00:04:19,640 --> 00:04:21,430
it's typically always on,
它通常是一直开启的。

73
00:04:21,440 --> 00:04:29,240
it has always to be ready to receive requests and answer this request.
它必须始终准备好接收请求并回答这些请求。

74
00:04:29,660 --> 00:04:31,370
Unlike on the other hand,
与另一方面不同的是，

75
00:04:31,380 --> 00:04:32,810
obviously is a client.
显然是一个客户端。

76
00:04:33,090 --> 00:04:36,630
It's not always on your phone, your computer,
它并不总是在你的手机、电脑上，

77
00:04:36,640 --> 00:04:39,110
your laptop is not always on most of the time.
你的笔记本电脑并不总是开机，大部分时间都是关机的。

78
00:04:39,120 --> 00:04:40,670
It's actually off.
它实际上是关闭的。

79
00:04:41,220 --> 00:04:43,670
But when it's on, it's going to send his request to a server.
但是当它开启时，它会将请求发送到服务器。

80
00:04:43,680 --> 00:04:49,380
We should be on all the time in order for you to get the reply right away.
我们应该始终保持在线，这样你就能立即收到回复。

81
00:04:52,820 --> 00:04:53,790
And obviously,
显然，

82
00:04:53,800 --> 00:04:57,670
the clients initiate the conduct of the server nor the other way around.
客户端发起服务器的行为，而不是反过来。

83
00:04:58,760 --> 00:05:02,890
The client know doesn't need to know to have a because of that,
因此，客户端不需要知道有一个。

84
00:05:02,900 --> 00:05:06,300
the client doesn't need to have a well known address,
客户端不需要拥有一个众所周知的地址，

85
00:05:07,620 --> 00:05:12,460
but the server has to okay.
但是服务器必须正常运行。

86
00:05:12,470 --> 00:05:15,370
And like we said before,
就像我们之前说的一样，

87
00:05:15,380 --> 00:05:19,000
when the server gets a required as aa request,
当服务器收到一个名为"aa"的请求时，

88
00:05:19,310 --> 00:05:21,720
it's going to answer something back,
它将会回答一些信息。

89
00:05:21,730 --> 00:05:24,150
hopefully satisfying the reply,
希望这个回复能够令您满意，

90
00:05:26,420 --> 00:05:30,750
answering the reply according to the user expectations.
根据用户的期望回复。

91
00:05:36,150 --> 00:05:39,750
Again, we need to call to send data over the network.
再次，我们需要调用来发送数据通过网络。

92
00:05:42,520 --> 00:05:47,360
And what we do that,
我们要做的是什么？

93
00:05:48,630 --> 00:05:51,640
we need to send, we are going to send some bites.
我们需要发送一些数据，我们打算发送一些字节。

94
00:05:53,040 --> 00:05:54,430
Data consists of bits.
数据由位组成。

95
00:05:54,710 --> 00:05:56,720
We aggregate each eight beats.
我们将每八个节拍聚合在一起。

96
00:05:56,730 --> 00:05:57,440
It's a one bike,
这是一辆自行车。

97
00:05:58,090 --> 00:05:59,480
typically of majoring bytes,
通常是指主要的字节类型。

98
00:06:00,220 --> 00:06:01,040
like memory.
像内存一样。

99
00:06:01,240 --> 00:06:02,790
You also typically major in bytes,
你通常也会专攻字节。

100
00:06:02,800 --> 00:06:05,320
or maybe which is a bunch of bytes.
或者说它是一串字节。

101
00:06:06,950 --> 00:06:14,610
So more than that is not only we have individual bytes,
所以不仅仅是我们有单独的字节，

102
00:06:14,620 --> 00:06:15,850
we have stream of bytes.
我们有一串字节流。

103
00:06:16,250 --> 00:06:19,120
Remember, the stream of bytes is the same interface,
记住，字节流是相同的接口。

104
00:06:19,520 --> 00:06:21,520
the high level interface from the file systems.
文件系统的高级接口。

105
00:06:25,000 --> 00:06:28,350
Here, we are going to talk more about networking later in the lecture,
在这里，我们将在后面的讲座中更多地讨论网络。

106
00:06:28,360 --> 00:06:30,550
but here we are talking about dcp connection.
但是在这里我们正在讨论DCP连接。

107
00:06:32,470 --> 00:06:35,560
Tcp stands for transport control protocol.
TCP是传输控制协议的缩写。

108
00:06:36,700 --> 00:06:39,170
Do you know what is the other type of protocol?
你知道还有哪种类型的协议吗？

109
00:06:39,180 --> 00:06:40,290
Common protocol?
常见协议？

110
00:06:42,820 --> 00:06:49,270
Besides dcp udp what does udp stands for?
除了数据复制协议（DCP）之外，UDP 还代表什么？

111
00:06:51,180 --> 00:06:57,320
And icmp acdp is a protocol,
ICMP（Internet Control Message Protocol）和ACDP（Application Control and Data Plane）都是协议。

112
00:06:57,330 --> 00:06:59,840
but a a it's at a higher level.
但是它是在更高的层次上。

113
00:06:59,850 --> 00:07:07,420
It's on top of the tcp udp it's user data, ground protocol,
它位于TCP和UDP之上，是用户数据的底层协议。

114
00:07:07,430 --> 00:07:09,420
not unified user data,
不统一的用户数据

115
00:07:09,950 --> 00:07:10,830
ground protocol.
地面协议。

116
00:07:14,240 --> 00:07:17,710
And http and ftp are also protocols,
HTTP和FTP也是协议。

117
00:07:17,720 --> 00:07:21,740
but they are the higher levels they are running on top of pcp again,
但它们是在 PCP 上运行的更高级别的组件。

118
00:07:21,750 --> 00:07:23,740
we are going to learn the network.
我们要学习网络。

119
00:07:23,750 --> 00:07:27,260
Software is organizing stacks a in a bunch of players.
软件正在将一堆玩家的堆栈进行组织。

120
00:07:27,980 --> 00:07:33,140
Here we are going to talk about the transport layer and pcp and udp are
在这里，我们将讨论传输层以及PCP和UDP。

传输层是计算机网络中的一层，负责在源主机和目标主机之间提供可靠的数据传输。它使用不同的协议来实现这一目标，其中包括传输控制协议（TCP）和用户数据报协议（UDP）。

PCP是端口控制协议（Port Control Protocol）的缩写，它是一种用于网络地址转换（NAT）设备的协议。PCP允许主机在私有网络中使用公共IP地址，并通过NAT设备与公共互联网通信。

UDP是用户数据报协议（User Datagram Protocol）的缩写，它是一种无连接的传输协议。与TCP不同，UDP不提供可靠的数据传输，也不保证数据的顺序。UDP通常用于实时应用程序，如音频和视频流传输，以及简单的请求-响应通信。

希望以上信息对你有帮助！如果你还有其他问题，请随时提问。

121
00:07:33,570 --> 00:07:35,290
at the transport layer.
在传输层。

122
00:07:38,450 --> 00:07:39,890
So thanks for your answers.
感谢您的回答。

123
00:07:44,450 --> 00:07:49,670
So now we need to abstract the connection between two employees and b
现在我们需要对两个员工和b之间的连接进行抽象化处理。

124
00:07:50,920 --> 00:07:52,220
the way we are going to do that,
我们打算这样做，

125
00:07:52,230 --> 00:07:53,820
it should be, again, be very natural,
应该再次强调，非常自然。

126
00:07:53,830 --> 00:07:55,820
because you are going to send a string of bytes.
因为你将要发送一个字节串。

127
00:07:55,830 --> 00:07:57,700
You need to abstract like a cube,
你需要像一个立方体一样进行抽象化处理，

128
00:07:58,120 --> 00:08:00,280
write yaq because,
写yaq的原因是，

129
00:08:02,500 --> 00:08:04,460
for instance, aa very simple example,
例如，一个非常简单的例子，

130
00:08:04,470 --> 00:08:09,690
what happened if the client sends faster than the server can receive
如果客户端发送的速度快于服务器接收的速度，会发生什么情况？

131
00:08:09,700 --> 00:08:10,410
or the server,
或者服务器，

132
00:08:10,420 --> 00:08:11,010
for some reason,
由于某种原因，

133
00:08:11,020 --> 00:08:12,730
is doing something else.
正在做其他事情。

134
00:08:12,740 --> 00:08:16,660
And you cannot get the data sent to it right away.
你不能立即获取发送给它的数据。

135
00:08:17,800 --> 00:08:20,400
This data is either is lost,
这些数据可能已经丢失了，

136
00:08:20,410 --> 00:08:21,960
or if you don't want to lose it,
或者如果你不想丢失它，

137
00:08:21,970 --> 00:08:23,120
you need to buffer summer.
你需要缓冲夏天。

138
00:08:23,620 --> 00:08:24,000
Right?
对吗？

139
00:08:24,370 --> 00:08:26,150
So you have to have a cure, right?
所以你必须有一个解决办法，对吗？

140
00:08:28,180 --> 00:08:31,630
You need to have boss on from the client to the servant,
你需要在客户端和服务端之间建立一个主从关系。

141
00:08:31,640 --> 00:08:33,270
from the server to the client,
从服务器到客户端，

142
00:08:33,550 --> 00:08:36,460
because both of them, they are going to send data.
因为它们都要发送数据。

143
00:08:36,730 --> 00:08:38,960
One of them is going to send typically request,
其中一个将发送典型的请求。

144
00:08:38,970 --> 00:08:40,960
and the other one replies to the request.
另一个回复该请求。

145
00:08:43,890 --> 00:08:44,400
Now,
现在，

146
00:08:45,270 --> 00:08:46,420
but what is the abstraction?
但是什么是抽象化？

147
00:08:46,430 --> 00:08:46,620
Right?
对吗？

148
00:08:46,630 --> 00:08:47,620
This is kind of,
这有点...

149
00:08:48,270 --> 00:08:51,670
how do we manipulate this kind of connection?
我们如何操作这种连接？

150
00:08:52,500 --> 00:08:59,250
And remember that one of the big things about unix is that everything looks
而且请记住，Unix的一个重要特点就是一切看起来都是

151
00:08:59,260 --> 00:09:00,270
like a file,
像一个文件一样，

152
00:09:00,280 --> 00:09:00,610
right?
对的？

153
00:09:00,620 --> 00:09:04,110
Or it's abstract with very similar abstractions.
或者它是抽象的，具有非常相似的抽象概念。

154
00:09:04,860 --> 00:09:06,690
The same is true for communication,
通信也是如此。

155
00:09:06,700 --> 00:09:07,810
like we saw for pipes.
就像我们在管道中看到的那样。

156
00:09:07,820 --> 00:09:08,330
Last time.
上次。

157
00:09:08,340 --> 00:09:08,610
Pipes.
管道。

158
00:09:08,620 --> 00:09:12,510
Again, it's how you communicate between two processes on the same machine.
再次强调，它是关于如何在同一台机器上的两个进程之间进行通信的。

159
00:09:12,520 --> 00:09:14,710
Here are sockets about how you come,
这里是关于你如何连接的套接字的信息。

160
00:09:14,720 --> 00:09:19,030
how do two processes on different machines communicate with each other.
两台不同机器上的两个进程如何进行通信？

161
00:09:20,270 --> 00:09:23,520
But they are very similar that the abstraction is very similar,
但它们非常相似，抽象概念非常相似。

162
00:09:23,910 --> 00:09:26,210
and is looking like a fire.
看起来像是一场火灾。

163
00:09:26,220 --> 00:09:30,830
And this kind of abstraction for communication is called a socket.
这种用于通信的抽象称为套接字。

164
00:09:34,530 --> 00:09:35,440
This is how you do it.
这是你要做的方法。

165
00:09:35,810 --> 00:09:36,160
Right?
对吗？

166
00:09:36,520 --> 00:09:38,010
If you want to send some data,
如果你想发送一些数据，

167
00:09:38,990 --> 00:09:46,300
the processor sender is a client call or write system function call,
处理器发送者是一个客户端调用或写系统函数调用。

168
00:09:46,720 --> 00:09:48,590
which passes a descriptor.
传递一个描述符。

169
00:09:48,600 --> 00:09:50,070
This is a soccer descriptor,
这是一个关于足球的描述符。

170
00:09:50,080 --> 00:09:52,110
a buffer in the length of the buffer.
一个长度为缓冲区大小的缓冲区。

171
00:09:52,530 --> 00:09:56,160
And the receiver or the server.
接收方或服务器。

172
00:09:56,750 --> 00:10:04,730
It's calling the read operation with a file descriptor and aa
它正在使用文件描述符和 aa 调用读取操作。

173
00:10:04,740 --> 00:10:08,780
buffer where it can receive the data on the size of the buffer.
缓冲区可以接收与缓冲区大小相匹配的数据。

174
00:10:09,260 --> 00:10:12,070
To make sure that if it's more data,
为了确保如果有更多的数据，

175
00:10:12,080 --> 00:10:15,230
the operating system doesn't overflow that buffer.
操作系统不会溢出该缓冲区。

176
00:10:15,970 --> 00:10:16,330
Right?
对吗？

177
00:10:18,820 --> 00:10:21,900
The circuits is the endpoint of communication, right?
电路是通信的终点，对吗？

178
00:10:22,470 --> 00:10:27,680
And the cures are in between here somewhere along.
而治愈方法就在这里之间的某个地方。

179
00:10:27,690 --> 00:10:28,000
Actually,
实际上，

180
00:10:28,010 --> 00:10:30,380
there are many queues in the network that choosing
网络中有许多队列可供选择。

181
00:10:30,390 --> 00:10:33,880
the operating system queues as the routers along the path
操作系统将排队作为路径上的路由器

182
00:10:33,890 --> 00:10:35,680
between the sender and the receiver.
发送者和接收者之间的通信。

183
00:10:36,080 --> 00:10:36,490
It's pretty complicated.
这很复杂。

184
00:10:36,500 --> 00:10:38,330
We are going to learn more about that.
我们将会更多地了解这个。

185
00:10:38,650 --> 00:10:39,130
But in general,
但是一般来说，

186
00:10:39,900 --> 00:10:43,940
the things to for you to know that are accused, there are cues,
你需要知道的事情是被指控的事情，有线索。

187
00:10:44,610 --> 00:10:46,550
one of the simplest reasons,
最简单的原因之一，

188
00:10:47,000 --> 00:10:50,140
one of simple motivation for cures is to, again,
治愈的一个简单动机是，再次，

189
00:10:50,150 --> 00:10:52,940
because the client or the two end points,
因为客户端或两个端点，

190
00:10:54,530 --> 00:10:59,090
they don't have the same speed sending and receiving.
它们在发送和接收方面的速度不相同。

191
00:10:59,500 --> 00:11:01,310
If you receive at a lower speed,
如果你以较低的速度接收到数据，

192
00:11:01,320 --> 00:11:04,690
they need to buffer the data or that the receiver at that time,
他们需要对数据进行缓冲，或者在那个时候接收方需要进行缓冲。

193
00:11:04,930 --> 00:11:06,710
maybe is doing something else.
可能正在做其他事情。

194
00:11:07,590 --> 00:11:10,100
And he cannot receive the data right away.
他无法立即接收数据。

195
00:11:14,750 --> 00:11:16,140
So now,
所以现在，

196
00:11:16,390 --> 00:11:19,350
the circuits you have two sockets connected over the network,
这个电路有两个通过网络连接的插座。

197
00:11:19,360 --> 00:11:20,390
one of the sender,
发送者之一

198
00:11:20,400 --> 00:11:23,870
and on the receiver or one circuit for each endpoint.
在接收端，或者每个端点都需要一个电路。

199
00:11:25,940 --> 00:11:26,420
Now,
现在，

200
00:11:26,940 --> 00:11:28,150
the sockets, you remember,
套接字，你记得吧，

201
00:11:28,400 --> 00:11:29,510
what do you do with sockets?
你可以用套接字做什么？

202
00:11:29,520 --> 00:11:29,790
Right?
对吗？

203
00:11:29,800 --> 00:11:31,230
It's like, what is a typical?
这就像是，什么是典型的？

204
00:11:31,240 --> 00:11:32,110
What is a pattern?
什么是模式？

205
00:11:33,370 --> 00:11:34,130
Programming pattern?
编程模式？

206
00:11:34,480 --> 00:11:36,170
You open, you read,
你打开，你阅读，

207
00:11:38,550 --> 00:11:39,820
if you have a file descriptor,
如果你有一个文件描述符，

208
00:11:40,090 --> 00:11:41,240
like you open the file, a script,
就像你打开一个文件，一个脚本，

209
00:11:41,250 --> 00:11:42,950
or you read right from the file, a script,
或者你可以直接从文件中读取，一个脚本，

210
00:11:42,960 --> 00:11:44,280
and then you close the file list.
然后你关闭文件列表。

211
00:11:45,200 --> 00:11:51,120
So we need to learn about how to open and close are also these sockets.
所以我们需要学习如何打开和关闭这些套接字。

212
00:11:53,570 --> 00:11:54,210
Let me see,
让我看看，

213
00:11:55,560 --> 00:12:01,010
here is a question is a communication between two processes,
这是一个关于两个进程之间通信的问题。

214
00:12:01,020 --> 00:12:04,450
actually communication between the threat of the processes.
实际上是进程之间的通信。

215
00:12:08,010 --> 00:12:13,290
This is, so anyone wants to answer that question?
这是，有人想回答这个问题吗？

216
00:12:21,390 --> 00:12:25,290
The communication it's about is between two processes.
这里所讨论的通信是指两个进程之间的通信。

217
00:12:25,700 --> 00:12:28,370
But remember, the process is a container.
但是要记住，进程是一个容器。

218
00:12:29,120 --> 00:12:29,510
Right?
对吗？

219
00:12:29,520 --> 00:12:30,750
You have the other place,
你有另一个地方。

220
00:12:30,760 --> 00:12:31,830
other space,
其他空间

221
00:12:31,840 --> 00:12:33,470
and it provides a protection.
它提供了一种保护机制。

222
00:12:34,630 --> 00:12:40,850
But the actual unit of execution or concurrency is a thread.
但实际的执行单元或并发单元是线程。

223
00:12:41,600 --> 00:12:44,380
Each thread, each process is at least one thread.
每个线程，每个进程至少有一个线程。

224
00:12:45,260 --> 00:12:48,870
So it's correct to say that the processes communicate.
所以说进程之间进行通信是正确的。

225
00:12:49,690 --> 00:12:53,560
But it's also say it's correct to say that always to stress communicate,
但也可以说，始终强调沟通是正确的。

226
00:12:53,570 --> 00:12:58,020
because the things which are going to run the code inside this process are
因为将要运行此进程内代码的事物是

227
00:12:58,030 --> 00:12:58,540
the threads.
线程。

228
00:13:01,380 --> 00:13:03,830
Typically, when you have one thread and one process,
通常情况下，当你有一个线程和一个进程时，

229
00:13:04,850 --> 00:13:05,830
you just interchangeable.
你只是可以互换的。

230
00:13:05,840 --> 00:13:08,430
You can use process or thread,
你可以使用进程或线程。

231
00:13:08,440 --> 00:13:12,650
but hopefully that answers the question.
但希望这回答了你的问题。

232
00:13:14,450 --> 00:13:15,010
Okay?
好的？

233
00:13:20,660 --> 00:13:24,690
It is a hidden abstraction for socket io what we are going to talk about here,
我们将在这里讨论的是socket io的隐藏抽象。

234
00:13:24,700 --> 00:13:27,210
it's pretty much,
这差不多就是这样了。

235
00:13:27,220 --> 00:13:29,610
at least in the next couple of slides about,
至少在接下来的几张幻灯片中，

236
00:13:30,090 --> 00:13:33,820
actually, is how you are going to use a socket interface.
实际上，你将如何使用套接字接口。

237
00:13:34,850 --> 00:13:35,230
Right?
对吗？

238
00:13:37,540 --> 00:13:38,290
So
所以

239
00:13:46,450 --> 00:13:50,120
like we discuss the circuit is an abstraction for on end point of the network.
就像我们讨论的那样，电路是网络的一个端点的抽象表示。

240
00:13:50,130 --> 00:13:51,570
If you have do you have, in general,
如果你有的话，一般来说，

241
00:13:51,580 --> 00:13:56,430
you have two processes to end points communicate with each other.
你有两个进程，它们之间进行通信。

242
00:13:56,440 --> 00:13:58,630
Each of them is going to have a socket.
每个人都会有一个套接字。

243
00:13:58,640 --> 00:14:03,950
And somehow you need to connect these two sockets to each other.
你需要以某种方式将这两个套接字连接起来。

244
00:14:04,850 --> 00:14:06,560
If you want to establish a connection,
如果你想建立连接，

245
00:14:09,220 --> 00:14:16,640
it was introduced first in berkeley standard distribution version 4.2.
它首次在伯克利标准发行版4.2中引入。

246
00:14:16,950 --> 00:14:19,080
That is one of the biggest contributions
这是其中一个最大的贡献之一

247
00:14:19,090 --> 00:14:22,950
of actually open source contribution of berkeley,
伯克利实际上的开源贡献

248
00:14:23,620 --> 00:14:25,960
because has huge impact.
因为它有巨大的影响。

249
00:14:26,590 --> 00:14:35,610
And the story here is that then the runners like during those days,
这里的故事是，在那些日子里，跑步者们就像这样，

250
00:14:36,890 --> 00:14:42,520
you distribute these operating systems through tapes.
你通过磁带分发这些操作系统。

251
00:14:43,960 --> 00:14:50,730
And the things here is that it's about how you are going to.
这里的关键是你将如何去做。

252
00:14:52,220 --> 00:14:56,710
Then there are people waiting in line for the tapes to be copied.
然后还有人在排队等待磁带复制。

253
00:14:57,230 --> 00:14:59,780
Therefore, to take it back to their companies,
因此，将其带回他们的公司，

254
00:15:00,890 --> 00:15:03,110
to install the new version of unix,
安装新版本的Unix操作系统

255
00:15:04,140 --> 00:15:08,440
to which with this kind of dcpipa code in it.
其中包含有这种类型的DCPIPA代码。

256
00:15:10,900 --> 00:15:13,750
A this is a beautiful thing is that this is the local, again,
这是一件美好的事情，就是这个地方，再次，

257
00:15:13,760 --> 00:15:19,590
it's like it's the abstraction for a lot of kind of networks,
它就像是许多种网络的抽象化。

258
00:15:19,600 --> 00:15:23,910
not networks type of when I say a lot of kind of networks i'm talking about,
当我说到网络的不同类型时，我指的是很多种不同的网络。

259
00:15:24,850 --> 00:15:29,860
all boss about how how they are physically implemented.
所有的老板都关心他们是如何在物理上实现的。

260
00:15:29,870 --> 00:15:31,100
They are over fiber,
它们通过光纤传输。

261
00:15:31,110 --> 00:15:34,200
they are over satellite cellular networks.
它们通过卫星蜂窝网络进行连接。

262
00:15:35,130 --> 00:15:38,960
It abstracts away what kind of your application on your iphone.
它将您在iPhone上的应用程序的种类抽象化了。

263
00:15:38,970 --> 00:15:42,750
It doesn't knew, it doesn't know that you are on a solar network, right?
它不知道，它不知道你在一个太阳能网络上，对吗？

264
00:15:43,270 --> 00:15:45,060
Or you are a wifi, right?
或者你是一个无线网络，对吗？

265
00:15:45,070 --> 00:15:45,860
Doesn't know.
不知道。

266
00:15:46,030 --> 00:15:47,900
That means abstraction in that case.
在这种情况下，这意味着抽象化。

267
00:15:49,290 --> 00:15:52,640
Or there are also about how packets are rooted in the network
还有关于数据包在网络中如何路由的内容。

268
00:15:52,650 --> 00:15:53,760
and many other things.
还有许多其他事情。

269
00:15:54,120 --> 00:15:57,060
Lower level of the network stack resource,
网络栈资源的较低层级

270
00:15:57,490 --> 00:16:02,960
apple dog and ipx and the great thing about this tcpip it becomes an effect
苹果、狗和IPX，而TCP/IP的伟大之处在于它变得有效。

271
00:16:02,970 --> 00:16:04,950
of standard of how
如何的标准

272
00:16:06,250 --> 00:16:09,500
nodes communicate over the internet.
节点通过互联网进行通信。

273
00:16:10,240 --> 00:16:10,700
Right?
对吗？

274
00:16:11,050 --> 00:16:13,430
This is what enables the internet at the end of the day.
这就是最终使互联网成为可能的东西。

275
00:16:13,970 --> 00:16:15,880
And again, when I say the vector standard,
再次强调，当我提到向量标准时，

276
00:16:15,890 --> 00:16:17,080
I say because it doesn't,
我说它不是因为它不是这样的。

277
00:16:17,330 --> 00:16:18,360
it was a piece of gold.
它是一块黄金。

278
00:16:18,370 --> 00:16:21,750
It was not a standard body to create it,
没有一个标准的机构来创建它，

279
00:16:21,760 --> 00:16:25,190
but it's a standard now because everyone is using it.
但现在它已成为标准，因为每个人都在使用它。

280
00:16:25,760 --> 00:16:30,260
If you don't use the cpip you cannot talk with other as a noise in the internet.
如果你不使用CP/IP协议，你就无法在互联网上与其他人进行通信，就像在噪音中一样。

281
00:16:31,160 --> 00:16:31,580
Okay?
好的？

282
00:16:34,670 --> 00:16:35,420
The sockets,
套接字，

283
00:16:36,550 --> 00:16:37,380
you'll see,
你会看到，

284
00:16:37,950 --> 00:16:39,980
it's a little bit more elaborated interface.
这是一个稍微更加详细的界面。

285
00:16:40,270 --> 00:16:42,370
But at the end of the day, you need to open,
但归根结底，你需要打开，

286
00:16:42,380 --> 00:16:43,630
you need to create a socket.
你需要创建一个套接字。

287
00:16:43,640 --> 00:16:46,360
You can close a socket in between you read and read and write.
在读取和写入之间，您可以关闭套接字。

288
00:16:46,670 --> 00:16:46,970
Now,
现在，

289
00:16:48,100 --> 00:16:50,070
Everything is a file descriptor,
一切皆为文件描述符。

290
00:16:50,530 --> 00:16:52,800
like we discussed, but loss also, if you remember,
就像我们讨论过的那样，但也有损失，如果你还记得的话。

291
00:16:52,810 --> 00:16:53,880
like we discussed,
正如我们讨论过的，

292
00:16:54,330 --> 00:16:58,340
although you have every everything is file escaped out,
尽管你已经对所有内容进行了文件转义处理，

293
00:16:58,950 --> 00:17:01,010
you don't have for each device.
你不需要为每个设备都有。

294
00:17:01,450 --> 00:17:06,280
You don't have all the comments,
你没有所有的评论。

295
00:17:06,290 --> 00:17:07,880
like you have four file systems, right?
你有四个文件系统，对吗？

296
00:17:08,170 --> 00:17:08,920
For right?
是的，正确的。

297
00:17:09,100 --> 00:17:11,290
For five system, you remember you have a sick, right?
对于五个系统，你记得你生病了，对吗？

298
00:17:12,030 --> 00:17:18,310
You can reposition the pointer from what you read in a particular file.
你可以根据在特定文件中读取的内容重新定位指针位置。

299
00:17:18,320 --> 00:17:22,870
I can lc and I can read from the 100 bytes in the file, right?
我可以使用 lc 命令来统计文件中的行数，并且可以从文件中读取100个字节，对吗？

300
00:17:23,090 --> 00:17:23,640
Is still,
仍然是的，

301
00:17:24,930 --> 00:17:27,760
the abstraction is still aa stream of bites, right?
抽象仍然是一串字节流，对吗？

302
00:17:27,770 --> 00:17:29,120
But I can reposition.
但是我可以重新定位。

303
00:17:29,440 --> 00:17:29,450
Here.
在这里。

304
00:17:29,460 --> 00:17:30,550
You cannot have sick, right?
你不能生病，对吗？

305
00:17:30,560 --> 00:17:33,540
You send up, have you send the bias and you receive that?
你发送了吗？你发送了偏置并且你收到了吗？

306
00:17:33,550 --> 00:17:35,770
Or in the same order?
还是按照相同的顺序？

307
00:17:36,110 --> 00:17:37,860
It is kind of strange to be out.
出门感觉有点奇怪。

308
00:17:37,870 --> 00:17:40,020
I want to read the 100 bytes, right?
我想读取100个字节，对吗？

309
00:17:40,030 --> 00:17:45,780
Maybe that 100 bytes is not even your computer haven't received it.
也许那100字节甚至都没有被你的计算机接收到。

310
00:17:46,490 --> 00:17:50,370
So you don't have lc your abstraction is just a cube right?
所以你没有局部性，你的抽象只是一个立方体对吗？

311
00:17:50,710 --> 00:17:51,030
In.
在。

312
00:17:51,040 --> 00:17:51,690
First out,
首先，

313
00:17:52,250 --> 00:17:54,670
you always get the but data in the order.
你总是按照顺序获取错误的数据。

314
00:17:54,680 --> 00:18:02,410
And if you sent the other thing what happens is
如果你发送了其他的东西，会发生什么呢？

315
00:18:02,420 --> 00:18:07,390
under the hood is abstracted away is that you don't over the network,
在抽象层下隐藏的是你不需要通过网络进行操作。

316
00:18:07,400 --> 00:18:09,390
you don't send us small bikes, right?
你们不会给我们寄小型自行车，对吗？

317
00:18:09,780 --> 00:18:13,560
You actually put it in packages in your package it.
你实际上将它放在你的包裹中打包。

318
00:18:15,940 --> 00:18:17,410
You divide the data,
你将数据分割成不同的部分，

319
00:18:17,420 --> 00:18:19,410
you have to send your package it in a pack.
你需要将你的包裹装在一个包装盒里。

320
00:18:20,100 --> 00:18:21,830
Each packet will have addresses, right?
每个数据包都会有地址，对吗？

321
00:18:21,840 --> 00:18:25,890
Because it depends on this tells another where is the packet should be delivered.
因为它取决于这个信息，告诉另一个设备数据包应该被传送到哪里。

322
00:18:27,120 --> 00:18:27,450
Right?
对吗？

323
00:18:27,800 --> 00:18:34,240
It's like you put amazon is using trucks and each truck now says an address,
就像你把亚马逊使用卡车的情况，每辆卡车现在都有一个地址。

324
00:18:34,890 --> 00:18:37,040
the driver where it should deliver the packages.
司机应该将包裹送到哪里。

325
00:18:37,520 --> 00:18:37,870
Right?
对吗？

326
00:18:37,880 --> 00:18:38,750
Something like that.
差不多这样。

327
00:18:40,060 --> 00:18:45,490
The many need also some kind of like rbc kind of facility to,
许多人也需要一种类似于红细胞（rbc）设施的东西。

328
00:18:45,910 --> 00:18:47,400
for instance,
例如，

329
00:18:49,340 --> 00:18:51,600
because the data format,
由于数据格式，

330
00:18:51,810 --> 00:18:53,450
which is understand by the receiver,
能够被接收者理解的。

331
00:18:53,460 --> 00:18:55,850
is not as the same as the data format,
不同于数据格式。

332
00:18:55,860 --> 00:18:57,210
which is understood,
这是可以理解的，

333
00:18:57,370 --> 00:18:59,050
understand by the senate.
被参议院理解。

334
00:18:59,520 --> 00:18:59,840
Right?
对吗？

335
00:19:00,130 --> 00:19:02,750
And you'll talk about this is big indian,
你将讨论这是大端序。

336
00:19:02,760 --> 00:19:06,160
little indian kind of different formats,
小端（Little-endian）是一种不同的数据格式。

337
00:19:06,170 --> 00:19:08,600
different for different processors.
对于不同的处理器来说是不同的。

338
00:19:12,250 --> 00:19:15,520
This is a very simple example echo server.
这是一个非常简单的回显服务器示例。

339
00:19:15,530 --> 00:19:17,260
Hello, world echo mean,
你好，"echo" 是指将输入的内容原样输出。

340
00:19:17,670 --> 00:19:20,210
I am sending is a message to the server.
我正在发送一条消息给服务器。

341
00:19:20,220 --> 00:19:22,410
The server is going to send me the message back.
服务器将会把消息发送回给我。

342
00:19:22,780 --> 00:19:23,130
Right?
对吗？

343
00:19:25,260 --> 00:19:27,780
So here is how things that are happening, right?
所以这就是正在发生的事情，对吗？

344
00:19:27,790 --> 00:19:30,300
You have a client on the seller on the left hand side,
您在左侧有一个卖家客户端。

345
00:19:30,310 --> 00:19:31,560
stubborn on the right hand side.
固执地站在右边。

346
00:19:34,410 --> 00:19:39,680
You have with this also the data points at the time here goes from top
您在这里也有时间的数据点，从顶部开始计算。

347
00:19:39,690 --> 00:19:40,520
to the bottom.
到底部。

348
00:19:41,040 --> 00:19:48,880
You have this kind of this green rectangles shows about the
您有这种绿色矩形显示的内容是关于什么的？

349
00:19:48,890 --> 00:19:52,330
life lifetime of socket,
socket的生命周期，

350
00:19:52,690 --> 00:19:54,920
both on the client side and the several side.
既在客户端，也在服务器端。

351
00:19:55,770 --> 00:19:58,160
Soccer starts with being open and close, right?
足球的比赛开始和结束时都需要开放和关闭，对吗？

352
00:19:58,400 --> 00:19:58,790
Okay?
好的？

353
00:20:00,990 --> 00:20:03,480
Once you open and close the socket,
一旦你打开并关闭了套接字，

354
00:20:03,770 --> 00:20:06,190
the server should be ready to receive data.
服务器应该准备好接收数据。

355
00:20:07,730 --> 00:20:09,800
What the server is doing then, well,
服务器正在做什么呢？

356
00:20:09,810 --> 00:20:11,920
is calling a a a read,
将 a a a 的调用称为读取。

357
00:20:11,930 --> 00:20:19,260
the read system command on the corresponding socket descriptor of that
在相应的套接字描述符上执行读取系统命令

358
00:20:19,270 --> 00:20:25,520
connection and provide a buffer where the operating system should pass
连接并提供一个缓冲区，操作系统应该传递的地方

359
00:20:25,530 --> 00:20:26,720
the data it receives.
它接收到的数据。

360
00:20:27,280 --> 00:20:27,610
Okay?
好的？

361
00:20:29,170 --> 00:20:34,350
The clients say it do f gets to get from the standard input,
客户端说它需要从标准输入获取数据。

362
00:20:34,360 --> 00:20:37,050
from you can type the message.
你可以输入消息。

363
00:20:37,510 --> 00:20:39,660
And we want to send that message, right?
我们想要发送那条消息，对吗？

364
00:20:40,630 --> 00:20:43,350
How you send a message like we discussed, you do your color,
我们讨论过的消息是这样发送的，你可以自己选择颜色。

365
00:20:43,890 --> 00:20:44,280
right?
对的？

366
00:20:44,640 --> 00:20:50,290
And you pass the socket file descriptors on from the come from the same communication.
你可以将套接字文件描述符从一个通信传递给另一个通信。

367
00:20:52,270 --> 00:20:55,460
And on the center side of the client side,
在客户端的中心位置上，

368
00:20:55,920 --> 00:20:57,380
and you pass a buffer,
你传递了一个缓冲区，

369
00:20:57,390 --> 00:21:00,830
you want to send out right now.
你现在想要发送出去。

370
00:21:03,550 --> 00:21:04,900
And then you want to read back.
然后你想要读回来。

371
00:21:05,110 --> 00:21:05,260
Right?
对吗？

372
00:21:05,270 --> 00:21:07,580
Not is that both the reads are blocking.
不是两个读操作都是阻塞的。

373
00:21:07,590 --> 00:21:08,740
In this particular case,
在这种特殊情况下，

374
00:21:09,330 --> 00:21:11,970
there are variants of fields calls,
有各种类型的字段调用。

375
00:21:11,980 --> 00:21:13,210
which are not blocking.
不会阻塞的。

376
00:21:13,530 --> 00:21:16,030
But here we ask, by default, we assume is blocking.
但是在这里，默认情况下，我们假设是阻塞的。

377
00:21:16,040 --> 00:21:18,550
We need to you block until you get some data.
我们需要你阻塞直到获取到一些数据。

378
00:21:19,020 --> 00:21:19,370
Right?
对吗？

379
00:21:21,380 --> 00:21:23,780
The client writes as a message,
客户发送了一条消息，

380
00:21:23,790 --> 00:21:26,820
and then ways to get some a reply back,
然后获取回复的方法：

381
00:21:27,320 --> 00:21:29,710
that message may be chopped in different packets.
该消息可能会被分成不同的数据包。

382
00:21:29,720 --> 00:21:31,810
The packets are sent over the internet.
数据包通过互联网发送。

383
00:21:32,000 --> 00:21:35,160
Actually, each packet can can take a different path.
实际上，每个数据包可以选择不同的路径。

384
00:21:36,010 --> 00:21:39,400
And the set of the server gets the data.
服务器集合获取数据。

385
00:21:39,410 --> 00:21:42,680
Maybe rights show it on the screen,
也许权限会在屏幕上显示出来。

386
00:21:43,090 --> 00:21:46,270
is doing some print types or something like that.
正在进行一些打印类型或类似的操作。

387
00:21:46,670 --> 00:21:50,670
And then you write it back to the socket.
然后你将其写回套接字。

388
00:21:50,680 --> 00:21:54,600
So you want to send it back to as a client.
所以你想把它作为客户端发送回去。

389
00:21:55,100 --> 00:21:56,850
And the client, as I read,
根据我的理解，客户端

390
00:21:58,060 --> 00:21:59,970
it's, again, I was writing into it.
又是我，我正在写入其中。

391
00:21:59,980 --> 00:22:03,760
A call is going to get the message back and is going to print on the screen.
一个调用将会收到消息并打印在屏幕上。

392
00:22:04,000 --> 00:22:07,130
Again, the same as we are talking here about an echo server.
同样，我们在这里讨论的是一个回声服务器。

393
00:22:07,870 --> 00:22:08,150
Right?
对吗？

394
00:22:11,630 --> 00:22:11,740
Cooperation.
合作。

395
00:22:13,830 --> 00:22:15,780
Let me see if there's another question.
让我看看是否还有其他问题。

396
00:22:18,680 --> 00:22:20,790
Rpc what it stands,
RPC stands for Remote Procedure Call, which is a communication protocol that allows a computer program to request a service from another program located on a different computer in a network. RPC enables the client program to call a procedure or function on the server program and receive the results. It is commonly used in distributed systems and client-server architectures to facilitate inter-process communication.

397
00:22:21,040 --> 00:22:22,270
danny asked about,
丹尼问到，

398
00:22:22,280 --> 00:22:24,270
what does rpc stands for?
RPC stands for 远程过程调用 (Remote Procedure Call)

399
00:22:24,440 --> 00:22:27,270
Rpc stands for remote procedure call.
RPC代表远程过程调用。

400
00:22:27,740 --> 00:22:28,960
This is a higher level.
这是一个较高级别的问题。

401
00:22:28,970 --> 00:22:30,760
And again, we'll learn about it.
再一次，我们将学习它。

402
00:22:30,770 --> 00:22:35,200
And we just mentioned a little bit about it in a previous lecture.
而且我们在之前的讲座中只是稍微提到了一点关于它的内容。

403
00:22:35,790 --> 00:22:39,960
But this is about think about you want to call a function.
但是这是关于思考你想要调用一个函数的问题。

404
00:22:40,340 --> 00:22:41,350
And that function,
那个函数，

405
00:22:41,360 --> 00:22:43,170
instead of executing locally,
不再本地执行，

406
00:22:43,180 --> 00:22:45,390
it's executing on a different machine.
它正在另一台机器上执行。

407
00:22:45,720 --> 00:22:48,170
And you want to just set the syntax.
你只需要设置语法。

408
00:22:48,530 --> 00:22:49,880
And ideally the semantics,
理想情况下，还包括语义。

409
00:22:49,890 --> 00:22:53,060
although we learn that's not really possible to be
尽管我们了解到这并不真正可能

410
00:22:53,070 --> 00:22:57,220
very similar with invoking a local function call you want,
非常类似于调用您想要的本地函数调用。

411
00:22:57,670 --> 00:22:59,520
how you invoke a local function,
如何调用本地函数？

412
00:22:59,530 --> 00:23:00,760
aa remote function,
远程函数

413
00:23:01,120 --> 00:23:05,140
to look very similar with how you invoke a local function.
看起来与调用本地函数非常相似。

414
00:23:05,790 --> 00:23:10,980
So rpc tries to bridge that gap and make them very similar.
因此，远程过程调用（RPC）试图弥合这种差距，并使它们变得非常相似。

415
00:23:14,270 --> 00:23:14,790
Okay.
好的。

416
00:23:15,920 --> 00:23:20,900
That's we have a bunch of code here.
这里有一堆代码。

417
00:23:21,380 --> 00:23:24,470
I'm not going to go through every line of code.
我不会逐行检查代码。

418
00:23:24,790 --> 00:23:26,020
We don't have time.
我们没有时间。

419
00:23:27,670 --> 00:23:31,670
But we'll try to cover as much as possible,
但我们会尽量涵盖尽可能多的内容，

420
00:23:31,840 --> 00:23:34,470
but i'm saying that if i'm not going,
但是我在说，如果我不去的话，

421
00:23:34,480 --> 00:23:36,510
and maybe you have questions, please ask me.
也许你有问题，请问我。

422
00:23:36,850 --> 00:23:38,750
But it's not my intention to go through each line.
但我并不打算逐行查看。

423
00:23:39,860 --> 00:23:42,250
This is about for the previous examples,
这是关于之前的例子的问题，

424
00:23:42,260 --> 00:23:44,130
how the code look like, right?
代码是什么样子的，对吗？

425
00:23:44,390 --> 00:23:46,290
This is typically how the code look like, right?
这通常是代码的样子，对吗？

426
00:23:46,300 --> 00:23:50,510
It's like this is the cloud client.
这就是云客户端。

427
00:23:50,850 --> 00:23:53,000
You are in the y loop.
你现在在循环中。

428
00:23:53,010 --> 00:23:56,720
You get some message typed by the user.
你收到了用户输入的一条消息。

429
00:23:57,000 --> 00:23:58,310
You send it to the server,
你将它发送到服务器。

430
00:23:58,320 --> 00:24:00,290
the server send it back and you print it.
服务器将其发送回来，然后你打印出来。

431
00:24:00,300 --> 00:24:00,510
Right?
对吗？

432
00:24:00,520 --> 00:24:01,610
This is what you do.
这是你要做的事情。

433
00:24:01,620 --> 00:24:03,650
You get them as you get,
你会按照你所得到的方式获得它们。

434
00:24:03,920 --> 00:24:05,960
as a message you write to the socket.
作为你写给套接字的消息。

435
00:24:07,000 --> 00:24:08,200
You read it back,
你将它读回来，

436
00:24:08,210 --> 00:24:11,240
and you write to the you print it out.
你可以将它写下来然后打印出来。

437
00:24:11,780 --> 00:24:13,100
Before you read it back,
在你读回来之前，

438
00:24:13,110 --> 00:24:17,350
you clear the buffer so that it's not the message.
你清空缓冲区，这样它就不会是消息的内容了。

439
00:24:17,360 --> 00:24:19,150
You just send it just in the buffer.
你只需要将它发送到缓冲区中即可。

440
00:24:19,610 --> 00:24:23,030
You clearly to know that what you have in the buffer is what you receive
你清楚地知道，缓冲区中的内容就是你接收到的内容。

441
00:24:24,060 --> 00:24:25,110
from the setup.
从设置中。

442
00:24:26,230 --> 00:24:27,970
The server is very similar.
服务器非常相似。

443
00:24:28,680 --> 00:24:29,370
You read.
你阅读。

444
00:24:33,910 --> 00:24:38,820
Then I think it's a mistake in this code.
那么我认为这段代码有错误。

445
00:24:38,830 --> 00:24:41,580
They should be if land less than zero.
如果土地少于零，它们应该是这样的。

446
00:24:47,600 --> 00:24:49,390
So this is how much you read.
这是你读了多少。

447
00:24:50,820 --> 00:24:52,610
If land is less than zero,
如果土地少于零，

448
00:24:52,850 --> 00:24:53,880
this means that it's an error.
这意味着这是一个错误。

449
00:24:55,500 --> 00:24:57,050
If land is greater than zero.
如果土地大于零。

450
00:24:58,360 --> 00:25:01,870
So this land actually let me just try to,
这个地方实际上让我试试看，

451
00:25:08,420 --> 00:25:08,970
okay,
好的，没问题。

452
00:25:10,210 --> 00:25:13,400
you read it is a server reads data from the socket.
你读取的是一个服务器从套接字中读取数据。

453
00:25:14,140 --> 00:25:16,490
If it's greater less than zero, it's an error.
如果它大于零或小于零，那就是一个错误。

454
00:25:16,500 --> 00:25:18,490
You return greater than zero.
你返回的值大于零。

455
00:25:18,980 --> 00:25:24,820
You print it to the terminal,
你将它打印到终端。

456
00:25:25,280 --> 00:25:29,390
and then you send it back to the client.
然后你将它发送回客户端。

457
00:25:29,790 --> 00:25:30,030
Right?
对吗？

458
00:25:30,040 --> 00:25:33,250
You echo what you got from the client.
你将客户端传来的内容进行回显。

459
00:25:34,800 --> 00:25:39,770
This is a sand from the client and the corresponding received from the server.
这是客户端发送的数据和服务器接收到的相应数据。

460
00:25:40,320 --> 00:25:43,030
This is a corresponding send from the sender,
这是发送方的相应发送。

461
00:25:43,040 --> 00:25:46,430
from the server as a corresponding received from the client.
从服务器作为对应从客户端接收到的。

462
00:25:48,890 --> 00:25:49,450
Very simple.
非常简单。

463
00:25:54,400 --> 00:25:57,030
So now we are making some assumptions,
现在我们正在做一些假设，

464
00:25:57,040 --> 00:25:59,350
which are actually, this is,
which are actually - 实际上是

this is - 这是

465
00:26:00,270 --> 00:26:01,040
in some sense,
从某种意义上说，

466
00:26:01,050 --> 00:26:04,930
the assumption we are making here is about what is the networking field about,
我们在这里做出的假设是关于网络领域的内容。

467
00:26:04,940 --> 00:26:12,990
is about how to ensure that these assumptions are true, are standing.
是关于如何确保这些假设是成立的。

468
00:26:15,750 --> 00:26:21,460
So I know the assumption we make is that the data when you is not lost,
所以我知道我们所做的假设是，当你写入数据时不会丢失。

469
00:26:21,750 --> 00:26:22,250
right?
是的，正确的。

470
00:26:22,260 --> 00:26:23,610
You send it over the network,
你通过网络发送它。

471
00:26:23,850 --> 00:26:25,740
and the receiver gets all the data.
接收方获得所有数据。

472
00:26:26,250 --> 00:26:27,330
There's a scent of sand.
有一股沙子的气味。

473
00:26:31,910 --> 00:26:33,680
It's like a local pipe, right?
是的，它类似于本地管道。

474
00:26:33,690 --> 00:26:38,360
But this is difficult because this is internet is probably the biggest
但这很困难，因为互联网可能是最大的东西之一。

475
00:26:38,370 --> 00:26:39,600
and the most complex,
最复杂的是，

476
00:26:39,920 --> 00:26:42,480
a system that humans build in some sense.
在某种意义上，是人类建造的系统。

477
00:26:42,810 --> 00:26:46,370
And there are many things can go wrong in between.
在其中有很多事情可能会出错。

478
00:26:46,740 --> 00:26:48,690
So making,
所以制作，

479
00:26:49,100 --> 00:26:52,890
providing to the applications and no matter what happens under the hood is
提供给应用程序，无论底层发生什么情况。

480
00:26:52,900 --> 00:26:53,490
a network.
一个网络。

481
00:26:53,940 --> 00:26:58,840
The data which is sent by some of the client gets to the server
一些客户端发送的数据到达了服务器。

482
00:26:59,140 --> 00:27:03,030
without being lost is not easy fit.
不迷失自我并不容易适应。

483
00:27:03,940 --> 00:27:08,040
The other thing you have is that it's, again, remember,
另外一件事是，再次提醒你，

484
00:27:08,050 --> 00:27:09,960
this is the abstraction.
这是抽象化。

485
00:27:09,970 --> 00:27:10,920
It's a stream.
这是一个流。

486
00:27:10,930 --> 00:27:12,840
The radar abstraction is a stream.
雷达抽象是一个流。

487
00:27:12,900 --> 00:27:17,670
So this means that the water in which you send the data is the order
这意味着您发送数据的水是订单。

488
00:27:17,680 --> 00:27:20,370
in which the receiver gets the rape.
在这种情况下，接收者遭受了强奸。

489
00:27:23,140 --> 00:27:29,270
If you write x and write y then this receiver reads first x and then gets five.
如果你写下x，然后写下y，那么接收者首先读取x，然后得到5。

490
00:27:29,600 --> 00:27:29,950
Right?
对吗？

491
00:27:32,640 --> 00:27:34,820
When you ask for a read,
当你请求读取时，

492
00:27:35,220 --> 00:27:37,280
you get what it's ever at that time.
你得到了那个时候的一切。

493
00:27:40,010 --> 00:27:41,020
So basically say,
基本上说，

494
00:27:42,230 --> 00:27:43,840
if you write, for instance,
如果你写，例如，

495
00:27:43,850 --> 00:27:45,280
so this is very important.
所以这非常重要。

496
00:27:45,660 --> 00:27:46,820
So if you write,
那么如果你写的话，

497
00:27:47,950 --> 00:27:49,680
say, 1,000 bytes,
说，1,000字节。

498
00:27:50,920 --> 00:27:53,160
actually, the receiver can get,
实际上，接收方可以收到，

499
00:27:53,460 --> 00:27:57,930
he can get it in a bunch of 100 bytes.
他可以以100字节一组获取它。

500
00:27:58,220 --> 00:27:58,300
Right?
对吗？

501
00:27:58,310 --> 00:28:00,640
So if you get every time on hundred bytes,
所以如果每次你得到一百个字节，

502
00:28:00,650 --> 00:28:04,280
you need to read10 times to get the entire content.
你需要读10次才能完整阅读内容。

503
00:28:04,970 --> 00:28:07,370
That if nothing,
如果什么都没有的话，

504
00:28:07,700 --> 00:28:11,730
it's arrived after is on the connection,
连接后它已经到达了。

505
00:28:12,260 --> 00:28:13,940
you are blocking like we discussed.
你正在进行阻塞操作，就像我们讨论过的那样。

506
00:28:14,710 --> 00:28:16,740
And there's a semantics,
还有一个语义方面的问题，

507
00:28:16,750 --> 00:28:18,060
pretty much like pipes.
类似于管道。

508
00:28:18,390 --> 00:28:20,940
But now it's over another instead of a single note.
但现在它不再是单一的音符，而是另一种声音。

509
00:28:23,220 --> 00:28:25,850
Now, so we had a single getting more interesting.
现在，我们的情况变得更加有趣了。

510
00:28:26,780 --> 00:28:29,650
It's about how do you create these sockets, right?
是关于如何创建这些套接字的吗？

511
00:28:30,420 --> 00:28:35,020
And basically, it's you need to,
基本上，你需要...

512
00:28:36,880 --> 00:28:39,690
if you think about with files is simple, right?
如果你认为处理文件很简单，对吗？

513
00:28:39,700 --> 00:28:40,370
With files,
使用文件时，

514
00:28:40,380 --> 00:28:45,540
you have a name and of the file and the open that the file is
你需要一个文件的名称，并且打开该文件。

515
00:28:45,550 --> 00:28:46,700
that particular name.
那个特定的名字。

516
00:28:46,710 --> 00:28:51,300
And that's independent of the processes so easy tonight, right?
这与进程无关，所以今晚很容易，对吗？

517
00:28:52,890 --> 00:28:53,830
How do you do in pipes?
在管道中，你好吗？

518
00:28:53,840 --> 00:28:54,430
Do you remember?
你还记得吗？

519
00:28:54,440 --> 00:28:55,310
How do you do in pipes?
在管道中，你好吗？

520
00:28:55,320 --> 00:28:55,950
How do you do?
你好吗？

521
00:28:55,960 --> 00:28:57,350
How does, for instance,
例如，如何

522
00:28:57,360 --> 00:29:04,250
when ii guess it's the slide is already saying.
当我猜测时，幻灯片已经在说了。

523
00:29:04,600 --> 00:29:08,590
But how do you do it in with pipes against the pipes?
但是如何使用管道来对抗管道呢？

524
00:29:08,850 --> 00:29:10,520
Processes runs on the same machine.
进程在同一台机器上运行。

525
00:29:10,850 --> 00:29:14,640
If you are going to communicate between the parent and the child,
如果你要在父进程和子进程之间进行通信，

526
00:29:15,560 --> 00:29:16,510
then it's easier, right?
那么这样就更容易了，对吗？

527
00:29:16,520 --> 00:29:18,630
Because a child, remember,
因为一个孩子，记住，

528
00:29:19,040 --> 00:29:21,990
inherits all the file descriptors of the parrot.
继承了鹦鹉的所有文件描述符。

529
00:29:22,560 --> 00:29:23,720
So already, now,
所以，现在，

530
00:29:23,730 --> 00:29:25,920
the file descriptors corresponding to a pie.
对应于一个进程的文件描述符。

531
00:29:27,900 --> 00:29:29,170
So now,
所以现在，

532
00:29:31,110 --> 00:29:32,110
with the sockets,
使用套接字

533
00:29:32,350 --> 00:29:35,070
there are two things, one,
有两件事情，一件是，

534
00:29:35,830 --> 00:29:36,730
and like a pipe.
就像一个管道一样。

535
00:29:36,740 --> 00:29:39,830
If you remember this one way communication with sockets,
如果你还记得使用套接字进行的单向通信，

536
00:29:39,840 --> 00:29:41,380
you have two way communication.
你有双向通信。

537
00:29:42,270 --> 00:29:42,650
Right?
对吗？

538
00:29:42,930 --> 00:29:47,480
You need both the sender and the receiver being able to send data to each other.
发送方和接收方都需要能够彼此发送数据。

539
00:29:52,130 --> 00:29:53,400
You'll see a little bit.
你会看到一点点。

540
00:29:53,410 --> 00:29:54,000
Why is that?
为什么这样做呢？

541
00:29:56,900 --> 00:29:59,180
And the processes are separate,
而且这些进程是独立的，

542
00:30:00,200 --> 00:30:00,440
right?
对的？

543
00:30:00,450 --> 00:30:01,800
Are on different machines.
在不同的机器上。

544
00:30:02,450 --> 00:30:04,780
So they cannot communicate otherwise.
所以他们无法以其他方式进行交流。

545
00:30:04,790 --> 00:30:06,860
So how can they agree?
那么他们如何达成一致呢？

546
00:30:07,150 --> 00:30:13,020
Or how do I know to what other process I need to communicate?
或者我如何知道我需要与哪个其他进程进行通信？

547
00:30:13,280 --> 00:30:18,790
That that's kind of is a crux of the problem.
这是问题的关键所在。

548
00:30:18,800 --> 00:30:19,710
It's anemic.
这是贫血的。

549
00:30:21,470 --> 00:30:25,460
How do independent to independent programs know how to talk with each other?
独立的程序如何知道如何相互通信？

550
00:30:27,640 --> 00:30:31,590
Again, we discuss a little bit about at the beginning of the class.
再次，我们来讨论一下课程开始时的内容。

551
00:30:31,860 --> 00:30:33,500
But in the internet,
但在互联网上，

552
00:30:33,510 --> 00:30:36,410
the way you are going to name,
你打算命名的方式

553
00:30:37,310 --> 00:30:41,460
it's basically using these dns names, right?
基本上是使用这些 DNS 名称，对吗？

554
00:30:41,470 --> 00:30:42,860
And this is an example.
这是一个例子。

555
00:30:43,050 --> 00:30:44,770
Again, we are going to have a lecture.
再次，我们将进行一次讲座。

556
00:30:44,780 --> 00:30:46,610
We are going to talk more about that,
我们将会更详细地讨论这个问题，

557
00:30:46,620 --> 00:30:49,410
but for now is ww dot pcs not very clear,
但是现在ww点pcs不是很清楚。

558
00:30:49,420 --> 00:30:52,750
dot edo you have a domain name medium,
抱歉，我是一个AI助手，没有自己的域名。

559
00:30:52,760 --> 00:30:54,630
and then it's a top domain,
然后它是一个顶级域名。

560
00:30:54,640 --> 00:30:56,620
and then berkeley the institutions.
然后伯克利这些机构。

561
00:30:56,630 --> 00:30:57,900
And it's a department.
这是一个部门。

562
00:30:57,910 --> 00:30:59,500
And this is a protocol.
这是一个协议。

563
00:31:00,600 --> 00:31:02,070
This application level protocol.
这是一个应用层协议。

564
00:31:02,560 --> 00:31:07,410
Again, dcp and ipadcp and udp are transfer level protocols.
再次强调，DCP、IPDCP和UDP是传输层协议。

565
00:31:09,870 --> 00:31:11,230
But then under the hood,
但是在底层实现中，

566
00:31:12,310 --> 00:31:13,350
at the transport level,
在传输层，

567
00:31:13,360 --> 00:31:18,230
this is what application of this is what you can type in the browser,
这是你可以在浏览器中输入的应用程序。

568
00:31:18,810 --> 00:31:21,270
ww dot google dot com.
www.google.com.

569
00:31:22,520 --> 00:31:22,850
Right?
对吗？

570
00:31:23,560 --> 00:31:24,850
This is what application understands.
这是应用程序所理解的。

571
00:31:25,230 --> 00:31:26,610
The transfer layer,
传输层

572
00:31:27,310 --> 00:31:29,340
the tcp doesn't understand this.
TCP无法理解这个。

573
00:31:29,350 --> 00:31:31,660
What understands are ip addresses.
IP地址是什么意思？

574
00:31:32,610 --> 00:31:33,610
There is, a way,
有一种方法，

575
00:31:33,620 --> 00:31:38,220
is dns name resolution by which is dns names or the horse names
DNS名称解析是通过DNS名称或主机名称来实现的。

576
00:31:38,230 --> 00:31:40,960
are translated into these ip addresses.
被翻译成这些IP地址。

577
00:31:42,920 --> 00:31:45,250
But when we are going to operate at this level,
但是当我们要在这个层次上操作时，

578
00:31:45,260 --> 00:31:47,850
typically we are going to operate with the ip addresses.
通常我们会使用IP地址进行操作。

579
00:31:50,010 --> 00:31:50,920
An ip address.
一个IP地址。

580
00:31:50,930 --> 00:31:52,200
It used to have several beats.
它曾经有几个节拍。

581
00:31:52,210 --> 00:31:54,800
You still have in many parts of the world.
在世界的许多地方，你仍然存在。

582
00:31:55,720 --> 00:31:57,030
It's still dominant.
它仍然占主导地位。

583
00:31:57,330 --> 00:32:03,890
And this is ip ip before it's ipeip stands for internet protocol.
这是ip之前的ip，ipeip代表互联网协议。

584
00:32:04,120 --> 00:32:05,550
V four version four,
V四版本四

585
00:32:05,560 --> 00:32:06,670
32 beats.
32拍。

586
00:32:06,680 --> 00:32:08,590
This was from the beginning of the internet.
这是从互联网的起源开始的。

587
00:32:09,280 --> 00:32:12,630
Then we ran out of addresses because ipp four,
然后我们用完了地址，因为ipp只有四个。

588
00:32:12,930 --> 00:32:16,050
you have you have several to be,
你有几个任务需要完成。

589
00:32:16,060 --> 00:32:18,130
so you can have only 4 billion addresses.
所以你只能拥有40亿个地址。

590
00:32:18,910 --> 00:32:20,860
Now we have ipv six,
现在我们有IPv6。

591
00:32:20,870 --> 00:32:26,500
and it took probably 20 or more years to start and to kind of get
大概花了20年或更长时间才开始并逐渐取得进展。

592
00:32:26,690 --> 00:32:29,860
up to speed with the transition from ipv four and ipv six.
了解从IPv4到IPv6的过渡情况。

593
00:32:29,870 --> 00:32:32,060
And ivv six has 128 bits.
IVV六有128位。

594
00:32:32,320 --> 00:32:33,090
A lot of this,
很多这样的东西，

595
00:32:33,820 --> 00:32:35,250
we won't run out of them.
我们不会用完它们。

596
00:32:37,350 --> 00:32:41,040
Now, in addition to the addresses,
现在，除了地址之外，

597
00:32:41,310 --> 00:32:43,190
you have what are called poor numbers.
你所说的是贫穷数。

598
00:32:46,550 --> 00:32:50,940
And I probably there are people here who took networking.
我想这里可能有人学过网络课程。

599
00:32:51,320 --> 00:32:55,290
So can anyone answer what why do we need a port number?
端口号是计算机网络中用于标识特定应用程序或服务的数字。它们是在传输层协议（如TCP或UDP）中使用的。端口号的存在使得计算机能够将传入的数据包正确地路由到相应的应用程序或服务。通过使用端口号，计算机可以同时运行多个应用程序或服务，并确保它们之间的通信不会混淆或冲突。因此，端口号对于实现网络通信和应用程序之间的协作非常重要。

600
00:32:55,300 --> 00:32:57,230
What is the port number?
端口号是什么？

601
00:33:08,800 --> 00:33:10,000
Allison, very good.
艾莉森，非常好。

602
00:33:10,010 --> 00:33:14,330
So multiple services run on the same cost host.
所以多个服务在同一台成本主机上运行。

603
00:33:15,370 --> 00:33:16,530
So it's very simple.
所以这很简单。

604
00:33:16,910 --> 00:33:20,000
These ip addresses name a host,
这些IP地址指代一个主机。

605
00:33:20,340 --> 00:33:21,340
name a computer,
给一台计算机取个名字，

606
00:33:21,350 --> 00:33:22,380
name a machine.
给一个机器取个名字。

607
00:33:23,230 --> 00:33:25,470
But a machine, like, we know,
但是一个机器，就像我们所知道的，

608
00:33:25,480 --> 00:33:26,730
runs multiple processes.
运行多个进程。

609
00:33:27,360 --> 00:33:31,690
And your code to receive data runs in one of this process.
你的代码用于接收数据的运行在这些进程中的一个。

610
00:33:33,680 --> 00:33:36,400
So you don't need only to identify a host.
所以你不仅需要识别一个主机。

611
00:33:37,250 --> 00:33:41,090
You also need to identify the process to which you are going to send.
你还需要确定要发送的进程。

612
00:33:42,180 --> 00:33:43,770
And from the network perspective,
从网络的角度来看，

613
00:33:43,780 --> 00:33:50,190
that process is identify by a port number is not identified.
该进程通过一个端口号进行标识，而不是被识别。

614
00:33:50,200 --> 00:33:54,210
It is not by outside as a computer,
它不是作为一台外部计算机存在的。

615
00:33:54,220 --> 00:34:01,890
is not identified by the process id it's by these four numbers for numbers
不是通过进程ID来识别，而是通过这四个数字来识别。

616
00:34:01,900 --> 00:34:03,250
as to 16 bits.
关于16位。

617
00:34:05,110 --> 00:34:11,370
The first beats the first 1,023 ports are well known,
前1023个端口是众所周知的最常用端口。

618
00:34:11,950 --> 00:34:14,840
meaning that they are well known services.
意思是它们是众所周知的服务。

619
00:34:15,170 --> 00:34:15,670
What does it mean?
这是什么意思？

620
00:34:15,680 --> 00:34:19,810
80 for 80 is typically for a web web browser.
80对80通常用于网络浏览器。

621
00:34:19,820 --> 00:34:25,040
So if you've got 80s and it's typically a web browser,
那么如果你有80s，通常是一个网络浏览器。

622
00:34:25,410 --> 00:34:30,980
listen on the port 80 to get all the packets,
监听端口80以获取所有数据包。

623
00:34:31,290 --> 00:34:33,520
which are coming to that host.
这是指正在发送到该主机的数据包。

624
00:34:34,150 --> 00:34:37,500
They say they are looking for part eight.
他们说他们正在寻找第八部分。

625
00:34:45,920 --> 00:34:46,370
Now,
现在，

626
00:34:47,980 --> 00:34:50,830
when you have aa server, right?
当你有一个服务器时，对吗？

627
00:34:51,680 --> 00:34:54,650
And remember what we have this figure early on,
还记得我们之前有这个图吗？

628
00:34:54,990 --> 00:34:57,780
we have multiple clients talking with a server.
我们有多个客户端与服务器进行通信。

629
00:34:58,330 --> 00:34:58,800
Okay.
好的。

630
00:34:59,190 --> 00:35:01,610
How does the server can talk with multiple clients?
服务器如何与多个客户端进行通信？

631
00:35:02,330 --> 00:35:05,220
How does it now which packets come from each client?
它如何知道哪些数据包来自每个客户端？

632
00:35:06,670 --> 00:35:07,370
That's a problem.
这是一个问题。

633
00:35:08,040 --> 00:35:08,400
Right?
对吗？

634
00:35:12,630 --> 00:35:17,070
The way we take care of that is very simple.
我们处理这个问题的方式非常简单。

635
00:35:18,080 --> 00:35:21,530
The server doesn't communicate with each client.
服务器不与每个客户端进行通信。

636
00:35:21,540 --> 00:35:26,020
The server only ways from each client to connect.
服务器只接受来自每个客户端的连接。

637
00:35:26,030 --> 00:35:27,620
And when it connects,
当它连接上时，

638
00:35:28,610 --> 00:35:32,090
the server creates another process,
服务器创建另一个进程。

639
00:35:33,170 --> 00:35:34,540
which communicates with a client.
与客户端进行通信。

640
00:35:36,180 --> 00:35:36,700
Okay?
好的？

641
00:35:38,030 --> 00:35:39,260
That's kind of the idea.
这就是个大概的想法。

642
00:35:39,270 --> 00:35:41,260
We are going to reiterate on this idea,
我们将对这个想法进行重申。

643
00:35:41,350 --> 00:35:43,700
hopefully will be clear by the end of this lecture.
希望在本讲座结束时能够清楚明白。

644
00:35:44,140 --> 00:35:45,780
But that's what happened.
但事实就是这样发生的。

645
00:35:46,010 --> 00:35:46,590
That's about.
大概就是这样。

646
00:35:47,570 --> 00:35:52,300
So the client created socket and connect the setup request.
所以客户端创建了套接字并连接了设置请求。

647
00:35:52,550 --> 00:35:55,100
But again, it doesn't send just a message, a request.
但是再次强调，它不仅仅发送一条消息，而是一个请求。

648
00:35:57,080 --> 00:35:58,590
I have the request, give me a reply.
我已经收到了您的请求，请等待回复。

649
00:35:59,100 --> 00:36:03,660
The client sends a connection request to create a connection first.
客户端首先发送连接请求来创建一个连接。

650
00:36:04,060 --> 00:36:06,010
And only after he has a connection,
只有在他建立了连接之后，

651
00:36:06,190 --> 00:36:07,660
you can send, sorry,
你可以发送，抱歉，

652
00:36:07,670 --> 00:36:14,020
you are going to send the data and your request.
你将发送数据和你的请求。

653
00:36:14,030 --> 00:36:15,240
The server listens.
服务器监听。

654
00:36:15,250 --> 00:36:18,540
It's in the state of always listen for new connections,
它处于始终监听新连接的状态。

655
00:36:19,270 --> 00:36:20,550
accept the connection.
接受连接。

656
00:36:21,110 --> 00:36:26,170
And now it creates a a new con,
现在它创建了一个新的进程。

657
00:36:26,180 --> 00:36:27,290
aa new socket.
创建一个新的套接字。

658
00:36:28,960 --> 00:36:31,150
This socket can be in a different process,
这个套接字可以在不同的进程中。

659
00:36:31,160 --> 00:36:35,680
or can be in in a different thread in the same process.
或者可以在同一进程的不同线程中。

660
00:36:35,690 --> 00:36:36,310
We'll see that.
我们会看到的。

661
00:36:38,430 --> 00:36:42,100
Now you have a connection socket for this client.
现在你有一个与该客户端的连接套接字。

662
00:36:42,520 --> 00:36:46,030
Now you are going to send information about this connection socket,
现在你要发送关于这个连接套接字的信息。

663
00:36:46,040 --> 00:36:46,990
and you established.
你已经建立了。

664
00:36:47,680 --> 00:36:56,280
Now, a connection between the client socket and socket on the server side,
现在，客户端套接字和服务器端套接字之间建立了连接。

665
00:36:56,290 --> 00:36:58,200
which is special for that client.
这是为该客户特别定制的。

666
00:37:01,390 --> 00:37:02,740
This is what happens, right?
这就是发生的事情，对吗？

667
00:37:06,500 --> 00:37:09,330
Each connection, this yellow thing here, right?
每个连接，这个黄色的东西在这里，对吗？

668
00:37:10,850 --> 00:37:12,530
Between these two green bubbles,
在这两个绿色气泡之间，

669
00:37:13,130 --> 00:37:16,230
it's identified by five sinks,
它由五个接收器标识。

670
00:37:17,360 --> 00:37:18,650
source ip address,
源IP地址

671
00:37:19,040 --> 00:37:20,830
destination ip address, right?
目标 IP 地址，对吗？

672
00:37:22,230 --> 00:37:25,380
These are the source and the destination.
这是源地址和目的地址。

673
00:37:25,390 --> 00:37:26,500
When you send a packet,
当你发送一个数据包时，

674
00:37:27,400 --> 00:37:29,230
you have the source,
你有源代码。

675
00:37:29,240 --> 00:37:31,110
ip address of machine,
机器的IP地址

676
00:37:31,440 --> 00:37:35,030
the ip address of the machine who a sends a packet,
发送数据包的机器的IP地址

677
00:37:36,640 --> 00:37:40,950
the destination ip the ip address of the receiver machine,
目标IP是接收机器的IP地址。

678
00:37:41,900 --> 00:37:48,330
then you have the poor numbers is a poor numbers of the process who sent
那么，你手上有一个贫穷数字，这是一个发送该数字的进程的贫穷数字。

679
00:37:48,340 --> 00:37:49,090
the data
数据

680
00:37:49,590 --> 00:37:52,540
and send the destination port number.
并发送目标端口号。

681
00:37:52,550 --> 00:37:56,340
The rest is the port number of the process who receives the data
剩下的是接收数据的进程的端口号。

682
00:37:56,350 --> 00:37:57,940
as a new protocol type.
作为一种新的协议类型。

683
00:37:58,800 --> 00:38:00,280
Now here is a protocol type.
现在这是一个协议类型。

684
00:38:00,290 --> 00:38:03,160
It's tcp in this lecture,
这节课是关于TCP的。

685
00:38:03,370 --> 00:38:07,460
like we discuss, also you can have udp user data ground protocol.
正如我们讨论的那样，你也可以使用UDP（用户数据报协议）。

686
00:38:08,400 --> 00:38:10,190
Let me see it's another question.
让我看看，这是另一个问题。

687
00:38:16,270 --> 00:38:18,530
Ii think probably I missed this.
我想我可能错过了这个。

688
00:38:19,070 --> 00:38:20,380
Actually, as this question,
实际上，关于这个问题，

689
00:38:20,390 --> 00:38:24,230
isn't this also a problem for processes on the same computer?
这对于同一台计算机上的进程也是一个问题吗？

690
00:38:24,440 --> 00:38:29,900
How will one identify the other pid so basically about how do I identify
如何识别其他进程的PID？基本上是关于如何进行识别。

691
00:38:29,910 --> 00:38:30,820
the processes?
进程？

692
00:38:31,330 --> 00:38:31,920
So,
所以，

693
00:38:32,540 --> 00:38:34,420
yes, so depends.
是的，所以取决于情况。

694
00:38:34,430 --> 00:38:36,340
So on the same machine,
在同一台机器上，

695
00:38:36,670 --> 00:38:39,900
the problem is not about only how do I identify,
问题不仅仅是如何识别，

696
00:38:40,410 --> 00:38:42,850
but how you are sharing the identification.
但是你是如何分享身份信息的呢？

697
00:38:45,540 --> 00:38:47,470
For instance, on a machine,
例如，在一台机器上，

698
00:38:48,000 --> 00:38:51,670
you have access to the pid and you can identify everything by pid
你可以通过进程ID（pid）访问并识别所有内容。

699
00:38:51,680 --> 00:38:52,510
on the same machine.
在同一台机器上。

700
00:38:53,450 --> 00:39:01,030
If you want to send to make apid not to let one process
如果你想发送一个API请求，以防止某个进程执行

701
00:39:01,040 --> 00:39:04,190
about know about identify another process.
关于了解如何识别另一个进程。

702
00:39:04,470 --> 00:39:05,670
There are many ways to do it.
有很多种方法可以做到这一点。

703
00:39:06,010 --> 00:39:06,410
Right?
对吗？

704
00:39:06,420 --> 00:39:08,770
One way, simple ways to write that in a file.
一种简单的方法是将其写入文件中。

705
00:39:10,050 --> 00:39:10,380
Right?
对吗？

706
00:39:10,690 --> 00:39:15,990
Basically, you have like the cuba land of a server on your machine.
基本上，你的机器上有一个像古巴一样的服务器土地。

707
00:39:16,360 --> 00:39:19,350
You want to now say the pid of that one.
你现在想要知道那个进程的进程ID。

708
00:39:19,360 --> 00:39:22,350
You always when you start that server on that machine,
每次你在那台机器上启动服务器时，都会发生这种情况。

709
00:39:22,360 --> 00:39:23,830
you write the pid in a file.
你将进程ID写入一个文件中。

710
00:39:26,890 --> 00:39:29,060
So that one, but by the way,
那个，顺便说一下，

711
00:39:29,370 --> 00:39:32,840
by the way, the one important things to know is that while here,
顺便说一下，需要知道的一件重要事情是，在这里，

712
00:39:32,850 --> 00:39:36,350
I am always repeating and repeating and repeating that the sender
我一直在重复、重复、重复发送者的信息。

713
00:39:36,360 --> 00:39:40,590
and the receivers are on two different or are two different notes,
并且接收者在两个不同的地方或者是两个不同的笔记上。

714
00:39:40,600 --> 00:39:42,870
they can also be on the same machine.
它们也可以在同一台机器上。

715
00:39:43,440 --> 00:39:44,290
It's going to work.
它会起作用的。

716
00:39:47,510 --> 00:39:52,840
You can use dcp to run to communicate between two processes on the same machine.
您可以使用dcp在同一台机器上的两个进程之间进行通信。

717
00:39:54,750 --> 00:39:55,540
Okay, no problem.
好的，没问题。

718
00:39:57,420 --> 00:39:57,970
Yes, sir.
是的，先生。

719
00:40:03,850 --> 00:40:04,250
Good.
好的。

720
00:40:07,190 --> 00:40:08,950
So in order to know the server,
为了了解服务器，

721
00:40:08,960 --> 00:40:09,990
what do you need to know?
你需要了解什么？

722
00:40:10,000 --> 00:40:10,390
Right?
对吗？

723
00:40:10,830 --> 00:40:14,650
Again, you need to know about its ip address.
再次强调，您需要了解它的IP地址。

724
00:40:16,940 --> 00:40:21,010
And then the port numbers on which this server is listening.
然后是该服务器正在监听的端口号。

725
00:40:22,350 --> 00:40:25,270
And typically against the well known services,
通常对于众所周知的服务而言，

726
00:40:25,280 --> 00:40:28,430
they have well known ports like port 80.
它们有一些众所周知的端口，比如80端口。

727
00:40:29,420 --> 00:40:32,110
Send mail is 25 and things like that.
发送邮件的端口号是25，诸如此类的事情。

728
00:40:32,470 --> 00:40:32,710
Right?
对吗？

729
00:40:33,880 --> 00:40:40,170
And this is now means that everyone knows if it's an old server running
这意味着现在每个人都知道是否是一台旧服务器在运行。

730
00:40:40,260 --> 00:40:42,290
on one machine with this address,
在一台具有此地址的机器上，

731
00:40:42,610 --> 00:40:44,170
that website will run on board date.
该网站将在板上日期上运行。

732
00:40:47,670 --> 00:40:48,190
Okay?
好的？

733
00:40:48,560 --> 00:40:51,520
So now let's go a little bit more details about how things are happened.
现在让我们更详细地了解事情是如何发生的。

734
00:40:53,860 --> 00:40:57,680
To see how this new connection are created.
查看如何创建这个新连接。

735
00:40:59,820 --> 00:41:00,850
The server,
服务器，

736
00:41:01,670 --> 00:41:02,680
you create a socket,
你创建一个套接字。

737
00:41:03,940 --> 00:41:09,860
and you bind it to a local address to another,
然后你将其绑定到另一个本地地址。

738
00:41:09,870 --> 00:41:12,470
which is the local address of the machine, typically,
通常情况下，机器的本地地址是什么？

739
00:41:12,970 --> 00:41:13,790
and a port.
和一个端口。

740
00:41:14,830 --> 00:41:15,160
Right?
对吗？

741
00:41:16,660 --> 00:41:17,690
If your website about,
如果你的网站关于什么的话，

742
00:41:18,460 --> 00:41:20,770
you bind it to port eight,
你将它绑定到了端口八。

743
00:41:22,310 --> 00:41:25,130
and then you listen for connection from the clients.
然后你监听来自客户端的连接。

744
00:41:26,040 --> 00:41:27,250
You get a connection,
你建立了一个连接。

745
00:41:27,780 --> 00:41:28,620
you accept it.
你接受了。

746
00:41:29,660 --> 00:41:30,030
Right?
对吗？

747
00:41:32,140 --> 00:41:34,200
Now let's move to the client side.
现在让我们转到客户端。

748
00:41:34,210 --> 00:41:35,120
On the client side.
在客户端。

749
00:41:35,130 --> 00:41:36,040
I create a socket.
我创建了一个套接字。

750
00:41:37,320 --> 00:41:39,270
Then I connect to the server,
然后我连接到服务器，

751
00:41:39,280 --> 00:41:40,750
specifying the host,
指定主机

752
00:41:40,760 --> 00:41:42,310
ip address and the port number.
IP地址和端口号。

753
00:41:42,630 --> 00:41:43,720
It's a host and support.
它是一个主机和支持系统。

754
00:41:43,730 --> 00:41:45,480
Number two is a server has bind it.
第二个是一个已经绑定的服务器。

755
00:41:47,520 --> 00:41:47,800
Right?
对吗？

756
00:41:48,770 --> 00:41:51,010
This is a little bit of pattern we saw before.
这是我们之前见过的一点模式。

757
00:41:52,240 --> 00:41:56,460
You send a client send a connection request to the server,
当客户端发送连接请求到服务器时，

758
00:41:56,470 --> 00:42:01,050
which was listening and the server accept and send back,
服务器正在监听并接受请求，并发送回应。

759
00:42:02,370 --> 00:42:06,450
accept calls and now and new,
接受来电和新的来电。

760
00:42:06,730 --> 00:42:08,490
and creates also a socket, the server.
并且还创建了一个套接字，即服务器。

761
00:42:08,500 --> 00:42:10,170
And now you have a connection.
现在你已经建立了连接。

762
00:42:12,280 --> 00:42:16,720
Now the server goes to read into it,
现在服务器开始读取它。

763
00:42:16,730 --> 00:42:17,880
blocks into it.
将块插入其中。

764
00:42:18,320 --> 00:42:20,550
And the client writes, so eventually,
客户端会写入数据，所以最终，

765
00:42:20,560 --> 00:42:23,190
when the data written by the client gets to the server,
当客户端写入的数据到达服务器时，

766
00:42:23,200 --> 00:42:28,630
the server read it and write a response.
服务器读取并写入响应。

767
00:42:29,010 --> 00:42:30,330
The client reads a response.
客户端读取响应。

768
00:42:30,340 --> 00:42:31,930
And then at the end,
最后，

769
00:42:31,940 --> 00:42:33,210
you close the socket.
你关闭了套接字。

770
00:42:34,420 --> 00:42:34,740
Right?
对吗？

771
00:42:36,190 --> 00:42:37,500
If you can see about,
如果你能看到关于的信息，

772
00:42:37,770 --> 00:42:40,890
everyone is closing, the socket was a client and a server.
每个人都在关闭，套接字既是客户端又是服务器。

773
00:42:42,070 --> 00:42:45,530
And the client has create the socket.
客户端已经创建了套接字。

774
00:42:45,540 --> 00:42:47,560
This is a cuban with an open.
这是一个带有开放的古巴人。

775
00:42:48,220 --> 00:42:51,320
And the equivalent socket,
以及相应的套接字，

776
00:42:51,330 --> 00:42:53,680
which is the server creates two sockets,
哪个服务器创建了两个套接字

777
00:42:53,690 --> 00:42:57,330
one on which is listening for requests, for new connections.
一个正在监听请求和新连接的服务器。

778
00:42:57,340 --> 00:43:01,440
And then when it's going to accept a request for connection,
然后当它准备接受连接请求时，

779
00:43:01,450 --> 00:43:03,780
is going to create a socket for that connection.
将为该连接创建一个套接字。

780
00:43:05,370 --> 00:43:06,520
So seek, accept,
所以寻找，接受，

781
00:43:06,790 --> 00:43:09,900
cisco is going to create a socket for that connection,
思科将为该连接创建一个套接字。

782
00:43:09,910 --> 00:43:14,420
the connection corresponding to the connection request from the client.
对应于客户端的连接请求的连接。

783
00:43:22,180 --> 00:43:23,050
Here is a question.
这是一个问题。

784
00:43:23,500 --> 00:43:26,410
How do you have multiple web servers on the same machine?
如何在同一台机器上运行多个Web服务器？

要在同一台机器上运行多个Web服务器，可以采取以下几种方法：

1. 使用不同的端口：每个Web服务器可以监听不同的端口。例如，一个服务器可以监听80端口，另一个服务器可以监听8080端口。这样，当用户通过不同的端口访问服务器时，请求会被路由到相应的服务器。

2. 使用虚拟主机：虚拟主机允许在同一台机器上运行多个Web服务器，并使用不同的域名或子域名来区分它们。通过配置虚拟主机，可以将不同的域名指向不同的Web服务器。

3. 使用反向代理：反向代理服务器可以将请求转发到不同的Web服务器上。通过配置反向代理服务器，可以根据请求的URL或其他条件将请求路由到不同的Web服务器。

无论使用哪种方法，都需要确保每个Web服务器使用不同的端口或域名，并且配置正确以避免冲突。此外，还需要确保机器的资源（如带宽、内存和处理能力）足够支持多个Web服务器的运行。

785
00:43:26,420 --> 00:43:28,150
Is there is only one port.
只有一个端口吗？

786
00:43:30,520 --> 00:43:34,030
Typically, you don't have multiple web servers on the same machine.
通常情况下，您不会在同一台机器上运行多个Web服务器。

787
00:43:34,040 --> 00:43:36,830
If you want to have multiple web servers on the same machine,
如果你想在同一台机器上运行多个Web服务器，

788
00:43:37,250 --> 00:43:39,490
you have to assign them to a different numbers.
你需要将它们分配给不同的数字。

789
00:43:40,570 --> 00:43:42,460
And by this web number numbers,
通过这个网页的数字编号，

790
00:43:42,470 --> 00:43:50,150
you need to tell other clients what the new poor numbers are.
你需要告诉其他客户新的贫困指数是多少。

791
00:43:51,570 --> 00:43:51,740
Like.
喜欢。

792
00:43:51,750 --> 00:43:52,780
For instance, typically,
例如，通常情况下，

793
00:43:52,790 --> 00:43:55,780
another poor number website values.
又一个数值网站的价值不高。

794
00:43:55,790 --> 00:43:58,810
If it's not 80, it's 8080.
如果不是80，那就是8080。

795
00:44:00,380 --> 00:44:01,410
I didn't say that.
我没有说那个。

796
00:44:02,370 --> 00:44:08,540
But this the well known port number from 0 to 1 to 1,023,
但这是从0到1,023的众所周知的端口号范围。

797
00:44:09,760 --> 00:44:15,320
you can only bind them if you have a rude privileges.
只有在拥有管理员权限的情况下，你才能绑定它们。

798
00:44:15,900 --> 00:44:16,330
Right?
对吗？

799
00:44:16,660 --> 00:44:18,270
If you are just user,
如果你只是用户，

800
00:44:18,490 --> 00:44:20,360
you cannot bind on the sports.
你不能在运动上束缚自己。

801
00:44:20,750 --> 00:44:25,230
And so if you want to use to run the website about only as a user,
如果你只想作为用户使用这个网站，那么

802
00:44:25,240 --> 00:44:28,750
typically people put 88 the port number.
通常人们会将端口号设置为88。

803
00:44:32,020 --> 00:44:34,290
A few questions here?
这里有几个问题？

804
00:44:34,300 --> 00:44:35,430
Another question?
还有其他问题吗？

805
00:44:36,670 --> 00:44:38,700
No answer the question.
没有回答问题。

806
00:44:38,710 --> 00:44:39,380
Sorry.
抱歉。

807
00:44:44,510 --> 00:44:46,100
Pipes are one way.
管道是单向的。

808
00:44:47,080 --> 00:44:48,390
You need to create two pipes,
你需要创建两个管道，

809
00:44:48,400 --> 00:44:50,030
you want to communicate both ways.
你希望进行双向交流。

810
00:44:59,530 --> 00:45:01,560
There is another answer for allison.
对于艾莉森来说，还有另一个答案。

811
00:45:01,570 --> 00:45:03,800
If you have multiple websites on the same server,
如果您在同一台服务器上有多个网站，

812
00:45:03,810 --> 00:45:05,680
you can do it at the application layer.
你可以在应用层完成这个任务。

813
00:45:06,790 --> 00:45:08,660
Http requests have the horse header,
HTTP请求中有一个"horse"头部。

814
00:45:08,670 --> 00:45:12,480
which tells the server I want to talk to excite.
这个告诉服务器我想和excite通话。

815
00:45:12,490 --> 00:45:14,720
And the server can just send back the eyesight.
服务器可以直接发送视觉信息回来。

816
00:45:19,600 --> 00:45:20,880
That's a little bit more complicated.
这有点复杂。

817
00:45:23,600 --> 00:45:27,080
I guess everything is possible in software.
我猜在软件中一切皆有可能。

818
00:45:28,100 --> 00:45:29,410
But typically, this is,
但通常情况下，这是

819
00:45:30,800 --> 00:45:33,270
you can have the content distribution networks.
你可以使用内容分发网络。

820
00:45:33,760 --> 00:45:35,640
They do something like you propose here.
他们做了类似你在这里提出的事情。

821
00:45:36,450 --> 00:45:38,270
We'll talk a little bit about that later.
我们稍后会谈到这个话题。

822
00:45:39,030 --> 00:45:41,750
But for now, if you, again,
但是现在，如果你再次

823
00:45:42,520 --> 00:45:46,430
the one thing to know is that if you really want to run multiple observers
需要知道的一件事是，如果你真的想要运行多个观察者

824
00:45:47,180 --> 00:45:48,410
on the same,
在同一天

825
00:45:48,820 --> 00:45:50,100
not only the same house,
不仅是同一栋房子，

826
00:45:50,740 --> 00:45:54,800
you need to provide different phone numbers.
你需要提供不同的电话号码。

827
00:45:56,210 --> 00:45:58,680
This is a client protocol a little bit in more details.
这是一个稍微详细一些的客户端协议。

828
00:46:00,880 --> 00:46:02,310
This is how you create the socket.
这是创建套接字的方法。

829
00:46:03,730 --> 00:46:04,140
Right?
对吗？

830
00:46:04,150 --> 00:46:04,700
Remember.
记住。

831
00:46:04,710 --> 00:46:07,030
And when you create a socket, first of all,
当你创建一个套接字时，首先，

832
00:46:07,040 --> 00:46:09,910
you create this kind of addressing from address, info,
你可以通过地址、信息等来创建这种类型的寻址。

833
00:46:09,920 --> 00:46:10,950
data structure.
数据结构。

834
00:46:11,310 --> 00:46:13,430
When you provide the horse name and the port name,
当您提供马的名称和端口名称时，

835
00:46:15,490 --> 00:46:20,790
then you create the socket by using this data structure just graded.
然后你使用刚刚评分的数据结构创建套接字。

836
00:46:20,800 --> 00:46:22,890
And it has three things.
它有三个东西。

837
00:46:22,900 --> 00:46:26,190
Typically, you can add more address family.
通常情况下，您可以添加更多的地址族。

838
00:46:26,200 --> 00:46:34,060
You basically, this is whether it's ipp ipp six or something else set up.
基本上，这是关于是否设置了IPv6或其他什么的问题。

839
00:46:34,570 --> 00:46:35,910
You can have ice.
你可以拿冰。

840
00:46:38,920 --> 00:46:42,440
You have soccer stream type here.
这里有足球直播类型。

841
00:46:42,450 --> 00:46:44,600
It's a sock stream or soccer diagram.
这是一个套接字流或者说是一个足球图表。

842
00:46:44,960 --> 00:46:45,680
Soccer stream.
足球直播。

843
00:46:45,690 --> 00:46:48,350
This is a stream of bytes, the data ground,
这是一串字节流，即数据流。

844
00:46:48,960 --> 00:46:49,430
right?
对的？

845
00:46:49,700 --> 00:46:50,880
Is something we are not discussing,
这是我们不讨论的事情。

846
00:46:50,890 --> 00:46:54,790
which is udp in udp you don't send a stream of bytes.
在UDP中，你不发送字节流。

847
00:46:55,260 --> 00:46:56,830
You send packets,
你发送数据包，

848
00:47:01,160 --> 00:47:03,630
then you have,
那么你有，

849
00:47:04,160 --> 00:47:07,240
it's also pcp it says this is a protocol type,
这也是PCP，它表示这是一种协议类型。

850
00:47:07,730 --> 00:47:10,200
so this is can be like dcp zero.
这可以类似于零拷贝技术。

851
00:47:10,210 --> 00:47:12,270
You can have any protocol.
你可以选择任何协议。

852
00:47:13,610 --> 00:47:14,600
Then you connect,
然后你连接，

853
00:47:15,640 --> 00:47:16,970
this is a connection request.
这是一个连接请求。

854
00:47:17,510 --> 00:47:18,080
You say,
你说，

855
00:47:18,960 --> 00:47:21,850
if you define the server address and the phone number,
如果您定义了服务器地址和电话号码，

856
00:47:24,000 --> 00:47:29,220
then you run the client code on that file descriptor, soccer descriptor,
然后你在该文件描述符上运行客户端代码，足球描述符。

857
00:47:29,230 --> 00:47:30,240
and your clothes.
还有你的衣服。

858
00:47:31,010 --> 00:47:31,380
Right?
对吗？

859
00:47:32,090 --> 00:47:33,360
Again, the ceremony here,
再次，这里的仪式，

860
00:47:33,370 --> 00:47:39,640
just to make sure that I I didn't say something wrong.
只是为了确保我没有说错什么。

861
00:47:40,310 --> 00:47:41,620
The server here,
这里是服务器，

862
00:47:41,630 --> 00:47:42,740
when you do the look of,
当你进行外观设计时，

863
00:47:43,070 --> 00:47:45,770
you basically provide the host name.
你只需要提供主机名即可。

864
00:47:45,780 --> 00:47:48,770
This is a server name and the server port number.
这是服务器的名称和服务器端口号。

865
00:47:49,660 --> 00:47:51,290
This is what you provide in this server.
这是您在此服务器上提供的内容。

866
00:47:53,250 --> 00:47:55,050
What you're doing is several data structure.
你正在做的是几个数据结构。

867
00:47:57,330 --> 00:47:58,470
And for the server protocol,
关于服务器协议，

868
00:47:58,480 --> 00:48:00,370
it's a little bit more involved.
这需要更多的参与。

869
00:48:00,380 --> 00:48:01,450
You create a socket.
你创建了一个套接字。

870
00:48:03,650 --> 00:48:08,670
You brought you give the poor name where you want to bind to each one
你给了贫穷一个名字，你想把它绑定到每一个人身上。

871
00:48:08,680 --> 00:48:09,710
to bind this server,
绑定这个服务器，

872
00:48:09,720 --> 00:48:15,540
and then you bind this server to the typically to the local address
然后你将这个服务器绑定到通常的本地地址。

873
00:48:15,550 --> 00:48:16,900
and the port number.
以及端口号。

874
00:48:17,450 --> 00:48:20,140
Then you listen for connection requests.
然后你监听连接请求。

875
00:48:20,850 --> 00:48:22,520
Now, what you do,
现在，你要做的是什么？

876
00:48:22,530 --> 00:48:23,720
you go into a loop,
你进入了一个循环。

877
00:48:23,730 --> 00:48:26,640
and when you get a connection request, you accept it,
当你收到一个连接请求时，你接受它。

878
00:48:26,930 --> 00:48:28,110
you create a socket.
你创建了一个套接字。

879
00:48:28,120 --> 00:48:29,510
This is connect socket.
这是连接套接字。

880
00:48:29,770 --> 00:48:33,780
And then you serve the client and you close the socket.
然后你为客户端提供服务，并关闭套接字。

881
00:48:34,460 --> 00:48:34,860
Eventually,
最终，

882
00:48:36,100 --> 00:48:37,730
when the server ends,
当服务器结束时，

883
00:48:38,400 --> 00:48:42,240
then you also close the server socket,
那么你也需要关闭服务器套接字。

884
00:48:42,250 --> 00:48:44,640
but the server socket is the one on which you are listening.
但是服务器套接字是你正在监听的那个套接字。

885
00:48:45,260 --> 00:48:45,730
Remember.
记住。

886
00:48:49,210 --> 00:48:54,550
So then now you are going to have requests from different clients.
那么现在你将会收到来自不同客户的请求。

887
00:48:54,560 --> 00:48:56,580
We saw that for each of requests,
我们注意到对于每个请求，

888
00:48:56,680 --> 00:48:57,990
for each request connection,
对于每个请求连接，

889
00:48:58,300 --> 00:49:02,100
we are going to create a different socket on the server side.
我们打算在服务器端创建一个不同的套接字。

890
00:49:02,110 --> 00:49:05,590
Now, where is a code running on the server side?
现在，代码在服务器端运行在哪里？

891
00:49:05,600 --> 00:49:06,150
Going?
要去吗？

892
00:49:06,800 --> 00:49:09,470
Where is the code running on the server side going to run?
服务器端的代码将在哪里运行？

893
00:49:09,880 --> 00:49:12,080
What is this set of client going put up?
这组客户打算发布什么？

894
00:49:12,090 --> 00:49:12,830
You see here?
你看到这里了吗？

895
00:49:13,970 --> 00:49:14,660
Where is that going?
那要去哪里？

896
00:49:14,670 --> 00:49:14,940
Put up?
"Put up" 可以翻译为 "张贴"、"悬挂"、"安装" 或者 "举起"，具体取决于上下文。请提供更多上下文，以便我能够给出更准确的翻译。

897
00:49:17,360 --> 00:49:18,430
There are multiple ways,
有多种方式，

898
00:49:18,800 --> 00:49:19,830
multiple methods here.
这里有多种方法。

899
00:49:19,840 --> 00:49:28,810
One, if you want to really protect yourself about The client,
首先，如果你真的想保护自己免受客户端的影响，

900
00:49:28,820 --> 00:49:31,450
sending you something stupid or send,
发送给你一些愚蠢的东西或发送。

901
00:49:31,940 --> 00:49:35,520
and you you do some bad things.
你做了一些坏事。

902
00:49:35,720 --> 00:49:37,350
It causes you to do some bad things.
它会导致你做一些不好的事情。

903
00:49:37,360 --> 00:49:38,390
You can do it.
你能做到的。

904
00:49:38,400 --> 00:49:41,390
You can run that code in a separate process.
你可以在一个独立的进程中运行那段代码。

905
00:49:41,510 --> 00:49:44,670
You remember the processes as the unit of protection.
你将进程记作保护的单位。

906
00:49:45,030 --> 00:49:45,420
Right?
对吗？

907
00:49:46,550 --> 00:49:48,690
Processes are protected from each other, right?
进程之间是相互保护的，对吗？

908
00:49:49,270 --> 00:49:50,620
In this particular case,
在这种特定情况下，

909
00:49:51,020 --> 00:49:57,090
the idea you have a connection when accepts is called create a connection socket.
当接受连接时，你拥有一个连接的概念，这被称为创建连接套接字。

910
00:49:58,050 --> 00:50:01,930
You are going to create a child,
你将要创建一个子进程。

911
00:50:01,940 --> 00:50:06,090
and you are going to answer the client between in the child.
你将在子进程中回答客户端。

912
00:50:06,370 --> 00:50:09,700
While the parent doesn't do anything,
在父进程不做任何事情时，

913
00:50:09,710 --> 00:50:11,660
it may be ways for the child to finish.
这可能是孩子完成的方法。

914
00:50:11,940 --> 00:50:12,280
Right?
对吗？

915
00:50:13,820 --> 00:50:16,770
So this is a scout on the several side.
这是一个关于几个方面的侦察。

916
00:50:16,780 --> 00:50:18,720
You accept not all the code.
你不接受所有的代码。

917
00:50:18,890 --> 00:50:20,120
It's only in the while loop.
这只发生在 while 循环中。

918
00:50:20,540 --> 00:50:22,660
You accept as a connection request,
你接受了一个连接请求。

919
00:50:22,670 --> 00:50:25,490
then you for remember,
感谢你记住了。

920
00:50:25,500 --> 00:50:28,490
if the result of the four pid is zero,
如果四个进程的结果都是零，

921
00:50:28,750 --> 00:50:30,930
this means that you are here executing what?
这意味着你在这里执行什么任务？

922
00:50:32,970 --> 00:50:34,120
The child code, right?
是的，指的是子代码。

923
00:50:34,710 --> 00:50:37,690
The child, it's closed the server socket.
孩子关闭了服务器套接字。

924
00:50:37,930 --> 00:50:41,160
This is a socket, only the server listen for new connections.
这是一个套接字，只有服务器监听新的连接。

925
00:50:41,610 --> 00:50:44,530
So the child only needs to reply to the client,
所以孩子只需要回复客户端即可。

926
00:50:44,540 --> 00:50:48,050
so he's not going to listen for new clients, right?
所以他不会再听取新客户的意见了，对吗？

927
00:50:50,730 --> 00:50:56,740
Then you set of the client and you also close is a connection to that client.
然后你设置了客户端，并且关闭了与该客户端的连接。

928
00:50:57,270 --> 00:50:59,880
And you exit on the server side,
并且你在服务器端退出。

929
00:51:01,540 --> 00:51:02,850
on the pattern side,
在模式方面，

930
00:51:02,860 --> 00:51:04,500
which is a server itself.
它本身就是一个服务器。

931
00:51:06,200 --> 00:51:08,110
You close a connection socket,
你关闭了一个连接套接字。

932
00:51:08,120 --> 00:51:11,510
you because you are not going to communicate directly with our client.
因为你不会直接与我们的客户进行沟通。

933
00:51:11,990 --> 00:51:16,180
The child is going to communicate and then wait while the weight is going
孩子将要进行通信，然后等待，直到重量完成。

934
00:51:16,190 --> 00:51:18,200
great for the child to finish.
孩子完成得很好。

935
00:51:18,640 --> 00:51:19,710
And then at the end,
最后，

936
00:51:19,990 --> 00:51:22,780
you close the server connection, right?
你关闭了服务器连接，对吗？

937
00:51:24,170 --> 00:51:26,560
So to summarize a in a server,
所以总结一下，在服务器中，

938
00:51:26,570 --> 00:51:30,210
you listen for connection requests.
你监听连接请求。

939
00:51:30,220 --> 00:51:32,290
If there are multiple requests at the same time,
如果同时有多个请求，

940
00:51:32,300 --> 00:51:33,770
they are going to be cured.
他们将会被治愈。

941
00:51:36,200 --> 00:51:42,170
And then you create connections and then use this connection to communicate
然后你创建连接，然后使用这个连接进行通信。

942
00:51:42,620 --> 00:51:43,330
with a child.
带着一个孩子。

943
00:51:44,560 --> 00:51:45,090
Okay?
好的？

944
00:51:45,560 --> 00:51:51,190
This is aa server because it leads an increased connection for his child.
这是一个服务器，因为它为他的子节点提供了增加的连接。

945
00:51:51,460 --> 00:51:56,420
Can answer at the same time to mark can talk at the same time
可以同时回答问题，可以同时进行对话。

946
00:51:56,430 --> 00:51:57,110
with multiple clients.
与多个客户端。

947
00:51:58,640 --> 00:51:59,040
Okay?
好的？

948
00:52:01,830 --> 00:52:05,480
One potential thing here is that in this code, like I said,
这里可能有一个问题，就像我之前说的那样，

949
00:52:05,810 --> 00:52:11,240
the parent, this is a parent code in this else on the else branch.
父进程，这是一个父进程代码，在这个else分支中。

950
00:52:11,870 --> 00:52:13,890
You wait for the child to finish,
你等待孩子完成。

951
00:52:13,900 --> 00:52:15,730
but if you wait for the child to finish,
但是如果你等待孩子完成，

952
00:52:15,990 --> 00:52:17,430
then you cannot listen,
那么你无法听到。

953
00:52:17,440 --> 00:52:20,230
and you cannot satisfy other connection requests.
你无法满足其他连接请求。

954
00:52:20,460 --> 00:52:22,420
So actually, if you write this code,
实际上，如果你编写这段代码，

955
00:52:22,920 --> 00:52:28,770
the server, although you have a different process for the connection,
尽管服务器使用了不同的连接过程，

956
00:52:29,030 --> 00:52:30,270
you cannot accept new connections.
你无法接受新的连接。

957
00:52:30,280 --> 00:52:33,070
So you are talking with one client at a time.
所以你一次只与一个客户交谈。

958
00:52:33,890 --> 00:52:35,070
So what is the fix here?
那么这里的解决方法是什么？

959
00:52:40,150 --> 00:52:41,380
The fix is very simple.
修复非常简单。

960
00:52:41,390 --> 00:52:44,120
Don't wait to go back, don't wait.
不要等待回去，不要等待。

961
00:52:44,130 --> 00:52:48,010
And that go like if you had a server,
就好像你有一个服务器一样，

962
00:52:48,020 --> 00:52:57,070
go back and accept be ready to accept new new connection requests from new clients.
返回并准备接受来自新客户端的新连接请求。

963
00:52:57,080 --> 00:52:57,310
Okay?
好的？

964
00:53:01,350 --> 00:53:04,550
This is address how you set up the address again.
这是关于如何重新设置地址的说明。

965
00:53:04,560 --> 00:53:06,290
I'm not going to go from.
我不会离开。

966
00:53:06,610 --> 00:53:11,470
So details you have the same things like socks stream is like,
所以细节上你们有相同的东西，就像袜子流一样。

967
00:53:11,890 --> 00:53:13,160
it's a data stream.
这是一个数据流。

968
00:53:13,170 --> 00:53:21,680
This is what you have for pcp this is you don't specify the ip ib family
这是你在pcp中的设置，你没有指定IP IB族。

969
00:53:22,010 --> 00:53:22,960
and things like that.
等等之类的东西。

970
00:53:23,740 --> 00:53:25,130
But again,
但是再次，

971
00:53:25,490 --> 00:53:31,570
a it's a boiler plate code to set up this address information data structure.
这是一个用于设置地址信息数据结构的样板代码。

972
00:53:39,140 --> 00:53:40,290
This is a boiler.
这是一个锅炉。

973
00:53:41,600 --> 00:53:42,950
It's from the client side.
这是从客户端的角度来看。

974
00:53:43,640 --> 00:53:45,470
This is how you set the address.
这是设置地址的方法。

975
00:53:47,160 --> 00:53:53,120
And this is how you get the address of the server from the client.
这是客户端获取服务器地址的方法。

976
00:53:53,720 --> 00:53:54,080
Right?
对吗？

977
00:53:56,160 --> 00:53:57,990
You get it from,
你可以从...获取到它。

978
00:53:58,390 --> 00:54:01,290
you specify the host name and the port name.
你需要指定主机名和端口名。

979
00:54:01,780 --> 00:54:04,650
You get the address information,
你获取到了地址信息。

980
00:54:04,660 --> 00:54:07,940
including the ip address of the server.
包括服务器的IP地址。

981
00:54:13,940 --> 00:54:14,340
Now,
现在，

982
00:54:15,230 --> 00:54:15,670
so far,
到目前为止，

983
00:54:15,680 --> 00:54:22,280
I said that you can provide concurrency if you run and you for each client,
我说过，如果你运行并为每个客户端提供并发性，那么你就可以实现并发。

984
00:54:22,620 --> 00:54:24,620
you on the several side,
你在几个方面上。

985
00:54:24,630 --> 00:54:28,480
you have a different process to talk with that client.
你需要与该客户使用不同的流程进行沟通。

986
00:54:29,740 --> 00:54:32,970
Now you have concurrency because processes can run concurrently.
现在你有了并发性，因为进程可以同时运行。

987
00:54:33,570 --> 00:54:38,000
But now the problem is processes what it is that they provide protection,
但现在的问题是进程提供了什么样的保护。

988
00:54:38,010 --> 00:54:39,200
but they are heavyweight.
但它们很重量级。

989
00:54:41,090 --> 00:54:42,790
If you want to provide concurrency,
如果你想提供并发性，

990
00:54:42,800 --> 00:54:47,140
but more heavyweight and you are not as concerned about protection.
但是更加笨重，而且你对保护并不那么关心。

991
00:54:47,150 --> 00:54:47,900
What you do.
你在做什么。

992
00:54:48,250 --> 00:54:49,190
You can use threads,
你可以使用线程，

993
00:54:49,950 --> 00:54:50,290
right?
对的吗？

994
00:54:50,670 --> 00:54:51,180
The thread.
线程。

995
00:54:51,190 --> 00:54:53,940
You can have multiple thread in the same process.
在同一个进程中可以有多个线程。

996
00:54:54,410 --> 00:54:55,000
Now,
现在，

997
00:54:55,010 --> 00:55:01,090
what you are going to do when you are going to accept a connection request
当您接受连接请求时，您将要做什么？

998
00:55:01,100 --> 00:55:01,850
from a client,
来自一个客户，

999
00:55:01,860 --> 00:55:03,890
and you are created creating a socket,
并且你正在创建一个套接字，

1000
00:55:04,170 --> 00:55:05,790
you are going to spawn a thread.
你将要创建一个线程。

1001
00:55:08,550 --> 00:55:11,060
But if you spawn a thread,
但是如果你创建一个线程，

1002
00:55:11,070 --> 00:55:12,340
what is a problem right now?
现在有什么问题？

1003
00:55:13,330 --> 00:55:14,770
This was also in the case of that,
这也是那种情况下的情况。

1004
00:55:14,780 --> 00:55:16,090
when you use the processes,
当你使用进程时，

1005
00:55:16,660 --> 00:55:17,380
what is the problem?
有什么问题吗？

1006
00:55:18,300 --> 00:55:18,640
Right?
对吗？

1007
00:55:20,710 --> 00:55:21,880
See any problem here.
这里有什么问题吗？

1008
00:55:39,630 --> 00:55:41,650
What if you have many clients?
如果你有很多客户，会怎样呢？

1009
00:55:43,810 --> 00:55:45,280
You can have actually an attack.
你实际上可能会遭受攻击。

1010
00:55:46,140 --> 00:55:52,280
I can have many clients opening new connections and never closing them
我可以有很多客户端打开新连接，并且从不关闭它们。

1011
00:55:53,190 --> 00:55:54,470
and exhausted that is.
而且筋疲力尽。

1012
00:55:54,480 --> 00:55:58,890
But in this way, exhaust resources on the 7th side, how do you do that?
但是这样做会耗尽第7方的资源，你打算怎么处理？

1013
00:56:02,470 --> 00:56:03,660
What is the solution here?
这里的解决方案是什么？

1014
00:56:04,570 --> 00:56:07,270
The solution here is to create what is called a thread.
这里的解决方案是创建一个称为线程的东西。

1015
00:56:07,280 --> 00:56:10,760
So you create a bunch of threads, say,
所以你创建了一堆线程，比如说，

1016
00:56:10,770 --> 00:56:11,960
100 threads,
100个线程，

1017
00:56:14,320 --> 00:56:21,790
which means that a given time you can talk concurrently of with 100 clients.
这意味着在给定的时间内，你可以同时与100个客户进行交流。

1018
00:56:22,930 --> 00:56:24,970
What if there are more than 100 plants?
如果有超过100棵植物怎么办？

1019
00:56:25,990 --> 00:56:30,720
They have to wait for some of the current clients you are talking with to finish,
他们必须等待你正在与之交谈的一些当前客户完成。

1020
00:56:31,740 --> 00:56:32,580
and the leads a threat.
并且引发了威胁。

1021
00:56:35,280 --> 00:56:40,150
This is a concept, and it's a very useful concept about the threat pull.
这是一个概念，关于威胁拉取的概念非常有用。

1022
00:56:40,390 --> 00:56:44,650
And the main goal of the third world is to protect the resources
第三世界的主要目标是保护资源。

1023
00:56:45,120 --> 00:56:48,040
of the server from being
防止服务器被

1024
00:56:48,050 --> 00:56:50,890
exhausted very soon.
很快就会感到筋疲力尽。

1025
00:56:54,840 --> 00:56:56,070
How do you have that?
你是怎么得到的？

1026
00:56:56,080 --> 00:56:57,030
You have,
你有，

1027
00:57:00,540 --> 00:57:04,640
you have to hear a master thread and the master thread.
你需要创建一个主线程和一个从属线程。

1028
00:57:04,650 --> 00:57:06,720
This is actually the server,
这实际上是服务器。

1029
00:57:07,090 --> 00:57:10,420
which is going where the code of the server which is waiting
代码中的服务器正在等待的位置是哪里？

1030
00:57:10,430 --> 00:57:11,620
for the connection request,
对于连接请求，

1031
00:57:13,230 --> 00:57:16,810
runs a when you create,
当你创建一个程序时，它会运行。

1032
00:57:18,880 --> 00:57:20,150
when you create a connect,
当你创建一个连接时，

1033
00:57:20,160 --> 00:57:23,230
when you accept a connection request and you create a socket,
当你接受一个连接请求并创建一个套接字时，

1034
00:57:23,880 --> 00:57:28,490
then you put that you incur a request.
然后你提出了一个请求。

1035
00:57:29,370 --> 00:57:30,880
Now is the request for a thread.
现在是对线程的请求。

1036
00:57:30,890 --> 00:57:33,160
You ask for a thread.
你需要一个线程。

1037
00:57:34,090 --> 00:57:38,740
This is nq to the cube of threads, the connection.
这是关于线程的立方和连接的问题。

1038
00:57:39,980 --> 00:57:40,360
Right?
对吗？

1039
00:57:40,780 --> 00:57:42,930
You can the wake up the queue.
你可以唤醒队列。

1040
00:57:42,940 --> 00:57:44,250
This is another thread,
这是另一个线程。

1041
00:57:44,610 --> 00:57:49,310
actually, which basically you will keep you wake up to run the code.
实际上，基本上你需要保持清醒来运行代码。

1042
00:57:50,530 --> 00:57:51,930
And on the huge side,
而在巨大的一方，

1043
00:57:53,540 --> 00:58:00,070
you are going to look at the connection you dick,
你要检查连接，混蛋。

1044
00:58:00,080 --> 00:58:01,270
you from the queue.
你从队列中移除了。

1045
00:58:01,880 --> 00:58:04,190
And if the connection,
如果连接断开，

1046
00:58:05,260 --> 00:58:08,570
if connection is not known, it's not,
如果连接未知，则不是。

1047
00:58:08,580 --> 00:58:10,490
this means there is nothing in the cure.
这意味着治疗方法中没有任何东西。

1048
00:58:10,890 --> 00:58:12,470
So you'll just go to sleep.
那么你就去睡觉吧。

1049
00:58:12,970 --> 00:58:17,400
And that's why the master needs to wake you up, right?
这就是为什么主节点需要唤醒你，对吗？

1050
00:58:18,390 --> 00:58:20,830
As you set up the web page.
当你设置网页时。

1051
00:58:27,000 --> 00:58:29,430
So i'm going to have the announcement before.
所以我会在之前进行公告。

1052
00:58:29,440 --> 00:58:29,630
Then.
那么。

1053
00:58:29,640 --> 00:58:29,990
Let's see.
让我们看看。

1054
00:58:30,000 --> 00:58:31,150
What are the other questions?
其他的问题有哪些？

1055
00:58:35,430 --> 00:58:39,270
Does this newly creative process start listening for new requests as well?
这个新创造的过程也开始监听新的请求了吗？

1056
00:58:39,280 --> 00:58:39,670
Now,
现在，

1057
00:58:40,820 --> 00:58:42,070
this is a great question.
这是一个很好的问题。

1058
00:58:42,360 --> 00:58:44,790
Now the new creative requests do not.
现在新的创意请求不再存在。

1059
00:58:45,130 --> 00:58:47,310
And i'm going to show you the code.
我将向您展示代码。

1060
00:58:50,400 --> 00:58:50,910
You see,
你看，

1061
00:58:51,790 --> 00:58:52,350
here,
这里，

1062
00:58:53,560 --> 00:58:55,720
again, the new creative process.
再次，全新的创造过程。

1063
00:58:57,420 --> 00:58:58,300
It's a child.
这是一个孩子。

1064
00:58:59,830 --> 00:59:03,620
And this is a code under the pid equals zero,
这是一个在进程ID为零时执行的代码。

1065
00:59:03,630 --> 00:59:05,260
which is executed by the child.
由子进程执行的。

1066
00:59:06,050 --> 00:59:10,250
The first thing the child is doing is closing the server socket.
孩子要做的第一件事是关闭服务器套接字。

1067
00:59:11,680 --> 00:59:17,550
The server socket is the one only the server listen for new connections.
服务器套接字是服务器专门用来监听新连接的套接字。

1068
00:59:20,930 --> 00:59:26,280
So this tells you this instruction tells you right away that the client
所以这个指令立即告诉你，客户端

1069
00:59:26,290 --> 00:59:28,590
that the child doesn't
孩子不会

1070
00:59:28,600 --> 00:59:31,480
listen for new connection to be created.
监听新连接的创建。

1071
00:59:31,890 --> 00:59:33,410
The only role of child,
孩子的唯一角色

1072
00:59:33,420 --> 00:59:38,970
the child is to deal with a connection to the client.
这个子进程负责处理与客户端的连接。

1073
00:59:40,410 --> 00:59:41,530
It was associated, too.
它也有关联。

1074
00:59:44,890 --> 00:59:45,350
Okay.
好的。

1075
00:59:47,570 --> 00:59:48,280
Let me see.
让我看看。

1076
01:00:06,580 --> 01:00:10,240
Wait for the threats to join
等待威胁加入

1077
01:00:14,420 --> 01:00:20,980
if you create a new threat and you have to wait towards the threat to join,
如果你创建了一个新的线程，并且需要等待该线程加入，

1078
01:00:20,990 --> 01:00:22,620
because the strategy is a process.
因为策略是一个过程。

1079
01:00:22,630 --> 01:00:24,340
So if the process goes away,
那么如果进程消失，

1080
01:00:24,940 --> 01:00:29,180
then just the thread you created is going to go away.
那么你创建的线程就会消失。

1081
01:00:30,240 --> 01:00:30,500
Right?
对吗？

1082
01:00:31,060 --> 01:00:36,010
So you need like someone like christian or simon said,
所以你需要像Christian或Simon说的那样的人。

1083
01:00:36,620 --> 01:00:40,870
you need to wait for the strategy joints.
你需要等待策略联合。

1084
01:00:47,380 --> 01:00:47,830
Oops,
抱歉，

1085
01:00:48,530 --> 01:00:50,380
announcement project one,
公告：项目一，

1086
01:00:50,390 --> 01:00:53,020
the design documents are due to friday.
设计文档截止日期为周五。

1087
01:00:53,330 --> 01:00:57,970
This friday, the design reviews are going to happen next week,
本周五，设计评审将在下周进行。

1088
01:00:58,590 --> 01:01:00,980
and keep a look out on piazza for sign ups.
并且请密切关注 Piazza 上的报名信息。

1089
01:01:00,990 --> 01:01:05,020
You are going to sign with your pa to probably give the pa will provide.
您打算与您的父母签署协议，可能是为了提供给父母提供的东西。

1090
01:01:05,030 --> 01:01:07,650
You is a feedback on your design.
这是对你设计的反馈。

1091
01:01:08,070 --> 01:01:11,830
And the design is something very important design documents.
设计是非常重要的设计文档的一部分。

1092
01:01:12,120 --> 01:01:15,700
But I you may not have been used with this in other classes.
但是你可能在其他课程中没有使用过这个。

1093
01:01:16,450 --> 01:01:17,680
But in this class,
但在这门课中，

1094
01:01:17,910 --> 01:01:20,100
before you start writing the first lines of code,
在你开始编写第一行代码之前，

1095
01:01:20,110 --> 01:01:22,180
you are going to write a design document.
你需要撰写一个设计文档。

1096
01:01:22,560 --> 01:01:23,700
That is as a theory.
那只是理论上的说法。

1097
01:01:24,490 --> 01:01:28,790
Therefore, it's going to force you to think about about the design.
因此，它将迫使你思考设计问题。

1098
01:01:28,800 --> 01:01:30,870
And then the idea is,
然后这个想法是，

1099
01:01:30,880 --> 01:01:34,310
at once you have a good design document and you got the feedback,
一旦你有了一个好的设计文档并且得到了反馈，

1100
01:01:34,320 --> 01:01:35,430
you address the feedback,
你回应了反馈意见，

1101
01:01:36,150 --> 01:01:42,600
you'll have a much easier job to write and finish your project,
你将会更容易地完成你的项目。

1102
01:01:43,410 --> 01:01:44,250
to do your project,
完成你的项目，

1103
01:01:46,150 --> 01:01:49,290
sing more or less, something like that.
多唱一点或少唱一点，就是这样。

1104
01:01:51,730 --> 01:01:52,560
By the way,
顺便说一下，

1105
01:01:53,050 --> 01:01:58,280
probably with the people that many of you you want did summer internships
很可能是与你们中许多人想要做暑期实习的人一起。

1106
01:01:58,290 --> 01:01:59,880
at software engineering companies,
在软件工程公司中，

1107
01:02:00,400 --> 01:02:04,470
very well that everywhere you need to have a design document
非常好，无论在哪里，你都需要有一个设计文档。

1108
01:02:04,480 --> 01:02:05,620
before your eyes a code.
在你眼前是一段代码。

1109
01:02:06,380 --> 01:02:09,930
This is great practice for your next job.
这是对你下一份工作的很好的实践。

1110
01:02:11,510 --> 01:02:14,580
Even if you do the next thing, you are going to do,
即使你做接下来的事情，你也会这样做，

1111
01:02:14,590 --> 01:02:16,060
you do aphd still,
你仍然在攻读博士学位吗？

1112
01:02:16,070 --> 01:02:17,340
the design documents are great.
设计文档很棒。

1113
01:02:18,850 --> 01:02:21,240
The homework one is beyond thursday,
作业一的截止日期是周四之前。

1114
01:02:21,600 --> 01:02:28,580
and the midterm is due in15 days,
并且期中考试将在15天后截止。

1115
01:02:29,070 --> 01:02:30,220
5 to 6 spam,
5到6个垃圾邮件

1116
01:02:30,230 --> 01:02:31,700
or it will be 2 weeks from now.
或者将在两周后。

1117
01:02:32,700 --> 01:02:33,690
2 weeks from tomorrow.
从明天开始的两周后。

1118
01:02:34,470 --> 01:02:42,410
Sorry, and it will be online and propped out,
抱歉，它将在线并支持输出。

1119
01:02:42,420 --> 01:02:43,970
and we'll get more details,
然后我们会得到更多的细节，

1120
01:02:43,980 --> 01:02:45,330
will get more details next week.
下周将会得到更多的细节。

1121
01:02:48,490 --> 01:02:49,050
Okay.
好的。

1122
01:02:51,040 --> 01:02:53,230
Now for the last 15 minutes,
现在剩下最后15分钟，

1123
01:02:53,240 --> 01:02:55,150
we are going to switch gears,
我们要转换方向，

1124
01:02:55,160 --> 01:02:59,670
and we are going to talk about a very important topic,
我们将讨论一个非常重要的话题，

1125
01:03:00,620 --> 01:03:01,810
synchronization.
同步。

1126
01:03:01,820 --> 01:03:05,980
And we are only going to start here about synchronization, concurrency,
我们现在只会开始讨论关于同步、并发的内容。

1127
01:03:05,990 --> 01:03:06,900
and synchronization.
并且同步。

1128
01:03:12,070 --> 01:03:18,050
Everything starts from the need to multiplex processes.
一切都始于对进程进行多路复用的需求。

1129
01:03:18,420 --> 01:03:18,850
Right?
对吗？

1130
01:03:19,230 --> 01:03:22,820
And you need to run multiple activities concurrently.
你需要同时运行多个活动。

1131
01:03:23,130 --> 01:03:29,870
Like we've seen just a few minutes ago that if we want a server to handle
就像我们刚刚几分钟前看到的那样，如果我们想让一个服务器来处理

1132
01:03:29,880 --> 01:03:32,550
multiple clients at the same time,
同时处理多个客户端

1133
01:03:33,240 --> 01:03:38,900
the way is doing it either using processes or multiple threads running
这种方式可以通过使用进程或多个线程来实现。

1134
01:03:38,910 --> 01:03:40,020
at the same time.
同时。

1135
01:03:40,030 --> 01:03:43,340
Where is thread or processes is associated with the client?
线程或进程与客户端相关联的位置在哪里？

1136
01:03:47,720 --> 01:03:48,080
Good.
好的。

1137
01:03:49,250 --> 01:03:50,400
Now, again,
现在，再次，

1138
01:03:50,710 --> 01:03:53,960
remember, for the and thine, right,
记住，对于 "the" 和 "thine"，是这样的，对吗？

1139
01:03:53,970 --> 01:04:00,260
is like a process is a unit of protection.
就像一个进程是一个保护单元一样。

1140
01:04:01,310 --> 01:04:05,040
It has another space which is protected from other processes.
它还有另一个空间，受到其他进程的保护。

1141
01:04:06,020 --> 01:04:09,730
And the processes is represented by the process control block.
进程由进程控制块表示。

1142
01:04:10,630 --> 01:04:11,780
We talk a little bit about that.
我们稍微谈了一下。

1143
01:04:11,790 --> 01:04:12,580
If you remember,
如果你还记得的话，

1144
01:04:13,490 --> 01:04:21,050
this process control block has all the state that represents that process.
这个进程控制块包含了表示该进程的所有状态。

1145
01:04:22,040 --> 01:04:24,530
In short, if you save that state,
简而言之，如果你保存了那个状态，

1146
01:04:25,640 --> 01:04:32,000
then you can restart the process from that state as if nothing had happened.
然后你可以从那个状态重新启动进程，就好像什么都没有发生过一样。

1147
01:04:36,820 --> 01:04:37,490
So what do you have?
那么你有什么问题？

1148
01:04:37,500 --> 01:04:38,730
It has a status.
它有一个状态。

1149
01:04:38,960 --> 01:04:43,180
We'll see what is the status where there is a process of running radio block?
我们将查看正在运行无线电块的进程的状态是什么。

1150
01:04:46,620 --> 01:04:48,580
You have some register state one,
你有一些寄存器状态。

1151
01:04:48,590 --> 01:04:58,300
not ready process id some some other information,
进程ID不可用，还有其他一些信息。

1152
01:04:58,310 --> 01:05:01,340
like the cushion pain of time, memory space.
就像时间和内存空间的缓冲疼痛一样。

1153
01:05:01,350 --> 01:05:04,190
This is a big one, the memory of the process, right?
这是一个重要的问题，指的是进程的内存，对吗？

1154
01:05:04,840 --> 01:05:05,760
It has to be summer.
一定是夏天了。

1155
01:05:05,770 --> 01:05:07,440
You need one memo you are using.
你需要一个备忘录来记录你正在使用的事项。

1156
01:05:07,990 --> 01:05:09,280
You have to know it.
你必须知道它。

1157
01:05:10,690 --> 01:05:12,400
Translation, how you translate.
翻译，你如何翻译。

1158
01:05:12,410 --> 01:05:14,240
Remember, you have virtual memory,
记住，你有虚拟内存。

1159
01:05:14,250 --> 01:05:16,440
the process since it is a virtual memory.
由于它是虚拟内存，所以这个过程是发生的。

1160
01:05:17,100 --> 01:05:21,330
But the data is starting in physical memory.
但是数据是存储在物理内存中的。

1161
01:05:21,340 --> 01:05:25,110
You need to translate between the address of the virtual memory
你需要在虚拟内存的地址之间进行翻译。

1162
01:05:25,520 --> 01:05:27,040
to the physical memory.
到物理内存。

1163
01:05:27,560 --> 01:05:29,320
You need to have this translation paper.
你需要准备这份翻译文件。

1164
01:05:32,060 --> 01:05:34,480
Again, why do you need to define this contrast state?
再次问一下，为什么你需要定义这个对比状态？

1165
01:05:34,490 --> 01:05:36,240
It's because this allows, again,
这是因为这样可以再次允许

1166
01:05:36,250 --> 01:05:39,690
you the process to be to switch between processes.
进程切换是指在操作系统中切换执行不同进程的过程。

1167
01:05:40,100 --> 01:05:40,430
Right?
对吗？

1168
01:05:42,470 --> 01:05:44,430
You save, you give a process.
你保存，你给一个进程。

1169
01:05:44,440 --> 01:05:46,110
If you save all these states,
如果你保存所有这些状态，

1170
01:05:46,120 --> 01:05:48,350
associating the bcb is a process.
关联BCB是一个过程。

1171
01:05:48,600 --> 01:05:52,050
And then you can give the cpu to another process to run.
然后你可以将CPU分配给另一个进程来运行。

1172
01:05:52,060 --> 01:05:55,170
And then you can come back to the preview to the previous process.
然后你可以返回到之前的进程预览。

1173
01:05:55,510 --> 01:06:00,510
And we started from the same place so to speak by using all the information
我们可以说我们从同一个起点开始，通过使用所有的信息。

1174
01:06:00,520 --> 01:06:01,860
in the pcp
在PCP中

1175
01:06:07,040 --> 01:06:08,030
and this is what happens,
这就是发生的情况。

1176
01:06:08,040 --> 01:06:08,470
right?
对的吗？

1177
01:06:09,250 --> 01:06:11,940
This is how you are going to multiplex.
这是你要进行复用的方式。

1178
01:06:11,950 --> 01:06:14,340
For instance, once if you between two processes,
例如，一旦你在两个进程之间切换，

1179
01:06:14,850 --> 01:06:16,080
p zero and p one,
p zero 和 p one，

1180
01:06:18,790 --> 01:06:20,860
this is what you do it from p zero.
这是你从零开始做的事情。

1181
01:06:20,870 --> 01:06:22,900
You want to switch from p zero to p one.
你想从进程 p0 切换到进程 p1。

1182
01:06:23,360 --> 01:06:28,190
The operating system is going to save the state of the pcp zero in pcp zero.
操作系统将会保存PCP zero的状态在PCP zero中。

1183
01:06:29,790 --> 01:06:35,910
Then is going to reduce to load the state of process b one from pcb one.
然后要将进程b的状态从pcb一中减少一个负载。

1184
01:06:36,410 --> 01:06:40,300
Then it's going to run the process to run process beyond.
然后它将运行进程来运行超出进程。

1185
01:06:40,630 --> 01:06:42,420
And then at some.,
然后在某个时候...

1186
01:06:43,040 --> 01:06:46,720
when the time quanta for that process beyond expired,
当进程的时间片过期时，

1187
01:06:47,020 --> 01:06:50,140
or when it's waiting for something,
或者当它在等待某事时，

1188
01:06:50,600 --> 01:06:55,160
then is going to do the same thing.
然后会做同样的事情。

1189
01:06:55,170 --> 01:07:00,210
But the other way around is going to save the pcb one over the state
但是反过来的话，将会保存 PCB 上的一个状态。

1190
01:07:00,220 --> 01:07:02,050
of process b one in pcb one,
进程 b 的 PCB 中的一个。

1191
01:07:02,370 --> 01:07:05,530
and then reload the state of p zero and pcp zero,
然后重新加载 p zero 和 pcp zero 的状态。

1192
01:07:05,540 --> 01:07:08,700
and then resume the execution of p zero.
然后恢复 p zero 的执行。

1193
01:07:09,900 --> 01:07:10,390
That's all.
就这些。

1194
01:07:12,040 --> 01:07:13,910
This is operating system.
这是操作系统。

1195
01:07:14,130 --> 01:07:15,160
High level of privilege,
高权限级别

1196
01:07:15,170 --> 01:07:18,680
meaning that this code cannot be executed by the applications.
意思是这段代码无法被应用程序执行。

1197
01:07:21,520 --> 01:07:22,670
All of these yellow stuff,
所有这些黄色的东西，

1198
01:07:22,680 --> 01:07:27,710
what are those function calls interrupts?
这些函数调用中断是什么意思？

1199
01:07:31,010 --> 01:07:32,780
Now you remember that here,
现在你记住了，在这里，

1200
01:07:33,070 --> 01:07:37,440
we are talking about the status of the process in the PCB this is a status.
我们正在讨论进程控制块（PCB）中的进程状态，这是一个状态。

1201
01:07:40,190 --> 01:07:42,670
This is a state or the state of the process.
这是一个进程的状态或进程的状态。

1202
01:07:44,190 --> 01:07:45,860
A process first is created,
首先创建一个进程。

1203
01:07:46,910 --> 01:07:49,450
then is put in the queue if he's ready to execute,
如果他准备好执行，那么他将被放入队列中。

1204
01:07:51,130 --> 01:07:52,250
from the cure,
来自治愈者，

1205
01:07:52,260 --> 01:07:53,890
from being ready to execute,
从准备执行状态开始，

1206
01:07:55,620 --> 01:07:57,050
it can go in the running state.
它可以进入运行状态。

1207
01:07:58,100 --> 01:08:02,670
Ready to run is running,
准备就绪，正在运行中。

1208
01:08:04,520 --> 01:08:05,670
and can terminate,
并且可以终止，

1209
01:08:05,680 --> 01:08:08,240
or it can be interrupted.
或者它可以被中断。

1210
01:08:09,180 --> 01:08:09,420
Right?
对吗？

1211
01:08:09,430 --> 01:08:11,500
For instance, it's time quant expired.
例如，时间片已经过期。

1212
01:08:12,760 --> 01:08:14,320
So it's put again back in the real estate.
所以它又被放回了房地产市场。

1213
01:08:15,330 --> 01:08:18,110
Or is doing an io event,
正在执行一个IO事件。

1214
01:08:18,120 --> 01:08:20,350
is waiting for is doing it,
"正在等待"是指正在进行某项活动。

1215
01:08:20,860 --> 01:08:24,420
waiting from some data from the network to get some data from the network.
等待从网络获取数据。

1216
01:08:25,930 --> 01:08:26,270
Right?
对吗？

1217
01:08:26,740 --> 01:08:28,010
Now you are annoying state.
现在你是令人讨厌的状态。

1218
01:08:28,570 --> 01:08:29,970
Again, you are no longer running.
再次强调，你已经停止运行。

1219
01:08:30,760 --> 01:08:32,960
When you are going to get the data you are waiting for,
当你要获取你正在等待的数据时，

1220
01:08:32,970 --> 01:08:35,080
you are going to be in a real estate, so you can run again.
你将要进入房地产行业，这样你就可以再次运行了。

1221
01:08:36,070 --> 01:08:36,510
Right?
对吗？

1222
01:08:39,480 --> 01:08:41,150
So we have also the animation.
所以我们还有动画。

1223
01:08:41,160 --> 01:08:43,530
So look, process is created.
所以看，进程已经创建了。

1224
01:08:43,540 --> 01:08:45,960
You are going to go into any state here.
你将进入任何状态。

1225
01:08:45,970 --> 01:08:48,100
You can run when the processor,
当处理器运行时，你可以运行。

1226
01:08:48,980 --> 01:08:51,000
when the CPU is available,
当CPU可用时，

1227
01:08:51,330 --> 01:08:54,900
then you run, you can get an interrupt,
然后你运行时，可能会发生中断。

1228
01:08:56,150 --> 01:08:58,910
like I mentioned when your time.expired.

1229
01:08:59,680 --> 01:09:04,440
And then those are multiple times like we saw in the previous slide.

1230
01:09:04,740 --> 01:09:08,120
You can switch between p zero and p one, right?

1231
01:09:12,530 --> 01:09:13,560
Then you can,

1232
01:09:13,570 --> 01:09:16,840
if you execute and I operation,

1233
01:09:16,850 --> 01:09:18,040
the process can wait,

1234
01:09:19,190 --> 01:09:23,060
should wait no longer running when the weight ends,

1235
01:09:23,070 --> 01:09:25,370
because it got the data, for instance,

1236
01:09:25,380 --> 01:09:28,560
for which is waiting for going to a real estate.

1237
01:09:29,880 --> 01:09:31,590
You run for a little bit again,

1238
01:09:32,140 --> 01:09:35,070
and then you are done exit.

1239
01:09:42,590 --> 01:09:43,550
The scheduling.

1240
01:09:45,490 --> 01:09:47,870
This is just a part is ridicule.

1241
01:09:48,720 --> 01:09:49,720
And the scheduling.

1242
01:09:49,730 --> 01:09:51,240
Basically, what is the scheduler?

1243
01:09:52,720 --> 01:09:54,160
What is the role of the scheduler?

1244
01:09:54,520 --> 01:09:54,760
Right?

1245
01:09:54,770 --> 01:09:59,330
We talk about the scheduler picks, which one do you want?

1246
01:09:59,870 --> 01:10:00,550
Ready?

1247
01:10:01,090 --> 01:10:03,130
Process to run?

1248
01:10:03,540 --> 01:10:03,960
Next?

1249
01:10:07,000 --> 01:10:07,390
That's it.

1250
01:10:10,420 --> 01:10:10,700
Okay.

1251
01:10:10,710 --> 01:10:15,550
And here you see that once you run,

1252
01:10:18,440 --> 01:10:23,250
there are multiple ways you can stop running.

1253
01:10:24,160 --> 01:10:26,270
Like I said, time slice expires.

1254
01:10:27,720 --> 01:10:33,090
You are doing an io request and you need to wait for that to come to Complete.

1255
01:10:34,540 --> 01:10:38,970
You can fork a child or you can wait for interact like for instance,

1256
01:10:40,260 --> 01:10:40,480
yeah,

1257
01:10:40,490 --> 01:10:46,570
from a diamond interrupt or interrupt from the keyboard or something like that.

1258
01:10:47,880 --> 01:10:50,640
Ok let me see about examples.

1259
01:10:51,170 --> 01:10:51,680
Questions?

1260
01:10:51,690 --> 01:10:52,000
Sorry.

1261
01:10:55,670 --> 01:10:57,350
Why do we need struggles?

1262
01:10:57,750 --> 01:11:00,030
Can we just create thread as request comes?

1263
01:11:04,810 --> 01:11:08,060
Philip, so what happens if you have 11 million requests?

1264
01:11:09,910 --> 01:11:12,540
Each thread actually consumed resources.

1265
01:11:14,560 --> 01:11:16,430
So that far as at some.,

1266
01:11:16,440 --> 01:11:19,310
you exhaust the resources of a machine.

1267
01:11:21,300 --> 01:11:23,300
And then everything becomes extremely slow.

1268
01:11:23,310 --> 01:11:24,060
You get trash.

1269
01:11:25,080 --> 01:11:26,060
You want to avoid that.

1270
01:11:28,970 --> 01:11:30,560
Ramirez, assuming one CPU,

1271
01:11:30,570 --> 01:11:33,440
how does a kernel ensure each process is run smoothly?

1272
01:11:34,720 --> 01:11:38,240
Is there a timer for when the scheduler interrupts for each PCB?

1273
01:11:38,930 --> 01:11:39,710
That's correct.

1274
01:11:41,290 --> 01:11:44,870
This is the one time slice expires.

1275
01:11:45,720 --> 01:11:49,410
So the time slice the kernels, they typically have, say,

1276
01:11:50,170 --> 01:11:52,010
10 million seconds or 1 million seconds.

1277
01:11:52,930 --> 01:11:55,710
A process or a set, actually,

1278
01:11:55,720 --> 01:11:57,830
the thread runs when I say a process.

1279
01:11:58,280 --> 01:12:00,380
In this case, I am using interchangeably.

1280
01:12:01,550 --> 01:12:04,320
But the process like thread runs,

1281
01:12:04,820 --> 01:12:07,060
it can run only up to, say,

1282
01:12:07,070 --> 01:12:08,860
10 millisecond or 1 millisecond.

1283
01:12:10,290 --> 01:12:12,010
When that expires,

1284
01:12:12,550 --> 01:12:15,470
the process is or is swapped out.

1285
01:12:21,040 --> 01:12:22,150
No question.

1286
01:12:24,380 --> 01:12:28,340
How is the process PCB distinct from the threat control block?

1287
01:12:29,120 --> 01:12:30,340
The PCB,

1288
01:12:30,630 --> 01:12:32,830
it's again, contains a state associated with a process.

1289
01:12:32,840 --> 01:12:34,390
It's a lot of more state.

1290
01:12:34,920 --> 01:12:38,240
Like, for instance, the state about the memory,

1291
01:12:38,250 --> 01:12:39,280
the pages,

1292
01:12:40,350 --> 01:12:41,330
and the translations.

1293
01:12:42,640 --> 01:12:44,710
It's also contains a file descriptors.

1294
01:12:46,870 --> 01:12:47,420
Okay?

1295
01:12:48,510 --> 01:12:54,070
The thread, it's only touring the thread control block.

1296
01:12:54,080 --> 01:12:57,430
It's only typically registers and the stack.

1297
01:12:58,880 --> 01:12:59,240
Right?

1298
01:12:59,930 --> 01:13:02,690
It's much smaller.

1299
01:13:07,370 --> 01:13:08,490
Hopefully answer the question.

1300
01:13:09,620 --> 01:13:10,120
Okay.

1301
01:13:16,660 --> 01:13:18,220
If the process is not running,

1302
01:13:18,230 --> 01:13:21,700
is PCB which represents a process in the kernel,

1303
01:13:22,180 --> 01:13:23,670
is in some schedule cube,

1304
01:13:24,490 --> 01:13:28,880
may be waiting for the eye operation to Complete or waiting

1305
01:13:28,890 --> 01:13:30,320
for an interrupt or things like that.

1306
01:13:31,490 --> 01:13:31,890
Okay?

1307
01:13:33,130 --> 01:13:34,850
And each queue, again,

1308
01:13:34,860 --> 01:13:41,040
can have different scheduling policies about how you are going to set

1309
01:13:41,050 --> 01:13:42,430
of the next

1310
01:13:43,850 --> 01:13:44,960
PCB from that queue.

1311
01:13:46,500 --> 01:13:47,820
This is already queue.

1312
01:13:50,190 --> 01:13:52,980
Here represent, you have this kind of each node,

1313
01:13:52,990 --> 01:13:54,220
represent one process.

1314
01:13:54,230 --> 01:13:59,600
You see, here is apcb this is a cure for this device.

1315
01:13:59,610 --> 01:14:02,080
You can have for the USB for the disk.

1316
01:14:02,870 --> 01:14:04,540
If and this is for networking,

1317
01:14:05,390 --> 01:14:06,620
there is nothing there.

1318
01:14:06,930 --> 01:14:08,280
Now, for the list, for in this case,

1319
01:14:08,290 --> 01:14:12,000
we have two processes which are waiting to operate,

1320
01:14:12,010 --> 01:14:17,410
which are operate awaiting to operate a read or write on that disk.

1321
01:14:19,220 --> 01:14:25,870
The kernel will decide with what is the other news that are going to be scheduled?

1322
01:14:25,880 --> 01:14:31,350
That request is as going to be satisfied.

1323
01:14:33,090 --> 01:14:33,430
Okay?

1324
01:14:34,380 --> 01:14:36,110
And the same for the network.

1325
01:14:37,700 --> 01:14:38,890
So the schedule is actually,

1326
01:14:38,900 --> 01:14:40,050
the core is very simple.

1327
01:14:41,490 --> 01:14:43,330
Like this is for the ready process, right?

1328
01:14:45,550 --> 01:14:47,100
You go to the ready process.

1329
01:14:48,370 --> 01:14:50,210
Is there any process?

1330
01:14:50,700 --> 01:14:51,930
It's already process?

1331
01:14:53,570 --> 01:14:57,370
You if the queue is not empty, so what does it mean?

1332
01:14:57,950 --> 01:14:58,870
You select the process.

1333
01:14:58,880 --> 01:14:59,770
This is what?

1334
01:15:00,420 --> 01:15:01,240
From the queue.

1335
01:15:01,250 --> 01:15:04,190
This is a scheduling operation.

1336
01:15:04,790 --> 01:15:09,600
And you get the next the PCB of the next process to schedule.

1337
01:15:10,360 --> 01:15:12,100
And you run the next PCB.

1338
01:15:12,320 --> 01:15:16,510
Otherwise, you are idle because there is no process to be scheduled.

1339
01:15:18,470 --> 01:15:19,810
The process, like I mentioned,

1340
01:15:19,820 --> 01:15:24,840
the scheduling is a mechanism for deciding which process or thread to run

1341
01:15:24,850 --> 01:15:29,670
on the CPU there are lots of different scheduling policies.

1342
01:15:29,680 --> 01:15:33,350
There are thousand tens of thousands of papers on scheduling policies,

1343
01:15:33,910 --> 01:15:38,010
because there are different properties you want to enforce may be fairness

1344
01:15:38,020 --> 01:15:40,330
between different application or processes.

1345
01:15:41,570 --> 01:15:44,340
Provide real time, guarantees blood, latency,

1346
01:15:44,350 --> 01:15:46,020
optimization and things like that.

1347
01:15:49,240 --> 01:15:50,740
And remember that actually,

1348
01:15:50,750 --> 01:15:52,880
the part which is running from a process,

1349
01:15:52,890 --> 01:15:55,040
it's kind of is that thread.

1350
01:15:55,560 --> 01:15:56,840
That's the active component.

1351
01:15:57,720 --> 01:16:00,650
Other space is passive, its protection,

1352
01:16:01,080 --> 01:16:02,960
its protection.

1353
01:16:05,510 --> 01:16:08,990
Why have multiple threads where other space we already knew?

1354
01:16:09,000 --> 01:16:11,540
Now that we saw that an example,

1355
01:16:12,080 --> 01:16:15,840
you can have one thread for each connection for each client.

1356
01:16:17,920 --> 01:16:22,150
This again share is showing you the share the state between the trading

1357
01:16:22,160 --> 01:16:23,110
the same process.

1358
01:16:23,430 --> 01:16:24,870
And then but stress states,

1359
01:16:25,420 --> 01:16:25,940
right?

1360
01:16:26,180 --> 01:16:32,200
Is a strength control block and you have registers a stack Information.

1361
01:16:32,580 --> 01:16:33,770
That's pretty much it.

1362
01:16:34,210 --> 01:16:35,410
While the shared state,

1363
01:16:35,760 --> 01:16:37,270
you have global variables,

1364
01:16:37,280 --> 01:16:40,100
the hips and memories of code, and things like that.

1365
01:16:44,100 --> 01:16:47,130
The core of the concurrency is this dispatch loop, right?

1366
01:16:47,140 --> 01:16:47,610
Is a loop.

1367
01:16:47,620 --> 01:16:49,370
You run the strategy, choose an extra,

1368
01:16:49,730 --> 01:16:50,850
save the state.

1369
01:16:51,490 --> 01:16:57,450
This is now is written in terms of the threads at the Serena ID but this is

1370
01:16:57,460 --> 01:16:58,730
exactly what this core,

1371
01:16:58,740 --> 01:17:00,970
this loop in the kernel is doing.

1372
01:17:02,190 --> 01:17:03,770
You run the current thread,

1373
01:17:04,040 --> 01:17:07,810
then when that thread terminates or it's interrupted,

1374
01:17:07,820 --> 01:17:09,850
because the timer and so forth,

1375
01:17:09,860 --> 01:17:13,220
you choose an extra that I from the queue.

1376
01:17:13,530 --> 01:17:14,670
You save the thread,

1377
01:17:14,680 --> 01:17:16,710
the state of the current thread,

1378
01:17:17,270 --> 01:17:19,940
and the state of the new thread.

1379
01:17:20,250 --> 01:17:21,560
Now you run the new set.

1380
01:17:23,370 --> 01:17:25,480
This is an infinite look, like you never stop.

1381
01:17:30,110 --> 01:17:30,620
Okay.

1382
01:17:34,670 --> 01:17:35,630
Let's stop here.

1383
01:17:35,640 --> 01:17:38,990
And let me see any other question?

1384
01:17:44,810 --> 01:17:46,480
No, more questions.

1385
01:17:47,810 --> 01:17:49,450
So let's stop here.

1386
01:17:50,500 --> 01:17:51,530
Like on the..

1387
01:17:52,180 --> 01:17:53,400
Good luck with the homework,

1388
01:17:53,410 --> 01:17:55,200
the good luck with the project.

1389
01:17:55,880 --> 01:17:58,550
And let me know if you have any other questions.

1390
01:17:59,770 --> 01:18:03,280
If not, I'm going to see you all on Thursday.

1391
01:18:05,170 --> 01:18:07,270
I have a great day.

