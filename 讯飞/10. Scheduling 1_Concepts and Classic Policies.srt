1
00:00:07,880 --> 00:00:08,830
Hello, everyone.

2
00:00:08,840 --> 00:00:11,030
Welcome to the tennis lecture. 

3
00:00:12,810 --> 00:00:16,480
Today we are going to finish synchronization, primitives,

4
00:00:16,490 --> 00:00:18,840
and then the rest of the lecture, 

5
00:00:18,850 --> 00:00:22,590
we are going to focus on scheduling, 

6
00:00:23,950 --> 00:00:25,460
main key concepts. 

7
00:00:25,470 --> 00:00:29,740
And we are going to learn some of the basic policies. 

8
00:00:32,890 --> 00:00:38,280
Recall that last time we learned about monitors and condition variables, 

9
00:00:41,740 --> 00:00:43,920
just to, 

10
00:00:45,780 --> 00:00:47,450
if you remember a monitor, 

11
00:00:47,460 --> 00:00:48,490
it's a lock, 

12
00:00:50,340 --> 00:00:55,090
and which owns one or more conditioned variables, 

13
00:00:55,900 --> 00:01:01,450
these condition variables are used for managing the access to share data. 

14
00:01:02,330 --> 00:01:02,760
Okay? 

15
00:01:09,980 --> 00:01:12,730
The way this is happening is our conditional variable. 

16
00:01:12,740 --> 00:01:14,970
You can imagine it as a queue of thread, 

17
00:01:15,270 --> 00:01:19,580
waiting for something to happen inside a critical section, a section.

18
00:01:20,080 --> 00:01:26,610
And they are waiting for a signal from this condition variable. 

19
00:01:27,770 --> 00:01:32,990
The key here is that because you are waiting for something to happen

20
00:01:33,000 --> 00:01:34,830
in the critical section, 

21
00:01:36,150 --> 00:01:38,230
the critical section has a lock. 

22
00:01:38,960 --> 00:01:43,390
You need to look at critical section to implement mutual exclusion. 

23
00:01:44,720 --> 00:01:48,790
But because you are waiting in a critical section before, 

24
00:01:50,980 --> 00:01:52,970
when you're being the thread, 

25
00:01:53,230 --> 00:01:56,280
you are put to sleep on the waiting queue. 

26
00:01:56,530 --> 00:01:57,510
You need to release a lock. 

27
00:01:58,300 --> 00:02:01,140
And the monitors does the art for you. 

28
00:02:01,150 --> 00:02:04,410
You don't need as a programmer to do anything. 

29
00:02:07,150 --> 00:02:09,290
Basically, from the programming perspective,

30
00:02:09,300 --> 00:02:15,270
you can wait in the critical section for the event to happen. 

31
00:02:15,610 --> 00:02:17,280
But under the hood, 

32
00:02:17,600 --> 00:02:18,950
the lock is released. 

33
00:02:19,270 --> 00:02:20,920
Once you are put on the radio. 

34
00:02:21,960 --> 00:02:22,360
Okay? 

35
00:02:25,040 --> 00:02:27,210
Besides awake wake, 

36
00:02:28,970 --> 00:02:32,760
we take the argument as a lock of the critical section. 

37
00:02:32,770 --> 00:02:38,350
You are going to wait in order to trigger events, 

38
00:02:39,050 --> 00:02:42,280
to wake up the threads which are waiting for these events to happen. 

39
00:02:43,090 --> 00:02:46,560
There are two primitives, signal,

40
00:02:47,340 --> 00:02:48,630
and broadcast. 

41
00:02:49,590 --> 00:02:52,260
A signal wakes up only one waiter. 

42
00:02:52,570 --> 00:02:55,780
Aa broadcast can wake up all the waiters, 

43
00:02:56,100 --> 00:02:58,990
which are waiting for that particular event to happen. 

44
00:03:01,330 --> 00:03:01,760
Okay? 

45
00:03:04,860 --> 00:03:09,840
When you do condition variable operations, 

46
00:03:10,180 --> 00:03:12,960
then you are going to have to, obviously,

47
00:03:12,970 --> 00:03:14,480
to keep the lock. 

48
00:03:20,450 --> 00:03:22,520
One question here from actually, 

49
00:03:22,530 --> 00:03:26,600
that why it is nice to be able to wait in the critical section. 

50
00:03:28,360 --> 00:03:29,750
So if you remember, 

51
00:03:30,110 --> 00:03:34,880
if not, if the program doesn't allow you to wait,

52
00:03:35,110 --> 00:03:37,950
if the program constructs api doesn't allow you to wait, 

53
00:03:39,090 --> 00:03:46,790
then you need somehow programmatic to give the

54
00:03:46,800 --> 00:03:49,120
lock while you are going to sleep. 

55
00:03:49,860 --> 00:03:55,110
Because if you are going to sleep while you keep the lock that no one

56
00:03:55,120 --> 00:03:56,510
else can acquire the lock. 

57
00:03:56,920 --> 00:03:58,790
So basically, the entire system.

58
00:03:59,180 --> 00:04:01,680
So no one even can wake you up. 

59
00:04:02,210 --> 00:04:04,550
So the entire system is deadlock. 

60
00:04:05,200 --> 00:04:09,040
It's fundamental that as you are going to go to sleep, 

61
00:04:09,810 --> 00:04:11,390
you have to be the lock. 

62
00:04:12,300 --> 00:04:18,480
But doing that in a program is to separate instructions going to sleep and reading, 

63
00:04:18,490 --> 00:04:19,830
the lock is very difficult. 

64
00:04:20,420 --> 00:04:23,020
It cannot the instruction has to be atomic. 

65
00:04:23,620 --> 00:04:26,010
These two actions should be atomic in the same instruction. 

66
00:04:28,220 --> 00:04:31,400
That's what monitors provide to you. 

67
00:04:36,450 --> 00:04:37,180
Good question. 

68
00:04:39,110 --> 00:04:39,420
Now, 

69
00:04:39,430 --> 00:04:44,380
aa key question is that the monitor is clearly a a much more advanced api

70
00:04:44,550 --> 00:04:45,740
for synchronization. 

71
00:04:45,750 --> 00:04:49,380
And one of the natural question, actually, it's about,

72
00:04:49,390 --> 00:04:53,360
can you use lower level synchronization primitives like some of us to go

73
00:04:53,370 --> 00:04:54,290
to implement monitors? 

74
00:04:54,810 --> 00:04:55,170
Right? 

75
00:04:56,450 --> 00:05:00,140
Again, we got out of two to constructs,

76
00:05:00,150 --> 00:05:02,620
you need to implement one. 

77
00:05:02,630 --> 00:05:03,660
It's about, 

78
00:05:04,580 --> 00:05:05,410
you need to, 

79
00:05:07,110 --> 00:05:08,390
you have a critical section, 

80
00:05:08,820 --> 00:05:09,850
you need to implement. 

81
00:05:09,860 --> 00:05:14,590
So you need to lock the lock primitive. 

82
00:05:14,940 --> 00:05:16,840
The other one is signaling, right?

83
00:05:17,470 --> 00:05:20,680
To signal in the events or condition variables. 

84
00:05:22,400 --> 00:05:24,390
The condition variables, basically,

85
00:05:24,880 --> 00:05:26,470
you can think you can do it, 

86
00:05:26,820 --> 00:05:32,020
because you can one possibility would be to wait to use a semaphore. 

87
00:05:32,890 --> 00:05:34,160
You wait for a similar for, 

88
00:05:34,170 --> 00:05:37,000
and the way you do it, 

89
00:05:37,010 --> 00:05:44,240
you the seven p p operation and so forth. 

90
00:05:44,250 --> 00:05:47,360
If you remember the p operations decrement the similar for it, 

91
00:05:47,370 --> 00:05:49,280
it has a value greater than one. 

92
00:05:49,530 --> 00:05:52,350
If it has a value later than the issue is, 

93
00:05:52,660 --> 00:05:55,840
the film sum of our value is zero, then you wait.

94
00:05:57,590 --> 00:06:02,550
And then signaling its use as an operation which is v which is

95
00:06:02,560 --> 00:06:04,930
just increment the cinema for right? 

96
00:06:05,560 --> 00:06:09,950
If you are waiting on a similar for because the value zero and I

97
00:06:09,960 --> 00:06:12,270
am implementing the similar for the value to one, 

98
00:06:12,390 --> 00:06:15,010
i'm going to basically wake you up, 

99
00:06:15,660 --> 00:06:16,870
but i'm going to signal it. 

100
00:06:19,250 --> 00:06:20,120
So does this work? 

101
00:06:24,850 --> 00:06:25,850
One think, 

102
00:06:26,810 --> 00:06:28,290
one reason this may not work, 

103
00:06:28,300 --> 00:06:34,450
because if you call weight in during in the critical section, 

104
00:06:34,700 --> 00:06:36,120
then it doesn't release a lock. 

105
00:06:37,030 --> 00:06:39,070
And if you have the problem, 

106
00:06:39,080 --> 00:06:44,840
I just mentioned earlier that you are going to sleep with while you hold

107
00:06:44,850 --> 00:06:45,280
the lock. 

108
00:06:45,590 --> 00:06:48,300
So no one else can enter the critical section. 

109
00:06:54,970 --> 00:06:56,600
In order to avoid this problem, 

110
00:06:56,610 --> 00:06:58,760
you can think to have something like this, right?

111
00:06:58,770 --> 00:06:59,240
It's like, 

112
00:07:02,110 --> 00:07:02,830
when you wait, 

113
00:07:03,560 --> 00:07:06,030
this is the implementation of the weight function. 

114
00:07:06,550 --> 00:07:06,990
Right? 

115
00:07:08,450 --> 00:07:09,560
You release a lock, 

116
00:07:10,320 --> 00:07:15,310
then you do some r for p and again, 

117
00:07:15,320 --> 00:07:16,470
you try to decrement, 

118
00:07:16,890 --> 00:07:18,080
you acquire the lock. 

119
00:07:18,730 --> 00:07:19,040
Right? 

120
00:07:19,650 --> 00:07:21,550
So basically, so in this sense,

121
00:07:21,560 --> 00:07:25,700
is that if you are going to slap sleep across the center for zero, 

122
00:07:26,490 --> 00:07:33,450
your lock was at least the signal is the same. 

123
00:07:34,910 --> 00:07:35,840
It does this work. 

124
00:07:36,290 --> 00:07:36,660
Right? 

125
00:07:38,360 --> 00:07:40,940
It doesn't work a for a series of reason, 

126
00:07:40,950 --> 00:07:43,820
but one of the things which is, again, we discussed last time.

127
00:07:44,180 --> 00:07:48,990
But I want to emphasize is that the condition variables, 

128
00:07:49,000 --> 00:07:50,190
when you send a signal, 

129
00:07:50,570 --> 00:07:51,720
there is no history. 

130
00:07:54,430 --> 00:08:00,270
If there is, if no one is waiting on a condition variable,

131
00:08:02,100 --> 00:08:05,390
some are someone will send a signal for that condition variable. 

132
00:08:06,300 --> 00:08:07,820
That signal was lost. 

133
00:08:10,150 --> 00:08:10,770
That is, 

134
00:08:11,090 --> 00:08:15,880
if you send a signal upon a conditioned variable on which no one is listening, 

135
00:08:16,540 --> 00:08:17,190
is writing. 

136
00:08:17,600 --> 00:08:17,870
Now, 

137
00:08:17,880 --> 00:08:21,370
someone else comes after you send the signal waiting on the condition

138
00:08:21,380 --> 00:08:24,420
variable that someone else is going to be stuck, 

139
00:08:24,430 --> 00:08:25,140
is going to wait. 

140
00:08:27,040 --> 00:08:28,440
This is different from singapore. 

141
00:08:28,450 --> 00:08:32,010
The singapore have history because you are increment in the singapore. 

142
00:08:33,300 --> 00:08:34,520
So take the same scenario. 

143
00:08:35,130 --> 00:08:36,210
No one is waiting. 

144
00:08:37,120 --> 00:08:38,350
But now the semaphore, 

145
00:08:38,360 --> 00:08:43,160
you called a signal and use a semaphore implementation. 

146
00:08:45,080 --> 00:08:45,950
What will happen then? 

147
00:08:46,280 --> 00:08:46,900
What will happen? 

148
00:08:47,310 --> 00:08:47,740
Then? 

149
00:08:47,750 --> 00:08:50,540
You are going to increment the summer now the summer for each one. 

150
00:08:51,870 --> 00:08:52,510
So the next, 

151
00:08:53,680 --> 00:08:58,690
if someone else waits on the summer for price to wait, 

152
00:08:59,120 --> 00:09:01,000
is no longer wait, because it's not for one,

153
00:09:01,010 --> 00:09:02,440
is going to decrement to zero. 

154
00:09:03,140 --> 00:09:04,280
And it's going to go ahead. 

155
00:09:05,310 --> 00:09:05,590
Right? 

156
00:09:06,050 --> 00:09:07,440
This is one of the key difference. 

157
00:09:11,170 --> 00:09:12,610
This is exactly what I mentioned. 

158
00:09:18,340 --> 00:09:18,750
Okay? 

159
00:09:20,330 --> 00:09:22,360
This is a key difference investment. 

160
00:09:26,210 --> 00:09:32,100
The other the main problem here is that another way to say it is

161
00:09:32,110 --> 00:09:35,880
that p and v are committed if it doesn't matter in which order happen, 

162
00:09:36,440 --> 00:09:38,180
the value of the semaphore will be the same. 

163
00:09:39,300 --> 00:09:39,630
Right? 

164
00:09:40,590 --> 00:09:42,020
On the other hand, 

165
00:09:42,400 --> 00:09:44,410
the condition variable or not, 

166
00:09:44,420 --> 00:09:47,010
because like we explain, if you send a condition,

167
00:09:47,440 --> 00:09:50,690
if you send a signal on a condition variable, 

168
00:09:50,700 --> 00:09:53,720
and no one is waiting on that condition variable, 

169
00:09:54,050 --> 00:09:55,880
that signal was lost. 

170
00:09:56,700 --> 00:09:57,130
Okay. 

171
00:10:00,130 --> 00:10:01,160
Here is another try. 

172
00:10:01,910 --> 00:10:03,540
Let's try to fix a problem. 

173
00:10:03,900 --> 00:10:06,090
And how do we try to fix the problem here? 

174
00:10:06,890 --> 00:10:09,600
You are going only to increment the semaphore. 

175
00:10:09,940 --> 00:10:18,740
If there is no one waiting on the npk or is aq is empty for that condition variable. 

176
00:10:18,750 --> 00:10:21,180
The condition variable associated with us an offer. 

177
00:10:24,120 --> 00:10:24,470
Is that? 

178
00:10:41,690 --> 00:10:45,110
So it doesn't talk either because, for instance, there is,

179
00:10:45,120 --> 00:10:47,350
you cannot look at the center for, 

180
00:10:48,000 --> 00:10:53,310
you cannot look at contents on some of the cube that there is no primitive. 

181
00:10:53,320 --> 00:10:54,630
There is no api for that. 

182
00:10:55,260 --> 00:10:55,700
Right? 

183
00:10:56,440 --> 00:10:58,110
That's one of the reason it doesn't work. 

184
00:10:58,580 --> 00:11:00,050
And also there is a race condition, 

185
00:11:05,660 --> 00:11:12,070
the signal that can just signal after the lock release and before the way

186
00:11:12,080 --> 00:11:13,390
to execute some authority, 

187
00:11:15,590 --> 00:11:17,540
hear what the rest condition can happen. 

188
00:11:20,500 --> 00:11:20,930
Anyway, 

189
00:11:23,100 --> 00:11:26,850
it turns out that it's actually possible to implement this correct reason for, 

190
00:11:26,860 --> 00:11:28,130
but it's a very complex solution. 

191
00:11:30,130 --> 00:11:34,720
The take away here is that the monitor is a very useful abstraction. 

192
00:11:35,520 --> 00:11:38,550
One way to see that it's useful abstraction. 

193
00:11:38,770 --> 00:11:42,580
It's by the fact that it's very hard to implemented using

194
00:11:42,590 --> 00:11:47,400
more primitive or more basic abstractions like some of us. 

195
00:11:48,630 --> 00:11:49,010
Okay? 

196
00:11:54,100 --> 00:11:55,050
In conclusion, 

197
00:11:56,070 --> 00:12:01,510
monitors they synchronize the present the synchronization of the logic, 

198
00:12:02,170 --> 00:12:06,500
then capsule the synchronization logic of the program. 

199
00:12:06,510 --> 00:12:13,330
And this means that to wait for some event to happen and the ability

200
00:12:13,340 --> 00:12:15,050
to signal that event. 

201
00:12:16,120 --> 00:12:20,500
And the typical monitor based program. 

202
00:12:20,510 --> 00:12:22,220
It looks something like that, right?

203
00:12:23,200 --> 00:12:25,530
You look the critical section, 

204
00:12:25,940 --> 00:12:28,650
you acquire the lock on the critical section where you

205
00:12:28,660 --> 00:12:31,790
are going to manipulate state variables. 

206
00:12:31,800 --> 00:12:33,110
If you remember, 

207
00:12:34,050 --> 00:12:35,320
in the previous lecture, 

208
00:12:35,330 --> 00:12:36,840
we have to acquire the lock. 

209
00:12:37,100 --> 00:12:38,410
While we are manipulating, 

210
00:12:38,420 --> 00:12:40,570
we are updating where we are testing, 

211
00:12:41,430 --> 00:12:46,980
that active writer is or waiting writer is activity that is waiting readers. 

212
00:12:50,620 --> 00:12:55,150
You are going to wait if necessary for some condition to happen. 

213
00:12:55,720 --> 00:12:56,100
Right? 

214
00:13:00,030 --> 00:13:01,100
In another, 

215
00:13:01,360 --> 00:13:03,470
typically, another critical section,

216
00:13:03,480 --> 00:13:05,670
you are going to signal. 

217
00:13:06,600 --> 00:13:07,670
That condition becomes true. 

218
00:13:07,680 --> 00:13:08,710
You are going to signal. 

219
00:13:08,920 --> 00:13:10,230
Now you are going to wait, 

220
00:13:10,600 --> 00:13:11,730
wake the threads, 

221
00:13:12,690 --> 00:13:14,120
one or more threads, 

222
00:13:14,410 --> 00:13:16,840
which are waiting for that condition variable to happen. 

223
00:13:16,850 --> 00:13:18,000
If you send a signal, 

224
00:13:18,010 --> 00:13:22,880
only one threading member is going to wake up that if you send broadcast, 

225
00:13:24,150 --> 00:13:27,860
if then all the strategies are waiting on their condition, 

226
00:13:27,870 --> 00:13:29,180
variable are going to wake up. 

227
00:13:32,350 --> 00:13:33,860
Now, question is about,

228
00:13:33,870 --> 00:13:35,300
what about these languages? 

229
00:13:35,310 --> 00:13:36,940
What is the support in today's languages? 

230
00:13:39,150 --> 00:13:46,100
There is every language has some level of support for synchronization primitives, 

231
00:13:46,590 --> 00:13:47,630
some better than others. 

232
00:13:48,290 --> 00:13:50,010
Like, for instance, for the sea language,

233
00:13:51,690 --> 00:13:54,070
they do have support. 

234
00:13:54,080 --> 00:13:56,230
You do have support for the locks, 

235
00:13:56,850 --> 00:13:59,660
right now, 

236
00:14:00,920 --> 00:14:02,920
with this support, for locks.

237
00:14:03,790 --> 00:14:08,610
So you need to be careful if you are going to return, right?

238
00:14:08,620 --> 00:14:13,810
Because if you acquire the lock at the beginning of your function, 

239
00:14:14,970 --> 00:14:19,400
naturally, you are going to release the look at the end of the function.

240
00:14:19,710 --> 00:14:23,730
But you need also to release a look at every time you return from that function. 

241
00:14:23,740 --> 00:14:25,270
So you need to be very careful, 

242
00:14:25,280 --> 00:14:26,810
because if you forget to do that, 

243
00:14:27,900 --> 00:14:28,970
you can happen. 

244
00:14:28,980 --> 00:14:30,250
Aa deadlock can happen. 

245
00:14:32,400 --> 00:14:39,490
Now, the other problem is that in sea,

246
00:14:39,700 --> 00:14:40,910
it's actually or unfortunate. 

247
00:14:40,920 --> 00:14:42,230
You can also jump. 

248
00:14:43,260 --> 00:14:48,160
And if you are going to jump into the program again, 

249
00:14:48,170 --> 00:14:49,630
you can create the deadlock. 

250
00:14:57,240 --> 00:15:00,020
But even when you have more rocks, 

251
00:15:00,030 --> 00:15:03,740
things are just becoming even more complex, right?

252
00:15:04,080 --> 00:15:08,050
Because you need to keep track in the program as a developer

253
00:15:08,490 --> 00:15:10,770
when to release every each lock. 

254
00:15:11,470 --> 00:15:19,710
And it's the program is not even going to look uniform in the same function. 

255
00:15:20,210 --> 00:15:20,630
Right? 

256
00:15:20,930 --> 00:15:23,360
Still, depending on where you allocate the locks and so forth.

257
00:15:23,370 --> 00:15:26,640
And for somebody tells you have to at least two locks in this example, 

258
00:15:26,650 --> 00:15:28,040
for some of them, only one lock.

259
00:15:28,580 --> 00:15:31,360
You can imagine that it's very easy to make mistakes. 

260
00:15:31,640 --> 00:15:33,300
And again, once you make mistakes,

261
00:15:33,510 --> 00:15:37,270
you run into the danger to create that looks. 

262
00:15:39,310 --> 00:15:39,670
Okay. 

263
00:15:42,750 --> 00:15:47,970
That another problem I just mentioned why is harbin see to to get locks

264
00:15:47,980 --> 00:15:50,040
because in ceo can also jump around. 

265
00:15:50,050 --> 00:15:51,420
You have a goal to stay. 

266
00:15:52,240 --> 00:15:52,630
Right. 

267
00:15:53,100 --> 00:15:56,720
Now you can think about they can use go to statement to provide

268
00:15:56,730 --> 00:15:59,360
some syntactic sugar to make it easier, 

269
00:15:59,370 --> 00:15:59,920
right? 

270
00:16:00,490 --> 00:16:05,730
Instead of having to instruction release and return, 

271
00:16:06,090 --> 00:16:07,640
you are going to have, 

272
00:16:08,430 --> 00:16:10,870
you are going to jump to another. 

273
00:16:10,880 --> 00:16:16,030
So you are going to release the lock and basically return. 

274
00:16:16,250 --> 00:16:16,440
Right? 

275
00:16:16,610 --> 00:16:23,760
You can write only one instruction to release and release and return a lock. 

276
00:16:24,110 --> 00:16:27,630
Now, the big obvious problem is that if you need to release two locks,

277
00:16:27,640 --> 00:16:34,280
you need to write another kind of instruction to release boss locks and so forth, 

278
00:16:34,290 --> 00:16:34,600
right? 

279
00:16:35,900 --> 00:16:42,160
Or to organize a code so that when you jump to one and address, 

280
00:16:42,890 --> 00:16:45,160
you release both locks and you jump on another address, 

281
00:16:45,170 --> 00:16:48,210
release only one look is, again, very complicated.

282
00:16:51,720 --> 00:16:52,980
C plus, 

283
00:16:54,120 --> 00:16:55,270
ac plus, again,

284
00:16:55,280 --> 00:16:56,950
in her support for rocks. 

285
00:16:58,410 --> 00:16:59,830
Now, we see plus, actually,

286
00:16:59,840 --> 00:17:04,110
things are even a little bit even more complicated during your head locks. 

287
00:17:04,460 --> 00:17:04,520
Why? 

288
00:17:04,530 --> 00:17:06,440
Because you have, if you remember,

289
00:17:06,450 --> 00:17:08,680
in c plus, you have exceptions.

290
00:17:13,400 --> 00:17:17,000
If you get an exception during the critical section, 

291
00:17:17,730 --> 00:17:20,290
you jump to treat the exception, 

292
00:17:20,810 --> 00:17:22,840
but you still hold the lock. 

293
00:17:24,170 --> 00:17:25,780
So you don't need a lock. 

294
00:17:26,440 --> 00:17:28,670
So in order to release a lock, 

295
00:17:28,970 --> 00:17:35,580
you need to catch every exception and release a lock explicitly. 

296
00:17:36,670 --> 00:17:37,150
Okay? 

297
00:17:37,440 --> 00:17:38,990
Because if you don't do that again, 

298
00:17:39,210 --> 00:17:46,260
you are going to go and attribute the exception And with while you

299
00:17:46,270 --> 00:17:46,940
still have the law, 

300
00:17:46,950 --> 00:17:48,250
so you don't need the law. 

301
00:17:49,810 --> 00:17:50,190
Okay. 

302
00:17:51,250 --> 00:17:52,790
Now, fortunately,

303
00:17:52,800 --> 00:17:55,150
c plus is a new version of locks, 

304
00:17:55,160 --> 00:17:57,070
which is called lock guards. 

305
00:17:57,990 --> 00:18:00,390
You can think about this looks like a variable. 

306
00:18:01,210 --> 00:18:06,120
And the cool thing about that is that you acquire the lock when you declare

307
00:18:06,130 --> 00:18:07,040
the variable. 

308
00:18:07,460 --> 00:18:10,950
And whenever the variables is going to go out of scope, 

309
00:18:12,200 --> 00:18:13,960
the lock is automatically released. 

310
00:18:16,710 --> 00:18:22,530
So you basically don't have an explicit instruction to release a lock. 

311
00:18:22,540 --> 00:18:26,660
You just declare the lock as a variable. 

312
00:18:27,360 --> 00:18:29,940
And in that function, 

313
00:18:31,890 --> 00:18:34,480
everything gets under that lock in that function. 

314
00:18:35,090 --> 00:18:38,030
And whenever eu or the method, 

315
00:18:38,040 --> 00:18:39,190
because it's c plus, 

316
00:18:39,600 --> 00:18:43,270
whenever you are going to go out of scope returning, 

317
00:18:43,280 --> 00:18:49,720
whether that's basically throw an exception or just turn, 

318
00:18:50,940 --> 00:18:54,220
then the lockets automatically list. 

319
00:18:58,370 --> 00:18:58,770
Okay? 

320
00:19:01,400 --> 00:19:02,890
With python, 

321
00:19:03,730 --> 00:19:06,280
you have this other construct, which is pretty cool.

322
00:19:06,290 --> 00:19:11,750
Again, you can declare lock like almost like a variable.

323
00:19:12,130 --> 00:19:20,050
And then you can use a statement with lock to basically declare a critical section. 

324
00:19:20,490 --> 00:19:22,470
So everything under the swiss lock, 

325
00:19:22,950 --> 00:19:23,970
it's going to be locked. 

326
00:19:25,020 --> 00:19:27,090
It's a critical section protected by the lock. 

327
00:19:27,540 --> 00:19:28,680
And again, 

328
00:19:28,690 --> 00:19:30,440
when you are going to leave the block, 

329
00:19:30,710 --> 00:19:32,880
the release of the lock happens out an article. 

330
00:19:34,700 --> 00:19:36,290
A little bit similar is bad locks. 

331
00:19:39,140 --> 00:19:44,010
We java goes one step further and also provides you

332
00:19:49,270 --> 00:19:51,140
what they call synchronized methods. 

333
00:19:51,660 --> 00:19:52,090
Right? 

334
00:19:52,600 --> 00:19:55,190
So basically, you can have synchronized methods,

335
00:19:55,910 --> 00:19:57,420
a in a class. 

336
00:19:58,040 --> 00:19:58,490
Basically, 

337
00:19:58,500 --> 00:20:06,560
the synchronized methods are think about that they protect all the variables, 

338
00:20:08,550 --> 00:20:10,300
a in the class, in the object,

339
00:20:12,060 --> 00:20:13,890
by a lock, by an implicit lock.

340
00:20:15,090 --> 00:20:16,480
So you can think about, 

341
00:20:16,490 --> 00:20:18,400
when you say public synchronized, 

342
00:20:18,780 --> 00:20:24,150
then this method automatically acquires a lock, 

343
00:20:24,450 --> 00:20:27,990
and it leaves as a lock for everything what is happening

344
00:20:28,220 --> 00:20:29,420
in this particular method. 

345
00:20:31,620 --> 00:20:33,100
So pretty cool. 

346
00:20:33,640 --> 00:20:35,510
And java also support monitors. 

347
00:20:36,650 --> 00:20:37,870
You can wait. 

348
00:20:38,640 --> 00:20:45,900
You can also have the notify and notify all for us to to notify

349
00:20:45,910 --> 00:20:46,740
when an event happens. 

350
00:20:50,190 --> 00:20:51,190
Any questions here? 

351
00:21:05,570 --> 00:21:12,190
So announcements tomorrow we have the meantime between

352
00:21:13,360 --> 00:21:20,210
5:00 and 7:00 pm is will david a proctor of a zone? 

353
00:21:20,860 --> 00:21:23,690
Please read the proctor in policies very carefully. 

354
00:21:24,360 --> 00:21:28,040
You can have a one handwritten cheat sheet. 

355
00:21:29,460 --> 00:21:31,070
And in addition to that, 

356
00:21:32,050 --> 00:21:35,640
upcoming deadlines at homework two is due on monday, 

357
00:21:36,320 --> 00:21:41,110
next monday, and the project to first project with you next monday.

358
00:21:48,750 --> 00:21:49,020
Great. 

359
00:21:49,210 --> 00:21:52,070
So now let's switch the gears. 

360
00:21:52,530 --> 00:21:56,850
And next we are going to start talking about scheduling. 

361
00:21:57,380 --> 00:21:57,830
Okay. 

362
00:21:59,000 --> 00:22:00,790
Before talking about scheduling, 

363
00:22:00,800 --> 00:22:04,150
remember about why do we need scheduling? 

364
00:22:04,910 --> 00:22:08,230
And remember about the user kernel thread models. 

365
00:22:11,380 --> 00:22:15,440
And for a very good question here, 

366
00:22:18,410 --> 00:22:24,910
I79 it's 79. 

367
00:22:25,180 --> 00:22:25,900
Thanks for, 

368
00:22:40,660 --> 00:22:41,240
okay. 

369
00:22:42,330 --> 00:22:42,810
Thank you. 

370
00:22:47,330 --> 00:22:48,600
In general, unless other.

371
00:22:48,610 --> 00:22:50,600
So you have user level threads, 

372
00:22:51,300 --> 00:22:51,740
right? 

373
00:22:52,130 --> 00:22:53,600
Which are to be fine, say,

374
00:22:53,610 --> 00:22:54,850
with ap thread library. 

375
00:22:55,540 --> 00:22:56,920
And then you have the kernel thread. 

376
00:22:57,400 --> 00:22:58,940
And typically, unless,

377
00:22:59,650 --> 00:23:01,170
as though I specified, 

378
00:23:01,440 --> 00:23:06,890
we assume that one user level thread is going to be mapped in a kernel thread, 

379
00:23:09,090 --> 00:23:10,320
the kennel, this,

380
00:23:11,150 --> 00:23:13,070
and they cannot only see kennel sets. 

381
00:23:14,170 --> 00:23:14,380
Okay. 

382
00:23:15,860 --> 00:23:21,010
And the kernel responsibility is to share the resources, 

383
00:23:21,240 --> 00:23:24,960
the cpu resources across threads. 

384
00:23:28,550 --> 00:23:32,380
There are a few others way to that you can also have

385
00:23:32,390 --> 00:23:35,340
many user threads mapping on the same kernel thread, 

386
00:23:35,670 --> 00:23:40,300
or many user threads mapping on many canon threads. 

387
00:23:40,750 --> 00:23:43,270
But in this particular case, and again,

388
00:23:43,280 --> 00:23:44,870
for unless otherwise specified, 

389
00:23:45,550 --> 00:23:50,060
we are assuming that it's unusual thread map to our calendar thread. 

390
00:23:54,000 --> 00:23:55,010
And for this thread, 

391
00:23:55,020 --> 00:23:56,170
if you remember, 

392
00:23:56,480 --> 00:23:59,310
in a a process has at least one thread, 

393
00:24:00,280 --> 00:24:02,790
the kernel maintains a thread control block, 

394
00:24:02,800 --> 00:24:11,680
pcb what you have in the thread you have is a state of the thread when he suspended. 

395
00:24:11,690 --> 00:24:13,280
And that's the state, 

396
00:24:13,290 --> 00:24:22,280
which is enough to resume the thread execution from the.where it was suspended. 

397
00:24:23,420 --> 00:24:25,940
And this means the content of the registers, 

398
00:24:26,270 --> 00:24:28,920
the program counter, and the stack..

399
00:24:36,770 --> 00:24:37,760
In addition, 

400
00:24:38,150 --> 00:24:44,450
some kernels are only belongs to the some threads only belongs to the kernel. 

401
00:24:45,180 --> 00:24:49,120
This is for the kernel to do some work. 

402
00:24:49,560 --> 00:24:50,310
In the background. 

403
00:24:53,880 --> 00:24:57,710
You can do some, maybe can do compaction of the file of things like that.

404
00:25:03,670 --> 00:25:09,750
Let's again look at this layout. 

405
00:25:10,940 --> 00:25:13,170
We have two processes here and one kernel. 

406
00:25:13,530 --> 00:25:15,750
A process, each process here has a thread.

407
00:25:15,760 --> 00:25:18,230
Remember, a process has at least one thread.

408
00:25:18,240 --> 00:25:23,220
The thread is a unit of execution and concurrency. 

409
00:25:24,410 --> 00:25:29,920
And a process owns before the stack. 

410
00:25:29,930 --> 00:25:34,500
It it's defines an address space, 

411
00:25:34,980 --> 00:25:38,180
which contains the before besides the stack, 

412
00:25:38,190 --> 00:25:42,020
it contains a code global variables and the hip. 

413
00:25:43,440 --> 00:25:48,520
And if you look at what happens in the kernel, 

414
00:25:48,530 --> 00:25:54,670
when what is what the kernel maintained for these processes? 

415
00:25:55,930 --> 00:26:02,170
It's going to maintain the pcb is a process control block. 

416
00:26:03,110 --> 00:26:04,440
And the kernel, 

417
00:26:04,740 --> 00:26:07,340
the stack for the kernel stack for the process. 

418
00:26:07,640 --> 00:26:09,370
When you are going to execute, 

419
00:26:12,310 --> 00:26:15,670
you are going to run a say, for instance,

420
00:26:15,680 --> 00:26:23,690
things like cisco on behalf of that process in the canon. 

421
00:26:25,230 --> 00:26:31,820
Obviously, the kernel has its own code and global variables and the heap.

422
00:26:35,410 --> 00:26:36,880
Now, as you know,

423
00:26:38,030 --> 00:26:40,940
like, with a process can have more than one threads.

424
00:26:40,950 --> 00:26:42,340
And here is a process one. 

425
00:26:42,350 --> 00:26:43,620
Now have two threads thread, 

426
00:26:43,630 --> 00:26:46,240
the thread b as you can see, 

427
00:26:46,490 --> 00:26:49,650
the only thing which you are going to replicate is a stack. 

428
00:26:50,510 --> 00:26:51,160
In this figure, 

429
00:26:52,760 --> 00:26:54,630
the thread had its own stack, 

430
00:26:54,800 --> 00:26:58,790
but all threads in the same process, 

431
00:26:59,150 --> 00:27:02,510
they share all the rest of the address space, 

432
00:27:02,850 --> 00:27:03,960
which means a code, 

433
00:27:04,290 --> 00:27:05,750
global variables and the ship. 

434
00:27:09,970 --> 00:27:12,000
Remember, in our example,

435
00:27:12,330 --> 00:27:15,450
in which in our model, 

436
00:27:15,460 --> 00:27:20,410
we have one user thread per kernel thread. 

437
00:27:20,990 --> 00:27:22,820
Basically, in the kernel,

438
00:27:23,160 --> 00:27:25,150
we are going to have now two threads. 

439
00:27:25,500 --> 00:27:28,180
Once for each a user threads, 

440
00:27:29,070 --> 00:27:35,240
for processor ok and in addition like I mentioned, 

441
00:27:35,250 --> 00:27:41,440
the terminal itself can have as some threads on its own to do

442
00:27:41,450 --> 00:27:44,310
some activities in the background. 

443
00:27:48,200 --> 00:27:48,460
Okay? 

444
00:27:50,220 --> 00:27:52,420
So these are using totally by the kernel. 

445
00:27:52,430 --> 00:27:54,140
They don't corresponds to any users such. 

446
00:27:58,820 --> 00:27:59,240
Okay. 

447
00:27:59,940 --> 00:28:02,370
Now, this is any question here.

448
00:28:12,650 --> 00:28:13,960
The kernel thread, 

449
00:28:14,210 --> 00:28:16,560
the question is kernel thread an actual thread, 

450
00:28:16,570 --> 00:28:19,640
or just a block of data in the kernel that store the stake. 

451
00:28:21,980 --> 00:28:26,940
Fundamentally, every strategy is just a block of data.

452
00:28:28,260 --> 00:28:29,290
When it's not active, 

453
00:28:29,760 --> 00:28:30,870
a bunch of pointers. 

454
00:28:31,790 --> 00:28:33,010
It's a data structure. 

455
00:28:33,610 --> 00:28:35,660
A thread is a data structure they send, 

456
00:28:35,670 --> 00:28:37,420
and they have some data associated with it. 

457
00:28:38,190 --> 00:28:38,470
Right? 

458
00:28:40,480 --> 00:28:42,910
You have, in this particular case,

459
00:28:43,380 --> 00:28:53,520
you have that in this particular case, again,

460
00:28:53,530 --> 00:28:57,240
you have thread control block. 

461
00:28:57,700 --> 00:29:00,210
And that's what you have in the stack. 

462
00:29:05,340 --> 00:29:07,530
When you run the threads, though,

463
00:29:07,910 --> 00:29:11,150
okay, then when you run the thread, you activate the thread.

464
00:29:11,160 --> 00:29:13,920
And now you have some active part of the thread, 

465
00:29:14,440 --> 00:29:15,120
which is running, 

466
00:29:15,630 --> 00:29:18,720
executing the instructions on behalf of the thread, 

467
00:29:20,340 --> 00:29:21,650
pointed by the program counter. 

468
00:29:27,700 --> 00:29:36,420
So that's what why do we need us? 

469
00:29:36,430 --> 00:29:37,140
Another question. 

470
00:29:37,150 --> 00:29:38,180
It's a very good question. 

471
00:29:38,190 --> 00:29:40,220
Why do we need multiple kernel threads? 

472
00:29:40,750 --> 00:29:44,760
What is the benefit of having my money over having one? 

473
00:29:46,250 --> 00:29:47,250
It's, again,

474
00:29:48,330 --> 00:29:56,560
remember, i'm the kernel does not see user threads, right?

475
00:29:56,690 --> 00:29:59,000
The kernel only seek kernel threats. 

476
00:30:00,180 --> 00:30:01,880
If you cannot has only one, 

477
00:30:01,890 --> 00:30:04,910
there is only one kernel thread. 

478
00:30:04,920 --> 00:30:07,420
The kennel only will schedule that thread. 

479
00:30:09,850 --> 00:30:15,570
Now, if the user wants to have multiple user threads,

480
00:30:16,670 --> 00:30:17,470
the threads, 

481
00:30:17,480 --> 00:30:22,280
the only way for these threads to have threads running in turn, 

482
00:30:23,820 --> 00:30:26,500
while there is only 1 kind of thread is for the threat

483
00:30:26,510 --> 00:30:30,240
to voluntarily release acpu basically, 

484
00:30:30,250 --> 00:30:31,000
say, yield,

485
00:30:34,540 --> 00:30:40,550
then the yield will let another thread from the same processor. 

486
00:30:45,950 --> 00:30:47,220
In this particular case, 

487
00:30:47,230 --> 00:30:53,740
the application itself is responsible for allocating that time across threads. 

488
00:30:55,510 --> 00:30:58,770
If you map a user thread on a current thread and the operating system

489
00:30:58,780 --> 00:31:04,140
automatically make sure that allocates times superior times. 

490
00:31:04,460 --> 00:31:07,080
To each set, the application doesn't need to do anything.

491
00:31:16,260 --> 00:31:17,410
Where are the pc bs? 

492
00:31:17,420 --> 00:31:19,410
And pc bs started in kernel, 

493
00:31:19,420 --> 00:31:21,170
in the kernel datas, 

494
00:31:21,420 --> 00:31:22,930
in the kernel data segments? 

495
00:31:23,260 --> 00:31:23,390
Typically, 

496
00:31:24,380 --> 00:31:26,040
they are going on hip, 

497
00:31:27,270 --> 00:31:31,420
because they are allocated at new and new processes and new threats are created. 

498
00:31:38,650 --> 00:31:39,380
Let me see. 

499
00:31:42,570 --> 00:31:46,570
So now remember about the stack segment. 

500
00:31:46,580 --> 00:31:49,270
So you want to this and this actually has yelled. 

501
00:31:50,950 --> 00:31:56,910
And you remember that you have this kind of to procedures. 

502
00:31:56,920 --> 00:31:59,790
One procedure calls b and b is calling while. 

503
00:31:59,800 --> 00:32:01,310
And from time to time yield, 

504
00:32:02,060 --> 00:32:04,490
what happens in this case when you call yield? 

505
00:32:04,790 --> 00:32:06,120
Then you relieves you. 

506
00:32:06,430 --> 00:32:08,220
And again, when I say, yell,

507
00:32:08,230 --> 00:32:10,020
there are three implementation of yield, 

508
00:32:10,440 --> 00:32:12,030
one implementation of yield, 

509
00:32:12,270 --> 00:32:14,700
which is gives a control. 

510
00:32:16,170 --> 00:32:18,200
This is a yield here. 

511
00:32:21,250 --> 00:32:22,170
It's a cities call. 

512
00:32:22,700 --> 00:32:25,460
It's an operating system called kernel call. 

513
00:32:26,150 --> 00:32:29,620
But there has also yelled when you have only one single camera like we

514
00:32:29,630 --> 00:32:30,740
discussed in the past, 

515
00:32:31,060 --> 00:32:32,810
which is only at the application level. 

516
00:32:32,820 --> 00:32:34,490
It's a library in the application. 

517
00:32:34,920 --> 00:32:36,120
And when you do the yield, 

518
00:32:36,130 --> 00:32:38,550
you just jump to another function, 

519
00:32:38,560 --> 00:32:40,030
in the application level, 

520
00:32:40,040 --> 00:32:41,230
to another function, 

521
00:32:41,240 --> 00:32:46,580
in the same to another thread in the same process. 

522
00:32:47,280 --> 00:32:50,260
In this case, I yield is basically operate.

523
00:32:50,270 --> 00:32:51,760
It's a kernel. 

524
00:32:52,770 --> 00:32:53,760
It's accessible. 

525
00:32:54,430 --> 00:32:56,900
And when you call yelled, 

526
00:32:56,910 --> 00:33:00,450
you basically tell to the kernel to run another thread. 

527
00:33:00,970 --> 00:33:02,010
As I said, 

528
00:33:02,020 --> 00:33:03,060
in this case, 

529
00:33:03,770 --> 00:33:09,500
it's going to be b and sorry, 

530
00:33:09,550 --> 00:33:13,660
in the other side will continue to will run the same code. 

531
00:33:15,330 --> 00:33:17,360
This is that code will, again,

532
00:33:17,370 --> 00:33:24,160
run call a and a call bb starters to execute while. 

533
00:33:24,490 --> 00:33:26,240
And then it calls yield. 

534
00:33:26,540 --> 00:33:34,120
And then it relinquish the cpu then the caramel is going now

535
00:33:34,130 --> 00:33:37,930
to go and back to s right? 

536
00:33:38,940 --> 00:33:39,320
Okay. 

537
00:33:40,480 --> 00:33:41,070
Basically, 

538
00:33:41,080 --> 00:33:44,830
the important things to do to see here that when a yield happens, 

539
00:33:45,350 --> 00:33:47,810
you ask the kernel, 

540
00:33:47,820 --> 00:33:51,180
the red things start executed by the kernel. 

541
00:33:51,190 --> 00:33:53,380
The blue things are executed by the application, 

542
00:33:53,720 --> 00:33:55,070
but run your thread. 

543
00:33:55,080 --> 00:34:00,280
You basically ask the kernel to find a new thread and run it. 

544
00:34:03,620 --> 00:34:04,940
If you don't have yield, 

545
00:34:05,320 --> 00:34:07,230
then if you remember, 

546
00:34:07,240 --> 00:34:16,220
how do we make sure that we still share the cpu between different threads? 

547
00:34:16,810 --> 00:34:22,890
You have a timer and the timer after you devise a time in time slices. 

548
00:34:23,290 --> 00:34:26,370
And every at the end of every time slices, 

549
00:34:26,700 --> 00:34:28,470
you have this timer interrupt. 

550
00:34:29,380 --> 00:34:32,050
And this is stated by the operating system. 

551
00:34:32,060 --> 00:34:33,410
And as a result, 

552
00:34:33,650 --> 00:34:38,500
it's, again, is looking is suspend the current thread which is executing.

553
00:34:38,750 --> 00:34:43,300
And then it selects another thread to switch to a species to another thread. 

554
00:34:47,650 --> 00:34:48,760
So you run a new thread. 

555
00:34:51,560 --> 00:34:59,080
The same things happens when you are now call a sis aa system call, 

556
00:34:59,360 --> 00:35:03,630
say, for instance, to copy a file and io operation.

557
00:35:04,120 --> 00:35:06,270
And that is a cisco. 

558
00:35:06,280 --> 00:35:08,670
And if it's a waiting operation, 

559
00:35:08,680 --> 00:35:15,300
then the current thread is suspended and gain around a new thread

560
00:35:15,310 --> 00:35:16,180
is selected to run. 

561
00:35:17,310 --> 00:35:19,240
So taking a step back, 

562
00:35:19,250 --> 00:35:25,300
you've seen here a few years cases in which the thread voluntarily yield

563
00:35:25,310 --> 00:35:27,970
to the cpu another one, 

564
00:35:27,980 --> 00:35:33,720
when you have the time mark the the system timer, 

565
00:35:34,600 --> 00:35:37,880
forcing the suspension of the current thread. 

566
00:35:38,530 --> 00:35:40,320
Here, in the last case,

567
00:35:40,330 --> 00:35:43,200
you have a cisco which is awaiting cisco, 

568
00:35:43,210 --> 00:35:50,040
which leads to the we do the celebrity involves are called waiting, 

569
00:35:50,050 --> 00:35:51,440
so being suspended. 

570
00:35:51,860 --> 00:35:53,360
So in all these cases, 

571
00:35:53,950 --> 00:35:57,150
you need to look for a new thread to run. 

572
00:35:59,120 --> 00:35:59,490
Okay? 

573
00:36:01,440 --> 00:36:04,280
And this is what the scheduling is about, 

574
00:36:05,520 --> 00:36:05,830
right? 

575
00:36:06,390 --> 00:36:10,140
Which thread you are going to pick if there are multiple threats which

576
00:36:10,150 --> 00:36:12,100
are going to be able to run, 

577
00:36:12,110 --> 00:36:14,170
are ready to run, 

578
00:36:14,570 --> 00:36:15,830
which one you are going to pick? 

579
00:36:17,050 --> 00:36:17,480
That's it. 

580
00:36:18,740 --> 00:36:19,060
Okay. 

581
00:36:28,800 --> 00:36:29,260
Threats. 

582
00:36:30,060 --> 00:36:31,410
Scheduling is complicated. 

583
00:36:32,410 --> 00:36:38,070
And this is aaa comment from dennis rich chain. 

584
00:36:39,280 --> 00:36:44,070
One of the inventors of unique sense, see.

585
00:36:44,850 --> 00:36:52,300
And it's a comment which is for a scheduling, 

586
00:36:53,070 --> 00:36:55,050
some scheduling functionality. 

587
00:36:55,500 --> 00:36:58,420
The main.here, you are not expected to understand it,

588
00:36:58,430 --> 00:36:59,340
because it's too complicate. 

589
00:37:00,720 --> 00:37:01,580
Scheduling is complicated. 

590
00:37:01,590 --> 00:37:05,060
And the reason it's complicated because it has a time they mentioned. 

591
00:37:05,530 --> 00:37:05,880
Right? 

592
00:37:06,200 --> 00:37:07,950
You need to be careful about the time. 

593
00:37:08,530 --> 00:37:12,330
That's part of you need to integrating the scheduling, 

594
00:37:16,500 --> 00:37:18,530
but a new thread. 

595
00:37:19,990 --> 00:37:21,350
And it's about, 

596
00:37:22,300 --> 00:37:25,830
you look at the threads which are ready. 

597
00:37:27,840 --> 00:37:32,830
You select the next round to schedule and run the next lap around this. 

598
00:37:34,270 --> 00:37:35,210
Next they select this thread. 

599
00:37:37,610 --> 00:37:38,210
So that's it. 

600
00:37:42,230 --> 00:37:43,420
The rest of the lecture, 

601
00:37:43,430 --> 00:37:46,640
we are only going to focus on scheduling. 

602
00:37:47,470 --> 00:37:47,970
Again, 

603
00:37:47,980 --> 00:37:57,480
the scheduling is selecting which thread to schedule out of all currently threads, 

604
00:37:57,490 --> 00:37:58,440
which are ready to run. 

605
00:38:02,150 --> 00:38:02,520
Now, 

606
00:38:07,100 --> 00:38:14,940
this is basically a diagram About the flow in the scheduler, 

607
00:38:15,560 --> 00:38:16,960
flow diagram of the scheduler. 

608
00:38:18,070 --> 00:38:22,220
This is acpu we are running to the side of the cpu and it's a radical. 

609
00:38:22,930 --> 00:38:27,670
The scheduler is going to pick one thread from the radical graph. 

610
00:38:29,790 --> 00:38:31,380
While the thread is running, 

611
00:38:32,250 --> 00:38:38,520
the thread can go into have io request and it can wait for the io request

612
00:38:38,530 --> 00:38:39,120
to complete. 

613
00:38:41,900 --> 00:38:44,460
It can wait for the time slice to expire. 

614
00:38:44,470 --> 00:38:46,820
This is going for the timer to kick in, 

615
00:38:47,620 --> 00:38:49,090
say, after 10 million seconds,

616
00:38:50,180 --> 00:38:51,780
you can wait, for instance,

617
00:38:52,470 --> 00:38:54,380
if you for a chilled child, 

618
00:38:55,040 --> 00:38:56,850
you wait for that child to finish, 

619
00:38:57,500 --> 00:39:00,670
to execute or to execute. 

620
00:39:02,240 --> 00:39:05,930
And you can also be interrupted by an interrupt. 

621
00:39:09,630 --> 00:39:10,500
And then, 

622
00:39:11,380 --> 00:39:13,290
once you are waiting, it's over.

623
00:39:13,300 --> 00:39:15,890
You are going to be put back in the video. 

624
00:39:20,640 --> 00:39:24,510
Again, scheduling is about deciding we spread from the radio to schedule.

625
00:39:28,500 --> 00:39:31,380
And when you say automatically, 

626
00:39:31,390 --> 00:39:34,180
you say to the scheduling, 

627
00:39:34,820 --> 00:39:38,040
it's about which task to run. 

628
00:39:38,990 --> 00:39:40,420
If I have more than one task, 

629
00:39:40,430 --> 00:39:42,020
then I automatically have a queue. 

630
00:39:44,350 --> 00:39:49,610
So queues are integrate our fundamental part of the scheduling. 

631
00:39:50,210 --> 00:39:52,260
You are waiting in a queue to be scheduled. 

632
00:39:55,910 --> 00:40:00,700
Cpo scheduling has been a big area of research since what? 

633
00:40:01,460 --> 00:40:03,530
50 years for 50 years. 

634
00:40:05,840 --> 00:40:15,300
And there are many implicit assumption and many kind of scheduling problems. 

635
00:40:17,110 --> 00:40:20,700
Like you can have one program per users. 

636
00:40:20,710 --> 00:40:24,140
You can have one separate program or multiple threat programs. 

637
00:40:25,120 --> 00:40:26,730
Programs are independent. 

638
00:40:27,200 --> 00:40:27,560
Right? 

639
00:40:28,460 --> 00:40:32,750
And so in many, and this,

640
00:40:32,760 --> 00:40:35,740
you make these assumptions to simplify the problem, 

641
00:40:36,150 --> 00:40:37,430
to make it more productive, 

642
00:40:38,090 --> 00:40:38,480
right? 

643
00:40:42,080 --> 00:40:43,440
And therefore, to solve it.

644
00:40:45,230 --> 00:40:47,920
But this problem is much more complicated. 

645
00:40:48,230 --> 00:40:52,640
That's why there are so much research in the 70s, 

646
00:40:56,640 --> 00:40:58,480
because there are different concepts. 

647
00:40:58,490 --> 00:41:07,150
So when you decide to run a new thread to pick a new threat to that, 

648
00:41:08,450 --> 00:41:09,360
when you decide that, 

649
00:41:10,020 --> 00:41:14,100
we said you are going to pick according to what the one is ahead of the cure. 

650
00:41:14,450 --> 00:41:15,180
Is that fair? 

651
00:41:15,860 --> 00:41:16,890
What does the fairness mean? 

652
00:41:17,580 --> 00:41:17,910
Right. 

653
00:41:20,400 --> 00:41:27,600
I if you and for different programs, 

654
00:41:27,610 --> 00:41:31,200
it's like for different user may be fairly that I get the same amount

655
00:41:31,210 --> 00:41:32,880
of cpu like you get. 

656
00:41:33,760 --> 00:41:34,310
Okay. 

657
00:41:34,570 --> 00:41:35,840
But what about the applications? 

658
00:41:36,050 --> 00:41:40,480
Because the applications that are application which are io heavy, right?

659
00:41:40,490 --> 00:41:41,240
Like an elite, 

660
00:41:42,130 --> 00:41:45,200
spend very little cpu right? 

661
00:41:45,210 --> 00:41:50,690
Mostly, it's waiting for you to type in new characters.

662
00:41:52,280 --> 00:41:53,960
Or you can have like compilers. 

663
00:41:54,260 --> 00:41:56,590
If you do a run a computer compilation job, 

664
00:41:56,830 --> 00:41:59,450
computers, and that's very cpu bounded.

665
00:41:59,670 --> 00:42:00,050
Right? 

666
00:42:00,420 --> 00:42:04,150
So what does mean for to be fair between these 2 kinds of jobs? 

667
00:42:04,760 --> 00:42:04,960
Right? 

668
00:42:04,970 --> 00:42:05,040
No. 

669
00:42:06,160 --> 00:42:09,210
Matter what is your answer there? 

670
00:42:09,880 --> 00:42:11,110
At the end of the day, 

671
00:42:11,650 --> 00:42:15,550
you need to allocate the cpu if you have one cpu, 

672
00:42:17,000 --> 00:42:18,270
but we have fewer cp us. 

673
00:42:18,280 --> 00:42:22,530
And so that's we need to allow to slice the cpo and allocate

674
00:42:22,540 --> 00:42:23,850
different time slices, 

675
00:42:24,570 --> 00:42:26,980
two different threads. 

676
00:42:34,780 --> 00:42:35,300
Now, 

677
00:42:39,860 --> 00:42:43,540
there is another implicit assumption which is done by today's, 

678
00:42:43,590 --> 00:42:47,160
but many of the today's schedulers operating system schedulers. 

679
00:42:49,500 --> 00:42:57,300
That assumption is that many of the applications are reversed the applications. 

680
00:42:58,880 --> 00:43:03,380
This means that they use a cpu for a little bit, 

681
00:43:04,610 --> 00:43:05,420
and then wait, 

682
00:43:06,790 --> 00:43:08,870
the news against the cpo for a little bit then, right?

683
00:43:14,520 --> 00:43:18,370
And like application, 

684
00:43:18,380 --> 00:43:21,690
like user facing applications, 

685
00:43:22,480 --> 00:43:27,590
like editors, like anything you interact with your computer.

686
00:43:29,230 --> 00:43:29,720
Web browsers. 

687
00:43:29,730 --> 00:43:31,370
Any other thing like that? 

688
00:43:32,480 --> 00:43:33,590
Fit in this category? 

689
00:43:33,860 --> 00:43:34,040
Right? 

690
00:43:34,050 --> 00:43:36,970
Because most of the time that program waits for your input. 

691
00:43:36,980 --> 00:43:45,500
And while it's wise, it doesn't need to use acpu again,

692
00:43:45,510 --> 00:43:50,280
this program satellite between cpo and io like we discussed. 

693
00:43:51,280 --> 00:43:58,190
And this means that you want to prioritize, for short, worse, right?

694
00:43:58,470 --> 00:44:00,700
Because you want to be responsive the program. 

695
00:44:02,830 --> 00:44:06,020
This is one way to think about the scheduling. 

696
00:44:06,030 --> 00:44:07,940
If you think about scheduling discipline, 

697
00:44:09,480 --> 00:44:11,510
I want to prioritize a short burst, 

698
00:44:12,200 --> 00:44:12,360
right? 

699
00:44:12,370 --> 00:44:13,680
Because the studies are facing, 

700
00:44:14,090 --> 00:44:15,870
they are going to be interactive. 

701
00:44:16,110 --> 00:44:17,900
I provide good experience to the user. 

702
00:44:18,130 --> 00:44:19,900
And if something is longer burst, 

703
00:44:20,150 --> 00:44:21,420
it takes for a while. 

704
00:44:21,650 --> 00:44:25,620
Like like a compilation job, 

705
00:44:25,630 --> 00:44:26,920
it can be lower product. 

706
00:44:28,080 --> 00:44:28,300
Right? 

707
00:44:28,310 --> 00:44:29,420
So keep in mind that one. 

708
00:44:30,890 --> 00:44:31,280
Now, 

709
00:44:31,990 --> 00:44:35,470
we move on what are the other possible policies? 

710
00:44:35,960 --> 00:44:38,000
What are the properties young for a scheduler? 

711
00:44:41,080 --> 00:44:43,290
There are many of these properties. 

712
00:44:43,530 --> 00:44:46,180
Again, that's the reason or the many of these policies.

713
00:44:47,050 --> 00:44:48,430
And there's a reason for it. 

714
00:44:48,440 --> 00:44:53,490
You have a a lot of research in scheduling for decades. 

715
00:44:55,520 --> 00:44:55,950
So on. 

716
00:44:55,960 --> 00:44:57,710
It's obviously minimize response time. 

717
00:44:58,140 --> 00:44:58,530
Right? 

718
00:44:58,830 --> 00:45:00,640
You want to finish the task, 

719
00:45:01,270 --> 00:45:03,250
the job as fast as possible. 

720
00:45:06,880 --> 00:45:07,340
Fair enough. 

721
00:45:09,630 --> 00:45:11,550
Another one is maximize the soup, 

722
00:45:12,980 --> 00:45:13,290
right? 

723
00:45:13,690 --> 00:45:16,780
The soup with it's about the number of queries per second, 

724
00:45:18,170 --> 00:45:18,520
right? 

725
00:45:18,830 --> 00:45:20,390
Number of transactions per second. 

726
00:45:21,760 --> 00:45:24,470
Here, this is more complicated because there are two parts.

727
00:45:25,460 --> 00:45:28,100
It's aio part and the cpo part. 

728
00:45:31,970 --> 00:45:34,040
It's also, if you, in general,

729
00:45:34,650 --> 00:45:40,770
and it's also one way. 

730
00:45:40,780 --> 00:45:44,500
Typically, you maximize the throughput is batching,

731
00:45:45,220 --> 00:45:48,090
which her two is a elapse time. 

732
00:45:49,160 --> 00:45:51,590
For instance, let me give you an example.

733
00:45:53,410 --> 00:46:01,560
If I want to optimize each the response times the latency of each rip

734
00:46:01,570 --> 00:46:02,160
to the disk, 

735
00:46:03,980 --> 00:46:05,290
it's one power problem. 

736
00:46:06,200 --> 00:46:13,130
If I want to maximize the number of reads to the disk is another problem. 

737
00:46:14,190 --> 00:46:16,060
In the first case, for each read,

738
00:46:16,070 --> 00:46:19,860
i'm going to execute separately and trying to execute as fast as possible. 

739
00:46:20,440 --> 00:46:23,520
In the second case, instead of executing one read, at a time,

740
00:46:23,530 --> 00:46:29,530
I am going to batch the reads and send them to the disk and the risk, 

741
00:46:29,540 --> 00:46:39,490
we can do a better job of serving these sleeves in a more intelligent way. 

742
00:46:40,480 --> 00:46:45,760
So it's going to increase a throughput to serve more risk per second. 

743
00:46:47,430 --> 00:46:49,850
But as the expense of the latency, 

744
00:46:49,860 --> 00:46:55,920
because now I need to wait for the batch to complete in order to get

745
00:46:55,930 --> 00:46:57,000
the result for my reach. 

746
00:46:59,800 --> 00:47:01,500
So typically, this is one,

747
00:47:02,260 --> 00:47:06,490
one trade off between the latency and the support. 

748
00:47:09,030 --> 00:47:11,260
The other thing it's about, 

749
00:47:11,910 --> 00:47:13,220
let me give you another example, 

750
00:47:13,230 --> 00:47:14,340
just thought about it. 

751
00:47:15,360 --> 00:47:17,550
If you want you go to grocery, 

752
00:47:17,560 --> 00:47:23,150
I know that many of you you are now you are the buying online, 

753
00:47:25,630 --> 00:47:28,610
but think about when you go to grocery. 

754
00:47:29,280 --> 00:47:30,560
If I need something right now, 

755
00:47:30,570 --> 00:47:35,400
I need milk in order to reduce the latency by how when i'm going to get

756
00:47:35,410 --> 00:47:35,880
the milk. 

757
00:47:36,850 --> 00:47:37,280
Okay? 

758
00:47:37,700 --> 00:47:39,990
I'm going to go right away and get milk, 

759
00:47:41,600 --> 00:47:42,720
but typically don't do that. 

760
00:47:43,510 --> 00:47:43,770
Right? 

761
00:47:43,780 --> 00:47:46,170
And I I get the milk saying half an hour. 

762
00:47:47,150 --> 00:47:48,670
But typically we don't do that. 

763
00:47:48,680 --> 00:47:50,770
What we do is basically we batch. 

764
00:47:51,070 --> 00:47:52,690
And when we go to grocery, 

765
00:47:52,700 --> 00:47:53,890
we buy many things. 

766
00:47:54,680 --> 00:47:55,110
Right? 

767
00:47:55,670 --> 00:47:57,740
So like ambassador, instead of buying me today,

768
00:47:57,750 --> 00:47:58,860
i'm going to talk tomorrow. 

769
00:47:58,870 --> 00:48:00,420
I'm going to go to grocery. 

770
00:48:01,270 --> 00:48:05,260
I am going to wait until tomorrow because I have a lot of other things to do. 

771
00:48:05,710 --> 00:48:07,600
And then I get them by tomorrow. 

772
00:48:07,610 --> 00:48:08,840
So it's lower latency. 

773
00:48:09,470 --> 00:48:11,060
But in terms of the throughput, 

774
00:48:11,310 --> 00:48:16,140
i'm going to get a a lot of more things. 

775
00:48:18,060 --> 00:48:19,200
At the same time, 

776
00:48:20,350 --> 00:48:21,620
the circuit will be higher, 

777
00:48:21,630 --> 00:48:22,860
but the latency will be lower. 

778
00:48:26,980 --> 00:48:30,040
And another thing it's about policy could be failed, 

779
00:48:30,050 --> 00:48:32,120
like we discuss in the past is fairness. 

780
00:48:34,440 --> 00:48:37,920
You want to share the cpu in some equity equitable way. 

781
00:48:38,500 --> 00:48:38,920
Okay. 

782
00:48:42,020 --> 00:48:42,370
Good. 

783
00:48:42,380 --> 00:48:47,210
So now next we are going to go through some first to go

784
00:48:47,220 --> 00:48:51,090
through some scheduling policies. 

785
00:48:51,100 --> 00:48:54,450
And we are going to start from simple to more complex. 

786
00:48:55,400 --> 00:48:56,550
For each of them, 

787
00:48:56,560 --> 00:49:02,800
we are going to look at what properties they have and one or what we

788
00:49:02,810 --> 00:49:03,700
are going to, 

789
00:49:03,710 --> 00:49:04,000
again, 

790
00:49:04,010 --> 00:49:05,800
compare them based on some metric. 

791
00:49:06,620 --> 00:49:09,670
And typically, the metric we are going to compare them.

792
00:49:09,920 --> 00:49:12,940
It's a response time, how long it takes to finish things.

793
00:49:13,530 --> 00:49:13,900
Right? 

794
00:49:13,910 --> 00:49:16,050
This is what we are going to do now. 

795
00:49:17,270 --> 00:49:21,890
One of the first and the simplest scheduling discipline is first curved, 

796
00:49:21,900 --> 00:49:23,570
first come, first served,

797
00:49:24,170 --> 00:49:25,960
or first in, first out.

798
00:49:26,870 --> 00:49:27,240
Right? 

799
00:49:29,340 --> 00:49:31,270
And a this is like, 

800
00:49:31,780 --> 00:49:33,380
you go to grocery everywhere. 

801
00:49:33,390 --> 00:49:36,080
This is exactly what it is, right?

802
00:49:36,550 --> 00:49:40,620
People are served in the order in which they arrived to the queue. 

803
00:49:44,690 --> 00:49:45,760
And now, 

804
00:49:47,080 --> 00:49:53,390
let's assume that now we have three processes. 

805
00:49:56,150 --> 00:49:59,390
Let's assume that we first come first serve. 

806
00:49:59,710 --> 00:50:08,040
Each process runs to completion is a reminding idea of this lecture. 

807
00:50:08,050 --> 00:50:11,800
I am a use processes and jobs interchangeable, 

808
00:50:12,320 --> 00:50:14,190
but it should be clear from context. 

809
00:50:18,160 --> 00:50:19,770
So now p one, 

810
00:50:20,590 --> 00:50:22,510
say it takes 24 time units. 

811
00:50:22,880 --> 00:50:24,920
Let's say 24 seconds. 

812
00:50:25,810 --> 00:50:27,400
B two takes 3 seconds, 

813
00:50:27,940 --> 00:50:31,410
and basically takes 3 seconds. 

814
00:50:31,420 --> 00:50:31,610
Now. 

815
00:50:32,710 --> 00:50:36,920
Suppose the processes the expression is arriving in the queue in the order

816
00:50:36,930 --> 00:50:37,670
of p one, 

817
00:50:37,680 --> 00:50:38,670
p two, p three.

818
00:50:39,560 --> 00:50:43,020
With the first come for self scheduling discipline, 

819
00:50:43,680 --> 00:50:49,720
we are going to serve to run the processing the same order for asp one, 

820
00:50:50,170 --> 00:50:52,150
then p two, then p three.

821
00:50:53,690 --> 00:50:57,910
Now let's see when each of these processes finishes. 

822
00:50:58,790 --> 00:50:59,250
Right? 

823
00:51:00,720 --> 00:51:01,630
What is the waiting time? 

824
00:51:01,640 --> 00:51:04,830
The waiting time is how long you wait before being scheduled. 

825
00:51:06,700 --> 00:51:09,290
So, and when you complete,

826
00:51:09,300 --> 00:51:14,970
so the first process doesn't play it any time. 

827
00:51:14,980 --> 00:51:16,570
So starts immediately. 

828
00:51:16,960 --> 00:51:21,090
The p two was 24 seconds for the p one to finish, 

829
00:51:22,110 --> 00:51:25,910
and p three ways for 27 seconds for p one and peter to finish. 

830
00:51:26,710 --> 00:51:27,020
Right? 

831
00:51:28,680 --> 00:51:35,090
And the average waiting time is 0+24+27/370. 

832
00:51:36,470 --> 00:51:38,340
Now, if you look at completion down,

833
00:51:38,350 --> 00:51:42,020
so the finishing time p one takes 24 seconds to finish b two. 

834
00:51:43,430 --> 00:51:48,140
27 seconds from the time was submitted and p three thirty seconds. 

835
00:51:48,820 --> 00:51:50,290
Again, in this particular case,

836
00:51:51,620 --> 00:51:57,980
we assume that all processes arrive basically the same time, 

837
00:51:58,430 --> 00:52:01,930
but that in certain in the queue, 

838
00:52:01,940 --> 00:52:04,010
in the order p one, p two, and p three,

839
00:52:07,630 --> 00:52:08,230
let's say, 

840
00:52:10,600 --> 00:52:13,960
cash, it's actually a very good question.

841
00:52:14,450 --> 00:52:17,530
Is there any way for the kernel to estimate, 

842
00:52:17,860 --> 00:52:22,590
know the first time of for a job without actually running it? 

843
00:52:22,850 --> 00:52:23,900
That's excellent question. 

844
00:52:26,230 --> 00:52:26,710
I think, 

845
00:52:27,600 --> 00:52:28,610
in general, now,

846
00:52:28,620 --> 00:52:31,890
and you'll see this is one of the problem which is scheduling discipline, 

847
00:52:32,620 --> 00:52:42,400
one of the many and the but you can, in some cases,

848
00:52:42,410 --> 00:52:44,200
you can know it, for instance,

849
00:52:44,210 --> 00:52:45,700
for its from historical data. 

850
00:52:49,110 --> 00:52:50,700
In some cases, it is possible.

851
00:52:52,320 --> 00:52:53,560
But in this case, again,

852
00:52:54,040 --> 00:52:56,880
this killer doesn't even care about the running time of a job, 

853
00:52:58,630 --> 00:52:59,460
a of a process. 

854
00:53:00,130 --> 00:53:01,360
It doesn't care, right?

855
00:53:01,370 --> 00:53:02,640
It just executes them in the order. 

856
00:53:02,650 --> 00:53:03,840
That means they arrive with lecture. 

857
00:53:04,200 --> 00:53:07,470
But we are going to touch to go back and touch this very question

858
00:53:07,480 --> 00:53:10,680
later in the lecture. 

859
00:53:11,180 --> 00:53:11,510
Good. 

860
00:53:12,670 --> 00:53:14,140
Now, if you look at this one,

861
00:53:15,930 --> 00:53:17,070
i'm just curious, 

862
00:53:19,580 --> 00:53:26,870
can you think about a better way to schedule

863
00:53:29,630 --> 00:53:32,850
these processes to have lower completion time? 

864
00:53:42,050 --> 00:53:47,300
Yeah, run p one after peter and after the p three to still a very good.

865
00:53:48,040 --> 00:53:48,600
That's very good. 

866
00:53:49,030 --> 00:53:49,730
Okay. 

867
00:53:50,990 --> 00:53:52,220
You see, this is a problem.

868
00:53:52,230 --> 00:53:58,620
It's exactly the problem with this kind of scheduler is very simple, 

869
00:53:58,940 --> 00:53:59,700
very simple. 

870
00:54:00,450 --> 00:54:00,820
Right? 

871
00:54:01,700 --> 00:54:05,880
But the problem is that if you have some short processes, 

872
00:54:06,780 --> 00:54:11,210
they end, they can get stuck behind a long process.

873
00:54:12,710 --> 00:54:15,030
This is called convoy yet effort. 

874
00:54:15,730 --> 00:54:16,150
Right? 

875
00:54:16,520 --> 00:54:18,410
Think about you go to the grocery, 

876
00:54:19,130 --> 00:54:28,910
and you are going to be stuck behind someone which has100 items is a couch. 

877
00:54:29,730 --> 00:54:30,180
Right? 

878
00:54:32,010 --> 00:54:33,140
You don't want that, right?

879
00:54:34,630 --> 00:54:38,560
You have only three or four items to do to buy. 

880
00:54:39,280 --> 00:54:41,240
How do they solve the grocery this problem? 

881
00:54:41,250 --> 00:54:43,200
How they try to alleviate this problem? 

882
00:54:50,540 --> 00:54:51,380
Express lines. 

883
00:54:51,750 --> 00:54:52,910
Yes, in the express line,

884
00:54:52,920 --> 00:54:57,680
there is a cap on the size of the job of the size of the process, right?

885
00:54:57,930 --> 00:55:00,100
Because the capital like, 

886
00:55:00,890 --> 00:55:03,870
you can only have 15 items, right?

887
00:55:03,880 --> 00:55:06,180
No more than 15 items, okay?

888
00:55:06,480 --> 00:55:08,870
To cap basically how long it takes the process. 

889
00:55:10,550 --> 00:55:11,120
Indeed, 

890
00:55:11,650 --> 00:55:13,520
a it should be a much better answer. 

891
00:55:14,060 --> 00:55:16,000
Now, the average waiting time is three.

892
00:55:16,010 --> 00:55:19,100
Instead of I seen 24 and 13, I believe,

893
00:55:19,110 --> 00:55:21,410
instead of 27, let me.

894
00:55:23,160 --> 00:55:27,890
So it's 3 and 10 instead of 17 and 2013 instead of 27. 

895
00:55:28,440 --> 00:55:28,850
Okay. 

896
00:55:31,560 --> 00:55:32,040
Good. 

897
00:55:33,910 --> 00:55:36,020
We learned that we know. 

898
00:55:37,160 --> 00:55:39,660
Now here is another one. 

899
00:55:42,330 --> 00:55:46,390
It's implemented by many schedulers, 

900
00:55:46,400 --> 00:55:48,770
this policy around robin. 

901
00:55:49,780 --> 00:55:50,060
Right? 

902
00:55:51,060 --> 00:55:52,840
So around robin, 

903
00:55:53,420 --> 00:55:55,940
for come first serve, depends on this.

904
00:55:55,950 --> 00:55:57,420
When the order is submitted. 

905
00:55:58,200 --> 00:56:00,680
The round, robin uses this preemption,

906
00:56:01,030 --> 00:56:03,270
which exactly we discussed as many times so far. 

907
00:56:03,880 --> 00:56:08,020
So basically, here, you do not wait for a process to finish execution.

908
00:56:08,600 --> 00:56:09,750
Instead of preempted. 

909
00:56:10,010 --> 00:56:12,230
After you, let it run, say,

910
00:56:12,240 --> 00:56:14,350
for until it blocks, 

911
00:56:14,360 --> 00:56:17,150
because wait for something or until it runs for, say,

912
00:56:17,410 --> 00:56:19,720
10 millisecond and then preempted. 

913
00:56:20,120 --> 00:56:20,990
You suspend it. 

914
00:56:21,540 --> 00:56:25,080
And you run another process, right?

915
00:56:25,950 --> 00:56:27,050
So this is a round robin. 

916
00:56:27,540 --> 00:56:27,840
Right? 

917
00:56:29,020 --> 00:56:34,270
And the reason is called round robin is because You take it 1 by 1, 

918
00:56:34,280 --> 00:56:35,750
you have ten processes. 

919
00:56:36,380 --> 00:56:41,490
Now iii run for ten ten10 millisecond one process. 

920
00:56:42,450 --> 00:56:47,040
Ii run process two for 10 millisecond process three for 20 seconds and so forth. 

921
00:56:47,050 --> 00:56:48,160
After 100 millisecond, 

922
00:56:48,170 --> 00:56:49,520
I am back to running processor. 

923
00:56:51,960 --> 00:56:53,030
In this case, 

924
00:56:53,040 --> 00:56:55,910
each process get one over if there are n processes. 

925
00:56:56,470 --> 00:56:59,530
Each process gets n one over n of the cpu time. 

926
00:57:00,130 --> 00:57:05,750
And if a time quanta is q then each time gets for q time contract. 

927
00:57:06,080 --> 00:57:13,830
And each process has to write how long n minus one over q if you have ten processes, 

928
00:57:13,840 --> 00:57:16,670
and each process takes the time quantize ten, 

929
00:57:17,140 --> 00:57:18,840
nearly 10 million seconds, 

930
00:57:19,380 --> 00:57:22,660
it takes for an entire round is take 100 million seconds. 

931
00:57:22,910 --> 00:57:26,580
But for one processor for it transferred in the second and history

932
00:57:26,590 --> 00:57:28,180
for another 90 million seconds. 

933
00:57:28,480 --> 00:57:30,450
To for his turns come, 

934
00:57:31,160 --> 00:57:32,430
it's n minus one. 

935
00:57:32,440 --> 00:57:37,140
In that case, n minus one nine times ten is nineteen eighty second.

936
00:57:42,550 --> 00:57:42,780
Here, 

937
00:57:43,310 --> 00:57:47,380
it's very interesting to look at and considering like what happens

938
00:57:47,390 --> 00:57:48,590
when the queue is very large. 

939
00:57:48,970 --> 00:57:49,430
Right? 

940
00:57:51,920 --> 00:57:57,190
If the queue is larger than the largest running time of a process, 

941
00:57:58,620 --> 00:58:04,490
then it's provides identical results, 

942
00:58:04,500 --> 00:58:05,650
like first come first serve. 

943
00:58:08,650 --> 00:58:10,390
If q is very small, 

944
00:58:11,170 --> 00:58:13,730
you have a lot of interleaving between the processes. 

945
00:58:15,550 --> 00:58:16,060
Okay? 

946
00:58:17,440 --> 00:58:19,110
Now, there is a trade off here.

947
00:58:19,120 --> 00:58:21,270
Ideally, you want to be as small as possible.

948
00:58:21,890 --> 00:58:24,240
However, remember about contact switching,

949
00:58:25,240 --> 00:58:26,960
there is an overhead of the complex switching. 

950
00:58:27,640 --> 00:58:32,340
If the quanta is too small or time slice is too small, 

951
00:58:33,260 --> 00:58:36,970
then you can spend more time in switching between the context

952
00:58:36,980 --> 00:58:41,240
than actually running the process. 

953
00:58:41,250 --> 00:58:41,470
Okay? 

954
00:58:51,770 --> 00:58:52,210
Sounds good. 

955
00:58:59,620 --> 00:59:07,220
So is that question here whether we can make the chat default instead of having the

956
00:59:08,890 --> 00:59:14,280
using the q and a i'm going to try to answer and I decided trying the past

957
00:59:14,290 --> 00:59:16,430
to answer both from q and a and the

958
00:59:16,440 --> 00:59:16,910
chat. 

959
00:59:17,490 --> 00:59:20,520
But if people prefer to use chat, 

960
00:59:20,530 --> 00:59:29,710
I am finding that here is an example time quanta, 

961
00:59:29,720 --> 00:59:30,950
24 hour example. 

962
00:59:31,510 --> 00:59:31,740
Right? 

963
00:59:31,750 --> 00:59:32,540
So what will happen? 

964
00:59:34,200 --> 00:59:35,950
You first run p one, 

965
00:59:35,960 --> 00:59:39,310
remember now and look at here. 

966
00:59:39,320 --> 00:59:40,430
We take another example. 

967
00:59:40,440 --> 00:59:43,160
I you have four processes, 

968
00:59:43,770 --> 00:59:45,410
p one, p two, p three,

969
00:59:45,420 --> 00:59:49,660
before which takes 50 38, 68,

970
00:59:49,670 --> 00:59:51,580
and 24 seconds, respectively.

971
00:59:54,330 --> 00:59:55,960
Now save the time quantize trend. 

972
00:59:56,560 --> 00:59:58,750
This is the order they arrive at the queue, 

973
00:59:59,640 --> 01:00:01,110
b one, b two, b three, before.

974
01:00:02,550 --> 01:00:03,340
Let's see what happens. 

975
01:00:04,670 --> 01:00:06,930
First, we start with the first process, b one.

976
01:00:09,050 --> 01:00:12,080
It runs for 20 seconds, 20 seconds.

977
01:00:12,900 --> 01:00:14,970
And then after 20 seconds, we interrupted,

978
01:00:15,720 --> 01:00:16,390
we preempt it. 

979
01:00:18,440 --> 01:00:19,750
We start running p two. 

980
01:00:21,430 --> 01:00:22,960
P two is only 8 seconds, 

981
01:00:22,970 --> 01:00:25,560
so it's less than the time quanta soft 8 seconds finishes. 

982
01:00:26,820 --> 01:00:27,610
We are done. 

983
01:00:27,620 --> 01:00:30,010
And now we are moving to the next energy speech. 

984
01:00:30,020 --> 01:00:30,290
Three. 

985
01:00:31,940 --> 01:00:34,450
B three has 60, it takes 68 seconds.

986
01:00:35,380 --> 01:00:35,780
Therefore, 

987
01:00:35,790 --> 01:00:39,720
it transferred 20 seconds after which is preempted after iran

988
01:00:39,730 --> 01:00:41,400
before for 20 seconds, 

989
01:00:41,410 --> 01:00:42,560
after which is preempted. 

990
01:00:43,380 --> 01:00:45,960
Now you come back for p one and p one. 

991
01:00:45,970 --> 01:00:48,440
You're the only one take 20 seconds out of p one. 

992
01:00:48,450 --> 01:00:50,200
So you have another 73 seats, 

993
01:00:50,470 --> 01:00:52,100
33 seconds to run. 

994
01:00:52,480 --> 01:00:54,680
So you run 20 seconds for 20 seconds. 

995
01:00:55,580 --> 01:00:56,820
And you preempt. 

996
01:00:57,460 --> 01:00:58,980
Now b two is done. 

997
01:00:59,790 --> 01:01:01,580
No need to run it. 

998
01:01:02,180 --> 01:01:03,640
And you are b to b three. 

999
01:01:04,910 --> 01:01:06,630
From p three, we already run it.

1000
01:01:07,160 --> 01:01:09,510
We already run p three for 20 seconds. 

1001
01:01:10,150 --> 01:01:11,810
Now we have another 20 seconds. 

1002
01:01:11,820 --> 01:01:18,100
We take another 20 seconds for to run for peace three after each pre preempted. 

1003
01:01:19,690 --> 01:01:22,320
And then things continue like this. 

1004
01:01:22,810 --> 01:01:25,930
You can easily follow up on it. 

1005
01:01:26,580 --> 01:01:26,980
Okay? 

1006
01:01:28,530 --> 01:01:30,680
The one interesting case is that at the end, 

1007
01:01:30,690 --> 01:01:32,400
you have only pc remaining to run, 

1008
01:01:32,410 --> 01:01:33,920
so you are going to run. 

1009
01:01:33,930 --> 01:01:36,520
You have only one processing the queue. 

1010
01:01:36,810 --> 01:01:38,920
You are going to run the process over and over again. 

1011
01:01:42,140 --> 01:01:43,370
What is the waiting time here? 

1012
01:01:44,640 --> 01:01:47,470
It's more complicated to look at the waiting time, 

1013
01:01:49,310 --> 01:01:50,630
because for ap one, 

1014
01:01:51,300 --> 01:01:52,490
you have what is the waiting time? 

1015
01:01:52,500 --> 01:01:57,540
You run p 13 times here at time zero, 

1016
01:01:57,550 --> 01:01:58,740
at time 68? 

1017
01:02:00,330 --> 01:02:01,460
At a time 1:12, 

1018
01:02:02,660 --> 01:02:04,410
the waiting time initially is zero. 

1019
01:02:06,520 --> 01:02:08,390
The second time on your run at time 68, 

1020
01:02:08,400 --> 01:02:10,710
the waiting time or twelve sixty eight-20, 

1021
01:02:10,720 --> 01:02:13,510
because it finishes previously, p one finished,

1022
01:02:14,160 --> 01:02:15,680
finishes a cushion at time 20. 

1023
01:02:16,840 --> 01:02:17,880
And for a pew on, 

1024
01:02:18,590 --> 01:02:20,750
when the last time when pew on the grounds, 

1025
01:02:21,960 --> 01:02:23,840
it started at 1:25, 

1026
01:02:25,440 --> 01:02:28,690
but the previously finished at time 88. 

1027
01:02:28,700 --> 01:02:31,690
So it's 125 minus, sorry, 112.

1028
01:02:31,700 --> 01:02:32,530
Sorry, i'm sorry.

1029
01:02:32,980 --> 01:02:34,580
P one starts at 112, 

1030
01:02:35,090 --> 01:02:37,140
and previously finishes at time 88. 

1031
01:02:37,150 --> 01:02:38,980
So it's 112-88. 

1032
01:02:39,430 --> 01:02:44,790
The total waiting time is 72, right?

1033
01:02:47,500 --> 01:02:49,750
P two at the time 20. 

1034
01:02:50,050 --> 01:02:58,010
So it says there is only one time is 20 and so forth for the other processes. 

1035
01:03:00,090 --> 01:03:01,880
What is the average right waiting time? 

1036
01:03:02,930 --> 01:03:06,470
You are all the waiting times of all processes, 

1037
01:03:06,480 --> 01:03:07,870
and you divide by four. 

1038
01:03:08,160 --> 01:03:09,830
It's 66.25. 

1039
01:03:11,170 --> 01:03:12,850
The same completion by, right?

1040
01:03:12,860 --> 01:03:18,660
The p Sorry, 

1041
01:03:18,670 --> 01:03:20,820
p one completes at time 1:25. 

1042
01:03:21,310 --> 01:03:21,790
Sorry. 

1043
01:03:22,650 --> 01:03:25,230
P two, this is 125 here, p two complicit.

1044
01:03:25,240 --> 01:03:33,390
I'm 28, p three complicit time on 53 before complete the time on 12th.

1045
01:03:35,040 --> 01:03:37,270
The average weighting completion time, 

1046
01:03:37,280 --> 01:03:39,370
it's 104 and1/2. 

1047
01:03:44,880 --> 01:03:47,530
So around robin, 

1048
01:03:47,540 --> 01:03:51,650
what are the pros and cons better for short jobs? 

1049
01:03:52,160 --> 01:03:53,400
If you are assured jobs, 

1050
01:03:54,130 --> 01:03:56,280
your turn will come faster, 

1051
01:03:56,290 --> 01:04:00,030
especially if you are at the end of the queue. 

1052
01:04:01,500 --> 01:04:02,580
But now it adds contact. 

1053
01:04:02,590 --> 01:04:04,420
Switching is more contact switching overhead. 

1054
01:04:12,260 --> 01:04:23,340
It's again, if you have the the response time, right?

1055
01:04:23,350 --> 01:04:26,010
Is like, is the can decrease.

1056
01:04:26,020 --> 01:04:31,000
Here is an example to illustrate how you around robin decrease

1057
01:04:31,010 --> 01:04:35,710
the response time and assume the duration of a task. 

1058
01:04:36,310 --> 01:04:39,090
Now is then and of the other one, it's one,

1059
01:04:39,100 --> 01:04:40,170
p two is one. 

1060
01:04:41,460 --> 01:04:44,660
We are using the task and processes interchangeable. 

1061
01:04:45,900 --> 01:04:47,770
And here, if you want,

1062
01:04:47,780 --> 01:04:49,650
runs first and you do next, 

1063
01:04:50,080 --> 01:04:52,140
the average response time is 10.5. 

1064
01:04:53,530 --> 01:04:53,990
Okay? 

1065
01:04:55,330 --> 01:04:57,480
However, if you use a tanguette,

1066
01:04:58,630 --> 01:05:00,180
that was a time quanta ten, 

1067
01:05:00,190 --> 01:05:02,020
where is larger than any burst, 

1068
01:05:02,030 --> 01:05:04,380
if you lose a time quanta of ten of five, 

1069
01:05:05,170 --> 01:05:09,030
t one will run only for 5 seconds. 

1070
01:05:09,340 --> 01:05:11,890
Then you run t two after you run t one. 

1071
01:05:12,570 --> 01:05:14,790
They are very response time in this case, 

1072
01:05:15,090 --> 01:05:16,260
will be 8.5, 

1073
01:05:16,630 --> 01:05:20,260
because t two finishes at time six. 

1074
01:05:20,600 --> 01:05:22,200
What do you want finishes at time 11? 

1075
01:05:26,790 --> 01:05:32,730
And so now think about, 

1076
01:05:33,810 --> 01:05:35,500
if you have two tasks, 

1077
01:05:35,510 --> 01:05:37,060
but they are one time unit. 

1078
01:05:37,720 --> 01:05:42,150
And you average the quantize, 

1079
01:05:42,960 --> 01:05:46,030
then it's obviously the average response time. 

1080
01:05:46,040 --> 01:05:47,270
It's 1.5. 

1081
01:05:49,110 --> 01:05:50,160
If it's time quantitative, 

1082
01:05:50,170 --> 01:05:52,120
one is the same. 

1083
01:05:52,900 --> 01:05:56,740
The point here is that if the average, 

1084
01:05:57,390 --> 01:06:01,050
if the time quanta is larger than the birds, 

1085
01:06:01,060 --> 01:06:02,490
like there is a time, 

1086
01:06:02,500 --> 01:06:05,490
it takes a task for a process to complete, 

1087
01:06:07,760 --> 01:06:09,280
then it doesn't matter. 

1088
01:06:10,580 --> 01:06:13,140
There is no difference in the average response time. 

1089
01:06:19,640 --> 01:06:28,290
Now, if the quanta girl is smaller than the time it

1090
01:06:28,300 --> 01:06:32,800
takes to complete or for a task or a process, 

1091
01:06:33,330 --> 01:06:35,360
then this is an interesting case. 

1092
01:06:35,370 --> 01:06:36,680
Here is 0.5. 

1093
01:06:37,010 --> 01:06:41,840
So basically, you run t 140.5,

1094
01:06:41,850 --> 01:06:43,280
then t 240.5, 

1095
01:06:43,290 --> 01:06:44,600
then t 140.5, 

1096
01:06:44,610 --> 01:06:45,920
and t 240.5. 

1097
01:06:46,440 --> 01:06:48,540
If you look as they are very response time, 

1098
01:06:48,770 --> 01:06:50,050
it's 175. 

1099
01:06:52,060 --> 01:06:53,580
So it's larger guess. 

1100
01:06:56,310 --> 01:06:57,710
So that's kind of interesting, right?

1101
01:06:57,720 --> 01:06:59,110
So we, at some point,

1102
01:06:59,120 --> 01:07:00,510
at least in this scenario, 

1103
01:07:00,520 --> 01:07:04,290
we reduce the time quanta. 

1104
01:07:04,840 --> 01:07:09,150
Instead of the response time to decrease. 

1105
01:07:09,570 --> 01:07:10,680
It's actually increase. 

1106
01:07:15,060 --> 01:07:17,250
It's very easy to see why this happens. 

1107
01:07:17,740 --> 01:07:19,960
And this happens when, 

1108
01:07:20,590 --> 01:07:25,780
in particular, when all task or processes take the same amount of time.

1109
01:07:26,970 --> 01:07:27,310
Right? 

1110
01:07:28,710 --> 01:07:30,750
Because everyone takes the same amount of time. 

1111
01:07:30,760 --> 01:07:32,710
If you see one first come first set up, 

1112
01:07:33,690 --> 01:07:38,890
it's your first time you finish the first process and the second process

1113
01:07:38,900 --> 01:07:40,170
and sub process and so forth. 

1114
01:07:41,030 --> 01:07:44,990
Clearly, the first process finishes earlier than the last process.

1115
01:07:46,970 --> 01:07:52,300
But now, if you have very small time quanta and you do round robin to exam,

1116
01:07:52,930 --> 01:07:54,850
you do a little bit of each of them, yourself,

1117
01:07:54,860 --> 01:07:55,970
a little bit of each of them, 

1118
01:07:56,570 --> 01:08:01,260
then all of them are going to finish almost at the same time, 

1119
01:08:02,820 --> 01:08:08,960
meaning that all of them are going to finish more or less when the last one

1120
01:08:08,970 --> 01:08:09,360
finishes. 

1121
01:08:10,140 --> 01:08:15,430
That's why is the intuition why this the round robin

1122
01:08:15,440 --> 01:08:17,710
actually can also lead in some

1123
01:08:17,720 --> 01:08:20,640
cases to increasing the response time, 

1124
01:08:20,650 --> 01:08:21,840
not only decreasing it. 

1125
01:08:26,000 --> 01:08:26,910
How do we implement around? 

1126
01:08:26,920 --> 01:08:27,150
Robin? 

1127
01:08:27,160 --> 01:08:27,990
Is the kernel. 

1128
01:08:28,560 --> 01:08:31,670
It's using the time I interrupt. 

1129
01:08:32,940 --> 01:08:35,020
Every time a quant expires, 

1130
01:08:35,440 --> 01:08:37,480
you trigger a time interrupt. 

1131
01:08:38,470 --> 01:08:41,220
This is what the pure project two is going to be about. 

1132
01:08:46,240 --> 01:08:46,870
In summary, 

1133
01:08:48,320 --> 01:08:49,450
you've done robin. 

1134
01:08:50,000 --> 01:08:53,160
If the time slice or quanta is too big, 

1135
01:08:53,900 --> 01:08:55,360
the response time will suffer. 

1136
01:08:56,040 --> 01:08:56,920
If it's infinite, 

1137
01:08:57,540 --> 01:09:02,160
it's basically first come first or five. 

1138
01:09:02,970 --> 01:09:06,280
If the time slice is too small, the throughput my suffer.

1139
01:09:06,290 --> 01:09:07,520
And in some cases, 

1140
01:09:07,530 --> 01:09:09,380
also the response time I suffer. 

1141
01:09:11,020 --> 01:09:17,170
So it's the actual choice of time slice. 

1142
01:09:17,180 --> 01:09:22,140
It has to be large enough. 

1143
01:09:23,130 --> 01:09:26,330
So it amortizes, the context switch overhead.

1144
01:09:27,590 --> 01:09:30,410
So stinky has to be a few times, 

1145
01:09:30,420 --> 01:09:34,720
maybe one order to order a magnitude larger than the context switch. 

1146
01:09:35,100 --> 01:09:36,240
That's basically what it is. 

1147
01:09:37,470 --> 01:09:37,860
Right? 

1148
01:09:38,980 --> 01:09:40,130
Basically, you want,

1149
01:09:41,630 --> 01:09:44,810
if the typical the context switches 1 millisecond, 

1150
01:09:45,630 --> 01:09:48,810
you want the time commander to be, say,

1151
01:09:48,820 --> 01:09:51,250
100 million seconds toward the romantic language. 

1152
01:09:53,960 --> 01:09:54,960
That's a rule of town. 

1153
01:10:01,350 --> 01:10:07,540
This is an example again to drive back home like assume that you were in ignore, 

1154
01:10:09,190 --> 01:10:15,320
ignore the context switching overhead is round robin

1155
01:10:15,330 --> 01:10:18,150
always better than first cast herself. 

1156
01:10:19,080 --> 01:10:24,160
Like we discussed the answer is now this drives home the point by having

1157
01:10:24,170 --> 01:10:25,280
another example, 

1158
01:10:25,530 --> 01:10:33,630
each we have ten jobs and each job or ten takes 100 seconds. 

1159
01:10:34,670 --> 01:10:35,060
Right? 

1160
01:10:35,820 --> 01:10:40,100
The round will be in caterpillar at the time quantize 1 second. 

1161
01:10:40,600 --> 01:10:41,110
Okay? 

1162
01:10:41,840 --> 01:10:45,510
If this happens in the round robin in the five for kids or first come

1163
01:10:45,520 --> 01:10:46,510
for self case, 

1164
01:10:47,260 --> 01:10:50,330
the first job finishes after 1 second 100 seconds, 

1165
01:10:50,340 --> 01:10:51,890
the second after 200 seconds, 

1166
01:10:51,900 --> 01:10:53,570
the last one after 1,000 seconds. 

1167
01:10:54,140 --> 01:10:55,450
While in the round robin case, 

1168
01:10:55,460 --> 01:10:58,970
the further job finishes after 991 seconds, 

1169
01:10:59,510 --> 01:11:03,940
the second bar and after 992 seconds and so forth, 

1170
01:11:04,740 --> 01:11:05,110
right? 

1171
01:11:05,610 --> 01:11:09,470
Both round 3 time and first come first serve in each at the same time. 

1172
01:11:09,690 --> 01:11:12,660
But the average response time is much worse for country time. 

1173
01:11:14,640 --> 01:11:17,060
Around 3 time that i'm sorry not around the time. 

1174
01:11:17,380 --> 01:11:18,320
Around robin, 

1175
01:11:18,850 --> 01:11:22,210
it's bad when all jobs have the same length. 

1176
01:11:23,450 --> 01:11:23,930
Remember. 

1177
01:11:26,480 --> 01:11:29,380
And there are other reasons for each round robin may suffer. 

1178
01:11:29,900 --> 01:11:32,400
With round robin, you can switch between processes.

1179
01:11:33,110 --> 01:11:34,730
If you see between processes, 

1180
01:11:35,010 --> 01:11:36,160
the casual suffer, 

1181
01:11:37,360 --> 01:11:37,730
right? 

1182
01:11:38,260 --> 01:11:43,600
Because each process can be a different program and is going to need

1183
01:11:43,610 --> 01:11:44,530
a different code. 

1184
01:11:44,540 --> 01:11:50,510
It's accessing different data is going to not benefit from the caching. 

1185
01:11:50,680 --> 01:11:53,900
From the previous process, 

1186
01:11:54,330 --> 01:11:56,210
you need to gain between everything into the cache. 

1187
01:11:56,760 --> 01:12:01,720
In the case of the first come for the set of then one program run

1188
01:12:01,730 --> 01:12:04,610
or one process run until finishes, 

1189
01:12:04,960 --> 01:12:07,650
it's going to maximum to maximize the benefit of cash. 

1190
01:12:10,470 --> 01:12:14,590
This is another example here in our we have this one

1191
01:12:14,600 --> 01:12:16,870
of the previous examples and have three, 

1192
01:12:17,450 --> 01:12:21,130
four processes, which takes eight, 24, 53,

1193
01:12:21,140 --> 01:12:22,890
and 68 seconds, 

1194
01:12:23,440 --> 01:12:24,280
respectively. 

1195
01:12:25,910 --> 01:12:28,660
He had the best first come, first serve.

1196
01:12:29,090 --> 01:12:30,200
What is the best order? 

1197
01:12:31,080 --> 01:12:31,830
P one, 

1198
01:12:36,140 --> 01:12:37,970
b two, b three, and b four.

1199
01:12:37,980 --> 01:12:39,330
And what is the way down? 

1200
01:12:40,250 --> 01:12:40,560
Right? 

1201
01:12:41,330 --> 01:12:42,480
Is the best order, 

1202
01:12:42,490 --> 01:12:44,400
the best for comfort person, right?

1203
01:12:45,500 --> 01:12:49,010
You start with p two, then before, then p one, then p three.

1204
01:12:49,020 --> 01:12:51,670
So what is the wait time? 

1205
01:12:52,300 --> 01:12:54,890
For a week time for the p one is 32. 

1206
01:12:55,280 --> 01:12:56,400
For p two is zero, 

1207
01:12:56,410 --> 01:12:57,750
for p four is eight, 

1208
01:12:57,760 --> 01:12:59,370
and p three is 85. 

1209
01:12:59,650 --> 01:13:00,720
You have 71. 

1210
01:13:00,970 --> 01:13:04,830
And a quarter worse, 

1211
01:13:04,840 --> 01:13:05,990
first come first serve. 

1212
01:13:06,000 --> 01:13:07,830
It's when does this happen? 

1213
01:13:08,490 --> 01:13:09,980
When you run firstly three, 

1214
01:13:10,950 --> 01:13:11,930
then p one, 

1215
01:13:14,570 --> 01:13:16,220
then before so reverse order. 

1216
01:13:17,600 --> 01:13:23,240
And in that case, the worst case is 83 and 1/2.

1217
01:13:24,070 --> 01:13:27,750
The corresponding completion times for the best first come for a service, 

1218
01:13:27,760 --> 01:13:31,590
69.5 for the worst one. 

1219
01:13:33,160 --> 01:13:34,240
It's one, 

1220
01:13:34,250 --> 01:13:36,600
20:00 1 and 3/4. 

1221
01:13:40,350 --> 01:13:41,420
In the meantime, 

1222
01:13:41,710 --> 01:13:42,900
in between here, 

1223
01:13:43,700 --> 01:13:45,430
you have four different bank want us. 

1224
01:13:46,170 --> 01:13:50,440
For this is the result for the time qanta, one, time qantas, eight,

1225
01:13:53,030 --> 01:13:54,390
and one, 

1226
01:13:55,150 --> 01:13:56,550
and five and ten. 

1227
01:13:57,060 --> 01:13:59,490
So please, as an exercise,

1228
01:14:00,910 --> 01:14:02,300
take a sheet of paper, 

1229
01:14:03,040 --> 01:14:07,690
you can check the results for different time quanta. 

1230
01:14:08,330 --> 01:14:13,910
Great exercise to better understand about how round robin scheduling is working. 

1231
01:14:14,660 --> 01:14:16,360
And as you can see here, 

1232
01:14:19,350 --> 01:14:26,230
the average waiting time for the round robin, 

1233
01:14:26,660 --> 01:14:28,420
it's between, 

1234
01:14:29,140 --> 01:14:30,740
as you might have expected, 

1235
01:14:31,150 --> 01:14:36,280
is between the first come first serve and the best first come, first serve,

1236
01:14:36,290 --> 01:14:38,600
and the worst was first come, first serve,

1237
01:14:38,610 --> 01:14:40,160
and the same for the completion time. 

1238
01:14:45,950 --> 01:14:48,640
Let me see is that a few questions here. 

1239
01:14:52,050 --> 01:14:54,680
Since we cannot estimate the run time of each burst, 

1240
01:14:55,110 --> 01:14:57,500
how can we schedule the order in each first count? 

1241
01:14:58,460 --> 01:14:59,450
Scheduling is the best. 

1242
01:15:01,210 --> 01:15:02,670
That's a very good question. 

1243
01:15:03,090 --> 01:15:06,770
It's again, you can use historical data if available.

1244
01:15:07,110 --> 01:15:11,820
But one reason we study the best first come first serve, 

1245
01:15:12,360 --> 01:15:18,600
which is also called like you'll see shortage of first, 

1246
01:15:20,260 --> 01:15:21,360
for obvious reasons, 

1247
01:15:21,720 --> 01:15:24,540
is that this is like a baseline. 

1248
01:15:25,720 --> 01:15:28,240
You can actually, as you'll see,

1249
01:15:30,170 --> 01:15:34,750
you can prove that running shortage of first, 

1250
01:15:35,110 --> 01:15:42,650
using shortage of first leads to the lowest wait time or completion time. 

1251
01:15:47,290 --> 01:15:49,280
Another question is, the best first come,

1252
01:15:49,290 --> 01:15:51,990
first serve order is shortest or longest. 

1253
01:15:55,760 --> 01:15:58,280
The best first come for self is a shortest, 

1254
01:15:58,900 --> 01:16:01,720
is when you start with the shortest job first, 

1255
01:16:02,870 --> 01:16:05,430
the world's first come for self is the longest. 

1256
01:16:06,180 --> 01:16:09,320
And you start with the longest job for us. 

1257
01:16:13,050 --> 01:16:13,500
Okay? 

1258
01:16:17,760 --> 01:16:22,000
You can see here about like p two. 

1259
01:16:22,780 --> 01:16:26,920
And we are PP two is we are all over. 

1260
01:16:26,930 --> 01:16:28,270
The place is very sensitive, 

1261
01:16:29,010 --> 01:16:29,500
right? 

1262
01:16:30,010 --> 01:16:31,740
Depending of where, 

1263
01:16:32,560 --> 01:16:34,150
depending when is scheduled, 

1264
01:16:34,810 --> 01:16:35,160
right? 

1265
01:16:35,170 --> 01:16:40,200
You go from 0 to 145, right?

1266
01:16:41,820 --> 01:16:42,990
Which is pretty bad. 

1267
01:16:44,010 --> 01:16:45,320
While for p three, 

1268
01:16:45,330 --> 01:16:46,760
which is the largest, 

1269
01:16:47,080 --> 01:16:48,250
hits more stable. 

1270
01:16:48,710 --> 01:16:49,070
Right? 

1271
01:16:49,510 --> 01:16:50,520
And it's natural, right?

1272
01:16:50,530 --> 01:16:54,230
Because the longer the bigger you are, 

1273
01:16:54,240 --> 01:16:55,830
the more you are going to dominate, 

1274
01:16:56,490 --> 01:16:57,710
the wait time, 

1275
01:16:57,960 --> 01:16:59,530
and also the completion time. 

1276
01:17:02,360 --> 01:17:04,770
This is p three, and this is p two.

1277
01:17:11,390 --> 01:17:13,090
There are many other scheduling disciplines, 

1278
01:17:13,100 --> 01:17:14,410
another scheduling discipline here. 

1279
01:17:14,420 --> 01:17:18,780
We are going to talk a little bit about this priority. 

1280
01:17:19,540 --> 01:17:20,980
You can have different jobs here, 

1281
01:17:20,990 --> 01:17:24,520
and different jobs have different priorities, like, for instance,

1282
01:17:24,530 --> 01:17:26,920
jobs which are associated with interactive user interaction. 

1283
01:17:27,650 --> 01:17:32,840
They can have higher priority than jobs who are doing compilation, 

1284
01:17:33,870 --> 01:17:39,490
where our jobs which are going to process data you receive on the network

1285
01:17:40,300 --> 01:17:42,870
from the network that can have higher probability. 

1286
01:17:47,330 --> 01:17:50,680
With this scheduler, 

1287
01:17:50,690 --> 01:17:52,960
you assign a job of priority, 

1288
01:17:53,640 --> 01:17:57,630
then you always execute the highest priority job first. 

1289
01:17:58,510 --> 01:17:59,780
In this particular example, 

1290
01:17:59,790 --> 01:18:03,620
you are going to execute job one, job two, and job three.

1291
01:18:04,170 --> 01:18:05,970
Before you execute job four, 

1292
01:18:07,190 --> 01:18:10,060
you execute your four, before you execute your five, jobs six,

1293
01:18:10,070 --> 01:18:10,660
and jobs seven. 

1294
01:18:13,310 --> 01:18:17,420
So one of the biggest problem is this one is starvation. 

1295
01:18:18,260 --> 01:18:19,390
What is starvation here? 

1296
01:18:20,470 --> 01:18:25,580
Assume that you always have new jobs arriving with the highest priority. 

1297
01:18:27,540 --> 01:18:30,400
So as long as you have jobs with the highest priority arriving, 

1298
01:18:32,370 --> 01:18:35,710
you cannot process jobs in lower products. 

1299
01:18:38,780 --> 01:18:41,730
You can also have this one is called propriety and version. 

1300
01:18:43,360 --> 01:18:47,040
We talk a little bit about that in a different lecture. 

1301
01:18:48,050 --> 01:18:55,150
But here is what assume that say job five owns a lock

1302
01:18:56,630 --> 01:18:59,400
after each job one waits. 

1303
01:19:01,570 --> 01:19:02,650
So job five. 

1304
01:19:03,460 --> 01:19:04,060
Okay? 

1305
01:19:04,310 --> 01:19:05,700
It is a critical section. 

1306
01:19:07,230 --> 01:19:11,010
It was preempted by a higher priority job. 

1307
01:19:14,370 --> 01:19:19,130
And then job one comes and wants to enter to critical section, 

1308
01:19:19,890 --> 01:19:22,870
but it cannot because the job five still owns a lock. 

1309
01:19:25,340 --> 01:19:27,330
It cannot be scared before you go on. 

1310
01:19:28,220 --> 01:19:29,340
So that's how you have a deadlock. 

1311
01:19:31,550 --> 01:19:33,300
There are many ways to fix a problem. 

1312
01:19:34,230 --> 01:19:37,450
We are not going to talk about as much about this, 

1313
01:19:38,750 --> 01:19:41,980
but there are every single and dynamic priorities. 

1314
01:19:41,990 --> 01:19:42,620
If like, 

1315
01:19:42,630 --> 01:19:47,500
you'll see if a job is too much at a high priorities and you

1316
01:19:47,510 --> 01:19:50,180
are going to push it down to a lower priority. 

1317
01:19:50,680 --> 01:19:53,110
There are many other holistics, but it's important.

1318
01:19:53,320 --> 01:19:55,230
You to know about this problem. 

1319
01:19:55,240 --> 01:19:59,370
The strict priority can lead to salvation and can lead to deadlock. 

1320
01:20:02,350 --> 01:20:03,630
Now, what about scheduling?

1321
01:20:03,640 --> 01:20:04,270
Fairness? 

1322
01:20:05,590 --> 01:20:06,340
Oops, sorry.

1323
01:20:10,720 --> 01:20:12,390
So strict priority. 

1324
01:20:12,400 --> 01:20:13,550
What do you now solve? 

1325
01:20:13,790 --> 01:20:16,930
What will the state priority clearly is not fair, right?

1326
01:20:17,800 --> 01:20:20,540
Because by definition, 

1327
01:20:20,550 --> 01:20:22,260
priority is not fair, right?

1328
01:20:22,510 --> 01:20:26,650
You give priority to process is the highest priority. 

1329
01:20:30,020 --> 01:20:31,610
The fairness is at all, 

1330
01:20:31,620 --> 01:20:32,890
so is a privatization, 

1331
01:20:33,740 --> 01:20:34,070
right? 

1332
01:20:36,810 --> 01:20:40,220
And around Robin, on the other hand, is fair,

1333
01:20:41,010 --> 01:20:41,290
right? 

1334
01:20:41,300 --> 01:20:46,370
Because there is no difference between the jobs you give to each

1335
01:20:46,380 --> 01:20:48,800
of the jobs that I'm quanta until it finishes. 

1336
01:20:49,340 --> 01:20:52,880
And you go round Robin across the jobs. 

1337
01:20:57,510 --> 01:21:03,830
But you'll see that the tradeoff is like fairness, 

1338
01:21:03,840 --> 01:21:05,070
which is round rock win. 

1339
01:21:06,150 --> 01:21:10,200
One of the policies around Robin can hurt the average response. 

1340
01:21:13,040 --> 01:21:14,870
And how do you implement the fairness? 

1341
01:21:14,880 --> 01:21:17,150
Again, you can do around Robin.

1342
01:21:18,560 --> 01:21:22,340
There are other ways to get some price, 

1343
01:21:22,350 --> 01:21:25,840
even if you have priority scheduling. 

1344
01:21:29,020 --> 01:21:35,390
There is an article version in which if you wait, 

1345
01:21:35,960 --> 01:21:39,270
if you wait for too long on a lower priority queue, 

1346
01:21:40,410 --> 01:21:41,860
your priority is bump up. 

1347
01:21:42,170 --> 01:21:44,230
You do eventually get to the higher product you, 

1348
01:21:44,240 --> 01:21:49,530
and then you can get up now. 

1349
01:21:49,850 --> 01:21:51,630
Let's go to answer the, 

1350
01:21:58,850 --> 01:22:01,120
let me answer this question before. 

1351
01:22:01,550 --> 01:22:06,760
And then I'm going to stop because you have done the best first conference, 

1352
01:22:06,770 --> 01:22:07,180
orderly, 

1353
01:22:07,190 --> 01:22:08,440
shortest to longest. 

1354
01:22:10,290 --> 01:22:13,410
Sorry, it's yes,

1355
01:22:13,420 --> 01:22:15,740
the best first come, first serve.

1356
01:22:15,750 --> 01:22:17,980
Order is shortest, the longest.

1357
01:22:17,990 --> 01:22:18,580
That's correct. 

1358
01:22:19,270 --> 01:22:22,660
And we are over time. 

1359
01:22:23,380 --> 01:22:25,290
We are going to stop here. 

1360
01:22:25,300 --> 01:22:28,490
We are going to continue Thursday to talk about scheduling. 

1361
01:22:30,240 --> 01:22:31,550
If there are any other questions, 

1362
01:22:31,560 --> 01:22:36,230
i'll be happy to answer until then good luck at midterm. 

