1
00:00:28,670 --> 00:00:29,980
Hello, everybody.
大家好。

2
00:00:32,260 --> 00:00:33,890
Welcome to the 11th lecture.
欢迎来到第11讲。

3
00:00:33,900 --> 00:00:36,310
So hopefully you hear me.
希望你能听到我。

4
00:00:38,620 --> 00:00:41,850
Today we are going to continue our discussion about scheduling.
今天我们将继续讨论调度的问题。

5
00:00:43,660 --> 00:00:46,660
We are going to learn a bit about fairness, real time,
我们将学习一些关于公平性和实时性的知识。

6
00:00:47,350 --> 00:00:49,830
and making further progress,
并取得进一步的进展，

7
00:00:49,840 --> 00:00:50,990
avoiding starvation,
避免饥饿，

8
00:00:51,870 --> 00:00:53,910
and do one or two case studies.
并进行一到两个案例研究。

9
00:00:56,120 --> 00:01:02,600
So one thing just to start with is us a question I got from some people
所以首先，我收到了一些人的问题。

10
00:01:02,610 --> 00:01:04,080
also before the midterm.
还有在期中考试之前。

11
00:01:05,010 --> 00:01:09,630
It's about what is the operating system,
操作系统是一种软件，它管理计算机硬件和软件资源，并提供给用户和应用程序访问和使用这些资源的接口。操作系统的主要功能包括进程管理、内存管理、文件系统管理、设备驱动程序管理和用户界面等。它充当计算机系统的核心，协调和控制各个组件之间的交互，以实现计算机的正常运行。操作系统可以在不同的计算机平台上运行，并为用户提供一个友好的界面，使他们能够轻松地与计算机进行交互。

12
00:01:09,640 --> 00:01:14,110
scheduling processes or threads?
调度进程还是线程？

13
00:01:15,500 --> 00:01:17,530
The answer, obviously, is threats.
显然，答案是威胁。

14
00:01:18,800 --> 00:01:21,030
A process has at least one threat.
一个进程至少有一个线程。

15
00:01:22,190 --> 00:01:24,660
When a process has exactly one thread,
当一个进程只有一个线程时，

16
00:01:24,670 --> 00:01:27,260
then you can think about its interchangeable.
那么你可以考虑它的可互换性。

17
00:01:28,310 --> 00:01:33,050
The scared the kernel will scared either a process or astray, you can say.
这句话的意思是，内核可能会因为害怕而使一个进程或者迷失方向。

18
00:01:34,080 --> 00:01:35,180
But obviously,
但显然，

19
00:01:35,190 --> 00:01:36,220
when a thread,
当一个线程，

20
00:01:36,230 --> 00:01:38,380
aaa process has multiple threads,
aaa进程有多个线程。

21
00:01:38,950 --> 00:01:39,850
kernel threads,
内核线程

22
00:01:40,360 --> 00:01:47,270
then the operating system will schedule independently each thread of the process.
然后操作系统将独立调度进程的每个线程。

23
00:01:48,080 --> 00:01:48,510
Okay?
好的？

24
00:01:48,970 --> 00:01:54,300
Now the one thing to keep in mind is that when you switch between the context,
现在要记住的一件事是，在切换上下文时，

25
00:01:54,310 --> 00:01:56,180
switching between two threads,
在两个线程之间切换，

26
00:01:56,610 --> 00:01:59,210
if you remember which belong to the same process,
如果你记得它们属于同一个进程，

27
00:01:59,750 --> 00:02:03,500
that's much quicker because they are living in the same address space,
这样会更快，因为它们位于同一地址空间中。

28
00:02:04,080 --> 00:02:07,130
you do not need to switch the address space.
你不需要切换地址空间。

29
00:02:07,710 --> 00:02:08,040
However,
然而，

30
00:02:08,050 --> 00:02:13,200
when you switch between two threads which are indifferent processes,
当你在两个不同的进程之间切换线程时，

31
00:02:13,530 --> 00:02:15,980
then you need also to switch the address space.
那么你还需要切换地址空间。

32
00:02:16,370 --> 00:02:17,880
And that's much more expensive.
而且那要贵得多。

33
00:02:18,290 --> 00:02:22,800
Think about one order of magnitude more expensive to switch to context,
考虑到切换上下文的成本可能会增加一个数量级。

34
00:02:22,810 --> 00:02:24,900
switch between two stress in different processes,
在不同进程之间切换两种压力。

35
00:02:25,370 --> 00:02:28,060
then switching between two strides in the same process.
在同一个进程中切换两个步幅。

36
00:02:30,910 --> 00:02:33,010
And also remember here that actually,
还要记住的是，实际上，

37
00:02:33,020 --> 00:02:38,620
there is this multithreading or hyper simultaneous multithreading or hyperthreading,
有多线程、超级同时多线程或超线程技术。

38
00:02:38,630 --> 00:02:44,260
that's kind of the harder level which allows you to run multiple threads
这是较难的级别，允许您运行多个线程。

39
00:02:44,270 --> 00:02:45,820
on the same call.
在同一个电话中。

40
00:02:46,080 --> 00:02:49,680
But from the operating system and from the application,
但是从操作系统和应用程序的角度来看，

41
00:02:49,900 --> 00:02:52,650
the only difference is that is hyper threading.
唯一的区别就是超线程技术。

42
00:02:52,850 --> 00:02:54,410
You can run more threads,
你可以运行更多的线程，

43
00:02:54,420 --> 00:02:55,690
kernel thread at the same time.
同时运行内核线程。

44
00:02:56,100 --> 00:02:57,020
There's the only difference,
这是唯一的区别，

45
00:02:58,690 --> 00:02:59,230
nothing more.
没有更多的信息。

46
00:03:00,680 --> 00:03:02,880
Now, we discussed last time,
现在，我们上次讨论了

47
00:03:02,890 --> 00:03:08,890
we did come first set of we ended up with this kind of discipline,
我们进行了第一轮的讨论，最终得出了这种纪律的结论。

48
00:03:08,900 --> 00:03:12,770
which is when we look at the best first compass, if you remember,
这是当我们看最佳优先罗盘时的情况，如果你还记得的话。

49
00:03:13,630 --> 00:03:17,230
we are starting with the smallest job first,
我们从最小的作业开始。

50
00:03:17,830 --> 00:03:21,710
and then to minimize the waiting time and to minimize the completion time.
然后最小化等待时间和最小化完成时间。

51
00:03:22,520 --> 00:03:22,950
Okay.
好的。

52
00:03:24,020 --> 00:03:27,110
Obviously, the question here is that for that,
显然，这里的问题是关于那个的。

53
00:03:27,120 --> 00:03:28,470
we need to know the future.
我们需要知道未来。

54
00:03:28,940 --> 00:03:32,820
And if the future,
而在未来，

55
00:03:32,830 --> 00:03:34,260
can we meet all the best?
我们能够见面吗？祝一切顺利！

56
00:03:35,110 --> 00:03:36,240
First come first serve?
先来先服务（FCFS）？

57
00:03:36,810 --> 00:03:39,310
The answer is, obviously we all be said,
答案显然是，我们都会说，

58
00:03:39,320 --> 00:03:40,430
what is a discipline?
学科是指一门特定的知识领域或学术领域，它涉及特定的理论、原则、方法和技术。学科通常由一组相关的主题、概念和原则组成，用于研究和理解特定领域的现象和问题。学科可以包括自然科学、社会科学、人文科学等不同领域。在学术界和教育领域，学科也可以指特定的学科领域，如数学、物理学、历史学等。

59
00:03:41,070 --> 00:03:46,380
And that is to run the first job at first.
首先要运行第一个作业。

60
00:03:46,850 --> 00:03:47,250
Right?
对吗？

61
00:03:48,200 --> 00:03:50,640
So whatever job takes,
无论是什么工作，

62
00:03:50,650 --> 00:03:51,800
the least run.
最少运行。

63
00:03:52,120 --> 00:03:54,270
It has priority over other jobs.
它具有比其他任务更高的优先级。

64
00:03:55,180 --> 00:03:57,370
And there are two versions of that.
有两个版本。

65
00:03:58,090 --> 00:03:59,560
One, it's a preemp.
一、这是一个抢占式的操作系统。

66
00:03:59,570 --> 00:04:01,600
It's non preemptive version and gone.
这是非抢占式版本，已经过时了。

67
00:04:01,610 --> 00:04:03,400
And the other one is preemptive version.
另一个版本是抢占式的。

68
00:04:04,340 --> 00:04:08,100
As and I implies for the non preemptive version,
对于非抢占式版本，"As"和"I"的含义是

69
00:04:08,110 --> 00:04:10,860
you run each job all the way to completion.
你将每个作业运行到完成。

70
00:04:11,420 --> 00:04:12,850
In the preemptive version,
在抢占式版本中，

71
00:04:12,860 --> 00:04:15,650
you are going to comprehend the existing jobs.
你需要理解现有的工作。

72
00:04:15,820 --> 00:04:17,610
For instance, if any existing jobs,
例如，如果存在任何现有的作业，

73
00:04:17,950 --> 00:04:19,580
there's still 10 seconds to run.
还有10秒钟可以运行。

74
00:04:19,590 --> 00:04:20,980
And now a new job arrives,
现在又来了一份新工作，

75
00:04:20,990 --> 00:04:22,620
which is only 1 second to run.
只需要1秒钟就能运行。

76
00:04:22,630 --> 00:04:27,350
The new job is going to preempt the existing job because it has
新工作将会抢占现有工作，因为它具有

77
00:04:27,360 --> 00:04:30,520
only 1 second to finish while the preview while
预览完成仅需1秒钟。

78
00:04:30,530 --> 00:04:33,040
the existing joke still has 10 seconds to finish.
这个笑话还剩下10秒钟才结束。

79
00:04:33,690 --> 00:04:34,150
Okay.
好的。

80
00:04:34,570 --> 00:04:36,540
This is about shortest remaining time.
这是关于最短剩余时间的问题。

81
00:04:36,550 --> 00:04:36,870
First,
首先，

82
00:04:37,980 --> 00:04:40,410
this is a preemptive version of shortage of us.
这是一个关于美国短缺的先发制人版本。

83
00:04:46,050 --> 00:04:47,180
So remember about that?
那个你还记得吗？

84
00:04:47,190 --> 00:04:48,260
So this is optimal.
所以这是最优的。

85
00:04:48,270 --> 00:04:53,210
And you can show that is optimal from the point of view of reduction,
你可以展示从减少的角度来看，它是最优的。

86
00:04:53,220 --> 00:04:55,600
reducing or minimizing the completion time.
减少或最小化完成时间。

87
00:04:59,990 --> 00:05:02,080
So keeping keep in mind,
所以请记住，

88
00:05:02,090 --> 00:05:04,180
this is an optimal scheduling discipline.
这是一种最优的调度策略。

89
00:05:04,930 --> 00:05:05,300
Now,
现在，

90
00:05:06,560 --> 00:05:08,680
so it's,
所以，它是这样的，

91
00:05:13,030 --> 00:05:19,490
so one question here is that when you have shortest remaining time, first,
首先，当你选择最短剩余时间优先调度算法时，

92
00:05:20,160 --> 00:05:23,580
if you want to compare with his first come first set up,
如果你想与他的先到先安装进行比较，

93
00:05:24,020 --> 00:05:25,050
the one question is,
问题是，

94
00:05:25,060 --> 00:05:26,930
what if all jobs have the same length?
如果所有的工作都具有相同的长度，会怎么样？

95
00:05:26,940 --> 00:05:28,490
Because it's all jobs at the same length?
因为所有的工作长度都相同吗？

96
00:05:28,500 --> 00:05:31,170
What you are going to do all of them are going to take the same time.
你要做的所有事情都需要花相同的时间。

97
00:05:32,130 --> 00:05:35,020
In this case, there is no difference between them, right?
在这种情况下，它们之间没有区别，对吗？

98
00:05:35,030 --> 00:05:38,160
Because it doesn't matter in which order you are going to run,
因为运行的顺序无关紧要，

99
00:05:38,170 --> 00:05:40,140
because you need to break the ties,
因为你需要打破这种关系，

100
00:05:40,480 --> 00:05:43,350
because they all have the same length in some arbitrary fashion.
因为它们在某种任意方式下具有相同的长度。

101
00:05:43,360 --> 00:05:47,420
And first come first service one of these ways to break the ties.
先到先服务是其中一种打破平局的方式。

102
00:05:48,570 --> 00:05:50,580
And you are going to get the same results.
你将会得到相同的结果。

103
00:05:52,470 --> 00:05:54,420
Obviously, if the jobs are varying length,
显然，如果作业的长度不同，

104
00:05:54,840 --> 00:05:57,680
then with the shortest stop short,
然后以最短的停留时间停下来，

105
00:05:57,690 --> 00:06:03,500
the remaining time first is going to prioritize, obviously, the short jobs.
首先，剩余时间优先会明显地优先考虑短作业。

106
00:06:03,880 --> 00:06:08,360
And they are not going to go to to start to be stuck behind the long ones.
他们不打算开始被长队拖延。

107
00:06:08,370 --> 00:06:11,650
Remember that the first come, first set, they didn't have,
请记住，先来先得，他们没有。

108
00:06:12,100 --> 00:06:19,170
you might not have a good average response time when you have a big job,
当你有一个大任务时，你的平均响应时间可能不会很好。

109
00:06:19,180 --> 00:06:23,450
and then as a small jobs are just stuck behind the big job,
然后，小任务只是被大任务拖延了。

110
00:06:23,460 --> 00:06:27,810
because all the small jobs are going to inherit the completion time,
因为所有的小任务都会继承完成时间，

111
00:06:27,820 --> 00:06:30,510
the running time of the big job,
大任务的运行时间

112
00:06:30,520 --> 00:06:31,950
because I have to wait after it.
因为我必须在之后等待。

113
00:06:34,930 --> 00:06:38,880
Here is a simple example to illustrate the benefit of the shortest
这里有一个简单的例子来说明最短作业优先调度算法的好处。

114
00:06:38,890 --> 00:06:39,920
remaining time.
剩余时间。

115
00:06:39,930 --> 00:06:40,320
First.
首先。

116
00:06:41,010 --> 00:06:42,760
The shortest reminding time,
最短提醒时间

117
00:06:42,770 --> 00:06:44,080
remaining time first.
剩余时间首先。

118
00:06:44,650 --> 00:06:50,500
It's a preemptive version of shorter job first.
这是短作业优先的抢占式版本。

119
00:06:51,190 --> 00:06:52,640
And here you have two jobs,
这里有两个工作，

120
00:06:53,400 --> 00:06:55,860
a and b they are cpu bound,
a和b它们是CPU密集型任务。

121
00:06:55,870 --> 00:06:58,260
meaning that they use only the cpu say,
意思是它们仅使用CPU。

122
00:06:58,270 --> 00:07:00,020
run for a week or for a long time.
运行一周或者很长时间。

123
00:07:00,630 --> 00:07:02,470
And then you have another job see,
然后你还有另一份工作，你看到了吗？

124
00:07:02,860 --> 00:07:04,180
which is io bound.
这是一个I/O密集型任务。

125
00:07:05,620 --> 00:07:11,030
This means that you do an eye operation in one will take so many seconds
这意味着进行一次眼部手术需要花费很多秒钟。

126
00:07:11,040 --> 00:07:11,990
to do eye operation,
进行眼部手术

127
00:07:12,000 --> 00:07:12,390
like, say,
比如说，

128
00:07:12,400 --> 00:07:14,610
you read or write to the list,
你可以读取或写入列表。

129
00:07:14,620 --> 00:07:19,070
but then I you wait for 9 million seconds for the operation to complete.
但是你需要等待900万秒才能完成操作。

130
00:07:20,310 --> 00:07:20,790
Okay?
好的？

131
00:07:21,460 --> 00:07:24,820
If you run one of the jobs at a time,
如果你一次只运行一个作业，

132
00:07:25,240 --> 00:07:32,730
then job a or b will use 100% of the cpu and 0% of the io of the disk.
那么作业A或作业B将使用100%的CPU和0%的磁盘IO。

133
00:07:34,270 --> 00:07:36,220
If you run c at the time,
如果你在那个时候运行c程序，

134
00:07:37,980 --> 00:07:42,110
c will use10% of the cpu and 90% of the risk.
C将使用CPU的10%，风险占90%。

135
00:07:43,090 --> 00:07:46,360
So what will happen with first time for a setup?
第一次设置时会发生什么？

136
00:07:46,680 --> 00:07:47,580
With first fargo?
第一个是Fargo吗？

137
00:07:47,590 --> 00:07:49,100
First come, first serve.
先到先得。

138
00:07:49,330 --> 00:07:52,950
Once a our big is scheduled,
一旦我们的大事件被安排好，

139
00:07:52,960 --> 00:07:56,230
then it's going to run the story.
然后它将运行故事。

140
00:07:57,000 --> 00:08:00,840
Going to hold the cpu for2 weeks together.
将CPU连续占用两周。

141
00:08:02,820 --> 00:08:05,730
They are going to get in because even if she starts to love me,
他们会进来的，因为即使她开始爱我，

142
00:08:05,740 --> 00:08:07,050
as starts to learn,
刚开始学习时，

143
00:08:07,060 --> 00:08:08,610
starts to run.
开始运行。

144
00:08:09,090 --> 00:08:13,700
After 1 mini seconds is going to give up the cpu because it has to wait
在等待1毫秒后，它将放弃CPU，因为需要等待。

145
00:08:14,080 --> 00:08:16,380
for to get
为了获得

146
00:08:19,840 --> 00:08:21,240
the eye operation complete.
眼部手术已完成。

147
00:08:23,030 --> 00:08:26,950
Now, what about a round robin or short as remaining time?
现在，关于轮转调度或短作业优先调度，有什么问题吗？

148
00:08:26,960 --> 00:08:28,430
First in this particular case?
在这个特定的情况中，首先是什么？

149
00:08:29,330 --> 00:08:30,360
Let's see what happens.
让我们看看会发生什么。

150
00:08:32,160 --> 00:08:35,800
This is round robin and assume the round robin.
这是轮转调度算法，并假设采用轮转调度。

151
00:08:35,810 --> 00:08:39,410
The time slice is 100 million seconds, okay?
时间片是1亿秒，好吗？

152
00:08:39,730 --> 00:08:44,140
So you execute in round robin every job.
所以你按照轮转的方式执行每个作业。

153
00:08:44,710 --> 00:08:49,760
So let's start with c it's again and say the time slice is
那么让我们继续讨论C语言，假设时间片是多少。

154
00:08:49,770 --> 00:08:51,000
100 million seconds again.
再次是1亿秒。

155
00:08:51,680 --> 00:08:58,590
So you start to see c runs for 1 millisecond and then gives up yell the cpu
所以你开始看到C运行了1毫秒，然后放弃了对CPU的使用。

156
00:08:58,600 --> 00:09:01,350
because it needs to wait for the eye operation to complete.
因为它需要等待眼部手术完成。

157
00:09:02,260 --> 00:09:05,070
Then you have to run a and then b and c again.
然后你需要再次运行a、b和c。

158
00:09:06,210 --> 00:09:08,930
Now a and b because our cpu bounded,
现在a和b因为我们的CPU受限而变得重要。

159
00:09:08,940 --> 00:09:11,250
they are going to take their entire time quanta.
他们将会使用完整的时间片。

160
00:09:11,260 --> 00:09:12,490
That is 100 reset.
这是第100次重置。

161
00:09:13,160 --> 00:09:13,570
Right?
对吗？

162
00:09:14,010 --> 00:09:15,700
In this case, a discretization,
在这种情况下，进行离散化处理，

163
00:09:15,710 --> 00:09:17,060
if you look about,
如果你四处看看，

164
00:09:18,100 --> 00:09:19,780
is like from around,
是来自周围的

165
00:09:19,790 --> 00:09:28,790
when you schedule caabc then it takes to all of them to complete takes 200,
当你安排了caabc时，完成所有任务需要200个单位的时间。

166
00:09:29,220 --> 00:09:30,390
1 million seconds,
1百万秒，

167
00:09:31,070 --> 00:09:36,330
100 for a 100 for b and one for c and out of this time,
100给a，100给b，还有一个给c，这次就这样了。

168
00:09:36,340 --> 00:09:38,770
because you have the only one eye operation,
因为你只有一只眼睛手术。

169
00:09:38,780 --> 00:09:43,100
because the schedule c only once the eye operation kept takes 9 millisecond.
因为调度C只需要一次眼部手术，耗时9毫秒。

170
00:09:43,760 --> 00:09:46,070
The discretization is 9 over 201,
离散化为9除以201。

171
00:09:46,080 --> 00:09:48,100
which is.5 years ago,
这是5年前的事情。

172
00:09:48,110 --> 00:09:49,260
4.5%.
4.5%。

173
00:09:51,510 --> 00:09:52,830
Very little bit.
非常少。

174
00:09:53,940 --> 00:09:55,090
Now let's say you do that.
现在假设你这样做。

175
00:09:55,100 --> 00:09:56,450
Our robin of 1 millisecond.
我们的1毫秒的红腹鸫。

176
00:09:56,460 --> 00:09:59,850
If you do round robin of about 1 millisecond, what do you go?
如果你使用大约1毫秒的时间片轮转调度算法，你会怎么做？

177
00:10:00,830 --> 00:10:01,340
What happens?
发生了什么事情？

178
00:10:01,350 --> 00:10:02,060
Your schedule?
你的日程安排？

179
00:10:02,070 --> 00:10:04,060
C first, it takes 1 millisecond.
首先，它需要1毫秒的时间。

180
00:10:04,810 --> 00:10:07,480
Then c will have to wait for 9.
那么c将需要等待9个单位的时间。

181
00:10:07,490 --> 00:10:12,270
Millisecond is going to be in the waiting queue to wait for the operations
毫秒将进入等待队列等待操作。

182
00:10:12,280 --> 00:10:12,850
to conflict.
冲突

183
00:10:13,090 --> 00:10:13,370
Right?
对吗？

184
00:10:13,740 --> 00:10:15,170
During these 9 million seconds,
在这900万秒的时间里，

185
00:10:15,180 --> 00:10:19,680
you are going to ultimate between a and b each of them for 1 million seconds,
你将对a和b进行一百万秒的终极对决。

186
00:10:19,690 --> 00:10:22,340
because they are ready to always run,
因为它们随时准备运行，

187
00:10:22,350 --> 00:10:24,300
because they are only cpu bounded, right?
是的，因为它们只受到 CPU 的限制，对其他资源的需求较少。

188
00:10:25,520 --> 00:10:26,790
What you get here,
在这里你可以得到什么

189
00:10:27,080 --> 00:10:29,710
the discretization is 90%, right?
离散化是90%，对吗？

190
00:10:29,720 --> 00:10:34,570
Because see, it's already once an io completes see,
因为你看，当一个IO完成时，它已经完成了一次。

191
00:10:34,580 --> 00:10:38,530
it's ready to launch the next time.
下次准备好发射了。

192
00:10:38,940 --> 00:10:39,230
Right?
对吗？

193
00:10:39,630 --> 00:10:41,540
The problem here is, if you see it,
问题在于，如果你能看到它，

194
00:10:42,450 --> 00:10:44,840
this is great maximize the discretization,
这很棒，最大化离散化。

195
00:10:44,850 --> 00:10:46,440
but in this particular case,
但在这种特殊情况下，

196
00:10:46,450 --> 00:10:48,770
you have a loss of context switches, right?
你指的是上下文切换的损失吗？

197
00:10:48,780 --> 00:10:51,610
Because between a and b you have a lot of contact switches.
因为在a和b之间有很多接触开关。

198
00:10:52,320 --> 00:10:54,630
And at every one, the second.
在每一个地方，第二个。

199
00:10:56,500 --> 00:10:58,540
Now what happens is the shortest time first,
现在发生的是最短时间优先。

200
00:10:58,890 --> 00:11:00,280
the shortest time first,
最短时间优先

201
00:11:00,290 --> 00:11:01,330
remaining time first.
剩余时间首先。

202
00:11:01,340 --> 00:11:03,080
So shortest remaining time first.
最短剩余时间优先算法。

203
00:11:03,430 --> 00:11:04,400
Let's see what happens.
让我们看看会发生什么。

204
00:11:04,910 --> 00:11:06,240
First, exactly see.
首先，确切地看到。

205
00:11:07,880 --> 00:11:09,730
Like in the previous two cases,
与前两种情况一样，

206
00:11:10,220 --> 00:11:11,490
it takes 1 millisecond,
它需要1毫秒。

207
00:11:11,810 --> 00:11:18,300
and then is going to wait for9 million seconds for the eye of the complete.
然后它将等待900万秒，直到完全完成。

208
00:11:18,860 --> 00:11:19,250
Right?
对吗？

209
00:11:21,140 --> 00:11:23,050
See, it's on the way to you.
看，它正在运送途中到你那里。

210
00:11:23,060 --> 00:11:28,490
So now you need to schedule between a and b let's say you schedule a you
现在你需要在a和b之间安排时间表，假设你选择了安排a。

211
00:11:28,500 --> 00:11:32,440
are going to schedule a until c becomes,
我们将安排一个任务，直到c变为。

212
00:11:32,770 --> 00:11:34,930
again, ready for execute to execute.
再次，准备执行。

213
00:11:35,160 --> 00:11:38,830
And he will become ready to execute when his io has completed.
当他的IO完成后，他将准备好执行。

214
00:11:38,840 --> 00:11:40,630
So after 9 million seconds,
所以经过900万秒之后，

215
00:11:41,590 --> 00:11:43,230
in the first 90 seconds,
在前90秒内，

216
00:11:43,490 --> 00:11:47,130
you run a and now c is ready to execute,
你运行了a，现在c准备执行。

217
00:11:47,140 --> 00:11:49,010
and c takes only 1 millisecond.
而且C只需要1毫秒的时间。

218
00:11:49,480 --> 00:11:53,750
The remaining time to finish first for seats,
完成第一次座位的剩余时间

219
00:11:53,760 --> 00:12:00,980
1 millisecond while for a it's 1 week minus9 millisecond.
对于a来说，1毫秒等于1周减去9毫秒。

220
00:12:02,000 --> 00:12:04,160
So we are going to schedule c see it again,
所以我们将安排再次查看C语言的课程。

221
00:12:04,170 --> 00:12:05,920
takes 1 millisecond to go to sleep,
需要1毫秒进入睡眠状态，

222
00:12:06,220 --> 00:12:09,740
because it's just like for waiting for the eye operation to complete.
因为这就像等待眼部手术完成一样。

223
00:12:10,010 --> 00:12:14,770
And now you have a and ba remaining time.
现在你还有a和ba的剩余时间。

224
00:12:15,130 --> 00:12:16,840
It's 1 week-90 seconds,
这是1周的时间，相当于90秒。

225
00:12:16,850 --> 00:12:20,880
the remaining time for b we didn't run at all b it's 1 week.
我们还没有运行 b 的剩余时间是 1 周。

226
00:12:22,540 --> 00:12:25,370
A is 1 week-90 seconds, b is 1 week.
A是1周-90秒，B是1周。

227
00:12:26,230 --> 00:12:29,950
A will take shorter to complete to terminate.
A将更快地完成终止。

228
00:12:30,680 --> 00:12:32,470
Therefore, you are going to schedule a gaming,
因此，你打算安排一场游戏。

229
00:12:32,480 --> 00:12:33,630
so you started to do it.
所以你开始做了。

230
00:12:34,060 --> 00:12:40,210
You do cacaca until a finishes this utilization 90%,
你要一直运行 cacaca 直到利用率达到90%。

231
00:12:40,730 --> 00:12:41,980
and much fewer context edges.
并且边缘上的上下文要少得多。

232
00:12:42,680 --> 00:12:42,920
Right?
对吗？

233
00:12:44,590 --> 00:12:45,250
Any questions?
有任何问题吗？

234
00:12:45,260 --> 00:12:45,890
Please ask?
请问有什么需要帮助的吗？

235
00:12:46,340 --> 00:12:47,530
Let's make it, again.
让我们再试一次。

236
00:12:47,820 --> 00:12:48,640
More interactive.
更加互动。

237
00:12:51,230 --> 00:12:53,740
It's pretty hard to just stare at the screen.
只盯着屏幕看确实很难受。

238
00:12:58,920 --> 00:12:59,950
Anyway, now,
无论如何，现在，

239
00:12:59,960 --> 00:13:01,590
what is the problem with shortest time?
最短时间的问题是什么？

240
00:13:01,600 --> 00:13:01,950
First?
首先？

241
00:13:01,960 --> 00:13:03,350
As short as yours are remaining?
和你剩下的一样短吗？

242
00:13:03,360 --> 00:13:03,790
The time?
时间是多少？

243
00:13:04,490 --> 00:13:07,090
First is starvation, what does it mean?
首先是饥饿（starvation），它是什么意思？

244
00:13:07,100 --> 00:13:07,320
Starvation?
饥饿问题？

245
00:13:07,760 --> 00:13:12,040
Can someone tell me what starvation means and why we are going to have starvation?
饥饿是指人们因缺乏足够的食物和营养而导致身体无法正常运作的状态。饥饿通常发生在资源匮乏的地区或人口过多的地方。以下是导致饥饿的一些原因：

1. 自然灾害：自然灾害如干旱、洪水、飓风等会破坏农作物和畜牧业，导致食物供应不足。

2. 贫困和不平等：贫困和不平等分配资源的问题也是导致饥饿的原因之一。一些人无法获得足够的收入来购买食物，而其他人则拥有过多的资源。

3. 冲突和战争：冲突和战争会破坏农田、基础设施和食物供应链，导致饥饿。

4. 疾病和健康问题：某些疾病和健康问题会影响人们的食欲和消化能力，导致营养不良和饥饿。

为了解决饥饿问题，国际组织、政府和非政府组织采取了许多措施，包括提供紧急援助、改善农业和畜牧业生产、提供教育和培训等。

246
00:13:12,050 --> 00:13:12,640
In this case?
在这种情况下？

247
00:13:26,330 --> 00:13:32,040
Never getting to run b never is scheduled in the previous example.
在之前的例子中，b任务永远不会被调度运行。

248
00:13:32,050 --> 00:13:32,760
Actually.
实际上。

249
00:13:33,140 --> 00:13:35,160
After you finish a you are going to eventually run.
完成一个任务后，你最终会去运行它。

250
00:13:35,170 --> 00:13:37,440
So we will wait a long time,
所以我们将等待很长时间，

251
00:13:37,450 --> 00:13:40,310
but starvation means that it may never be,
但饥饿意味着可能永远不会发生。

252
00:13:40,570 --> 00:13:42,310
you may never run as a joke.
你可能永远不会当作一个玩笑来运行。

253
00:13:51,670 --> 00:13:52,700
Any other answer?
还有其他答案吗？

254
00:13:52,990 --> 00:13:56,070
So it's against starvation means that the job industry remains a system
这意味着反对饥饿意味着保持就业行业的系统化。

255
00:13:56,270 --> 00:13:58,440
without ever being run executive.
从未被执行的执行文件。

256
00:13:59,920 --> 00:14:00,790
When can this happen?
这个什么时候可以发生？

257
00:14:06,780 --> 00:14:07,300
That's great.
太好了。

258
00:14:08,050 --> 00:14:09,530
So allison,
所以，Allison，

259
00:14:10,320 --> 00:14:13,800
so if you have a stream of short jobs,
所以如果你有一系列短作业，

260
00:14:14,410 --> 00:14:16,450
you always get new, short jobs,
你总是得到新的、短期的工作。

261
00:14:17,000 --> 00:14:20,760
then the long job may never be scheduled.
那么长时间的任务可能永远不会被调度。

262
00:14:22,670 --> 00:14:23,790
That's exactly what happens.
就是发生了这种情况。

263
00:14:29,660 --> 00:14:35,110
The other problem with this shortest remaining time first is that you
最短剩余时间优先算法的另一个问题是，你

264
00:14:35,120 --> 00:14:36,150
need to predict the future.
需要预测未来。

265
00:14:36,160 --> 00:14:40,230
You need to know how long a job is going to take.
你需要知道一个任务需要多长时间完成。

266
00:14:40,740 --> 00:14:44,230
There was a question or two last lectures about this.
上节课有一个或两个问题涉及到这个。

267
00:14:48,130 --> 00:14:50,360
There are some ways none of them is perfect.
有一些方法，但没有一个是完美的。

268
00:14:51,170 --> 00:14:54,440
One way is to rely on the users and as the users,
一种方法是依赖于用户，作为用户，

269
00:14:54,450 --> 00:14:56,920
how long will take the job or the job will take.
这项工作需要多长时间完成？或者这项工作将花费多长时间？

270
00:14:57,880 --> 00:15:00,090
But with this has certain problems.
但是这也存在一些问题。

271
00:15:00,100 --> 00:15:01,200
First of all,
首先，

272
00:15:02,390 --> 00:15:03,730
you assume the user now,
你现在假设用户是这样的，

273
00:15:03,740 --> 00:15:05,080
which is not always true,
这并不总是正确的，

274
00:15:05,670 --> 00:15:07,030
or which is rarely true.
或者很少是真实的。

275
00:15:07,690 --> 00:15:12,880
And also you open yourself to an attack in the sense that a user,
而且你还会面临一种攻击，即用户可以

276
00:15:13,350 --> 00:15:18,220
because if the user now that the system using the shortest remaining time first,
因为如果用户知道系统使用最短剩余时间优先算法，

277
00:15:18,510 --> 00:15:19,800
will declare a very short time,
将会宣布一个非常短的时间。

278
00:15:19,810 --> 00:15:21,480
even if the job will take long.
即使工作需要很长时间。

279
00:15:21,730 --> 00:15:23,120
Because in this way,
因为这样的话，

280
00:15:24,010 --> 00:15:26,470
she can ensure that the job will be scattered.
她可以确保工作会被分散。

281
00:15:29,850 --> 00:15:33,120
The other thing which is not here is basically to keep the history.
另外一件不在这里的事情基本上是保留历史记录。

282
00:15:33,130 --> 00:15:34,520
If you run a job repeatedly,
如果你重复运行一个作业，

283
00:15:34,530 --> 00:15:35,800
you look at the history.
你看看历史记录。

284
00:15:36,270 --> 00:15:43,060
If you see how long you basically assume that the past running time is
如果你看到一个程序运行的时间很长，基本上可以假设过去的运行时间也是如此。

285
00:15:43,070 --> 00:15:46,180
a good predictor for the future running time for the same job.
对于同一作业未来运行时间的一个很好的预测器。

286
00:15:46,190 --> 00:15:48,260
And we are going to use that prediction.
我们将会使用这个预测。

287
00:15:50,490 --> 00:15:52,580
But anyway, so this is hard.
但无论如何，这很困难。

288
00:15:52,880 --> 00:15:57,420
However, shortest running time first is still a very important discipline.
然而，最短运行时间优先仍然是一个非常重要的原则。

289
00:15:57,690 --> 00:15:58,660
For one reason,
首先，

290
00:15:59,370 --> 00:16:00,920
it represents a yardstick.
它代表了一个标准尺。

291
00:16:00,930 --> 00:16:04,090
It's a baseline for measuring other policies.
这是衡量其他政策的基准。

292
00:16:04,310 --> 00:16:08,780
When it comes to minimize the average response line,
当涉及到最小化平均响应时间时，

293
00:16:10,580 --> 00:16:11,250
it's optimal.
这是最优的。

294
00:16:11,260 --> 00:16:12,290
You cannot do it better.
你无法做得更好。

295
00:16:13,510 --> 00:16:16,780
If you are looking, if you are designing a new scheduler, one of them,
如果你正在寻找，如果你正在设计一个新的调度器，其中之一，

296
00:16:16,790 --> 00:16:18,700
at least the average response time,
至少平均响应时间，

297
00:16:19,040 --> 00:16:21,470
you are going to compare the average response time
你将要比较平均响应时间。

298
00:16:21,480 --> 00:16:25,910
of that new discipline or scheduling discipline through your design,
通过你的设计来推动这个新学科或调度学科的发展，

299
00:16:26,340 --> 00:16:27,820
Against the shortest,
反对最短的

300
00:16:28,210 --> 00:16:29,390
a remaining time first.
首先是剩余时间。

301
00:16:29,740 --> 00:16:31,610
The closer you are, the better you are,
你越接近，你就越好。

302
00:16:33,730 --> 00:16:35,640
in summary, for shortest remaining time.
总结一下，最短剩余时间算法。

303
00:16:35,650 --> 00:16:36,120
First.
首先。

304
00:16:36,760 --> 00:16:40,230
It's optimal with respect to a very response time,
它在响应时间方面是最优的。

305
00:16:40,240 --> 00:16:42,030
but it can be hard to predict.
但是很难预测。

306
00:16:43,090 --> 00:16:44,040
It brings the future.
它带来了未来。

307
00:16:44,050 --> 00:16:45,480
You need to bring the future.
你需要带来未来。

308
00:16:45,490 --> 00:16:46,440
And this is hard.
而且这很困难。

309
00:16:46,650 --> 00:16:49,460
And can be unfair.
而且可能是不公平的。

310
00:16:49,470 --> 00:16:51,140
Here means also starvation.
这里也意味着饥饿。

311
00:16:51,370 --> 00:16:54,570
The long jobs not may never be scheduled.
长作业可能永远不会被调度。

312
00:17:01,480 --> 00:17:04,670
This is what I said in the earliest.
这是我之前说的话。

313
00:17:04,680 --> 00:17:06,670
This is one way to implement what I said.
这是一种实现我所说的方法。

314
00:17:07,870 --> 00:17:09,060
In the previous slide,
在前面的幻灯片中，

315
00:17:09,070 --> 00:17:12,500
that one way is to predict is based on the past behavior.
一种预测的方法是基于过去的行为。

316
00:17:12,510 --> 00:17:12,740
Right?
对吗？

317
00:17:12,750 --> 00:17:18,300
So you look at is that how long a particular job or process the first time
所以你的意思是，你想知道一个特定作业或进程第一次运行的时间有多长。

318
00:17:18,550 --> 00:17:20,330
is the previous first time?
之前是第一次吗？

319
00:17:20,340 --> 00:17:27,360
And you use that as aa prediction for the future times and for the future.
你将这个作为对未来时间和未来的预测。

320
00:17:27,370 --> 00:17:31,610
And one way is to do this exponentially averaging in which you
一种方法是通过指数平均化来实现这一点，其中你可以

321
00:17:31,620 --> 00:17:35,010
are going to put away against the
你打算存钱吗？

322
00:17:35,020 --> 00:17:38,970
duration of the last time the job runs,
作业上次运行的持续时间

323
00:17:39,370 --> 00:17:47,260
and then discount to one minus alpha
然后打折至1减去α

324
00:17:47,270 --> 00:17:51,780
for the existing prediction.
对于现有的预测。

325
00:17:52,400 --> 00:17:54,030
You have an existing prediction.
你有一个现有的预测。

326
00:17:55,640 --> 00:17:58,670
You can multiply that pre existing prediction with a way.
你可以将那个预测与一种方法相乘。

327
00:17:59,210 --> 00:18:02,000
Then you add to one minus weight,
然后你将其加到1减去权重的结果上。

328
00:18:03,170 --> 00:18:06,820
the last running time of the job.
作业的最后运行时间。

329
00:18:08,650 --> 00:18:09,720
At one extreme,
在一个极端的情况下，

330
00:18:09,730 --> 00:18:11,560
if you wait with zero,
如果你等待时间为零，

331
00:18:14,140 --> 00:18:15,910
the previous prediction,
之前的预测，

332
00:18:16,120 --> 00:18:20,470
this means that you don't care about the past execution,
这意味着你不关心过去的执行情况，

333
00:18:20,480 --> 00:18:24,190
but the last one because the weight will be one for the last execution.
但是最后一个不同，因为最后一次执行的权重将为1。

334
00:18:24,890 --> 00:18:28,440
And if you have a small weight for the last execution,
如果最后一次执行的权重很小，

335
00:18:28,710 --> 00:18:31,060
this means that you are going to put a lot of weight
这意味着你将要承担很大的压力。

336
00:18:31,380 --> 00:18:34,700
on the previous equations before the last one.
在最后一个方程之前的前面方程中。

337
00:18:42,780 --> 00:18:44,090
What about the fairness?
公平性如何？

338
00:18:44,500 --> 00:18:48,000
And this is a very important aspect they are going to talk about.
这是他们将要讨论的一个非常重要的方面。

339
00:18:48,250 --> 00:18:50,450
We discuss about first come first serve,
我们讨论先来先服务（First Come First Serve）算法，

340
00:18:50,460 --> 00:18:51,530
not really fair.
不太公平。

341
00:18:51,540 --> 00:18:55,090
We discuss about shortage of first not really necessary fair.
我们讨论了第一次不是真正必要的公平短缺问题。

342
00:18:56,100 --> 00:18:58,820
We discuss about robin actually that's kind of fair.
我们讨论一下关于轮转调度算法，实际上这是相当公平的。

343
00:19:03,490 --> 00:19:08,070
And now,
现在，

344
00:19:09,020 --> 00:19:12,850
keep in mind that this kind of fairness is another very important metric.
请记住，这种公平性是另一个非常重要的指标。

345
00:19:13,120 --> 00:19:15,720
We are going to use to characterize the schedule.
我们将使用来描述调度。

346
00:19:18,850 --> 00:19:20,500
And fundamentally,
从根本上说，

347
00:19:20,510 --> 00:19:22,790
there is a strict,
有一个严格的，

348
00:19:23,510 --> 00:19:27,750
it's a hard trade off between the average response time and the fairness.
在平均响应时间和公平性之间存在一个艰难的权衡。

349
00:19:28,770 --> 00:19:29,160
Right?
对吗？

350
00:19:29,670 --> 00:19:30,890
If you remember,
如果你记得的话，

351
00:19:30,900 --> 00:19:34,490
we had last lecture,
我们上次有一堂课，

352
00:19:34,500 --> 00:19:38,450
we had this example and between the round robin, which is fair,
我们有一个例子，在轮转调度算法中，它是公平的。

353
00:19:38,460 --> 00:19:40,500
because during one round,
因为在一轮中，

354
00:19:40,510 --> 00:19:45,850
you schedule every process or every job.
你可以安排每个进程或每个作业的调度。

355
00:19:48,310 --> 00:19:49,420
First come, first serve.
先到先得。

356
00:19:50,140 --> 00:19:55,200
If you remember, you are looking at equal a length of jobs.
如果你还记得的话，你需要考虑作业的长度是否相等。

357
00:19:56,390 --> 00:20:00,580
And because if you really want to be fair,
而且，如果你真的想要公平的话，

358
00:20:00,590 --> 00:20:02,540
everyone will finish at the same time.
每个人将在同一时间完成。

359
00:20:02,550 --> 00:20:04,420
So everyone will be like,
所以每个人都会像这样，

360
00:20:05,140 --> 00:20:05,540
right?
对的？

361
00:20:05,920 --> 00:20:09,070
Heard the average response time while if you are not fair,
听说如果你不公平的话，平均响应时间会变长。

362
00:20:09,810 --> 00:20:15,360
if you run everyone at comfortable at every job to completion,
如果你让每个人在每个工作上都舒适地完成任务，

363
00:20:15,560 --> 00:20:18,500
then the one that you get first are going to finish
那么你先得到的那个将会先完成。

364
00:20:18,510 --> 00:20:20,180
much earlier than the last one.
比上一个要早得多。

365
00:20:20,530 --> 00:20:20,890
Right?
对吗？

366
00:20:21,480 --> 00:20:24,700
So you're going to get better response to keep in mind.
所以你要记住，要获得更好的回应。

367
00:20:24,710 --> 00:20:32,510
The fairness may in general hurt the response to how do you and basically also
公平原则通常可能会对回答“你好吗？”这类问题产生不利影响，基本上也会如此。

368
00:20:32,520 --> 00:20:37,270
have other scheduling discipline like we are going to learn about fixed priority.
还有其他调度策略，比如我们将要学习的固定优先级调度。

369
00:20:37,720 --> 00:20:40,690
The fixed priority is also fundamental fair.
固定优先级也是基本公平的。

370
00:20:40,970 --> 00:20:43,690
With a priority, basically assign different jobs,
通过优先级，基本上分配不同的任务。

371
00:20:43,700 --> 00:20:45,010
different priorities,
不同的优先级

372
00:20:45,890 --> 00:20:49,280
because you deem that some jobs are more important than the others.
因为你认为有些工作比其他工作更重要。

373
00:20:49,290 --> 00:20:50,000
And by the way,
顺便一提，

374
00:20:50,010 --> 00:20:53,120
whenever you say something is more important than the other,
每当你说某事比另一件事更重要时，

375
00:20:53,370 --> 00:20:55,190
basically, you give up on the fairness.
基本上，你放弃了公平性。

376
00:20:55,800 --> 00:20:56,790
It's at some level.
它在某种程度上。

377
00:20:57,830 --> 00:20:59,230
So how do you implement fairness?
那么，你如何实现公平性呢？

378
00:21:01,100 --> 00:21:03,150
One is around robin.
一种是轮询调度算法。

379
00:21:05,330 --> 00:21:12,670
But and but the fundamental thing is that to implement fairness, you need,
但是实现公平性的基本要素是，你需要

380
00:21:12,950 --> 00:21:13,620
in some sense,
在某种意义上，

381
00:21:13,630 --> 00:21:18,260
to divide to visualize the cpu you need to divine devise acpu and give
要将CPU可视化分割，你需要设计一个CPU并进行划分。

382
00:21:18,270 --> 00:21:21,310
each job a fraction of the cpu
每个作业占用CPU的一部分

383
00:21:27,710 --> 00:21:28,900
and now,
现在，

384
00:21:29,210 --> 00:21:30,710
let's talk a little bit about units.
让我们稍微谈谈单位。

385
00:21:32,850 --> 00:21:33,840
In unix,
在Unix中，

386
00:21:36,550 --> 00:21:40,740
it's using an original unit is using priority scheduling.
它使用的是原始单位的优先级调度。

387
00:21:41,590 --> 00:21:43,330
So you have a bunch of priorities,
所以你有一堆优先事项，

388
00:21:44,680 --> 00:21:46,790
as if you remember from last time,
就像你上次记得的那样，

389
00:21:46,800 --> 00:21:52,040
and the jobs and with the highest priority are going to run first.
具有最高优先级的作业将首先运行。

390
00:21:52,610 --> 00:21:55,770
And jobs is a lower priority can run.
而且作业是较低优先级可以运行的。

391
00:21:56,050 --> 00:22:00,360
Only if there are no other jobs is higher priority which are ready to run.
只有当没有其他准备就绪的高优先级作业时，才会执行该作业。

392
00:22:02,420 --> 00:22:03,460
So this is a call.
所以这是一个电话。

393
00:22:03,760 --> 00:22:06,630
But now how do you are going to get some fairness?
但是现在你打算如何实现公平性？

394
00:22:06,930 --> 00:22:07,300
Right?
对吗？

395
00:22:07,820 --> 00:22:12,560
There are I many proposals,
有很多提案。

396
00:22:13,620 --> 00:22:15,880
one way to implement.
一种实现方法。

397
00:22:16,250 --> 00:22:17,360
It's not very scheduled.
这个计划安排得不是很合理。

398
00:22:18,150 --> 00:22:18,560
Okay?
好的？

399
00:22:19,320 --> 00:22:20,350
So this one,
所以这个问题，

400
00:22:20,360 --> 00:22:23,270
and it's a very nice analogy.
这是一个非常好的比喻。

401
00:22:23,690 --> 00:22:25,160
It's basically the lottery scheduling.
这基本上就是抽签调度算法。

402
00:22:25,170 --> 00:22:28,310
You give each job some number of lottery tickets.
你给每个作业分配一定数量的彩票。

403
00:22:29,680 --> 00:22:30,880
And each time,
每次，

404
00:22:31,240 --> 00:22:33,480
each time slice, you randomly pick a winning ticket.
每个时间片，你随机选择一张中奖票。

405
00:22:34,110 --> 00:22:34,520
Right?
对吗？

406
00:22:34,980 --> 00:22:35,690
On average,
平均而言，

407
00:22:35,700 --> 00:22:41,810
the cpu time is proportionally allocated to the number of tickets given
CPU时间按照分配的票数成比例分配

408
00:22:41,820 --> 00:22:42,450
to a job.
找工作。

409
00:22:45,340 --> 00:22:48,710
Now, how you can assign the dockets, right?
现在，你可以如何分配任务单，对吗？

410
00:22:49,190 --> 00:22:50,340
How you are going to.
你打算如何做呢？

411
00:22:50,350 --> 00:22:53,980
And it turns out that the nice thing about this lottery scheduling,
事实证明，这种抽签调度的好处是，

412
00:22:54,430 --> 00:23:03,490
you can approximate some of these other disciplines.
你可以对这些其他学科进行近似。

413
00:23:05,560 --> 00:23:06,590
If you want,
如果你愿意，

414
00:23:07,130 --> 00:23:08,560
or you can use to implement,
或者你可以使用来实现，

415
00:23:09,190 --> 00:23:12,040
like, if you want to implement shortest running time first,
如果你想实现最短运行时间优先算法，

416
00:23:12,450 --> 00:23:15,610
you can give those are small jobs,
你可以给那些小任务。

417
00:23:15,620 --> 00:23:18,490
a much larger number of tickets.
更多的门票数量。

418
00:23:19,130 --> 00:23:19,330
Right?
对吗？

419
00:23:19,540 --> 00:23:21,170
The long jobs get fewer tickets.
长时间的任务获得较少的票数。

420
00:23:22,120 --> 00:23:22,460
Now,
现在，

421
00:23:23,040 --> 00:23:25,330
the nice thing it's also can avoid starvation.
这个好处还可以避免饥饿问题。

422
00:23:27,060 --> 00:23:29,500
If I give to each job,
如果我给每个任务分配

423
00:23:30,470 --> 00:23:31,680
at least one picket,
至少一个哨兵

424
00:23:32,420 --> 00:23:32,670
right?
对的？

425
00:23:32,680 --> 00:23:33,550
At least one picket,
至少有一名哨兵，

426
00:23:34,320 --> 00:23:38,640
then that job is not going to be stuck forever,
那么这个工作不会永远被卡住，

427
00:23:39,670 --> 00:23:44,730
because it will be at some. that is the cat will be selected.
因为它将会在某个地方。也就是说，猫将被选择。

428
00:23:45,420 --> 00:23:46,640
And therefore, it will be scattered.
因此，它将被分散。

429
00:23:51,680 --> 00:23:54,550
This is one advantage of our state priorities, right?
这是我们州政府优先事项的一个优势，对吗？

430
00:23:55,010 --> 00:23:57,200
Again, you restate priorities.
再次，你重新阐述了优先事项。

431
00:23:57,550 --> 00:23:58,560
If a job,
如果一个工作，

432
00:23:59,050 --> 00:24:07,350
a if you are aaa job cannot run unless there is no other job ready to execute,
如果你是一个作业，除非没有其他准备执行的作业，否则无法运行。

433
00:24:07,780 --> 00:24:08,850
which has high approach.
具有高度可行性的方法。

434
00:24:10,980 --> 00:24:15,350
With this one, we say the jobs in the heart already have more tickets,
对于这个问题，我们说心脏中的作业已经有更多的票数了。

435
00:24:15,660 --> 00:24:17,250
but the job is a low priority.
但这个工作是低优先级的。

436
00:24:17,510 --> 00:24:18,610
Have at least on weekend.
至少要有一个周末。

437
00:24:20,010 --> 00:24:20,880
Now I will be stuck.
现在我会被卡住了。

438
00:24:25,580 --> 00:24:25,690
Here.
在这里。

439
00:24:25,700 --> 00:24:26,410
It's an example,
这是一个例子，

440
00:24:28,220 --> 00:24:29,300
lottery scheduling.
抽奖调度。

441
00:24:29,310 --> 00:24:32,460
So assume that you have short jobs and long jobs,
假设你有短作业和长作业，

442
00:24:33,060 --> 00:24:36,870
and you have a job,
而且你有一份工作，

443
00:24:38,230 --> 00:24:39,640
get ten tickets,
请购买十张门票。

444
00:24:39,650 --> 00:24:41,720
and long job get one ticket.
长时间的工作会得到一张票。

445
00:24:42,440 --> 00:24:42,820
Right?
对吗？

446
00:24:44,540 --> 00:24:49,130
If a short job gets ten tickets and a long job gets one ticket,
如果一个短作业获得十张票，而一个长作业获得一张票，

447
00:24:49,550 --> 00:24:59,030
then the cpu get given to the short jobs is 91%, right?
那么，CPU分配给短作业的比例是91%，对吗？

448
00:24:59,650 --> 00:25:01,080
The other one is 9%.
另一个是9%。

449
00:25:01,800 --> 00:25:02,880
Because in total,
因为总的来说，

450
00:25:02,890 --> 00:25:04,880
you have 11 tickets in the system,
系统中有11张票据。

451
00:25:05,580 --> 00:25:07,010
then for the short jobs,
那么对于短作业来说，

452
00:25:07,520 --> 00:25:08,680
one for the long jobs.
一个用于长时间任务的。

453
00:25:10,370 --> 00:25:20,350
If you if you are going to give you have two long jobs,
如果你要执行两个长时间的任务，

454
00:25:23,520 --> 00:25:27,050
and you zero short jobs,
而且你将短作业置零，

455
00:25:28,220 --> 00:25:30,180
you are going to divide,
你要进行除法运算。

456
00:25:30,450 --> 00:25:32,550
because each long job gets on tickets,
因为每个长时间的任务都会被分配到票据上，

457
00:25:32,560 --> 00:25:34,270
you have only two tickets in the system.
系统中只有两张票。

458
00:25:34,600 --> 00:25:36,390
Each of the long jobs will get 50%.
每个长任务将获得50%的份额。

459
00:25:36,400 --> 00:25:38,390
If you have two short jobs,
如果你有两个短任务，

460
00:25:38,400 --> 00:25:40,310
you have 50%, each of short jobs.
你有50%的短作业。

461
00:25:40,320 --> 00:25:41,750
You don't have any long jobs.
你没有任何长时间的任务。

462
00:25:42,180 --> 00:25:43,540
You have ten, short, long,
你有十个，短的，长的。

463
00:25:43,550 --> 00:25:45,460
short jobs and long, long jobs.
短作业和长作业。

464
00:25:45,960 --> 00:25:52,780
You have now101 tickets in the system because each short job will have ten tickets.
您现在系统中有101张票，因为每个短作业都有十张票。

465
00:25:54,310 --> 00:25:57,680
Therefore, the short jobs get,
因此，短作业得到了

466
00:25:59,030 --> 00:26:00,830
they should each issue jobs,
他们应该每个人都发出任务，

467
00:26:00,840 --> 00:26:03,670
each issue job get 9.9%,
每个问题的工作占比为9.9%。

468
00:26:03,970 --> 00:26:05,920
all short jobs will get 99%.
所有短作业将获得99%的优先级。

469
00:26:06,910 --> 00:26:11,890
The a as a long job will get on% and so forth.
作为一个长时间的工作，将会获得百分之几的进展，等等。

470
00:26:13,050 --> 00:26:15,000
Let me see if there is a question.
让我看看是否有问题。

471
00:26:18,670 --> 00:26:20,900
Since the scheduling is probabilistic,
由于调度是概率性的，

472
00:26:20,910 --> 00:26:25,860
isn't there still the possibility that the long job gets started
难道还有可能启动长时间的作业吗？

473
00:26:25,870 --> 00:26:27,100
for quite a while?
很长一段时间了吗？

474
00:26:29,440 --> 00:26:30,120
That's correct.
没错。

475
00:26:30,890 --> 00:26:33,880
The long job can still wait for a while,
长时间的工作还可以等一会儿。

476
00:26:34,400 --> 00:26:41,030
but eventually is going to be selected while in,
但最终会在其中被选择。

477
00:26:44,150 --> 00:26:45,270
say, for instance,
比如说，

478
00:26:45,280 --> 00:26:52,020
with shorter job first or with for a strict priority scheduling,
使用短作业优先或严格优先调度算法。

479
00:26:53,320 --> 00:26:56,080
a job might never ever be scheduled.
一个工作可能永远不会被调度。

480
00:26:57,040 --> 00:27:04,500
If there are always enough lower priority jobs in the system,
如果系统中始终有足够的低优先级作业，

481
00:27:04,510 --> 00:27:05,700
very good question.
非常好的问题。

482
00:27:10,160 --> 00:27:10,530
Okay.
好的。

483
00:27:13,730 --> 00:27:16,600
What if too many short jobs are in the system to give reason
如果系统中有太多短作业，会出现什么情况呢？

484
00:27:16,610 --> 00:27:17,560
of the response time?
响应时间是指系统从接收到请求到产生响应的时间。

485
00:27:18,560 --> 00:27:21,590
You can take a long time.
你可以花很长时间。

486
00:27:21,600 --> 00:27:23,980
So it can be hard to make progress, right?
所以进展可能会很困难，对吗？

487
00:27:23,990 --> 00:27:25,300
Because there are too many jobs.
因为有太多的工作。

488
00:27:25,810 --> 00:27:29,790
So it takes too long to get your thought.
所以你思考的时间太长了。

489
00:27:32,950 --> 00:27:38,480
11answer here is that kick some users out of the system.
这里的答案是将一些用户从系统中踢出去。

490
00:27:44,500 --> 00:27:44,980
Now,
现在，

491
00:27:45,500 --> 00:27:47,460
let's take a step back and let's say,
让我们退后一步，假设一下，

492
00:27:47,470 --> 00:27:53,190
what are the kind of jobs you are expecting to run on to your computer?
你期望在你的计算机上运行哪些类型的工作？

493
00:27:54,090 --> 00:27:56,190
And typically, there is a mix of jobs.
通常情况下，工作岗位是多样化的。

494
00:28:00,400 --> 00:28:03,070
One of them will have the short burst time,
其中一个将具有较短的爆发时间，

495
00:28:03,820 --> 00:28:05,840
and some of them longer burst times.
其中一些进程具有较长的突发时间。

496
00:28:06,710 --> 00:28:09,170
Let's see, think about what are this kind of job?
让我们来看看，思考一下这种工作是什么样的？

497
00:28:09,180 --> 00:28:10,170
What are the possible?
可能的有哪些？

498
00:28:11,310 --> 00:28:12,800
Some jobs are interactive jobs,
有些工作是交互式工作，

499
00:28:13,450 --> 00:28:13,740
right?
对的？

500
00:28:14,640 --> 00:28:15,360
These are,
这些是，

501
00:28:17,890 --> 00:28:20,360
it's editors,
这是编辑器。

502
00:28:21,910 --> 00:28:25,030
your chat application.
你的聊天应用程序。

503
00:28:25,530 --> 00:28:27,920
You're interacting with the browser.
您正在与浏览器进行交互。

504
00:28:28,910 --> 00:28:30,440
And it's not a short burst, right?
这不是一个短暂的爆发，对吗？

505
00:28:30,450 --> 00:28:32,840
It's interactive like the short burst.
它像短暂的爆发一样具有互动性。

506
00:28:33,400 --> 00:28:37,100
They have to respond quickly into the user interaction.
他们必须迅速响应用户的交互。

507
00:28:40,470 --> 00:28:45,780
Then there are other ones which are io it's also io not necessarily the users,
还有其他一些是输入/输出（I/O）的，它也是I/O，不一定是用户的。

508
00:28:45,790 --> 00:28:50,590
but they are waiting for networking to get the data from the network
但是他们正在等待网络获取数据。

509
00:28:51,180 --> 00:28:52,670
or for an eye or to complete.
或者为了一个眼睛或者完成。

510
00:28:53,250 --> 00:28:53,610
Right?
对吗？

511
00:28:55,520 --> 00:29:00,310
There are others which are long run.
还有其他一些是长期的。

512
00:29:00,680 --> 00:29:02,030
Like, for instance,
例如，

513
00:29:02,510 --> 00:29:03,510
one example,
一个例子，

514
00:29:03,520 --> 00:29:05,750
would be a compiler,
将会是一个编译器，

515
00:29:06,770 --> 00:29:07,800
or one example.
或者一个例子。

516
00:29:07,810 --> 00:29:08,520
You do training,
你进行培训。

517
00:29:09,200 --> 00:29:09,760
machine learning.
机器学习。

518
00:29:12,560 --> 00:29:17,790
And you'd expect here that if something is interactive,
在这里，你会期望如果某个东西是交互式的，

519
00:29:17,800 --> 00:29:19,630
it has to get the higher priority,
它必须获得更高的优先级。

520
00:29:20,480 --> 00:29:23,990
because he needs to provide the user good user experience and the one which
因为他需要为用户提供良好的用户体验和满足用户需求的产品。

521
00:29:24,000 --> 00:29:26,470
are not in long running jobs.
不在长时间运行的作业中。

522
00:29:26,880 --> 00:29:29,820
It's okay that they are not interactive because they are running in the background.
它们不需要交互也没关系，因为它们在后台运行。

523
00:29:30,420 --> 00:29:30,630
Right?
对吗？

524
00:29:30,640 --> 00:29:36,570
It doesn't matter if a training neural network model is going to take
训练神经网络模型所需的时间并不重要。

525
00:29:36,940 --> 00:29:39,110
5 hours or 5 hours and 5 minutes.
5小时或5小时5分钟。

526
00:29:42,280 --> 00:29:48,780
These are not will not realize.
这些不会实现。

527
00:29:49,300 --> 00:29:49,700
Okay.
好的。

528
00:29:50,560 --> 00:29:52,230
So again, in general,
所以再次，总的来说，

529
00:29:52,240 --> 00:29:54,270
it's hard to characterize all the application.
很难对所有的应用进行分类。

530
00:29:54,700 --> 00:29:55,100
But,
但是，

531
00:29:55,950 --> 00:30:01,040
again, you can classify broadly in interactive applications.
再次，你可以广泛地将其分类为交互式应用程序。

532
00:30:01,050 --> 00:30:04,800
They have typically have short bars and long running applications,
它们通常具有短的任务栏和长时间运行的应用程序。

533
00:30:04,810 --> 00:30:07,150
which have obviously long reversed.
显然已经很久以前就发生了颠倒。

534
00:30:09,600 --> 00:30:19,030
So in recognizing that this is how early implement the scheduler,
在认识到这是早期实现调度器的方式后，

535
00:30:19,520 --> 00:30:21,610
this is multilevel feedback schedule.
这是多级反馈调度算法。

536
00:30:23,410 --> 00:30:27,120
The mind never scheduling is like it has a bunch of cures,
不安排时间的头脑就像拥有一堆解药一样。

537
00:30:29,170 --> 00:30:31,550
and each queue has a different priority,
每个队列都有不同的优先级。

538
00:30:33,110 --> 00:30:35,570
the different time quant, let me guess.
不同的时间片大小，让我猜一下。

539
00:30:38,320 --> 00:30:45,460
So the cure at the top has a highest priority,
所以位于队列顶部的任务具有最高优先级，

540
00:30:45,470 --> 00:30:46,960
and there were a task.
然后出现了一个任务。

541
00:30:47,300 --> 00:30:50,840
It's the process is in cue first.
这个进程首先在队列中。

542
00:30:52,300 --> 00:30:55,180
And the same time quanta says 8 million seconds.
同时，Quanta也表示为800万秒。

543
00:30:56,810 --> 00:31:04,120
And if a job spends
如果一个作业花费的时间超过了它的时间限制，

544
00:31:05,000 --> 00:31:08,820
too much time on at some level,
在某个层面上花费太多时间

545
00:31:09,660 --> 00:31:13,160
is demoted to the next level.
被降级到下一个级别。

546
00:31:13,770 --> 00:31:15,450
In this case, there's an execute,
在这种情况下，有一个执行操作。

547
00:31:16,030 --> 00:31:22,850
which is quantum of 16 millisecond.
这是16毫秒的量子。

548
00:31:24,670 --> 00:31:27,420
If you spend too much at this level,
如果你在这个层面上花费太多的话，

549
00:31:27,430 --> 00:31:31,280
you are demoted to the next cure,
你被降级到下一个级别。

550
00:31:31,290 --> 00:31:33,810
which is first conference set.
第一个会议集是哪个？

551
00:31:34,560 --> 00:31:35,750
So the first two,
所以前两个，

552
00:31:37,490 --> 00:31:40,680
can each of these levels can use a different schedule and be separate?
每个层级都可以使用不同的调度算法并且相互独立吗？

553
00:31:42,390 --> 00:31:43,630
The first two, in this case,
在这种情况下，前两个

554
00:31:43,640 --> 00:31:45,830
can use round robin.
可以使用轮转调度算法。

555
00:31:46,170 --> 00:31:47,600
The last time first come, first set.
先到先得。

556
00:31:49,770 --> 00:31:50,070
Basically,
基本上，

557
00:31:50,080 --> 00:31:56,660
what does this mean is that if you have an interactive job which are small bursts,
这意味着如果你有一个交互式的任务，它是小的突发性任务，

558
00:31:58,310 --> 00:31:59,950
that will be first endured.
那将是首先要忍受的。

559
00:32:01,060 --> 00:32:02,080
At the first level,
在第一层级上，

560
00:32:02,590 --> 00:32:03,770
as a highest priority,
作为最高优先级，

561
00:32:03,780 --> 00:32:05,250
it will be scheduled quickly.
它将会被快速安排。

562
00:32:06,590 --> 00:32:07,860
If it's a small burst,
如果只是一个小的爆发，

563
00:32:09,480 --> 00:32:12,720
then it relinquishes a cpu, goes to sleep.
然后它释放CPU，进入睡眠状态。

564
00:32:14,480 --> 00:32:17,920
So it will always remain at the first level.
所以它将始终保持在第一级。

565
00:32:19,580 --> 00:32:21,180
Now consider a long job.
现在考虑一个长时间的任务。

566
00:32:22,700 --> 00:32:24,650
Come like training a neural level.
就像训练神经网络一样。

567
00:32:25,510 --> 00:32:28,560
It starts at the first level.
它从第一级开始。

568
00:32:29,880 --> 00:32:31,140
And after a while,
过了一会儿，

569
00:32:31,450 --> 00:32:34,200
say, after several seconds,
说，几秒钟后，

570
00:32:34,780 --> 00:32:35,760
is still running.
仍在运行。

571
00:32:37,700 --> 00:32:38,080
Right?
对吗？

572
00:32:40,630 --> 00:32:44,040
It's going to be in the mounted to the second level.
它将被安装在第二层。

573
00:32:46,400 --> 00:32:49,580
And the second level, if he stays and continuously running for,
而在第二层，如果他留下并持续运行，

574
00:32:51,020 --> 00:32:54,420
say, i'm just making up like for another 1 hour,
我只是编造了一个小时的借口。

575
00:32:54,430 --> 00:32:58,180
then it's pushed to the lower level.
然后它被推送到较低的层级。

576
00:33:00,460 --> 00:33:02,300
So you can see that in this way,
所以你可以看到，以这种方式，

577
00:33:02,820 --> 00:33:04,710
the jobs takes a long time.
这个任务需要很长时间。

578
00:33:04,720 --> 00:33:10,530
They are going to fall through this kind of different levels to the bottom level.
他们将会穿过这些不同的层级直到最底层。

579
00:33:11,140 --> 00:33:12,430
And you'll have lower products.
你将会拥有更低价的产品。

580
00:33:13,560 --> 00:33:15,320
These are very nice mechanics,
这些机制非常好。

581
00:33:15,330 --> 00:33:16,880
but adaptive mechanisms,
但是自适应机制，

582
00:33:17,300 --> 00:33:23,940
but in which that jobs with short bursts remains the high priority,
但在这种情况下，短时间内完成的工作仍然是高优先级的。

583
00:33:23,950 --> 00:33:24,660
high levels.
高级水平。

584
00:33:25,090 --> 00:33:26,430
And the one is lower,
而另一个则更低，

585
00:33:27,250 --> 00:33:31,620
which takes a long time they are going to be demoted
由于花费了很长时间，他们将被降职。

586
00:33:31,930 --> 00:33:35,420
naturally to the levels with a lot of birds.
自然而然地，这些地方有很多鸟类。

587
00:33:39,220 --> 00:33:39,580
Okay?
好的？

588
00:33:42,410 --> 00:33:43,800
The results really here,
结果真的在这里。

589
00:33:43,810 --> 00:33:46,960
you can think you approximate the shortest remaining time.
你可以认为你近似了最短剩余时间。

590
00:33:46,970 --> 00:33:47,480
First.
首先。

591
00:33:48,250 --> 00:33:50,410
Again, if the job is small enough,
如果工作足够小的话，

592
00:33:50,920 --> 00:33:54,190
you always got executed with the highest product.
你总是以最高的产出被执行。

593
00:34:00,710 --> 00:34:02,190
Again, between the queues,
再次强调，在队列之间，

594
00:34:02,200 --> 00:34:03,710
you have fixed priorities.
你有固定的优先级。

595
00:34:04,470 --> 00:34:11,080
And then you can have different time quanta,
然后你可以有不同的时间片大小，

596
00:34:11,090 --> 00:34:15,050
like we saw in these examples between different cures.
就像我们在不同治疗方法之间的这些例子中看到的那样。

597
00:34:23,160 --> 00:34:24,510
Here is a question.
这是一个问题。

598
00:34:25,690 --> 00:34:28,080
This was probably about lottery scheduling, sorry,
这可能是关于抽奖调度的问题，抱歉，

599
00:34:28,090 --> 00:34:30,900
for not saying it bit short job.
对不起，我没有理解你的问题。你能提供更多的细节吗？

600
00:34:31,320 --> 00:34:33,880
These are short job and long job run simultaneous.
这是同时运行的短作业和长作业。

601
00:34:35,480 --> 00:34:39,980
In that case, we assume they don't run to completion.
在这种情况下，我们假设它们不会运行到完成。

602
00:34:40,590 --> 00:34:42,780
We assume a lottery scheduling,
我们假设使用抽签调度算法，

603
00:34:42,790 --> 00:34:44,900
assume a preemptive scheduling.
假设采用抢占式调度。

604
00:34:46,310 --> 00:34:48,460
This is a preemptive scheduling discipline.
这是一种抢占式调度策略。

605
00:34:49,470 --> 00:34:53,240
So you're basically each time qanta is, again,
所以你基本上每次都是在回答问题，是吗？

606
00:34:53,250 --> 00:34:55,920
you run a lottery and your work.
你负责管理一项彩票活动，并且你的工作是运营这个活动。

607
00:34:57,550 --> 00:34:59,630
Cpu to the winning ticket,
中奖票的中央处理器

608
00:35:00,240 --> 00:35:01,750
to the process with the winning ticket.
给获胜票的进程。

609
00:35:02,660 --> 00:35:03,880
So from that perspective,
从那个角度来看，

610
00:35:04,330 --> 00:35:08,020
they are interviewed That the short jobs and long run,
他们正在接受面试，无论是短期工作还是长期发展。

611
00:35:08,030 --> 00:35:09,870
long jobs are intended.
长期工作的目的是。

612
00:35:23,940 --> 00:35:25,020
Now, obviously,
显然，

613
00:35:25,030 --> 00:35:26,300
if the scheduler,
如果调度器，

614
00:35:26,310 --> 00:35:28,860
you can actually fool the scheduler.
你实际上可以欺骗调度器。

615
00:35:30,980 --> 00:35:32,010
For instance,
例如，

616
00:35:32,310 --> 00:35:33,420
if I want,
如果我想的话，

617
00:35:34,250 --> 00:35:37,630
what can I do for my job to remain as a high priority?
如何保持工作的高优先级？

要保持工作的高优先级，你可以考虑以下几点：

1. 确定关键任务：确定工作中最重要的任务，并将其优先处理。这样可以确保你的工作始终处于高优先级。

2. 制定清晰的目标：设定明确的目标，并制定相应的计划和时间表。这样可以帮助你集中精力并按时完成任务。

3. 提前沟通：与团队成员和上级进行沟通，了解他们的期望和优先事项。这样可以确保你的工作与整个团队的目标保持一致。

4. 保持高效率：学会管理时间，避免拖延和浪费时间。使用工具和技术来提高工作效率，如时间管理应用程序、任务管理工具等。

5. 保持灵活性：随时准备应对变化和紧急情况。灵活适应工作需求，及时调整优先级。

6. 持续学习和提升：保持对行业和工作的学习态度，不断提升自己的技能和知识。这样可以增加你在团队中的价值和竞争力。

通过以上方法，你可以保持工作的高优先级，并展现出你的专业能力和价值。

618
00:35:37,640 --> 00:35:42,000
Well, i'm going to insert some io operations from time to time,
好的，我会不时地插入一些IO操作。

619
00:35:42,700 --> 00:35:50,800
because io operations put the process of the job to split to sleep.
因为I/O操作会使作业的进程进入睡眠状态。

620
00:35:51,250 --> 00:35:58,120
And there are 40 to remain at the high in the double level tears.
还有40个保持在双层泪沟的高位。

621
00:36:05,570 --> 00:36:11,200
And that I actually run games in which it is all the law.
而且我实际上运行的游戏中，一切都是法律。

622
00:36:11,210 --> 00:36:13,360
It's an old head program game.
这是一个古老的头部程序游戏。

623
00:36:13,850 --> 00:36:15,880
You try to play against computer.
你想和电脑对战。

624
00:36:17,940 --> 00:36:22,730
The key is to do computation at a higher priority than the company competitor.
关键是将计算任务的优先级设置得比竞争对手高。

625
00:36:25,940 --> 00:36:26,370
So I see,
原来如此，我明白了。

626
00:36:28,600 --> 00:36:29,950
again, the way you do it,
再次，你的做法是这样的，

627
00:36:29,960 --> 00:36:31,470
the way you are doing it,
你现在的做法，

628
00:36:32,240 --> 00:36:37,070
some of these game developers just put a bunch of print depths,
有些游戏开发者只是随意地添加了一堆打印语句。

629
00:36:37,300 --> 00:36:38,410
because the print depths, again,
由于打印深度的原因，再次，

630
00:36:38,420 --> 00:36:41,740
you have io the thread is put us to sleep.
你有IO线程将我们置于休眠状态。

631
00:36:42,270 --> 00:36:45,790
When you come back, it's going to go with a high priority queue.
当你回来的时候，它将进入一个高优先级队列。

632
00:36:45,800 --> 00:36:47,510
While if you don't have to go to sleep,
如果你不必要去睡觉，

633
00:36:47,810 --> 00:36:51,280
you are going to fall through the levels to the bottom level,
你将会从上层逐渐下降到最底层。

634
00:36:51,290 --> 00:36:53,710
and you are going to be with a lot.
你将会有很多任务。

635
00:36:55,770 --> 00:36:55,980
Right?
对吗？

636
00:36:56,210 --> 00:36:56,860
So it's fine.
没问题。

637
00:36:58,960 --> 00:37:00,080
Multicore scheduling.
多核调度。

638
00:37:01,350 --> 00:37:02,300
You have multiple core.
你有多个核心。

639
00:37:02,310 --> 00:37:04,180
Now, all the processors have multiple cores.
现在，所有的处理器都有多个核心。

640
00:37:04,190 --> 00:37:06,100
Your mac has multiple cores,
您的Mac有多个核心，

641
00:37:06,110 --> 00:37:07,420
your pc has multiple cores,
你的电脑有多个核心，

642
00:37:07,430 --> 00:37:09,100
your phones have multiple cores.
你的手机有多个核心。

643
00:37:09,660 --> 00:37:10,060
Algorithm.
算法。

644
00:37:10,070 --> 00:37:11,900
Italy is not a huge difference now,
意大利现在没有太大的差异，

645
00:37:13,320 --> 00:37:14,620
but implementation way,
但是实现方式，

646
00:37:15,150 --> 00:37:17,460
why is there are some things you need to keep in mind.
为什么有一些事情你需要牢记在心？

647
00:37:18,150 --> 00:37:21,330
And one thing to keep in mind is a cash coherence.
还有一件需要记住的事情是现金的一致性。

648
00:37:22,100 --> 00:37:25,170
Every court has its own cash.
每个法庭都有自己的现金。

649
00:37:25,920 --> 00:37:29,910
Therefore, you want to have this affinity scheduling.
因此，您希望使用亲和性调度。

650
00:37:30,210 --> 00:37:38,440
You want to schedule a thread on the same cpu when it doesn't come.
当线程没有到达时，您想要在同一CPU上调度它。

651
00:37:39,090 --> 00:37:39,330
Speak.
说话。

652
00:37:39,340 --> 00:37:39,730
Why?
为了方便学生理解和使用操作系统课程的内容，我会将英文翻译成中文。这样可以帮助学生更好地学习和掌握相关知识。

653
00:37:39,740 --> 00:37:41,450
Because if you do so,
因为如果你这样做的话，

654
00:37:41,990 --> 00:37:42,980
that thread,
那个线程，

655
00:37:44,230 --> 00:37:46,140
you can leverage the date of the set,
你可以利用集合的日期信息。

656
00:37:46,150 --> 00:37:48,860
which is still in the local cache of the same superior.
这仍然在同一个上级的本地缓存中。

657
00:37:49,150 --> 00:37:54,510
If you schedule the thread on a different cpu then that cash will not have
如果你将线程调度到不同的CPU上，那么缓存将不会存在。

658
00:37:54,520 --> 00:37:55,200
any date out.
有任何日期发布了吗？

659
00:37:55,210 --> 00:37:55,660
That's right.
没错。

660
00:37:59,190 --> 00:38:00,900
Speed, lock and multiprocessor.
速度、锁定和多处理器。

661
00:38:03,310 --> 00:38:04,380
Let me guess.
让我猜一下。

662
00:38:08,650 --> 00:38:11,910
It turns out that the one way,
原来如此，只有一种方式，

663
00:38:11,920 --> 00:38:13,790
actually to,
实际上，要，

664
00:38:15,900 --> 00:38:17,990
especially for multiprocessors,
特别是针对多处理器系统，

665
00:38:20,300 --> 00:38:24,530
there are two reasons or you use as spin locks.
使用自旋锁有两个原因。

1. 等待时间短：自旋锁适用于等待时间短的情况。当线程需要获取锁时，如果锁已经被其他线程占用，该线程会一直循环检查锁是否可用，而不会进入睡眠状态。这样可以避免线程切换的开销，提高了锁的获取效率。

2. 锁竞争激烈：自旋锁适用于锁竞争激烈的情况。当多个线程同时竞争同一个锁时，自旋锁可以减少线程切换的次数，提高并发性能。因为自旋锁不会主动释放CPU资源，而是一直循环检查锁是否可用，所以在锁竞争激烈的情况下，自旋锁的效果会更好。

666
00:38:25,670 --> 00:38:29,180
The spin lock is just waiting for some condition to become true,
自旋锁只是在等待某个条件变为真时。

667
00:38:29,190 --> 00:38:32,680
and you can do the test and set on a particular value, right?
你可以对特定的值进行测试和设置，对吗？

668
00:38:33,010 --> 00:38:36,450
It's like think about acquiring the law, right?
这就像是考虑获取法律一样，对吗？

669
00:38:37,300 --> 00:38:40,010
There are two cages to use a spin lock, one.
有两种方式可以使用自旋锁，一种是使用一个锁。

670
00:38:40,460 --> 00:38:44,170
It's typically when you have multiple strides to execute at the same time,
当您需要同时执行多个步长时，通常会出现这种情况。

671
00:38:44,180 --> 00:38:44,810
like, for instance,
例如，比如说，

672
00:38:44,820 --> 00:38:47,090
you have two strategies communicate between each other,
你们有两种策略可以相互沟通，

673
00:38:47,360 --> 00:38:48,970
you have to run them at the same time.
你需要同时运行它们。

674
00:38:49,520 --> 00:38:50,640
So you want,
所以你想要，

675
00:38:50,650 --> 00:38:55,990
then the threats to wait for each other to be scheduled at the same time.
然后等待彼此被安排在同一时间的威胁。

676
00:38:56,640 --> 00:38:58,190
If I said it's scheduled.
如果我说已经安排好了。

677
00:38:58,760 --> 00:39:00,430
First, the second thread,
首先，第二个线程，

678
00:39:01,360 --> 00:39:04,270
it has to wait for the second set to be scheduled, in order to say,
它必须等待第二组被安排，才能说，

679
00:39:04,280 --> 00:39:04,790
for instance,
例如，

680
00:39:04,800 --> 00:39:05,870
to start the communication.
开始沟通。

681
00:39:07,140 --> 00:39:09,210
You use, typically for that test and set.
通常情况下，你会使用测试和设置（test and set）操作。

682
00:39:09,220 --> 00:39:11,330
Now, the problem is this test and set.
现在，问题是这个测试和设置（test and set）操作。

683
00:39:12,050 --> 00:39:14,380
If this test and set is done on,
如果对此进行测试和设置操作，

684
00:39:14,970 --> 00:39:18,750
you have different threads on different course.
你在不同的课程中有不同的线程。

685
00:39:19,190 --> 00:39:25,560
The piston said you are going to involve aaa right?
活塞说你打算涉及aaa对吗？

686
00:39:25,880 --> 00:39:27,530
If you remember the test and set,
如果你还记得测试和设置操作，

687
00:39:27,810 --> 00:39:30,230
it takes a value from the other is savage.
它从另一个地方获取一个值是残酷的。

688
00:39:31,010 --> 00:39:34,940
And then set that value to one,
然后将该值设置为1，

689
00:39:34,950 --> 00:39:39,740
irrespective of what was the value before and write it back in the memory,
无论之前的值是什么，都将其写回内存中。

690
00:39:40,750 --> 00:39:43,030
and then return the original value.
然后返回原始值。

691
00:39:44,740 --> 00:39:46,930
This is what is less than said, if you remember.
这是比所说的更少的东西，如果你记得的话。

692
00:39:47,460 --> 00:39:51,370
But if I am going to write and another test and set is going to read
但是如果我要写入，而另一个测试和设置操作要读取

693
00:39:51,380 --> 00:39:53,210
from a different processor,
来自不同的处理器，

694
00:39:53,630 --> 00:39:58,060
then you are going to the value has to go through the main memory
那么你要传递的值必须经过主内存。

695
00:39:58,070 --> 00:39:59,860
and then go back between.
然后来回切换。

696
00:40:00,160 --> 00:40:05,030
It is going to go to me to go to the other process.
它将会传递给另一个进程。

697
00:40:05,040 --> 00:40:07,230
You can understand that any of these investments,
你可以理解这些投资中的任何一项，

698
00:40:07,880 --> 00:40:12,550
if two sides of the good test and set and they run on different cp us,
如果两个好的测试和设置的一侧在不同的 CPU 上运行，

699
00:40:12,830 --> 00:40:14,770
then you are going to ping pong,
那么你们要进行乒乓球比赛了，

700
00:40:14,780 --> 00:40:18,070
the value between each other without doing anything.
彼此之间的值在不做任何操作的情况下保持不变。

701
00:40:21,570 --> 00:40:23,180
And another way to do it,
还有另一种方法来做这件事，

702
00:40:23,190 --> 00:40:27,150
if you need to do that is to do this test and set.
如果你需要做这个，就需要进行这个测试和设置。

703
00:40:27,560 --> 00:40:30,850
Basically, instead of doing having in the wildest and set,
基本上，不再进行最疯狂和设定的行为。

704
00:40:31,240 --> 00:40:32,640
in the while you have the value,
在这期间，你拥有这个值。

705
00:40:32,650 --> 00:40:33,880
just look at the value.
只需查看数值即可。

706
00:40:34,410 --> 00:40:36,630
You look for the value, for the inquiry,
你在寻找价值，为了查询，

707
00:40:36,640 --> 00:40:41,380
look for the value to become zero.
寻找数值变为零。

708
00:40:42,730 --> 00:40:46,580
Then this is going to just do a read.
那么这只是进行读取操作。

709
00:40:47,100 --> 00:40:49,570
So you read local value always.
所以你总是读取本地值。

710
00:40:52,650 --> 00:40:57,000
Then you are going to do again a while at best and said,
然后你最多再做一会儿，然后说。

711
00:40:57,310 --> 00:40:58,650
if the value is zero.
如果值为零。

712
00:40:58,660 --> 00:41:02,400
And the reason it is a second test and set is because the race condition,
而之所以是第二次测试和设置，是因为存在竞争条件。

713
00:41:02,630 --> 00:41:03,820
because you don't want,
因为你不想要。

714
00:41:04,200 --> 00:41:08,320
because you want to acquire the lock in this case,
因为在这种情况下你想要获取锁。

715
00:41:08,330 --> 00:41:10,880
or which means to set the value to one.
或者表示将值设置为1。

716
00:41:11,200 --> 00:41:15,270
You don't know the race condition is that two threads executing
你不知道什么是竞态条件，即两个线程同时执行。

717
00:41:15,280 --> 00:41:16,990
test and set at the same time,
同时测试和设置

718
00:41:17,230 --> 00:41:18,660
they receive the value zero,
它们接收到了零值。

719
00:41:18,670 --> 00:41:20,580
and then they both of them,
然后他们两个都这样做了。

720
00:41:20,810 --> 00:41:22,110
they are going to settle one.
他们打算解决这个问题。

721
00:41:22,570 --> 00:41:23,680
In order to avoid that,
为了避免这种情况，

722
00:41:23,690 --> 00:41:26,160
you do a test and set again to the value.
你再次进行测试并设置值。

723
00:41:26,680 --> 00:41:32,000
You have only one will succeed because test and said is going to be atom.
你只有一个机会成功，因为测试结果显示它将成为原子。

724
00:41:33,290 --> 00:41:36,480
But again, the main.here is that you avoid a right,
但是重要的是，你要避免一个错误。

725
00:41:36,890 --> 00:41:38,100
because you avoid the right,
因为你回避了正确的事情

726
00:41:38,110 --> 00:41:40,350
you are going to go through the main memory,
你将要遍历主内存。

727
00:41:40,360 --> 00:41:45,300
and you are going to go to avoid a lot of context,
你将要避免许多背景信息，

728
00:41:45,310 --> 00:41:50,030
which is this.
这是CS162计算机操作系统课程。

729
00:41:50,620 --> 00:41:51,650
That's a great question.
这是一个很好的问题。

730
00:41:53,230 --> 00:41:55,670
Is this an issue of correctness of all efficient?
这是一个关于正确性和效率的问题吗？

731
00:41:55,680 --> 00:41:57,700
This is a progression from outside.
这是一个从外部进行的进展。

732
00:42:00,950 --> 00:42:02,140
It's about it.
关于这个。

733
00:42:02,350 --> 00:42:03,580
This is about efficiency.
这是关于效率的问题。

734
00:42:03,840 --> 00:42:04,890
It's not about correctness.
这不是关于正确性的问题。

735
00:42:05,210 --> 00:42:07,240
Both codes are correct.
这两段代码都是正确的。

736
00:42:07,800 --> 00:42:11,030
Both using both test and set and test and set are core.
同时使用测试并设置和测试并设置是核心的。

737
00:42:11,480 --> 00:42:12,700
It's only about the patients.
只涉及患者相关的事情。

738
00:42:19,790 --> 00:42:20,180
Good.
好的。

739
00:42:25,820 --> 00:42:33,950
This is exactly why when these are used this spin locks and spin waiting.
这就是为什么当使用这些时会出现自旋锁和自旋等待的原因。

740
00:42:35,160 --> 00:42:36,430
When multiple threads, again,
当多个线程再次

741
00:42:36,440 --> 00:42:37,750
like ii just mentioned,
就像我刚才提到的，

742
00:42:37,760 --> 00:42:39,470
work together on a multiple floor,
在多层楼上一起工作

743
00:42:39,480 --> 00:42:41,030
try to schedule them together.
尽量将它们安排在一起。

744
00:42:41,230 --> 00:42:43,360
This is also called gang gang scheduling.
这也被称为gang gang调度。

745
00:42:44,330 --> 00:42:47,240
There are other ways to do it instead of using spin lock.
除了使用自旋锁之外，还有其他的方法可以实现。

746
00:42:47,250 --> 00:42:51,750
Another way is basically to tell the os to tell the application.
另一种方法基本上是告诉操作系统去告诉应用程序。

747
00:42:51,920 --> 00:42:56,350
Iiii could schedule only three of your threads, and you take care,
我只能为你的三个线程安排时间，请注意。

748
00:42:57,920 --> 00:43:01,030
you should that you have three slides with running parallel.
你应该有三张幻灯片同时运行。

749
00:43:01,410 --> 00:43:04,900
So you can figure the way you run the program,
所以你可以找到运行程序的方法，

750
00:43:05,440 --> 00:43:08,270
knowing that you have only three slides which are running in power.
知道你只有三张幻灯片在播放。

751
00:43:08,760 --> 00:43:08,880
Right?
对吗？

752
00:43:09,290 --> 00:43:10,480
By the way,
顺便说一下，

753
00:43:12,090 --> 00:43:13,680
there is another reason.
还有另一个原因。

754
00:43:15,070 --> 00:43:18,890
There is another example in which you do this been a spin locks.
还有另一个例子，其中你可以使用自旋锁来实现这一点。

755
00:43:19,400 --> 00:43:25,280
And the reason is that if you expect that you have an eye operation,
原因是如果你预计要进行眼部手术，

756
00:43:25,550 --> 00:43:27,720
which we expect to finish very quickly,
我们预计会很快完成。

757
00:43:30,190 --> 00:43:36,020
so this is to avoid the context switch.
这样做是为了避免上下文切换。

758
00:43:36,590 --> 00:43:38,740
So say a context switch, it takes 1 millisecond,
所以说，上下文切换需要1毫秒的时间。

759
00:43:39,940 --> 00:43:41,110
but you are a program,
Yes, I am a program designed to assist with tasks such as translation. How can I help you today?

760
00:43:41,120 --> 00:43:44,300
and you do an operation which takes 0.1 millisecond.
你执行一个耗时为0.1毫秒的操作。

761
00:43:45,210 --> 00:43:53,030
So you do not want to be just suspending a delinquent acpu and also is
所以你不只是想暂停一个违约的ACPU，而且还是...

762
00:43:53,040 --> 00:43:54,830
not very effective for the system,
对系统来说并不是很有效。

763
00:43:55,110 --> 00:43:58,470
because it takes 1 million seconds to which is wasted time
因为这需要100万秒，这是浪费的时间。

764
00:43:58,480 --> 00:44:00,390
to contact switching to another strike.
切换到另一个罢工联系方式。

765
00:44:01,280 --> 00:44:02,890
Instead, you just do us.
相反，你只需要为我们做事。

766
00:44:03,530 --> 00:44:05,000
You are waiting, busy,
你正在等待，忙碌着。

767
00:44:05,010 --> 00:44:08,010
waiting for the for the eye operation to complete.
等待眼部手术完成。

768
00:44:08,020 --> 00:44:11,650
And then you write only for 0.1 millisecond and then continue.
然后你只需要写入0.1毫秒，然后继续。

769
00:44:12,120 --> 00:44:12,520
Right?
对吗？

770
00:44:12,720 --> 00:44:13,710
No contact switching.
不进行接触切换。

771
00:44:14,040 --> 00:44:16,230
You spend wasted 10.10 millisecond,
你浪费了10.10毫秒。

772
00:44:16,240 --> 00:44:17,630
but it's shorter than 1 millisecond.
但它比1毫秒还要短。

773
00:44:17,640 --> 00:44:18,590
It's a contact switching.
这是一种联系切换。

774
00:44:19,010 --> 00:44:22,380
You are going to get much better response time because you
由于您将获得更好的响应时间，因为您

775
00:44:22,390 --> 00:44:25,180
are continue to run instead of waiting to be scheduled again.
继续运行而不是等待重新调度。

776
00:44:27,490 --> 00:44:30,120
Announcements, congrats for finishing with them on.
公告，恭喜你已经完成它们了。

777
00:44:30,440 --> 00:44:32,950
We started to grade it will take a little bit of time.
我们已经开始评分了，需要一点时间。

778
00:44:33,240 --> 00:44:37,070
We'll let you know for sure that is the ada to give your grading on monday,
我们会确保在周一之前通知您，这是给您评分的时间。

779
00:44:37,080 --> 00:44:40,960
hopefully will be very close to monday after monday.
希望在周一之后的周一非常接近。

780
00:44:41,830 --> 00:44:44,340
Homework two is due on monday.
作业二的截止日期是星期一。

781
00:44:44,870 --> 00:44:49,530
And project one code and final reporting member is due on wednesday next week.
项目一的代码和最终报告成员将于下周三截止。

782
00:44:51,040 --> 00:44:51,480
Now.
现在。

783
00:44:51,770 --> 00:44:54,440
Ii understand that things are difficult, right?
我理解事情很困难，对吗？

784
00:44:54,450 --> 00:44:58,630
It's like we are still in this kind of remote instruction.
就好像我们还在进行这种远程教学一样。

785
00:44:58,640 --> 00:45:01,990
It's you still have a tough time,
你仍然感到困难，

786
00:45:02,000 --> 00:45:03,630
maybe home and so forth,
也许是家庭等等

787
00:45:04,390 --> 00:45:06,580
and make making things work.
并使事物运作起来。

788
00:45:07,170 --> 00:45:08,840
You are stressed.
你感到有压力。

789
00:45:08,850 --> 00:45:14,400
So make sure that your da understand any issue that you may be having
所以请确保你的数据管理员了解你可能遇到的任何问题。

790
00:45:14,410 --> 00:45:15,180
because of that,
因此，

791
00:45:15,190 --> 00:45:17,610
or and also is a group.
"or"和"and"也是一组。

792
00:45:18,140 --> 00:45:19,630
And if you,
如果你，

793
00:45:19,910 --> 00:45:21,400
if you want to escalate,
如果你想升级处理，

794
00:45:22,290 --> 00:45:23,960
i'll be happy to meet with a group,
我很乐意与一个小组见面。

795
00:45:23,970 --> 00:45:25,240
just send emails,
只需发送电子邮件即可。

796
00:45:25,540 --> 00:45:26,110
an email,
一封电子邮件，

797
00:45:26,120 --> 00:45:32,110
and i'll be happy to meet with you and provide some best practices
我很乐意与您会面并提供一些最佳实践。

798
00:45:32,120 --> 00:45:33,010
and some advice.
还有一些建议。

799
00:45:41,300 --> 00:45:44,860
So next, let's talk about real time scheduling.
接下来，让我们来谈谈实时调度。

800
00:45:46,430 --> 00:45:47,740
Real time scheduling,
实时调度

801
00:45:47,750 --> 00:45:50,830
think about you,
想着你，

802
00:45:51,260 --> 00:45:58,990
your the programs which runs on your car,
你的车上运行的程序。

803
00:45:59,700 --> 00:46:02,180
like abs anti blocking,
像绝对值反阻塞这样的功能

804
00:46:02,190 --> 00:46:05,250
whatever for breaks.
为了休息。

805
00:46:06,030 --> 00:46:10,200
You have in your car, you have probably of processors,
你的车上可能装有处理器。

806
00:46:10,980 --> 00:46:12,440
tens hundreds of programs run.
数以十计的程序正在运行。

807
00:46:13,040 --> 00:46:13,530
Okay?
好的？

808
00:46:14,530 --> 00:46:15,800
Or think about self driving.
或者考虑一下自动驾驶技术。

809
00:46:17,550 --> 00:46:22,260
You really want their predictable performance.
你真的希望它们有可预测的性能。

810
00:46:23,300 --> 00:46:27,150
You run sinks to finish by a certain time,
你需要在特定时间内完成任务。

811
00:46:28,490 --> 00:46:33,720
like our steering or it's out in a self driving car.
就像我们的方向盘一样，它在自动驾驶汽车中是不存在的。

812
00:46:33,990 --> 00:46:35,160
You need to steer in time, right?
你需要及时转向，对吗？

813
00:46:35,170 --> 00:46:37,060
If it doesn't steer in time, you have an accident.
如果它不能及时转向，你就会发生事故。

814
00:46:39,390 --> 00:46:40,520
So therefore,
因此，

815
00:46:40,530 --> 00:46:42,280
these are the core the power plant.
这些是核电厂的核心部件。

816
00:46:46,050 --> 00:46:51,210
Think about landing and taking off for airplanes,
考虑一下飞机的起降，

817
00:46:51,220 --> 00:46:53,050
which is done automatically.
这是自动完成的。

818
00:46:54,080 --> 00:46:55,400
For all of these use cases,
对于所有这些使用情况，

819
00:46:55,410 --> 00:46:56,720
you need to have programs.
你需要有程序。

820
00:46:57,110 --> 00:46:57,590
For sure,
当然可以。

821
00:46:58,840 --> 00:47:00,230
you don't get starvation,
你不会遭遇饥饿问题。

822
00:47:01,090 --> 00:47:01,480
right?
对的吗？

823
00:47:02,120 --> 00:47:04,630
And you can predict these are predictable.
你可以预测这些是可预测的。

824
00:47:05,580 --> 00:47:07,170
Now, the real time is, again,
现在，实时时间是，再次，

825
00:47:07,180 --> 00:47:12,580
is predictable predictability about things happening by a certain time.
可预测性是指事物在特定时间内发生的可能性。

826
00:47:13,850 --> 00:47:16,090
It's not about being fast.
这不是关于速度的问题。

827
00:47:19,900 --> 00:47:22,610
And there are multiple classes about real time.
还有多个关于实时系统的课程。

828
00:47:22,840 --> 00:47:24,590
In real time, it's again, a big area.
实时性，又是一个广阔的领域。

829
00:47:24,600 --> 00:47:27,470
There are conferences only dedicated real time.
有一些专门致力于实时计算的会议。

830
00:47:29,670 --> 00:47:31,180
It's about meetings, the deadlines, right?
是关于会议和截止日期的吗？

831
00:47:31,190 --> 00:47:34,140
You have some deadlines by some task is to finish.
你有一些任务的截止日期需要完成。

832
00:47:35,610 --> 00:47:38,200
And in these areas,
在这些领域中，

833
00:47:38,210 --> 00:47:39,440
there are different categories.
有不同的分类。

834
00:47:39,450 --> 00:47:42,080
There are soft real deadlines,
有软实时截止日期，

835
00:47:42,090 --> 00:47:43,320
hard real time deadlines.
硬实时截止时间。

836
00:47:43,330 --> 00:47:44,680
You need to meet all the deadlines.
你需要按时完成所有的截止日期。

837
00:47:45,640 --> 00:47:47,430
Several times, best effort.
尽力而为，多次尝试。

838
00:47:47,880 --> 00:47:48,950
Try to be your best to meet.
尽力争取达到最好的结果。

839
00:47:48,960 --> 00:47:49,390
Most of them.
大部分。

840
00:47:50,260 --> 00:47:52,910
Depends on the application that you expect.
这取决于您期望的应用程序。

841
00:47:52,920 --> 00:47:54,030
There are a lot of algorithms,
有很多算法。

842
00:47:54,040 --> 00:47:56,190
and the algorithms scaling algorithms are quite different.
而且算法的扩展算法也非常不同。

843
00:47:58,400 --> 00:48:01,750
And we are going to look at only one, which is very simple,
我们将只研究一个非常简单的问题，

844
00:48:01,760 --> 00:48:03,230
which is early deadline first.
哪个是先到期的截止日期。

845
00:48:04,690 --> 00:48:06,480
By the way, another,
顺便说一下，另外一个问题，

846
00:48:06,490 --> 00:48:08,560
for an example of a soft real time,
软实时的一个例子是，

847
00:48:08,810 --> 00:48:09,920
is for multimedia,
是为了多媒体。

848
00:48:09,930 --> 00:48:15,960
for your playing back video or the voice over when you chat over your over phone.
用于在手机通话时播放视频或语音的功能。

849
00:48:16,390 --> 00:48:16,780
Right?
对吗？

850
00:48:18,050 --> 00:48:21,420
It's great to have hard deadlines.
有明确的截止日期是很好的。

851
00:48:21,710 --> 00:48:22,970
Your message,
您的留言，

852
00:48:23,300 --> 00:48:25,770
what you are saying to arrive to the other and say
你要说什么才能到达另一个地方并传达信息？

853
00:48:25,780 --> 00:48:28,170
within 15 minutes seconds never later.
15分钟内，绝不晚于。

854
00:48:28,490 --> 00:48:29,730
But if it's alive,
但如果它还活着，

855
00:48:30,220 --> 00:48:31,410
it's a little bit longer.
这个有点长。

856
00:48:31,650 --> 00:48:32,160
It's okay.
没问题。

857
00:48:32,490 --> 00:48:33,790
The humans are going to adapt.
人类将会适应。

858
00:48:39,110 --> 00:48:39,820
And here we are,
我们到了，

859
00:48:40,870 --> 00:48:44,860
and we are going to talk about only ones are scheduling, this discipline,
我们将讨论的是只有一次调度的这个学科。

860
00:48:44,870 --> 00:48:46,180
which is a leader line first.
首先是引线。

861
00:48:46,910 --> 00:48:48,050
But here is a model.
但是这里有一个模型。

862
00:48:48,570 --> 00:48:52,170
The model is that the task have deadlines.
这个模型是任务有截止日期。

863
00:48:53,100 --> 00:48:57,420
This they declare about the computation time is now.
他们声明的是关于计算时间的现状。

864
00:48:58,220 --> 00:49:00,450
So here we are talking about sinks,
所以我们现在在讨论水槽，

865
00:49:00,970 --> 00:49:02,880
getting repeatedly being done.
重复进行。

866
00:49:05,810 --> 00:49:09,360
You have pretty good idea about each when each task,
你对每个任务的情况有很好的了解，

867
00:49:09,370 --> 00:49:11,280
how long each task is going to take.
每个任务需要多长时间完成。

868
00:49:11,970 --> 00:49:16,160
It's different from general case in which it's hard to predict the future.
这与一般情况不同，一般情况下很难预测未来。

869
00:49:16,520 --> 00:49:18,030
Here, you have to predict the future,
在这里，你需要预测未来。

870
00:49:18,040 --> 00:49:22,920
because how can you set up a deadline without knowing how much
因为你不知道有多少工作量，所以怎么能设定一个截止日期呢？

871
00:49:22,930 --> 00:49:23,800
a conversation will take?
需要多长时间进行一次对话？

872
00:49:24,280 --> 00:49:25,080
It's impossible.
这是不可能的。

873
00:49:26,180 --> 00:49:30,900
So it's part of the game here that you are going to know how long a task
在这里，你将知道一个任务需要多长时间，这是游戏的一部分。

874
00:49:30,910 --> 00:49:31,940
is going to take.
即将进行。

875
00:49:32,890 --> 00:49:33,360
Okay.
好的。

876
00:49:34,300 --> 00:49:35,490
Now the question is,
现在的问题是，

877
00:49:35,500 --> 00:49:36,690
you have multiple tasks.
你有多个任务。

878
00:49:36,700 --> 00:49:40,570
Each of them, they have certain computation time and certain deadlines.
每个任务都有一定的计算时间和截止时间。

879
00:49:41,180 --> 00:49:47,740
The computer, the thing is that can all the task meets at that place.
计算机，它是能够集中完成所有任务的工具。

880
00:49:48,050 --> 00:49:48,790
That's a good question.
这是一个很好的问题。

881
00:49:50,520 --> 00:49:50,800
Right?
对吗？

882
00:49:51,170 --> 00:49:53,760
Here is one of the example of scheduling.
这是一个调度的示例之一。

883
00:49:54,550 --> 00:49:56,260
Again, it's preemptive.
再次强调，这是一种抢占式的操作方式。

884
00:49:56,270 --> 00:49:59,680
You still have time quanta between these tasks.
你在这些任务之间还有一些时间间隔。

885
00:50:01,180 --> 00:50:03,190
And it turns out this other deadlines,
结果发现还有其他的截止日期，

886
00:50:03,800 --> 00:50:05,490
the up arrows.
上箭头。

887
00:50:07,370 --> 00:50:09,890
The answer is apparatus is when the task,
答案是设备是指完成任务时所使用的工具或装置。

888
00:50:11,360 --> 00:50:13,730
even which triggers the computation arrives.
即使触发计算的事件到达。

889
00:50:14,380 --> 00:50:18,040
And the down arrows are the deadlines.
而向下的箭头表示截止日期。

890
00:50:18,900 --> 00:50:22,530
And here is an example in which this scheduling,
以下是一个示例，其中使用了这种调度算法，

891
00:50:22,540 --> 00:50:29,010
particular scheduling of these tasks is going to violate the deadlines for desktop.
这些任务的特定调度将违反桌面的截止日期。

892
00:50:32,890 --> 00:50:33,320
Now,
现在，

893
00:50:35,100 --> 00:50:35,970
I like I mentioned,
我喜欢我之前提到的。

894
00:50:35,980 --> 00:50:37,610
we are going to learn about one
我们将要学习关于一个的内容。

895
00:50:37,620 --> 00:50:40,730
such a scheduling discipline and leader line first.
这是一种调度策略，即先处理领导者行。

896
00:50:42,090 --> 00:50:42,680
Difficult.
困难。

897
00:50:42,690 --> 00:50:47,810
They assume that the task I is periodic is period pi meaning
他们假设任务I是周期性任务，其周期为pi。

898
00:50:47,820 --> 00:50:50,540
that and computation ci meaning
"that and computation ci meaning" can be translated to "那个和计算的意思是什么?" in Chinese.

899
00:50:50,550 --> 00:50:53,830
that in each period,
每个周期中，

900
00:50:54,080 --> 00:50:58,500
you have to perform a computation for that task,
你需要执行一个计算任务。

901
00:50:59,760 --> 00:51:01,780
like, for instance,
例如，比如说，

902
00:51:01,790 --> 00:51:03,340
every 100 millisecond,
每100毫秒，

903
00:51:03,670 --> 00:51:06,680
the task needs to perform a computation of 10 millisecond.
该任务需要执行一个10毫秒的计算。

904
00:51:07,610 --> 00:51:08,380
Example.
例子。

905
00:51:08,840 --> 00:51:09,820
Think about,
思考一下，

906
00:51:10,990 --> 00:51:14,430
It's again, something like a self driving car or anything in the car.
这又是关于自动驾驶汽车或车内其他事物的问题。

907
00:51:14,750 --> 00:51:19,640
You have sensors which are like video cameras and so forth,
你有类似于视频摄像头等传感器。

908
00:51:19,940 --> 00:51:26,360
which periodically take take a measurements,
定期进行测量的操作。

909
00:51:26,790 --> 00:51:30,660
maybe the state of the brake or the speed,
可能是刹车状态或速度的问题。

910
00:51:31,070 --> 00:51:33,630
or obviously a video frame.
或者显然是一个视频帧。

911
00:51:34,120 --> 00:51:34,480
Right?
对吗？

912
00:51:35,280 --> 00:51:37,410
And these are periodic.
这些是周期性的。

913
00:51:37,860 --> 00:51:39,100
And they need to be processed.
它们需要被处理。

914
00:51:40,340 --> 00:51:42,330
Before the next measurement mistaken,
在下一次测量之前，误解了，

915
00:51:42,340 --> 00:51:44,180
we need to process the previous measure.
我们需要处理之前的测量数据。

916
00:51:44,940 --> 00:51:46,360
But that's kind of my motivation.
但这正是我的动力所在。

917
00:51:48,490 --> 00:51:51,730
And the early deadline first is very simple,
而且早期的截止日期首先非常简单，

918
00:51:52,190 --> 00:51:53,420
is basically saying,
基本上是在说，

919
00:51:53,430 --> 00:51:54,740
like the name implies,
正如名称所示，

920
00:51:55,080 --> 00:51:59,970
you always schedule the task whose deadline is the earliest.
你总是安排最早截止日期的任务。

921
00:52:04,240 --> 00:52:04,750
That's it.
就是这样。

922
00:52:05,180 --> 00:52:06,150
Let's take an example.
让我们举个例子。

923
00:52:06,800 --> 00:52:07,300
Okay.
好的。

924
00:52:07,700 --> 00:52:10,350
So let's have three tasks.
所以我们来设定三个任务。

925
00:52:11,030 --> 00:52:12,300
And for each task,
对于每个任务，

926
00:52:12,730 --> 00:52:17,670
the two numbers in parentages represent the period,
百分比中的两个数字表示时间段。

927
00:52:18,160 --> 00:52:21,980
the first number, and how long it needs to come?
第一个数字是多少，还需要多长时间才能到达？

928
00:52:22,320 --> 00:52:24,270
It should take to compute in this period.
在这个时间段内应该完成计算。

929
00:52:25,670 --> 00:52:26,690
So for one,
首先，

930
00:52:27,040 --> 00:52:28,960
means that every 4 time, you need say,
意思是每4次，你需要说一次。

931
00:52:28,970 --> 00:52:30,760
for every set 4 seconds,
每隔4秒一次。

932
00:52:32,250 --> 00:52:34,770
t one is requires 1 second of computation.
每个任务需要1秒的计算时间。

933
00:52:34,780 --> 00:52:40,320
The two during 5 seconds requires 2 seconds of computation.
在5秒钟内，需要2秒的计算时间。

934
00:52:40,860 --> 00:52:43,940
These three average 7 seconds requires 2 seconds of competition.
这三个平均需要7秒，需要2秒的竞争时间。

935
00:52:44,700 --> 00:52:44,960
Right?
对吗？

936
00:52:45,750 --> 00:52:47,730
And these are the first deadlines, right?
这些是第一个截止日期，对吗？

937
00:52:47,740 --> 00:52:52,360
Because you need to finish to process in the current period
因为你需要在当前时间段内完成处理任务。

938
00:52:52,370 --> 00:52:54,660
before the next period starts.
在下一个时期开始之前。

939
00:52:56,420 --> 00:53:02,030
41, the first deadline is Time for, sorry,
41，第一个截止日期是时间为，抱歉，

940
00:53:02,040 --> 00:53:04,550
42 is five, 4037.
42 是五，4037。

941
00:53:06,420 --> 00:53:07,390
So there are four.
所以有四个。

942
00:53:07,700 --> 00:53:08,280
First,
首先，

943
00:53:09,600 --> 00:53:15,970
you are going to schedule and say that i'm going to hear each one.
你将安排并通知我每个人的时间安排。

944
00:53:16,920 --> 00:53:19,050
So first, you are going to schedule.
首先，你需要进行调度。

945
00:53:19,060 --> 00:53:19,490
You are.
你是。

946
00:53:20,260 --> 00:53:20,680
Right?
对吗？

947
00:53:20,910 --> 00:53:21,100
Why?
为了方便中文用户理解和阅读，我会将英文内容翻译成中文。这样可以更好地帮助您解决问题和理解相关知识。

948
00:53:21,110 --> 00:53:22,850
Because the deadline the earliest.
因为截止日期最早。

949
00:53:23,500 --> 00:53:23,650
Right?
对吗？

950
00:53:23,660 --> 00:53:24,170
You see,
你看，

951
00:53:25,020 --> 00:53:28,240
is that for the other deadlines are at five and seven,
其他截止日期是五点和七点吗？

952
00:53:29,450 --> 00:53:30,650
once you are done of that,
一旦你完成了那个任务，

953
00:53:30,900 --> 00:53:32,210
you are going to schedule p two.
你要安排进程二。

954
00:53:32,890 --> 00:53:36,720
And let's assume that we don't preempt here, for simplicity,
假设我们在这里不进行抢占，为了简单起见，

955
00:53:40,770 --> 00:53:46,680
because the two has earlier deadlines and these 35 versus seven to schedule
因为这两个任务的截止日期较早，所以需要将这35个任务与七个任务进行安排。

956
00:53:46,690 --> 00:53:47,040
that.
那个。

957
00:53:47,050 --> 00:53:48,080
And finally,
最后，

958
00:53:48,360 --> 00:53:52,030
you schedule pc now,
你现在安排计算机。

959
00:53:52,040 --> 00:53:53,230
what are the next deadlines?
下一个截止日期是什么？

960
00:53:53,240 --> 00:54:00,350
He said the next deadlines of t one is at time of eight.
他说t1的下一个截止时间是八点。

961
00:54:00,870 --> 00:54:02,790
The next line of the two is time ten,
下一行的两个是时间乘以十倍。

962
00:54:02,800 --> 00:54:06,070
and the next line of history is time14.
历史的下一行是 time14。

963
00:54:07,190 --> 00:54:08,490
We are going to spend the first step,
我们将进行第一步。

964
00:54:08,860 --> 00:54:09,980
which is the next deadline.
下一个截止日期是什么？

965
00:54:13,970 --> 00:54:15,960
Again, duan is earlier strong.
再次，段是先强的。

966
00:54:17,490 --> 00:54:21,150
Then again, d two and against this.
再说一次，对这个有两种观点并且反对。

967
00:54:21,510 --> 00:54:22,060
Again.
再一次。

968
00:54:22,110 --> 00:54:23,220
But again,
但是再次，

969
00:54:23,230 --> 00:54:24,420
before going to this three,
在进行这三个之前，

970
00:54:24,430 --> 00:54:25,620
let's look at the next at last.
让我们最后再看一下下一个。

971
00:54:27,970 --> 00:54:32,410
The next deadline of t one is now 12.
t one的下一个截止日期现在是12号。

972
00:54:33,450 --> 00:54:35,960
The next deadline of t two is now 15.
t的下一个截止日期现在是15。

973
00:54:36,850 --> 00:54:38,880
The next deadline of these three, actually,
这三个的下一个截止日期，实际上是

974
00:54:38,890 --> 00:54:39,920
the second deadline,
第二个截止日期

975
00:54:40,500 --> 00:54:42,250
it's 14,
是14点。

976
00:54:43,210 --> 00:54:46,070
which is the earliest deadlines we need to consider now.
我们现在需要考虑的最早截止日期是哪个？

977
00:54:47,180 --> 00:54:47,540
Right?
对吗？

978
00:54:48,470 --> 00:54:49,550
You are the next one.
你是下一个。

979
00:54:49,560 --> 00:54:51,850
It's 12.
现在是12点。

980
00:54:52,630 --> 00:54:55,170
They do 50 and 340.
他们做了50和340。

981
00:54:55,870 --> 00:54:56,820
Obviously still on.
显然仍然开着。

982
00:54:56,830 --> 00:55:01,660
They are going to schedule pr so now you see that you schedule
他们打算安排公关活动，现在你可以看到你的日程安排了。

983
00:55:02,280 --> 00:55:04,650
for the first three periods of yuan,
元朝的前三个时期，

984
00:55:05,350 --> 00:55:06,540
while for these three,
对于这三个来说，

985
00:55:06,550 --> 00:55:07,820
you scattered for only one.
你只分散了一个。

986
00:55:10,540 --> 00:55:12,290
But now after a schedule 41,
但是现在经过一个调度41之后，

987
00:55:12,300 --> 00:55:16,060
you are going to consider pc because it's deadline.
你要考虑电脑，因为截止日期快到了。

988
00:55:17,350 --> 00:55:18,410
It's earlier than people.
它比人类更早。

989
00:55:19,200 --> 00:55:21,250
And then you continue.
然后你继续。

990
00:55:24,920 --> 00:55:27,380
Now, an interesting question here.
现在，这里有一个有趣的问题。

991
00:55:30,970 --> 00:55:31,560
It's,
这是，

992
00:55:31,650 --> 00:55:37,690
let me just say it's how do you know that you can satisfy the algorithms
让我来说一下，你如何知道你能满足算法的要求呢？

993
00:55:37,700 --> 00:55:41,510
can satisfy all the task deadlines?
能够满足所有任务的截止日期吗？

994
00:55:41,870 --> 00:55:44,140
As you can see, from the previous example, is not easy.
正如你在之前的例子中所看到的，这并不容易。

995
00:55:45,140 --> 00:55:49,850
The order that it changes as your progress.
随着你的进展而改变的顺序。

996
00:55:51,370 --> 00:55:51,910
Okay?
好的？

997
00:55:52,450 --> 00:55:53,770
It's actually quite complicated.
实际上，这是相当复杂的。

998
00:55:55,060 --> 00:55:58,740
Now, it turns out that is early deadline.
现在，事实证明是提前截止日期。

999
00:55:58,750 --> 00:56:00,740
First, there is a simple condition.
首先，有一个简单的条件。

1000
00:56:00,750 --> 00:56:05,070
You can use to check whether you can satisfy early deadline first,
你可以使用它来检查是否能够满足早期截止日期。

1001
00:56:05,370 --> 00:56:08,040
satisfy the deadlines of all tasks,
满足所有任务的截止日期

1002
00:56:09,720 --> 00:56:16,050
and that you sum up the computation of a period for all tasks.
并且你对所有任务的周期计算进行求和。

1003
00:56:16,060 --> 00:56:17,770
And if that is the lesson one,
如果这是第一课的话，

1004
00:56:18,520 --> 00:56:20,570
you the edf is feasible.
你好，EDF调度算法是可行的。

1005
00:56:21,060 --> 00:56:21,680
It's working.
它正在工作。

1006
00:56:22,200 --> 00:56:28,070
In our case, it's 1 over 4 plus 2 over 5 plus 2 over 7 is less than one.
在我们的情况下，1除以4加上2除以5再加上2除以7小于1。

1007
00:56:28,320 --> 00:56:28,910
It's feasible.
这是可行的。

1008
00:56:30,020 --> 00:56:35,190
We've seen, at least from our simulation for the first,
从我们的模拟中，我们至少看到了第一个。

1009
00:56:36,180 --> 00:56:37,810
whatever 30 seconds.
无论30秒。

1010
00:56:40,350 --> 00:56:42,530
This is very cool, because you see,
这很酷，因为你看到，

1011
00:56:42,540 --> 00:56:45,130
this is also optimal from the point of view optimization,
从优化的角度来看，这也是最优的。

1012
00:56:45,490 --> 00:56:52,290
because c over b for a task is how much is going to utilize from the cpu
因为任务的 c 比 b 更多，所以它将更多地利用 CPU。

1013
00:56:53,850 --> 00:56:55,030
if I want to utilize,
如果我想利用，

1014
00:56:55,040 --> 00:56:56,430
I have like the first task,
我喜欢第一个任务。

1015
00:56:56,810 --> 00:56:57,940
one time unit,
一个时间单位

1016
00:56:58,170 --> 00:56:59,950
1 second out of 4 seconds,
1秒占4秒的比例，

1017
00:57:01,060 --> 00:57:04,860
the utilization that task alone is going to get 1 over 4 of the cpu
该任务独占CPU的利用率将达到1/4。

1018
00:57:04,870 --> 00:57:08,610
25% of the cpu so the sum of
CPU的25%所以总和是

1019
00:57:08,620 --> 00:57:12,000
these see over these cannot be greater than one,
这些看起来不能超过一个。

1020
00:57:13,700 --> 00:57:14,030
right?
对的？

1021
00:57:15,430 --> 00:57:17,670
Because you cannot use more cp us than you have.
因为你不能使用比你拥有的更多的CPU。

1022
00:57:18,830 --> 00:57:19,510
This is a very good.
这非常好。

1023
00:57:19,520 --> 00:57:21,510
That's how you are talking about salary, because it's very good.
这是你在谈论薪水的方式，因为它非常好。

1024
00:57:21,520 --> 00:57:22,310
It's also optimal.
这也是最优的。

1025
00:57:28,320 --> 00:57:30,710
Now, things are more complicated,
现在，事情变得更加复杂了，

1026
00:57:30,720 --> 00:57:33,830
and we touch a little bit about starvation.
我们稍微讨论了一下饥饿问题。

1027
00:57:35,720 --> 00:57:38,990
We are going to talk more during this lecture and the next lecture.
我们将在本节课和下一节课中进行更多讨论。

1028
00:57:43,920 --> 00:57:47,760
One thing to make sure is that starvation is different from deadlock.
需要确保的一件事是，饥饿（starvation）和死锁（deadlock）是不同的。

1029
00:57:49,000 --> 00:57:53,130
Starvations means that you are a star,
饥饿意味着你是一颗星星，

1030
00:57:53,140 --> 00:57:56,970
but eventually you are not,
但最终你不是。

1031
00:57:58,670 --> 00:57:59,550
you can still run.
你仍然可以逃跑。

1032
00:57:59,560 --> 00:58:00,510
Like we are talking.
就像我们正在交谈一样。

1033
00:58:00,520 --> 00:58:04,940
In the previous case, you are start and you can be started forever.
在前面的情况下，你是启动的，并且可以无限地被启动。

1034
00:58:05,740 --> 00:58:08,160
If there are prosperity scheduling.
如果存在繁荣调度。

1035
00:58:08,460 --> 00:58:13,590
If there are always lower produce tasks or jobs in the system,
如果系统中始终存在较低优先级的生产任务或作业，

1036
00:58:14,550 --> 00:58:17,480
but once that they are no longer,
但一旦他们不再存在，

1037
00:58:17,790 --> 00:58:23,000
you are scared that look is a different in the sense that you get
你害怕外貌不同会带来不同的感受

1038
00:58:23,010 --> 00:58:25,880
to a point that you cannot resolve that.
到达一个你无法解决的程度。

1039
00:58:26,160 --> 00:58:27,860
No matter what happens in the system,
无论系统发生什么情况，

1040
00:58:29,010 --> 00:58:31,760
unless you kill the process, so you start the system.
除非你杀掉该进程，否则你需要重新启动系统。

1041
00:58:32,700 --> 00:58:32,980
Right?
对吗？

1042
00:58:33,650 --> 00:58:35,120
We'll talk more about the next time,
我们下次再详细讨论。

1043
00:58:35,740 --> 00:58:38,690
but we also going to touch a little bit during this lecture.
但是在本次讲座中，我们也会稍微涉及一点。

1044
00:58:40,720 --> 00:58:43,830
You have these causes of starvation, scaling police, like we said,
你有这些导致饥饿的原因，比如我们所说的，扩大警力。

1045
00:58:43,840 --> 00:58:46,870
never runs a particular thread on the cpo and so forth.
不会在CPO上运行特定的线程等等。

1046
00:58:51,000 --> 00:58:54,380
But we'll explore more about these problems.
但是我们将进一步探讨这些问题。

1047
00:58:57,720 --> 00:59:04,990
One way to avoid survey starvation is not one way.
避免调查饥饿的方法不止一种。

1048
00:59:05,000 --> 00:59:13,290
It's it's obviously one way to alleviate starvation.
这显然是缓解饥饿的一种方式。

1049
00:59:13,730 --> 00:59:16,750
Is that if the cpu is always yours,
这意味着如果CPU始终属于你，

1050
00:59:18,260 --> 00:59:19,370
if there is work to do,
如果有工作要做，

1051
00:59:20,440 --> 00:59:20,830
right?
对的吗？

1052
00:59:21,340 --> 00:59:25,630
If you have a scheduler which doesn't use the cpu and keep the cpu idol,
如果你有一个调度器不使用CPU并保持CPU空闲的话，

1053
00:59:25,970 --> 00:59:28,690
obviously, it's much higher chance that you are going to stop some threats.
显然，你有更高的机会阻止一些威胁。

1054
00:59:29,610 --> 00:59:33,390
The schedulers, which are always using cpu.
调度器始终在使用CPU。

1055
00:59:33,960 --> 00:59:39,640
They don't leave the cpu idle while there is work to do while there are
只要有工作要做，他们就不会让 CPU 空闲。

1056
00:59:39,650 --> 00:59:41,690
ready processes in the system.
系统中的就绪进程。

1057
00:59:42,480 --> 00:59:45,830
Already threats they are called work on sale.
已经有人威胁称他们会公开你的工作。

1058
00:59:47,350 --> 00:59:54,330
They are scheduled which are not considering a schedule which are they
他们被安排了，但没有考虑他们的时间表。

1059
00:59:54,340 --> 00:59:56,410
may maintain the cpu idle,
可以保持CPU空闲状态，

1060
00:59:56,420 --> 00:59:58,730
even if there are processes in the system,
即使系统中有进程，

1061
00:59:59,540 --> 01:00:01,520
which can are ready to execute.
可以立即执行的程序。

1062
01:00:02,210 --> 01:00:03,820
And obvious, like I said,
显而易见，就像我说的那样，

1063
01:00:04,410 --> 01:00:07,330
they can linear triviality to this to celebration.
他们可以将这个庆祝活动线性化为琐碎的事情。

1064
01:00:09,170 --> 01:00:12,130
In this class, you'll assume that the schedulers were concerned.
在这门课中，你将假设调度程序是关注的。

1065
01:00:12,960 --> 01:00:15,520
We don't need to worry about hong kong were conserving,
我们不需要担心香港正在保护的问题。

1066
01:00:15,530 --> 01:00:17,960
but just to keep for completeness,
但为了完整起见，

1067
01:00:17,970 --> 01:00:19,800
let you know that there are such catalysts.
通知您，确实存在这样的催化剂。

1068
01:00:28,080 --> 01:00:30,100
Here is another thing.
这是另一件事情。

1069
01:00:30,320 --> 01:00:33,030
There's another example of schedule as a few example of schedule,
这里有另一个关于调度的例子，作为一些调度的示例。

1070
01:00:33,040 --> 01:00:34,230
which leads to starvation.
这导致了饥饿。

1071
01:00:34,240 --> 01:00:36,670
Again, you already knew now about some of them.
再次强调，你现在已经对其中一些有所了解。

1072
01:00:37,010 --> 01:00:38,140
Here is a new one,
这是一个新的问题，

1073
01:00:38,440 --> 01:00:41,300
is life for last in first out.
生活是先进后出的。

1074
01:00:41,870 --> 01:00:45,660
It's as opposed to first team first out or first come first serve.
这是与先进先出或先来先服务相对的概念。

1075
01:00:47,040 --> 01:00:51,370
This is going to serve the tasks which arrived,
这将用于处理到达的任务。

1076
01:00:51,380 --> 01:00:52,410
which are inserted,
被插入的是哪些？

1077
01:00:52,420 --> 01:00:55,280
which arrived the latest first.
哪个最后到达的先到达。

1078
01:00:56,110 --> 01:00:56,510
Right?
对吗？

1079
01:00:57,500 --> 01:01:02,180
And this can be very unfair and obviously can cause starvation,
这样做非常不公平，显然会导致饥饿问题。

1080
01:01:02,820 --> 01:01:05,710
because you can have new task always arriving.
因为你可能会不断收到新的任务。

1081
01:01:05,720 --> 01:01:08,320
You are already all only going to schedule those.
你们已经只需要安排那些了。

1082
01:01:12,690 --> 01:01:18,860
And when arrival rate exceeds the how much the number of task which you get,
当到达速率超过您获得的任务数量时，

1083
01:01:18,870 --> 01:01:20,610
it's more than what you can process,
这超出了你的处理能力。

1084
01:01:20,620 --> 01:01:22,890
obviously are going to start the whole task.
显然要开始整个任务。

1085
01:01:28,060 --> 01:01:30,420
54doesn't really have that problem.
54并没有那个问题。

1086
01:01:31,030 --> 01:01:36,730
But anyway, this is just about what about first come, first set,
但无论如何，这只是关于先来先服务的问题。

1087
01:01:36,740 --> 01:01:40,480
but it for five or first come first set is the same thing.
但是"五分钟内完成"和"先到先得"是一回事。

1088
01:01:42,010 --> 01:01:44,130
They don't have as much of a problem,
他们没有那么大的问题，

1089
01:01:45,940 --> 01:01:48,370
because eventually you are going to drain the cure.
因为最终你会耗尽治愈的方法。

1090
01:01:49,660 --> 01:01:49,930
Right?
对吗？

1091
01:01:51,800 --> 01:01:52,240
Let me see.
让我看看。

1092
01:01:52,250 --> 01:01:53,120
It's a question.
这是一个问题。

1093
01:01:54,300 --> 01:01:57,420
Why would you ever want a non work on serving scheduler?
为什么你会想要一个不工作的服务调度器？

1094
01:02:00,430 --> 01:02:02,420
A that's a good question.
那是一个很好的问题。

1095
01:02:02,430 --> 01:02:07,020
Why we always would like to.
为什么我们总是喜欢这样做呢？

1096
01:02:07,030 --> 01:02:16,550
So there are there are schedulers which you want to be very predictable.
所以有一些调度器你希望它们非常可预测。

1097
01:02:17,660 --> 01:02:18,530
There are scheduler.
有调度器。

1098
01:02:18,540 --> 01:02:22,730
You want to happen certain things to happen exactly the right at the right time.
你希望某些事情在恰当的时间发生，并且以恰当的方式发生。

1099
01:02:23,570 --> 01:02:24,800
You want, for instance,
例如，您想要的是

1100
01:02:24,810 --> 01:02:28,600
to produce a result every 100 millisecond.
每100毫秒产生一个结果。

1101
01:02:30,000 --> 01:02:31,390
In that particular case,
在那种特殊情况下，

1102
01:02:31,400 --> 01:02:37,970
even if you can process more and earlier,
即使你能更早更快地处理，

1103
01:02:37,980 --> 01:02:41,770
you are not going to process because you are going to produce a disaster.
你不会被处理，因为你将会造成灾难。

1104
01:02:44,090 --> 01:02:45,330
So that's kind of one.
所以这就是其中之一。

1105
01:02:50,070 --> 01:02:52,330
When you want to regularly,
当你想要定期地，

1106
01:02:52,340 --> 01:02:53,690
this is also a networking.
这也是一个网络相关的话题。

1107
01:02:54,240 --> 01:02:54,760
You're not talking.
你没有说话。

1108
01:02:54,770 --> 01:02:56,360
You want to send one packet.
你想发送一个数据包。

1109
01:02:56,920 --> 01:03:01,610
Every say you have one packet,
每次你都有一个数据包。

1110
01:03:01,620 --> 01:03:07,130
you are going to send one microsecond.
你要发送一微秒的时间。

1111
01:03:07,140 --> 01:03:08,250
Now you may ask,
现在你可以提问了，

1112
01:03:08,730 --> 01:03:09,850
why do you want to do that?
为什么你想要这样做？

1113
01:03:10,090 --> 01:03:10,310
Right?
对吗？

1114
01:03:10,320 --> 01:03:10,670
Why?
为什么？

1115
01:03:11,460 --> 01:03:12,690
And in general,
总的来说，

1116
01:03:13,240 --> 01:03:16,560
one reason you may want to do this to keep this kind of pace,
你可能希望保持这种节奏的一个原因是

1117
01:03:17,020 --> 01:03:22,870
because you don't want to overwhelm the next stage or the next processing stage,
因为你不想给下一阶段或下一个处理阶段带来过多的压力。

1118
01:03:22,880 --> 01:03:24,170
like, for instance, in networking.
比如，在网络中。

1119
01:03:24,370 --> 01:03:28,310
If you send burst of packets instead of facing them,
如果你发送突发的数据包而不是面对它们，

1120
01:03:28,830 --> 01:03:31,490
then you have a higher probability.
那么你有更高的概率。

1121
01:03:31,500 --> 01:03:34,540
You are going to go into overflow,
你即将发生溢出。

1122
01:03:35,080 --> 01:03:40,130
to send more packets and downstream router can handle.
发送更多的数据包，下游路由器可以处理。

1123
01:03:40,470 --> 01:03:41,780
Then I guess it'll be lost.
那我猜它就会丢失了。

1124
01:03:42,830 --> 01:03:45,210
So that's an example.
那就是一个例子。

1125
01:03:55,460 --> 01:03:57,050
It's again, the first come first serve.
这还是先来先服务的原则。

1126
01:03:57,060 --> 01:04:00,210
The only problem you have is that you are going to have a very long job
你唯一的问题是你将会有一个非常长的工作任务

1127
01:04:00,220 --> 01:04:01,090
with nobody else.
独自一人。

1128
01:04:02,200 --> 01:04:04,710
Then you have to start for samoa while.
那么你得先去萨摩亚一段时间。

1129
01:04:05,110 --> 01:04:08,620
But it's again, as long as over some time intervals,
但是只要在一些时间间隔内，

1130
01:04:09,390 --> 01:04:10,510
the load of purpose,
目的的负载

1131
01:04:10,520 --> 01:04:15,810
a system that the system has to process is lower than the capacitor of the system.
系统需要处理的系统负载低于系统的电容。

1132
01:04:16,370 --> 01:04:24,210
Everyone's is going to run is the round robin from the starvation.
每个人都会以轮转法来运行，以避免饥饿。

1133
01:04:27,140 --> 01:04:35,040
If you have any processes and if you have aa time quantum
如果你有任何进程，并且有一个时间片大小

1134
01:04:35,050 --> 01:04:42,840
of then of q then your turn will come every n minus one times
如果当前是第q个人的回合，那么你的回合将会每隔n-1次到来一次。

1135
01:04:42,850 --> 01:04:43,840
few millisecond.
几毫秒。

1136
01:04:44,150 --> 01:04:44,720
What are you doing?
你在做什么？

1137
01:04:45,790 --> 01:04:49,550
So we see you don't have salvation.
所以我们看到你没有救赎。

1138
01:04:53,240 --> 01:04:55,750
Now is priority scheduling from the salvation.
现在是优先级调度从救赎开始。

1139
01:04:56,200 --> 01:04:58,070
It is we just discuss about that, right?
我们刚刚讨论过这个问题，对吗？

1140
01:04:59,010 --> 01:05:02,120
Again, early scheduling grants every job,
再次强调，提前调度为每个作业分配了时间。

1141
01:05:02,170 --> 01:05:07,500
every first it has to finish all the jobs at the high priority level
每一次首先需要完成所有高优先级级别的工作。

1142
01:05:07,510 --> 01:05:10,230
before going to the next time.
在继续下一步之前。

1143
01:05:11,850 --> 01:05:17,310
And now as what you say,
根据你所说的，

1144
01:05:17,320 --> 01:05:22,840
what is the word it's like as a preview for the next lecture,
这个词就像是下一堂课的预览一样。

1145
01:05:22,850 --> 01:05:23,760
for the deadlock?
关于死锁？

1146
01:05:25,000 --> 01:05:28,020
Let me give you one example about a deadlock.
让我给你举一个死锁的例子。

1147
01:05:28,750 --> 01:05:33,020
We alluded about this deadlock last lecture when we talk about priority inversion.
上一堂课我们谈到了优先级反转时，我们提到了这个死锁问题。

1148
01:05:34,730 --> 01:05:36,000
This is what can happen.
这是可能发生的事情。

1149
01:05:41,960 --> 01:05:44,300
But again, that means you are stuck.
但是再次，这意味着你被困住了。

1150
01:05:46,300 --> 01:05:46,910
Can do anything.
可以做任何事情。

1151
01:05:46,920 --> 01:05:52,800
Even if you have no other job in the system, you are still stuck,
即使你在系统中没有其他任务，你仍然被卡住了。

1152
01:05:52,810 --> 01:05:53,800
you cannot make progress.
你无法取得进展。

1153
01:05:54,810 --> 01:05:56,850
So say a job at priority one,
假设有一个优先级为一的作业，

1154
01:05:56,860 --> 01:05:58,490
lower priority acquire a lot.
降低优先级获取大量资源。

1155
01:06:03,080 --> 01:06:06,450
And now the job one is in critical section.
现在任务一进入了临界区。

1156
01:06:08,240 --> 01:06:10,890
But now jobs three comes, it's a hybrid,
但现在有第三种工作方式出现了，它是一种混合型的工作方式。

1157
01:06:12,850 --> 01:06:17,130
and jobs three tries to acquire the lock held by job one.
作业三尝试获取由作业一持有的锁。

1158
01:06:20,040 --> 01:06:20,370
Right?
对吗？

1159
01:06:25,400 --> 01:06:27,680
But you cannot your block on a query.
但是你不能在一个查询上阻塞。

1160
01:06:31,440 --> 01:06:32,270
By the way,
顺便说一下，

1161
01:06:33,220 --> 01:06:39,820
now, job three waits for the job one to finish to release a lock.
现在，作业三等待作业一完成以释放锁。

1162
01:06:40,410 --> 01:06:43,770
And job to one is not executive because jobs three has a higher product.
而将工作分配给一个人并不是因为工作三的产出更高，所以工作三不是执行工作。

1163
01:06:44,890 --> 01:06:45,650
That's kind of that.
就是这样了。

1164
01:06:48,600 --> 01:06:49,750
This is priority inversion,
这是优先级反转。

1165
01:06:52,070 --> 01:06:59,010
because you are waiting for a job with a lower priority to release a lock.
因为你正在等待一个优先级较低的任务释放一个锁。

1166
01:06:59,380 --> 01:07:01,020
And we cannot believe a lot because of you.
因为你的原因，我们不能相信很多事情。

1167
01:07:07,310 --> 01:07:09,370
And this is the definition of working version.
这是工作版本的定义。

1168
01:07:11,670 --> 01:07:14,300
This is another example is a live block.
这是另一个例子，是一个实时块。

1169
01:07:15,290 --> 01:07:17,490
You have local choirs, local release,
你有本地合唱团，本地发布。

1170
01:07:18,120 --> 01:07:19,210
the low priority.
低优先级。

1171
01:07:19,620 --> 01:07:21,110
The high priority is, again,
高优先级再次是

1172
01:07:21,120 --> 01:07:22,610
try to achieve live long,
努力追求长寿，

1173
01:07:24,030 --> 01:07:25,710
always busy waiting.
一直忙于等待。

1174
01:07:29,530 --> 01:07:30,780
So what are the solutions?
那么有哪些解决方案呢？

1175
01:07:31,120 --> 01:07:34,650
One solution is priority donation or inheritance.
一种解决方案是优先捐赠或继承。

1176
01:07:35,830 --> 01:07:38,010
In this particular case, if job one,
在这种特殊情况下，如果作业一，

1177
01:07:38,020 --> 01:07:39,850
which is not priority, holds a lock,
不是优先级，持有一个锁。

1178
01:07:40,660 --> 01:07:42,250
and jobs three wants to acquire it.
Jobs希望收购它。

1179
01:07:43,010 --> 01:07:44,370
What happens in this case?
在这种情况下会发生什么？

1180
01:07:44,800 --> 01:07:47,930
Job three, donate its priority to job one.
作业三，将其优先级捐赠给作业一。

1181
01:07:48,630 --> 01:07:52,700
So job one while it is a critical section and while holding the lock,
在持有锁的情况下，作业一是一个关键部分。

1182
01:07:53,180 --> 01:07:56,930
now it's going to be promoted to priority three to the highest priority.
现在它将被提升为优先级三，即最高优先级。

1183
01:07:57,720 --> 01:08:03,260
Now it's got times to run and to finish after he believes it goes back,
现在它已经运行了一段时间，并在他相信它返回后完成。

1184
01:08:03,510 --> 01:08:04,790
job one and priority one,
工作一和优先级一

1185
01:08:04,800 --> 01:08:08,560
dollar priority on his previous priority and jobs three can acquire the law.
根据他之前的优先级和工作三可以获得该法律的美元优先权。

1186
01:08:10,490 --> 01:08:12,480
And you're going to have in protective.
你需要进行保护。

1187
01:08:14,510 --> 01:08:14,800
Here.
在这里。

1188
01:08:14,810 --> 01:08:15,700
It's an example.
这是一个例子。

1189
01:08:18,380 --> 01:08:19,810
This is not only theoretical.
这不仅仅是理论上的。

1190
01:08:20,300 --> 01:08:21,100
This is a marathon,
这是一场马拉松比赛，

1191
01:08:21,650 --> 01:08:22,720
but find a robber.
但要找到一个强盗。

1192
01:08:23,150 --> 01:08:24,930
And I have here for the fun,
我在这里只是为了好玩。

1193
01:08:25,370 --> 01:08:27,370
which is not necessarily like it with the lecture.
这并不一定与讲座相似。

1194
01:08:27,380 --> 01:08:31,070
This is in 97 or so many years ago.
这是大约97年前的事情了。

1195
01:08:31,460 --> 01:08:37,390
But it was a big event because it was the first one of these
但这是一个重大事件，因为这是第一个这样的事件。

1196
01:08:41,460 --> 01:08:42,060
satellites.
卫星。

1197
01:08:42,070 --> 01:08:47,620
And actually it has also actually landed on the planet since 76,
实际上，自1976年以来，它实际上也已经在这个星球上着陆了。

1198
01:08:47,630 --> 01:08:49,670
so after 21 years, right?
所以是在21年后，对吗？

1199
01:08:50,330 --> 01:08:52,510
And one thing it was fun.
还有一件事很有趣。

1200
01:08:52,790 --> 01:08:55,720
It was this kind of different delivery mechanics.
这是一种不同的交付机制。

1201
01:08:56,150 --> 01:08:58,400
Let me just see whether I have this one.
让我看看我是否明白这个。

1202
01:09:03,080 --> 01:09:11,990
So i'm guessed, okay,
所以我被猜到了，好吧，

1203
01:09:13,480 --> 01:09:14,680
do you see my screen?
你能看到我的屏幕吗？

1204
01:09:14,690 --> 01:09:15,680
You don't see my screen.
你看不到我的屏幕。

1205
01:09:18,510 --> 01:09:24,240
Let me just, i'm not sure how much you see it.
让我看一下，我不确定你看到了多少。

1206
01:09:28,950 --> 01:09:31,980
For some reason, I cannot let me see if I can do it.
由于某种原因，我无法让我自己看看我能否做到。

1207
01:09:35,420 --> 01:09:36,420
Let's do this for now.
暂时就这样吧。

1208
01:09:42,070 --> 01:09:43,900
It's a very interesting delivery mechanics.
这是一个非常有趣的交付机制。

1209
01:09:44,470 --> 01:09:49,080
How is this lander delivered how he planned it on mars?
这个着陆器是如何按照他在火星上的计划进行投送的？

1210
01:09:52,560 --> 01:09:54,720
It has like balloons, like airbags,
它像气球一样，像安全气囊一样，

1211
01:09:55,050 --> 01:09:56,130
all over the place.
到处都是。

1212
01:09:57,230 --> 01:10:00,960
And this is how is the house delivered?
房屋是如何交付的？

1213
01:10:03,430 --> 01:10:05,440
Very innovative, very, very cool.
非常创新，非常非常酷。

1214
01:10:21,090 --> 01:10:22,470
So eventually stopped.
最终停止了。

1215
01:10:24,850 --> 01:10:27,090
But this is the one we are talking about.
但这就是我们正在讨论的那个。

1216
01:10:28,600 --> 01:10:37,930
And now the problem is that a few days intermissions into the mission,
现在的问题是，在任务进行了几天后，出现了间断的情况。

1217
01:10:37,940 --> 01:10:39,650
multiple systems resets occur,
发生多次系统重启，

1218
01:10:40,870 --> 01:10:44,430
and it was forced for the software.
并且这是对软件进行的强制操作。

1219
01:10:46,350 --> 01:10:48,710
And the system appeared to reboot randomly,
而且系统似乎会随机重新启动，

1220
01:10:49,520 --> 01:10:52,230
losing valuable time and making progress.
浪费宝贵的时间并且无法取得进展。

1221
01:10:52,790 --> 01:10:57,300
What it turned out to be was priority inversion.
事实证明，发生的是优先级反转。

1222
01:10:57,310 --> 01:10:59,470
It was his priority to high priority,
他把高优先级视为首要任务。

1223
01:10:59,480 --> 01:11:01,330
which was a data distribution task.
这是一个数据分发任务。

1224
01:11:02,530 --> 01:11:03,400
They need a lock.
他们需要一个锁。

1225
01:11:03,990 --> 01:11:06,800
The problem is that the collector, the one,
问题在于收集器，那个收集器

1226
01:11:07,090 --> 01:11:10,780
another task, which was collecting samples, collecting data,
另一个任务是收集样本和数据。

1227
01:11:11,400 --> 01:11:12,660
which was lower priority,
哪个优先级较低，

1228
01:11:13,660 --> 01:11:14,610
was getting the lock.
正在获取锁。

1229
01:11:16,430 --> 01:11:16,900
Now,
现在，

1230
01:11:18,420 --> 01:11:19,450
the priority,
优先级

1231
01:11:21,440 --> 01:11:23,350
the collector adds a log.
收集器添加一条日志。

1232
01:11:24,490 --> 01:11:30,610
And the data distribution task couldn't acquire the law.
数据分布任务无法获取规律。

1233
01:11:31,340 --> 01:11:32,090
Now, what happens?
现在发生了什么？

1234
01:11:32,100 --> 01:11:33,330
Typically in these systems?
在这些系统中通常是这样的？

1235
01:11:33,710 --> 01:11:34,660
You have a watchdog.
你有一个看门狗。

1236
01:11:35,780 --> 01:11:42,310
It's a the white dog is a process which looks whether there is forward progress.
这是一个进程，它检查是否有前进的进展。

1237
01:11:42,780 --> 01:11:46,290
If there is no further progress and you have this, in this case, a backlog,
如果没有进一步的进展，并且你有一个积压的情况，

1238
01:11:46,720 --> 01:11:49,020
what is going to do is going to reboot the system.
即将要做的是重新启动系统。

1239
01:11:53,380 --> 01:11:58,770
It turns out that the rose actually called for the priority donation
原来玫瑰实际上要求优先捐赠

1240
01:11:59,450 --> 01:12:00,580
to avoid this problem,
为了避免这个问题，

1241
01:12:01,200 --> 01:12:02,080
writing version.
写作版本。

1242
01:12:02,920 --> 01:12:10,730
But it was turned off because
但是它被关闭了，因为

1243
01:12:10,740 --> 01:12:14,450
the developers thought it's still worried about the performance.
开发人员认为他们仍然担心性能问题。

1244
01:12:16,380 --> 01:12:19,850
In this case, the fix was to upload and feedback the code.
在这种情况下，修复的方法是上传并反馈代码。

1245
01:12:22,040 --> 01:12:24,750
Again, what you are talking here is not only theoretical.
再次强调，你在这里讨论的不仅仅是理论问题。

1246
01:12:24,990 --> 01:12:25,460
It happens.
没关系。

1247
01:12:28,660 --> 01:12:29,880
Let's talk about others.
让我们谈谈其他人。

1248
01:12:29,930 --> 01:12:34,680
It's shortest time first and multilevel feedback you from the starvation.
这是最短时间优先和多级反馈调度算法，可以避免饥饿问题。

1249
01:12:37,460 --> 01:12:38,300
They are right.
他们是正确的。

1250
01:12:39,440 --> 01:12:41,330
Like we discussed shortest time first.
正如我们讨论过的，最短时间优先。

1251
01:12:42,400 --> 01:12:45,000
The long job can be started in the favor of short runs.
长时间的任务可以在短时间运行的情况下开始。

1252
01:12:45,010 --> 01:12:47,800
If you have always short jobs arriving,
如果你总是有短作业到达，

1253
01:12:48,360 --> 01:12:57,110
they are going to start the long jobs with multilevel feet queue fit by queue.
他们打算使用多级反馈队列按队列进行长作业的调度。

1254
01:12:57,860 --> 01:13:01,180
It's an approximation assured that remaining time first.
首先，这是一个保证剩余时间的近似值。

1255
01:13:01,640 --> 01:13:03,030
So it suffers from the same problem.
所以它遭受了同样的问题。

1256
01:13:05,710 --> 01:13:07,180
Again, in some sense,
再次，在某种意义上，

1257
01:13:07,650 --> 01:13:10,520
the case, the cause for starvation, it's always a priority,
饥饿的情况，造成饥饿的原因，始终是优先考虑的。

1258
01:13:10,530 --> 01:13:12,120
whether it's a fixed priority,
无论是固定优先级还是

1259
01:13:12,130 --> 01:13:13,720
or whether it's implicit,
还是它是隐含的，

1260
01:13:14,400 --> 01:13:16,600
explicit fixed priority or implicit priority,
显式固定优先级或隐式优先级

1261
01:13:16,610 --> 01:13:18,950
like the length of a job.
比如作业的长度。

1262
01:13:21,250 --> 01:13:26,400
So you have this kind of a priority which is encoded in the schedulers,
所以你有这种优先级，它被编码在调度器中，

1263
01:13:26,410 --> 01:13:27,840
how schedule make the decision?
调度是如何做出决策的？

1264
01:13:28,800 --> 01:13:34,620
It should be a raise a flag that it you may then end up with starvation.
这应该引起警觉，因为你可能最终会陷入饥饿状态。

1265
01:13:39,160 --> 01:13:40,990
Again, our job, remember,
再次强调，记住我们的工作任务，

1266
01:13:41,000 --> 01:13:45,860
is the server mix of CPU bound and io bound and interactive jobs effectively.
服务器是否有效地混合了CPU密集型、IO密集型和交互式任务。

1267
01:13:47,230 --> 01:13:51,780
Here you want to have interactive jobs to be interactive,
在这里，您希望将交互式作业设置为交互式。

1268
01:13:51,790 --> 01:13:55,930
be very quick response time,
非常快的响应时间。

1269
01:13:55,940 --> 01:13:57,170
verify the response time.
验证响应时间。

1270
01:13:57,690 --> 01:14:02,000
We need to give I abound the jobs enough CPU so that they are going to do
我们需要给I/O密集型的任务足够的CPU资源，以便它们能够执行。

1271
01:14:02,010 --> 01:14:02,640
their work.
他们的工作。

1272
01:14:03,450 --> 01:14:05,730
Ideally want them to be our bound, right?
理想情况下，我们希望他们成为我们的约束，对吗？

1273
01:14:10,210 --> 01:14:12,560
And then the CPU bound ones,
然后是CPU密集型任务，

1274
01:14:12,570 --> 01:14:16,210
you want to still let them running to eventually finish.
你希望让它们继续运行直到最终完成。

1275
01:14:18,640 --> 01:14:19,000
Now,
现在，

1276
01:14:21,210 --> 01:14:22,680
the scheduling discipline,
调度策略

1277
01:14:23,210 --> 01:14:27,410
it's also we are going to learn and we learned.
这也是我们要学习的内容，而且我们已经学过了。

1278
01:14:28,860 --> 01:14:34,660
It's also a reflection of the changes in the landscape of computers
这也反映了计算机领域的变化。

1279
01:14:35,710 --> 01:14:37,120
for big mainframes,
对于大型主机，

1280
01:14:37,130 --> 01:14:39,320
where you have a lot of users using them.
在你有很多用户使用它们的地方。

1281
01:14:39,880 --> 01:14:40,790
To b C's,
为了成为C的一员，

1282
01:14:40,800 --> 01:14:45,950
you have one user over and maybe one program earlier on a single machine
在一台单机上，你可能有一个用户登录并且可能有一个程序在之前运行。

1283
01:14:45,960 --> 01:14:49,770
to multiple programs on a single machine,
在一台计算机上运行多个程序

1284
01:14:49,780 --> 01:14:51,090
but only one users.
但只有一个用户。

1285
01:14:51,610 --> 01:14:53,760
And to even internet of things,
甚至连物联网也包括在内，

1286
01:14:53,770 --> 01:14:58,600
which the things are sitting there just to get some Information from the environment.
这些东西只是为了从环境中获取一些信息而存在。

1287
01:14:59,650 --> 01:14:59,930
Right?
对吗？

1288
01:15:01,170 --> 01:15:04,560
So priority by scheduling is rooted in times sharing.
调度中的优先级根源于时间共享。

1289
01:15:04,960 --> 01:15:07,290
When you have fewer resources,
当你拥有更少的资源时，

1290
01:15:07,970 --> 01:15:13,070
lot of things running on the same competing for the resources.
很多东西同时运行，争夺资源。

1291
01:15:13,910 --> 01:15:16,730
And that's why.
这就是为什么。

1292
01:15:17,000 --> 01:15:19,950
But and then they LED to starvation.
然而，这导致了饥荒。

1293
01:15:20,480 --> 01:15:22,970
People try to resolve the starvation,
人们试图解决饥饿问题，

1294
01:15:23,390 --> 01:15:24,950
try to develop new scheduling,
尝试开发新的调度算法。

1295
01:15:24,960 --> 01:15:26,230
which are more fair,
哪个更公平，

1296
01:15:28,320 --> 01:15:29,190
and things like that.
等等之类的东西。

1297
01:15:31,120 --> 01:15:38,620
And one question here is that this is
这里有一个问题是

1298
01:15:39,510 --> 01:15:44,390
desperate providing some jobs necessarily start those that aren't prioritized.
在迫切需要提供一些工作的情况下，必要时可以先开始那些没有优先级的工作。

1299
01:15:47,660 --> 01:15:54,740
Not three priorities in certain cases, like we've seen, absolutely.
在某些情况下，就像我们所看到的那样，并不是三个绝对的优先级。

1300
01:15:55,260 --> 01:15:59,010
It turns out that people have a bunch of holistics to reduce that miss,
事实证明，人们有很多整体性方法来减少这种错误。

1301
01:15:59,020 --> 01:15:59,650
reduce,
减少、缩小、降低

1302
01:15:59,660 --> 01:16:01,130
alleviate starvation.
缓解饥饿问题。

1303
01:16:03,630 --> 01:16:05,670
There are a few ways to do it.
有几种方法可以做到这一点。

1304
01:16:06,540 --> 01:16:07,770
Multilevel feedback,
多级反馈调度算法

1305
01:16:07,860 --> 01:16:08,970
if you remember,
如果你记得的话，

1306
01:16:09,310 --> 01:16:14,770
tries to reduce the starvation by having CPU bounded jobs,
通过让CPU密集型任务来减少饥饿现象。

1307
01:16:15,660 --> 01:16:17,810
falling that the one which keeps along to,
如果有一个人一直跟着下去，

1308
01:16:17,820 --> 01:16:20,580
it takes a long time to admit,
承认需要很长时间。

1309
01:16:20,590 --> 01:16:21,980
to be deprived,
被剥夺

1310
01:16:22,230 --> 01:16:24,650
to go to a lower priority in time.
降低优先级的时间。

1311
01:16:26,040 --> 01:16:29,360
The other things are the mechanics like the mechanics,
其他事情就像机械一样，就像机械一样。

1312
01:16:29,370 --> 01:16:33,310
which are API exposed to the users to being nice.
哪些API对用户是可见的？

1313
01:16:33,660 --> 01:16:34,010
Right?
对吗？

1314
01:16:35,260 --> 01:16:39,450
So basically, and if you want it to be nice and is this a unique command,
基本上，如果你希望它看起来好一些，并且这是一个独特的命令，

1315
01:16:39,800 --> 01:16:42,680
you can be prioritize your task,
你可以优先处理你的任务，

1316
01:16:42,690 --> 01:16:44,000
your program.
你的程序。

1317
01:16:44,440 --> 01:16:48,230
So other people will work and run their programs.
这样其他人就可以工作和运行他们的程序了。

1318
01:16:50,170 --> 01:16:52,880
The nice value ranged from-20 to 19,
优先级值的范围是-20到19。

1319
01:16:52,890 --> 01:16:55,800
negative values are not nice.
负值不好。

1320
01:16:56,400 --> 01:17:00,830
The things is that for in this particular,
问题是在这个特定情况下，

1321
01:17:03,940 --> 01:17:04,970
in this particular case,
在这种特殊情况下，

1322
01:17:04,980 --> 01:17:10,990
you can think about for unique sum systems, like unique.
你可以考虑独特求和系统，比如独特。

1323
01:17:11,000 --> 01:17:12,550
Suddenly, some version of UNIX,
突然间，UNIX的某个版本，

1324
01:17:13,100 --> 01:17:16,290
the lower priorities are the lower properties.
较低的优先级意味着较低的属性。

1325
01:17:16,300 --> 01:17:18,250
Values are higher priorities.
价值观是更高的优先事项。

1326
01:17:18,540 --> 01:17:20,210
So far in all our examples,
到目前为止，在我们的所有示例中，

1327
01:17:20,220 --> 01:17:23,890
you assume the higher priority values of priority three has a high priority.
你假设优先级为三的较高优先级值具有较高的优先级。

1328
01:17:24,300 --> 01:17:26,530
But in UNIX,
但在UNIX中，

1329
01:17:26,540 --> 01:17:28,850
at least some version of UNIX is the other around.
至少某个版本的UNIX是相反的。

1330
01:17:29,280 --> 01:17:33,990
The lower priority values of priority zero is the highest priority,
优先级为零的较低优先级值表示最高优先级。

1331
01:17:34,000 --> 01:17:35,830
and priority three is the lower price.
优先级三是较低的价格。

1332
01:17:36,730 --> 01:17:38,360
Then in this case,
那么在这种情况下，

1333
01:17:38,580 --> 01:17:42,740
so therefore, if you increase a nice value, you increase,
因此，如果你增加一个良好值，你就会增加

1334
01:17:42,750 --> 01:17:47,810
you basically decrease a priority of your increase a priority value,
你基本上是降低一个优先级或者增加一个优先级值。

1335
01:17:47,820 --> 01:17:50,570
but it is a priority of your job.
但这是你工作的优先事项。

1336
01:17:51,640 --> 01:17:51,990
Okay?
好的？

1337
01:17:54,580 --> 01:17:55,770
Let me stop here.
让我停在这里。

1338
01:17:55,780 --> 01:17:58,010
And we are almost done with the lecture,
我们的讲座快要结束了，

1339
01:17:58,020 --> 01:17:59,810
but we are going to continue next time.
但我们下次会继续。

1340
01:18:00,440 --> 01:18:02,830
It's the last lecture on scheduling.
这是关于调度的最后一节课。

1341
01:18:03,440 --> 01:18:06,190
And we are going to look a little bit about Linux,
我们将稍微了解一下Linux，

1342
01:18:06,200 --> 01:18:07,750
how Linux is implemented.
Linux是如何实现的。

1343
01:18:08,690 --> 01:18:15,210
And then we are going to talk a little bit more about fairness with that.
然后我们将稍微讨论一下公平性。

1344
01:18:15,220 --> 01:18:18,250
If there are any other questions, I could answer
如果有其他问题，我可以回答。

1345
01:18:27,440 --> 01:18:27,990
the deadlock.
死锁。

1346
01:18:28,000 --> 01:18:31,790
There only happens that does deadlock only happens here on spin locks.
只有在自旋锁上才会发生死锁。

1347
01:18:32,690 --> 01:18:34,640
In that particular example is yes.
在这个特定的例子中是的。

1348
01:18:37,910 --> 01:18:41,260
But interlock is a much more general concept like we will see you next time.
但是"interlock"是一个更加通用的概念，就像我们下次见面一样。

1349
01:18:45,950 --> 01:18:46,180
No.
不。

1350
01:18:46,190 --> 01:18:46,900
Other questions.
其他问题。

1351
01:18:46,910 --> 01:18:48,100
Thank you so much, sir.
非常感谢您，先生。

1352
01:18:48,110 --> 01:18:49,900
And I am going to see you on Monday.
我会在星期一见到你。

1353
01:18:51,120 --> 01:18:53,290
Good luck with your homework and the project.
祝你在作业和项目中好运。

1354
01:18:54,360 --> 01:18:54,670
Bye.
再见。

