1
00:00:05,080 --> 00:00:06,040
Hello, everyone.
大家好。

2
00:00:08,650 --> 00:00:12,530
So welcome.
非常欢迎。

3
00:00:13,100 --> 00:00:18,250
We are going to continue our lecture on a virtual memory.
我们将继续进行关于虚拟内存的讲座。

4
00:00:19,400 --> 00:00:26,360
We are going to start discussion on caching and tlb so it's time for the translation.
我们将开始讨论缓存和TLB，所以现在是翻译的时候了。

5
00:00:26,370 --> 00:00:27,530
Look aside buffers.
旁路缓冲区

6
00:00:31,360 --> 00:00:33,040
So if you recall,
所以如果你还记得的话，

7
00:00:36,350 --> 00:00:37,600
address translation,
地址转换

8
00:00:37,610 --> 00:00:39,240
as a name implies,
正如其名所示，

9
00:00:39,250 --> 00:00:44,820
it's about translating the addresses which are viewed by the application
这是关于将应用程序查看的地址进行翻译的问题。

10
00:00:44,830 --> 00:00:47,300
by the cp us into physical addresses.
通过将CPU转换为物理地址。

11
00:00:48,820 --> 00:00:56,750
There are a couple of reasons why we want to have this different kind of
有几个原因我们想要有这种不同类型的方式

12
00:00:56,760 --> 00:01:04,150
addresses for the application and versus of the physical
应用程序的地址和物理地址的对比

13
00:01:04,160 --> 00:01:04,870
addresses.
地址。

14
00:01:06,800 --> 00:01:13,470
Some of them are about providing the illusion to each application.
其中一些问题涉及为每个应用程序提供幻觉。

15
00:01:13,480 --> 00:01:16,200
It has its own machine,
它有自己的机器。

16
00:01:16,210 --> 00:01:17,480
its own resources,
自己的资源

17
00:01:17,490 --> 00:01:18,680
including the memory,
包括内存在内，

18
00:01:20,480 --> 00:01:27,080
which means that then you need to map the address space of each
这意味着你需要映射每个地址空间。

19
00:01:27,090 --> 00:01:30,120
of the application in the same physical space,
在同一物理空间中的应用程序

20
00:01:30,130 --> 00:01:31,680
which is physical memory.
物理内存是指计算机系统中实际存在的内存硬件。

21
00:01:32,680 --> 00:01:33,800
And also,
而且，

22
00:01:33,810 --> 00:01:35,680
another reason is protection,
另一个原因是保护性。

23
00:01:37,160 --> 00:01:44,310
because you want to protect the address space and of one application from another,
因为你想要保护一个应用程序的地址空间不受其他应用程序的影响。

24
00:01:45,280 --> 00:01:48,000
and also sharing, control, sharing, if you remember,
还有共享、控制、共享，如果你还记得的话。

25
00:01:48,010 --> 00:01:52,710
in which actually some parts of the address space you want to be shared.
你希望在实际上共享地址空间的某些部分。

26
00:01:52,950 --> 00:01:53,360
For instance,
例如，

27
00:01:53,370 --> 00:01:58,600
the address space which contains a code of a shared library of a library,
包含库的共享库代码的地址空间

28
00:01:58,610 --> 00:02:00,490
which is a code of a library,
这是一个库的代码。

29
00:02:00,500 --> 00:02:05,350
which is used by two applications like windows library on your own windows machine.
这是在你自己的Windows机器上，两个应用程序使用的类似于Windows库的功能。

30
00:02:06,040 --> 00:02:08,640
You do not want, but it begins that code in each application.
你不想要，但每个应用程序都会开始那段代码。

31
00:02:08,650 --> 00:02:09,560
You want to share that.
你想分享那个。

32
00:02:13,150 --> 00:02:15,060
Typically, you do the sharing.
通常情况下，您进行共享。

33
00:02:15,070 --> 00:02:16,100
It happens.
没关系。

34
00:02:17,790 --> 00:02:20,550
It's handled by one of these components are cheap,
其中一个组件是廉价的，它会处理这个问题。

35
00:02:20,560 --> 00:02:25,360
which is called a lot of this memory management unit.
这被称为内存管理单元。

36
00:02:27,060 --> 00:02:32,280
This was originally a a a was a standalone chip,
这最初是一个独立的芯片。

37
00:02:32,970 --> 00:02:37,000
which is you put near your between the processor and the memory.
在处理器和内存之间，你应该放置什么？

38
00:02:37,550 --> 00:02:41,120
But in the more than processors,
但在多处理器系统中，

39
00:02:41,380 --> 00:02:44,100
it just a component of that processor.
它只是该处理器的一个组件。

40
00:02:47,190 --> 00:02:53,880
One of the modest one of the techniques to do address translation was
其中一种较为简单的地址转换技术是

41
00:02:53,890 --> 00:02:56,280
a segment using multi segment.
使用多段的分段。

42
00:02:57,930 --> 00:02:59,960
And in this case, if you remember,
在这种情况下，如果你还记得的话，

43
00:03:00,870 --> 00:03:04,710
reach a segment is represented by a base and a limit.
一个段的表示由基址和限长组成。

44
00:03:05,840 --> 00:03:06,260
Okay?
好的？

45
00:03:07,170 --> 00:03:08,120
Now, the visual,
现在，视觉化，

46
00:03:08,650 --> 00:03:11,440
the address, which our address is against the address,
地址，我们的地址与该地址相对立。

47
00:03:11,450 --> 00:03:14,520
which is seen by the cpu and is seen by the application.
这是CPU所看到的，也是应用程序所看到的。

48
00:03:15,670 --> 00:03:17,700
We split into two,
我们分成两组，

49
00:03:17,710 --> 00:03:25,450
the first part of the first few beats represent an index in the segment table.
第一部分的前几个节拍代表段表中的索引。

50
00:03:27,520 --> 00:03:28,750
And then there is an opposite.
然后还有一个相反的情况。

51
00:03:29,850 --> 00:03:30,300
Okay?
好的？

52
00:03:30,850 --> 00:03:32,300
When you have a virtual address,
当你有一个虚拟地址时，

53
00:03:33,060 --> 00:03:34,550
you look at the first field,
你看一下第一个字段，

54
00:03:34,560 --> 00:03:35,800
which is the segment number.
这是段号。

55
00:03:36,440 --> 00:03:38,550
The first speech represent the second number,
第一个演讲代表第二个数字。

56
00:03:38,810 --> 00:03:42,790
use up to index into segment table.
使用索引访问段表。

57
00:03:43,270 --> 00:03:48,020
And then in that segment table,
然后在那个段表中，

58
00:03:48,310 --> 00:03:51,430
you are going to find the base of the segment and the limit.
你需要找到该段的基址和限制。

59
00:03:52,240 --> 00:03:58,560
And you are going to compute the physical address by adding the offset,
然后你将通过添加偏移量来计算物理地址。

60
00:04:00,060 --> 00:04:06,590
which is the second giving the virtual address to the segment base.
第二种方式是将虚拟地址赋值给段基址。

61
00:04:07,330 --> 00:04:09,080
These are the address.
这些是地址。

62
00:04:09,360 --> 00:04:15,320
And you are also going to check whether the address is generated is
而且你还要检查生成的地址是否正确

63
00:04:15,330 --> 00:04:16,330
less than the limit.
小于限制。

64
00:04:16,340 --> 00:04:17,630
So it's within the segment.
所以它在段内。

65
00:04:22,640 --> 00:04:27,930
You also have in some architecture, actually,
在某些体系结构中，你也有这样的情况。

66
00:04:27,940 --> 00:04:30,520
in intel eight x 86.
在英特尔的x86架构中。

67
00:04:31,340 --> 00:04:37,700
Instead of having the first the beats in the virtual address,
不再将虚拟地址中的第一个字节作为开头。

68
00:04:37,710 --> 00:04:40,250
presenting the the base,
呈现基础部分，

69
00:04:40,260 --> 00:04:45,060
the indexing into the segment table,
对段表进行索引

70
00:04:45,660 --> 00:04:47,200
you have just a bunch of segments,
你只有一堆段落。

71
00:04:47,210 --> 00:04:48,240
you have the initial,
你有初始值。

72
00:04:48,250 --> 00:04:49,280
you have four segments.
你有四个段。

73
00:04:50,040 --> 00:04:51,580
And these segments are men,
这些片段是男性。

74
00:04:51,590 --> 00:04:53,220
are base segments,
基本段

75
00:04:53,690 --> 00:04:57,400
are stored in special registers.
被存储在特殊寄存器中。

76
00:04:58,240 --> 00:05:05,980
Like es this is s is for the stack and three other registers.
这是关于栈和其他三个寄存器的说明。

77
00:05:07,910 --> 00:05:11,140
Then you compute the address by taking the virtual address,
然后你通过获取虚拟地址来计算地址。

78
00:05:11,150 --> 00:05:19,780
and you are going to add it to the segment register.
你需要将它添加到段寄存器中。

79
00:05:20,460 --> 00:05:22,650
That's how you are going to compute the physical address.
这是你计算物理地址的方法。

80
00:05:24,550 --> 00:05:27,400
A finally, there is a bit valid or not valid.
最后，有一个位是有效的还是无效的。

81
00:05:30,770 --> 00:05:32,480
This one is at the segment,
这个位于段落中。

82
00:05:32,490 --> 00:05:36,960
not all segments of all application can fit in the physical memory
并非所有应用程序的所有段都能适应物理内存。

83
00:05:36,970 --> 00:05:37,760
at the same time.
同时。

84
00:05:38,850 --> 00:05:42,290
So when you run out of space in the physical memory,
当物理内存空间不足时，

85
00:05:42,300 --> 00:05:43,590
and you want to load,
而且你想要加载，

86
00:05:43,820 --> 00:05:48,760
you start a new application on your program that it needs to.
你在程序上启动了一个新的应用程序，它需要...

87
00:05:49,090 --> 00:05:51,390
You need to allocate spacing.
你需要分配空间。

88
00:05:51,400 --> 00:05:55,270
The physical memory presenting program is a segment, is a new program.
物理内存展示程序是一个段，是一个新的程序。

89
00:05:56,310 --> 00:05:59,470
You may take one of the existing segments of an application.
您可以使用应用程序中的一个现有段落。

90
00:05:59,480 --> 00:06:02,980
It doesn't run, and we are going to store it on the disk.
它无法运行，我们打算将其存储在磁盘上。

91
00:06:03,980 --> 00:06:04,560
Okay?
好的？

92
00:06:05,390 --> 00:06:08,140
Then therefore, the segment is no longer in memory.
因此，该段不再在内存中。

93
00:06:08,150 --> 00:06:15,100
So then you can say it's you can use this bit to specify that.
那么你可以说，你可以使用这个位来指定。

94
00:06:15,110 --> 00:06:16,820
So whenever next time,
所以下次无论何时，

95
00:06:16,830 --> 00:06:18,820
when you are looking for something in that segment,
当你在那个段落中寻找某个东西时，

96
00:06:19,830 --> 00:06:26,920
then you are going to you are going to get an exception,
那么你将会收到一个异常。

97
00:06:26,930 --> 00:06:30,040
and the exception is going to be treated by the operating system.
异常将由操作系统处理。

98
00:06:30,420 --> 00:06:34,320
The operating system will bring the segment from the disk to memory
操作系统将从磁盘将段加载到内存中。

99
00:06:34,330 --> 00:06:36,280
before executing that instruction.
在执行该指令之前。

100
00:06:41,730 --> 00:06:42,880
This is some examples.
这是一些例子。

101
00:06:44,020 --> 00:06:44,170
Here.
在这里。

102
00:06:44,660 --> 00:06:45,530
It's a simple.
这很简单。

103
00:06:48,760 --> 00:06:53,680
An example of an architecture is four segments.
一个架构的例子是四个段。

104
00:06:54,220 --> 00:06:56,550
The address is 16 bits.
地址是16位的。

105
00:06:57,260 --> 00:07:03,780
The first 2 bits of the address are used to specify the segment number,
地址的前两位用于指定段号。

106
00:07:04,860 --> 00:07:06,130
because we have four segments.
因为我们有四个段。

107
00:07:06,140 --> 00:07:07,090
We need only to be.
我们只需要存在。

108
00:07:07,100 --> 00:07:09,170
So this at least 15 and 14.
至少是15和14。

109
00:07:09,570 --> 00:07:12,400
The rest of these from 13 to 0 represent the office.
从13到0的剩余部分代表办公室。

110
00:07:13,570 --> 00:07:16,170
On the left hand side, you can see the address space,
在左侧，您可以看到地址空间。

111
00:07:16,580 --> 00:07:17,650
the virtual address space.
虚拟地址空间。

112
00:07:17,660 --> 00:07:20,530
So as seen by the application,
从应用程序的角度来看，

113
00:07:21,660 --> 00:07:23,870
we have our traditional four segments,
我们有我们传统的四个段，

114
00:07:23,880 --> 00:07:24,980
a code segments,
一个代码段

115
00:07:26,080 --> 00:07:27,070
the data,
数据

116
00:07:27,580 --> 00:07:29,070
the stack segments.
栈段。

117
00:07:29,880 --> 00:07:32,670
This is also we added a shared segment.
这也是我们添加了一个共享段。

118
00:07:33,100 --> 00:07:35,770
Think about this is either that 8 hours a code,
考虑一下，这可能是每天编码8小时的情况。

119
00:07:35,780 --> 00:07:39,070
which you may want to share with another application.
这些信息可能需要与另一个应用程序共享。

120
00:07:41,110 --> 00:07:44,840
So here with in green,
这里是绿色的。

121
00:07:44,850 --> 00:07:45,960
you have the table,
你有这张表。

122
00:07:46,330 --> 00:07:47,360
the segment table,
段表

123
00:07:47,720 --> 00:07:51,620
again, four entries for code data shared and the stack.
再次，对于代码、数据、共享和栈，有四个条目。

124
00:07:52,680 --> 00:07:57,790
And you have the base and the limit for each of these segments.
你有每个段的基址和限长。

125
00:07:58,650 --> 00:07:59,240
Now,
现在，

126
00:08:00,810 --> 00:08:01,960
let's see what happens,
让我们看看会发生什么，

127
00:08:02,370 --> 00:08:04,200
for instance, and on the right hand side,
例如，在右侧。

128
00:08:04,210 --> 00:08:05,600
you have the physical address.
你有物理地址。

129
00:08:05,910 --> 00:08:07,740
For simply things like, in this case,
对于简单的事情，比如在这种情况下，

130
00:08:07,750 --> 00:08:09,900
the physical address and the virtual address spaces,
物理地址和虚拟地址空间

131
00:08:09,910 --> 00:08:11,100
they have the same size.
它们的大小相同。

132
00:08:14,200 --> 00:08:15,870
Say, you are going from the code,
你正在从代码中进行操作。

133
00:08:15,880 --> 00:08:18,950
you are going to execute in instruction in the code.
你将要执行代码中的一条指令。

134
00:08:22,100 --> 00:08:25,730
Where is that going to be mapped in the physical address space?
这将被映射到物理地址空间的哪个位置？

135
00:08:27,390 --> 00:08:31,130
If you look about in the segment table,
如果你在段表中查找，

136
00:08:32,280 --> 00:08:37,870
because the first two beats of everything in the code segment at zero.
因为代码段中的所有内容的前两个节拍都是零。

137
00:08:38,500 --> 00:08:41,460
Therefore, you are going to identify the first entry,
因此，你将要识别第一个条目。

138
00:08:42,370 --> 00:08:42,670
right?
对的？

139
00:08:43,430 --> 00:08:44,730
In the segment table,
在段表中，

140
00:08:45,380 --> 00:08:48,690
you have a base of four salad in hex,
你有一个以十六进制表示的四个沙拉的基数。

141
00:08:48,700 --> 00:08:50,170
a specimen format.
一个样本格式。

142
00:08:51,430 --> 00:08:57,620
Therefore, you have to add an 4,000 to every address,
因此，您需要将每个地址增加4,000。

143
00:08:57,630 --> 00:09:00,770
a virtual address is a code segment.
虚拟地址是一个代码段。

144
00:09:01,430 --> 00:09:03,250
And to get the physical responding,
为了获得物理响应，

145
00:09:03,260 --> 00:09:08,000
physical address for the code in the physical outer space,
物理外部空间中代码的物理地址

146
00:09:11,310 --> 00:09:12,970
then for data,
那么对于数据来说，

147
00:09:12,980 --> 00:09:17,710
the data starts in the visual of the space at 4,000.
数据从空间的可视化开始，位于4,000处。

148
00:09:18,850 --> 00:09:27,660
This means that what are the first two beats of any address in the data segment?
这意味着在数据段中，任何地址的前两个字节是什么？

149
00:09:28,880 --> 00:09:29,590
Why don't you tell me?
为什么你不告诉我呢？

150
00:09:29,600 --> 00:09:32,270
It should be a very simple answer here.
这应该是一个非常简单的答案。

151
00:09:36,170 --> 00:09:43,070
The first we have 16 bits when we use a hexadecimal representation,
当我们使用十六进制表示时，首先我们有16位。

152
00:09:43,640 --> 00:09:43,830
right?
对的吗？

153
00:09:43,840 --> 00:09:46,830
4 bits represent one digit.
4位表示一个数字。

154
00:09:47,690 --> 00:09:49,920
Now we have four here for us.
现在我们这里有四个人。

155
00:09:50,730 --> 00:09:51,470
What does it mean?
这句话的意思是什么？

156
00:09:53,870 --> 00:09:54,780
What are the forbes?
福布斯是一家美国的商业杂志和媒体公司，成立于1917年。福布斯以发布全球富豪榜而闻名，该榜单列出了世界上最富有的人。此外，福布斯还报道商业、投资、科技、创业和领导力等领域的新闻和文章。福布斯也是一个知名的品牌，拥有多个国际版本和在线平台。

157
00:09:54,790 --> 00:09:55,980
The first forbids,
第一个禁止，

158
00:09:55,990 --> 00:09:58,350
the forbids representing the 4th.
禁止代表第四个。

159
00:09:59,020 --> 00:10:02,600
How do you write for in binary presentation?
你如何用二进制表示"for"这个词？

160
00:10:18,330 --> 00:10:18,800
Here it is.
这是它。

161
00:10:18,810 --> 00:10:20,560
I'm writing this in our chat,
我正在我们的聊天中写这个。

162
00:10:21,880 --> 00:10:23,070
foreign binary representation.
外部二进制表示。

163
00:10:23,080 --> 00:10:25,470
If you want to represent it,
如果你想要表示它，

164
00:10:25,480 --> 00:10:32,230
or in using 4 bits is 10100.
或者使用4位二进制表示为10100。

165
00:10:35,090 --> 00:10:36,130
This is it, right?
是这样的，对吗？

166
00:10:36,140 --> 00:10:39,430
It's 100 is 4 in the binary presentation,
在二进制表示中，100等于4。

167
00:10:41,850 --> 00:10:47,520
which means that the first beats for any address in the beta segment.
这意味着beta段中的任何地址的第一个字节。

168
00:10:52,050 --> 00:10:58,410
The segment number here is what?
这里的段号是什么？

169
00:10:58,420 --> 00:10:59,450
01.
01. 欢迎来到CS162计算机操作系统课程！我是你的助教。如果你有任何问题或需要帮助，请随时向我提问。

170
00:11:01,280 --> 00:11:03,160
Now it's not 00101,
现在不是00101了。

171
00:11:03,170 --> 00:11:04,680
because it's only the first to beat,
因为它只是第一个被击败的。

172
00:11:05,220 --> 00:11:06,540
but it is for its product.
但这是针对它的产品。

173
00:11:06,750 --> 00:11:08,660
It can go, okay,
可以，好的。

174
00:11:09,470 --> 00:11:10,020
it's 01.
现在是01点。

175
00:11:10,030 --> 00:11:11,870
This is what is one?
这是什么意思？

176
00:11:13,480 --> 00:11:14,230
This is what you have.
这是你所拥有的。

177
00:11:19,070 --> 00:11:22,980
Therefore, to translate any address in the data segment.
因此，要将数据段中的任何地址进行翻译。

178
00:11:23,920 --> 00:11:24,650
What do you need to?
你需要什么帮助？

179
00:11:25,590 --> 00:11:30,180
Do you go to the second entry in the segment table?
你是否要进入段表的第二个条目？

180
00:11:30,190 --> 00:11:33,280
The one, which the segment id number is one,
其中段号为1的那个

181
00:11:34,350 --> 00:11:36,290
and the base here is 4,800.
这里的基数是4,800。

182
00:11:37,370 --> 00:11:40,660
So what you need to do is that you are going to add,
你需要做的是添加，

183
00:11:40,970 --> 00:11:43,590
in order to translate any address in the data segment,
为了翻译数据段中的任何地址，

184
00:11:43,920 --> 00:11:45,910
you need to add to it for the 800
你需要为800添加一些内容。

185
00:11:55,180 --> 00:11:56,930
for the shared segment.
对于共享段。

186
00:11:57,360 --> 00:11:59,370
This is the things go.
事情就是这样进行的。

187
00:11:59,380 --> 00:12:00,930
This similarly,
同样地，

188
00:12:01,220 --> 00:12:02,810
for the share of settlement,
关于结算的分享，

189
00:12:02,820 --> 00:12:04,610
they started 800,000.
他们开始了80万。

190
00:12:05,450 --> 00:12:07,790
So the first four beats is eight,
所以前四拍是八拍。

191
00:12:08,030 --> 00:12:09,050
represent eight.
表示数字八。

192
00:12:09,550 --> 00:12:11,370
What is the binary presentation of eight?
八的二进制表示是 1000。

193
00:12:19,060 --> 00:12:19,810
It's exactly.
没错。

194
00:12:20,580 --> 00:12:22,860
The first two beats at 10.
前两拍速度为10。

195
00:12:23,930 --> 00:12:25,280
The second one number,
第二个数字，

196
00:12:26,760 --> 00:12:28,520
one, it's 10 is two.
一，它是10，是二。

197
00:12:29,140 --> 00:12:29,340
Right?
对吗？

198
00:12:29,350 --> 00:12:31,020
Because you take only the first two beats.
因为你只取前两拍。

199
00:12:31,560 --> 00:12:35,690
And finally, stack c what is ac the representation?
最后，栈 c 的表示是什么？

200
00:12:39,160 --> 00:12:46,160
Binary representation of c you should remember this.
你应该记住 c 的二进制表示。

201
00:12:47,140 --> 00:12:47,340
Right?
对吗？

202
00:12:47,350 --> 00:12:48,500
Is the review.
这是一篇评论。

203
00:12:50,400 --> 00:12:51,880
It's 1100.
现在是1100点。

204
00:12:54,860 --> 00:12:55,300
Exactly, very good.
没错，非常好。

205
00:12:57,250 --> 00:12:58,880
The first two bits are 11.
前两位是11。

206
00:12:59,400 --> 00:12:59,950
It's three.
现在是三点钟。

207
00:13:00,250 --> 00:13:04,240
Number three is the last entry in the table.
第三个是表格中的最后一项。

208
00:13:05,660 --> 00:13:07,090
And for go to the stack,
而要进入栈，

209
00:13:07,790 --> 00:13:10,730
the base is zero, right?
基数是零，对吗？

210
00:13:10,980 --> 00:13:14,040
You add the base offset to the base.
你将基址偏移量加到基址上。

211
00:13:14,130 --> 00:13:15,600
We started from 000.
我们从000开始。

212
00:13:19,820 --> 00:13:20,630
Does it make sense?
这有意义吗？

213
00:13:24,180 --> 00:13:25,890
Let's look at this as an example.
让我们以这个作为例子来看。

214
00:13:25,900 --> 00:13:26,410
By the way,
顺便说一下，

215
00:13:27,100 --> 00:13:30,680
you should you should try.
你应该尝试一下。

216
00:13:31,290 --> 00:13:33,080
These are some very important slides,
这些是一些非常重要的幻灯片，

217
00:13:34,410 --> 00:13:42,360
because you may expect not only to understand how the address translation works,
因为你可能希望不仅了解地址转换的工作原理，

218
00:13:42,370 --> 00:13:47,360
which is one of the fundamental mechanics in used in the existing
这是现有系统中使用的基本机制之一。

219
00:13:47,370 --> 00:13:50,330
in today's processors and leverage
在今天的处理器中利用和发挥作用

220
00:13:50,340 --> 00:13:52,930
by the operating system to provide virtual memory,
通过操作系统提供虚拟内存，

221
00:13:53,830 --> 00:13:54,850
abstraction,
抽象化

222
00:13:54,860 --> 00:14:00,010
but also because you can expect problems like this in your next meter.
而且因为你可以预料到你下一个计量器会出现类似的问题。

223
00:14:01,110 --> 00:14:01,450
Okay.
好的。

224
00:14:03,590 --> 00:14:09,160
Now, let's look at this piece of code and see what happens under the foot.
现在，让我们来看看这段代码，在底层发生了什么。

225
00:14:09,170 --> 00:14:13,860
And we are assuming this piece of code is going to run
我们假设这段代码将会运行。

226
00:14:13,870 --> 00:14:15,620
on the previous architecture from.
在先前的架构上。

227
00:14:15,630 --> 00:14:18,180
Ii just showed you in the last slide,
我刚在上一张幻灯片中给你展示了。

228
00:14:20,460 --> 00:14:22,330
you have the segment table is the same.
你有相同的段表。

229
00:14:23,920 --> 00:14:24,710
Now is a code.
现在是一段代码。

230
00:14:24,880 --> 00:14:26,710
The code starts that to 40.
代码从40开始。

231
00:14:27,600 --> 00:14:31,470
We don't basically the entire address is 0240,
我们的基本地址是0240。

232
00:14:31,950 --> 00:14:36,000
but you don't show the first four beats which are zero.
但你没有显示前四个节拍，它们都是零。

233
00:14:39,320 --> 00:14:39,720
Okay.
好的。

234
00:14:40,990 --> 00:14:42,070
Now let's see what happens.
现在让我们看看会发生什么。

235
00:14:42,080 --> 00:14:44,390
And this is a serial language,
这是一种串行语言，

236
00:14:44,400 --> 00:14:47,260
theodore assembly, language, code.
Theodore汇编语言代码。

237
00:14:48,370 --> 00:14:50,800
Let's see what happens when we start with the disco.
让我们看看从迪斯科开始会发生什么。

238
00:14:51,990 --> 00:14:53,910
The first instruction is a main,
第一条指令是一个主函数。

239
00:14:54,630 --> 00:14:57,420
and basically what his instruction is doing.
基本上，他的指令是在做什么。

240
00:14:58,050 --> 00:15:04,880
It loads an address which is bar x into register a
它将一个地址 bar x 加载到寄存器 a 中。

241
00:15:06,670 --> 00:15:08,720
zero right now,
零，现在。

242
00:15:09,620 --> 00:15:16,070
this code is run in the user process,
这段代码在用户进程中运行。

243
00:15:16,080 --> 00:15:17,210
the user process.
用户进程。

244
00:15:17,570 --> 00:15:18,870
See virtual addresses.
查看虚拟地址。

245
00:15:19,740 --> 00:15:23,550
So all the addresses you see here are virtual addresses.
这里看到的所有地址都是虚拟地址。

246
00:15:24,480 --> 00:15:24,820
Okay?
好的？

247
00:15:25,840 --> 00:15:32,720
But now the code and the data they are actually stored in the physical memory
但是现在代码和数据实际上存储在物理内存中。

248
00:15:33,570 --> 00:15:38,130
in order to read the instructions and access a data,
为了阅读说明并访问数据，

249
00:15:38,420 --> 00:15:41,630
we need to translate the virtual addresses to the physical address.
我们需要将虚拟地址转换为物理地址。

250
00:15:45,390 --> 00:15:49,260
So they address the instruction, firstly,
首先，他们解析指令。

251
00:15:49,830 --> 00:15:53,060
to fetch the instruction in order to execute the instructions instruction.
为了执行指令，需要获取指令。

252
00:15:53,070 --> 00:15:54,700
Again, it's in physical memory.
再次强调，它存储在物理内存中。

253
00:15:56,160 --> 00:15:57,750
The address of virtual address,
虚拟地址的地址

254
00:15:57,760 --> 00:15:59,580
it's 0~40.
是0到40。

255
00:15:59,590 --> 00:16:00,740
We discussed.
我们讨论了。

256
00:16:01,570 --> 00:16:04,760
Here is a binary representation of the address.
这是一个地址的二进制表示。

257
00:16:05,210 --> 00:16:06,440
The first to beat are zero.
首先要击败的是零。

258
00:16:07,720 --> 00:16:13,790
The segment id the sigma number is zero.
该段的Sigma编号为零。

259
00:16:14,570 --> 00:16:16,960
Is that a four in order,
这是按顺序的四个吗？

260
00:16:17,370 --> 00:16:22,360
translate this address for virtual address to 40,
将虚拟地址转换为物理地址为40。

261
00:16:24,000 --> 00:16:25,200
to a physical address,
到物理地址，

262
00:16:25,490 --> 00:16:29,840
we need to add the base address corresponding to the segment.
我们需要添加与段对应的基地址。

263
00:16:30,730 --> 00:16:36,780
So the basis 4,000 and the virtual offset,
所以基址是4,000，虚拟偏移量是...

264
00:16:37,430 --> 00:16:37,860
right?
对的？

265
00:16:38,310 --> 00:16:39,070
Is 240.
是240。

266
00:16:39,340 --> 00:16:40,110
The virtual officers.
虚拟官员。

267
00:16:40,120 --> 00:16:45,440
The offset is the other side of the black beats.
偏移量是黑色节拍的另一侧。

268
00:16:45,810 --> 00:16:46,710
In the address,
在地址中，

269
00:16:47,380 --> 00:16:52,770
the beats encoding,
Beats编码

270
00:16:52,780 --> 00:16:55,650
the segment identifier are the green beats.
段标识符是绿色的节拍。

271
00:16:56,020 --> 00:16:56,550
Obviously,
显然，

272
00:16:58,250 --> 00:17:00,640
you have to add all the offset,
你需要将所有的偏移量相加。

273
00:17:00,650 --> 00:17:03,590
which is 240 to 4,000,
这是从240到4,000。

274
00:17:03,600 --> 00:17:04,670
which is a base.
哪一个是基数。

275
00:17:04,680 --> 00:17:09,200
And therefore, you are going to get the physical address 4,000, 200, 40.
因此，您将获得物理地址 4,000、200、40。

276
00:17:10,180 --> 00:17:10,420
Now,
现在，

277
00:17:10,430 --> 00:17:14,200
you are going to use this address to fetch the instruction from the memory.
你将使用这个地址从内存中获取指令。

278
00:17:15,310 --> 00:17:18,310
And the instruction is basically like I told you,
指令基本上就像我告诉你的那样。

279
00:17:18,630 --> 00:17:20,690
it's to load the address,
这是为了加载地址。

280
00:17:20,700 --> 00:17:22,410
which is barracks address,
请问是哪个兵营的地址？

281
00:17:22,810 --> 00:17:29,250
which is 4050 is the virtual address into a registration.
将4050作为虚拟地址加载到寄存器中。

282
00:17:32,740 --> 00:17:34,510
Now, after that,
现在，在那之后，

283
00:17:34,950 --> 00:17:37,070
you execute the instruction, you would know very well.
你执行这条指令，你会非常清楚。

284
00:17:37,080 --> 00:17:38,230
What happens next?
接下来会发生什么？

285
00:17:38,240 --> 00:17:39,750
The program counter.
程序计数器。

286
00:17:40,200 --> 00:17:43,110
It's increment by four,
它每次增加四，

287
00:17:43,600 --> 00:17:47,770
because he are assuming that there are instruction,
因为他假设存在指令。

288
00:17:47,780 --> 00:17:49,980
they occupy 4 bytes.
它们占据4个字节。

289
00:17:50,720 --> 00:17:53,270
The next instruction address is 2, 44.
下一条指令的地址是2, 44。

290
00:17:57,540 --> 00:18:00,520
So let's execute the next instruction.
那么让我们执行下一条指令。

291
00:18:03,130 --> 00:18:03,780
It's again,
又是这样，

292
00:18:05,170 --> 00:18:06,530
in the next instruction,
在下一条指令中，

293
00:18:06,870 --> 00:18:11,190
you are going to see you have now the other sister for,
你将会看到，你现在有了另一个姐妹。

294
00:18:11,200 --> 00:18:12,350
like I mentioned,
就像我之前提到的那样，

295
00:18:12,850 --> 00:18:14,440
again, the physical,
再次，物理层

296
00:18:14,450 --> 00:18:16,040
if you look at,
如果你看一下，

297
00:18:16,840 --> 00:18:18,960
this will also be in the code segment,
这也将位于代码段中，

298
00:18:19,300 --> 00:18:21,450
we need to add the base, which is 4,000.
我们需要加上基数，即4,000。

299
00:18:21,460 --> 00:18:23,930
The physical address would be 4244.
物理地址将是4244。

300
00:18:24,440 --> 00:18:26,910
You are going to get the next instruction,
你将要获取下一条指令。

301
00:18:26,920 --> 00:18:32,060
which is jail to jam to this string,
将这个字符串压缩到哪个目录下？

302
00:18:32,070 --> 00:18:33,890
land address,
土地地址

303
00:18:34,960 --> 00:18:35,330
label.
标签。

304
00:18:35,650 --> 00:18:36,000
All right?
好吗？

305
00:18:37,090 --> 00:18:40,360
And this is exactly what you do it.
这就是你所做的。

306
00:18:41,370 --> 00:18:44,720
But before the jumping here,
但在此之前，

307
00:18:44,730 --> 00:18:47,410
we store the return address.
我们存储返回地址。

308
00:18:47,420 --> 00:18:49,490
After we execute the function string land,
执行完函数string land之后，

309
00:18:49,500 --> 00:18:51,010
we need to return, well,
我们需要返回，嗯，

310
00:18:51,700 --> 00:18:53,730
to the next instruction after the jump,
跳转指令后的下一条指令

311
00:18:53,740 --> 00:18:56,700
the next instruction after the jump would be zero,
跳转指令之后的下一条指令将是零。

312
00:18:56,710 --> 00:18:59,160
x 248.
x 248. 

x 248.

313
00:19:02,540 --> 00:19:04,010
Therefore, we are going to,
因此，我们打算，

314
00:19:04,020 --> 00:19:07,130
we assume here that we have a return address registers,
我们在这里假设我们有一个返回地址寄存器。

315
00:19:07,550 --> 00:19:09,220
Which stores the return address.
存储返回地址的是什么？

316
00:19:09,230 --> 00:19:11,540
So we are going to load into the return address,
所以我们将加载到返回地址中，

317
00:19:12,330 --> 00:19:13,160
0248.
0248.

318
00:19:13,170 --> 00:19:21,250
And this is done automatically by the compiled code,
这是由编译后的代码自动完成的。

319
00:19:21,720 --> 00:19:22,760
by your obligation.
根据你的义务。

320
00:19:25,870 --> 00:19:28,020
Then you move in the priest program,
然后你进入了牧师程序。

321
00:19:28,030 --> 00:19:29,340
counter the address,
计数器地址

322
00:19:29,350 --> 00:19:30,420
or you want to jump.
或者你想跳跃。

323
00:19:30,430 --> 00:19:32,020
So the address you want to jump,
所以你想要跳转的地址是，

324
00:19:32,030 --> 00:19:36,510
the label string line is corresponding to the address360.
标签字符串行对应于地址360。

325
00:19:37,890 --> 00:19:38,990
So you're going to jump there,
所以你要跳过去，

326
00:19:39,000 --> 00:19:42,220
and you are going to execute that next instruction,
然后你将执行下一条指令。

327
00:19:42,230 --> 00:19:44,780
which will be the address 360360.
地址360360将是什么？

328
00:19:45,690 --> 00:19:48,100
Its, again, is in the segment code.
这个问题再次出现在代码段中。

329
00:19:48,580 --> 00:19:50,470
In order to compute the physical address,
为了计算物理地址，

330
00:19:50,480 --> 00:19:52,330
you are going towards the base,
你正在朝基地前进。

331
00:19:54,290 --> 00:19:57,600
which is 4,000 of 4,000+360,
4,000占4,000+360的比例是多少？

332
00:19:58,140 --> 00:20:00,210
is 400, 660.
是 400，660。

333
00:20:00,220 --> 00:20:03,690
And then you are going to read from the physical memory.
然后你将从物理内存中读取数据。

334
00:20:03,990 --> 00:20:05,780
You are going to read,
你将要阅读的是，

335
00:20:06,510 --> 00:20:11,950
and this instruction is basically initialize this account, put a zero,
这个指令基本上是初始化这个账户，将其设为零。

336
00:20:12,280 --> 00:20:14,940
a in a register v zero.
将 a 存储在寄存器 v zero 中。

337
00:20:17,370 --> 00:20:20,000
Once you execute that to go to the next instruction,
执行该指令后，进入下一条指令。

338
00:20:22,080 --> 00:20:23,280
and the next instruction,
下一条指令是，

339
00:20:24,770 --> 00:20:27,350
the other is 364.
另一个是364。

340
00:20:28,020 --> 00:20:29,670
And this next instruction,
而这个下一条指令，

341
00:20:29,880 --> 00:20:35,170
it loads what is at this particular address,
它加载了这个特定地址上的内容，

342
00:20:35,180 --> 00:20:36,570
which is stored in a zero?
存储在零中的是什么？

343
00:20:36,780 --> 00:20:39,090
Remember that what is stored in the a zero?
记住，零存储的是什么？

344
00:20:39,100 --> 00:20:41,580
It was bar x address.
这是一个地址为x的酒吧。

345
00:20:41,970 --> 00:20:44,560
This is a bar x address is 4050.
这是一个酒吧，地址是4050。

346
00:20:45,760 --> 00:20:50,290
Now we are one to load in register t zero.
现在我们要将数据加载到寄存器 t zero 中。

347
00:20:50,800 --> 00:20:55,040
The content of the address barracks of the address 4050.
地址4050处的地址营房的内容。

348
00:20:56,440 --> 00:20:59,190
When we want to do that and we want to access it,
当我们想要做那件事并且想要访问它时，

349
00:20:59,840 --> 00:21:03,030
to see what is the content of that mutual address.
查看该共享地址的内容。

350
00:21:03,040 --> 00:21:05,470
The mutual address is 4050.
相互地址是4050。

351
00:21:06,420 --> 00:21:08,130
This is a binary representation.
这是一个二进制表示。

352
00:21:08,140 --> 00:21:10,290
The first two beats are 01.
前两拍是01。

353
00:21:11,200 --> 00:21:12,430
The segment index,
段索引

354
00:21:12,440 --> 00:21:15,390
which corresponds to this address is one.
对应于该地址的值为1。

355
00:21:16,470 --> 00:21:21,580
Therefore, the base address of that segment is840 800.
因此，该段的基地址是840 800。

356
00:21:22,300 --> 00:21:25,700
Therefore, you need to add the 4,800 to what?
因此，你需要将4,800加到什么上面？

357
00:21:26,450 --> 00:21:27,240
To the offset.
到偏移量。

358
00:21:27,770 --> 00:21:29,150
So what is the offset here?
这里的偏移量是什么？

359
00:21:29,460 --> 00:21:31,290
The offset here, notice is 50.
这里的偏移量是50。

360
00:21:31,770 --> 00:21:34,720
The virtual address is 4050.
虚拟地址为4050。

361
00:21:36,280 --> 00:21:37,230
But remember,
但是请记住，

362
00:21:37,530 --> 00:21:42,270
the first 2 bits of this address represent the segment id that's one.
这个地址的前两位表示段标识符为1。

363
00:21:42,820 --> 00:21:45,040
And the last, in this case,
最后，在这种情况下，

364
00:21:45,520 --> 00:21:48,270
14 beats represents the opposite,
14拍代表相反的意思。

365
00:21:48,570 --> 00:21:50,710
but the last 14 beats is 50.
但最后14拍是50。

366
00:21:52,800 --> 00:21:54,990
Now is the offset is 50.
现在的偏移量是50。

367
00:21:55,000 --> 00:21:59,630
It's, again, offset is a black digits,
这里，偏移量是黑色数字。

368
00:21:59,640 --> 00:22:00,670
like 01.
喜欢 01.

369
00:22:03,730 --> 00:22:08,130
Then you are going to add the offset to the basis,
然后你将把偏移量加到基数上。

370
00:22:08,140 --> 00:22:09,290
4,800.
4,800.  (四千八百)

371
00:22:09,660 --> 00:22:13,030
The physical address you are going to compute is 4,850.
你要计算的物理地址是4,850。

372
00:22:15,990 --> 00:22:20,160
And you are going to load the bite from that address to d zero.
你将从该地址加载字节到d zero寄存器中。

373
00:22:20,960 --> 00:22:22,400
And you increment the program count.
然后你增加程序计数器的值。

374
00:22:24,350 --> 00:22:26,740
The main thing to note here that everything,
需要注意的主要事项是，一切事物都

375
00:22:26,750 --> 00:22:29,260
which is in what the processor sees,
这是处理器所看到的内容。

376
00:22:30,250 --> 00:22:31,130
everything,
一切事物，

377
00:22:31,690 --> 00:22:33,970
what is in the registers of the processors?
处理器的寄存器中存储了什么内容？

378
00:22:34,930 --> 00:22:37,260
All these are virtual addresses.
这些都是虚拟地址。

379
00:22:38,360 --> 00:22:43,320
The translation happens only where you are going to access a memory.
翻译仅在您要访问内存的地方发生。

380
00:22:45,780 --> 00:22:49,240
So the memory management units really sits
因此，内存管理单元实际上是坐在那里的。

381
00:22:49,250 --> 00:22:55,290
between the arithmetic logical units and all the registers and the memory.
在算术逻辑单元、所有寄存器和内存之间。

382
00:22:57,860 --> 00:22:58,880
Any questions?
有任何问题吗？

383
00:23:07,860 --> 00:23:10,420
We spent quite a bit of time on this one,
我们在这个问题上花了相当多的时间，

384
00:23:10,430 --> 00:23:11,460
but this is important.
但这很重要。

385
00:23:11,470 --> 00:23:15,150
Please make sure that you understand this example,
请确保您理解这个例子。

386
00:23:17,490 --> 00:23:24,280
as you'll see, from the previous years and previous exams,
正如你所看到的，从以往的年份和以往的考试中，

387
00:23:25,320 --> 00:23:28,500
you are going to see a lot of problems like this one.
你将会遇到很多类似这样的问题。

388
00:23:33,110 --> 00:23:36,560
So a few things about some segmentation.
关于分段的一些事情。

389
00:23:38,510 --> 00:23:40,870
The one problem with the segmentation is nice.
分段的一个问题是很好的。

390
00:23:40,880 --> 00:23:42,630
It's a very elegant solution,
这是一个非常优雅的解决方案。

391
00:23:43,330 --> 00:23:46,000
but you are going to translate on every instruction,
是的，我会在每个指令上进行翻译。

392
00:23:46,720 --> 00:23:49,310
everything even in fetching instruction,
包括获取指令在内的一切

393
00:23:49,530 --> 00:23:53,730
access of read some data,
读取某些数据的访问权限

394
00:23:53,740 --> 00:23:55,130
write some data from the node.
从节点中写入一些数据。

395
00:24:01,200 --> 00:24:04,380
And virtual address space has halls, right?
虚拟地址空间有走廊吗？

396
00:24:04,910 --> 00:24:09,300
Because you are not going to use everything in your visual address.
因为你不会使用到你的虚拟地址空间中的所有内容。

397
00:24:13,470 --> 00:24:16,260
That's why I use a segmentation in the first part,
这就是为什么我在第一部分使用了分段的原因。

398
00:24:16,270 --> 00:24:21,410
in the first thing in the first in the first place.
首先，首先，首先。

399
00:24:21,910 --> 00:24:23,660
Because if you think about,
因为如果你仔细考虑一下，

400
00:24:23,670 --> 00:24:25,500
if you have the code and the segment,
如果你有代码和段落，

401
00:24:25,900 --> 00:24:27,210
the segment grows,
段增长。

402
00:24:28,230 --> 00:24:30,540
you put the segment as a high addresses,
你将段放在高地址处。

403
00:24:30,890 --> 00:24:32,920
because it grows to the smaller,
因为它逐渐变小，

404
00:24:32,930 --> 00:24:35,200
grows downwards to the smaller addresses.
向较小的地址方向增长。

405
00:24:35,670 --> 00:24:37,050
For instance, a data segment,
例如，数据段，

406
00:24:37,060 --> 00:24:39,290
you have to be as a lower others,
你必须以低姿态对待他人，

407
00:24:39,570 --> 00:24:40,690
because it's going growing up.
因为它正在不断成长。

408
00:24:41,490 --> 00:24:42,000
Okay?
好的？

409
00:24:43,410 --> 00:24:45,010
Whilst the stack growing down,
在栈向下增长时，

410
00:24:45,020 --> 00:24:47,690
so you need to separate them and between them, there is a gap.
所以你需要将它们分开，并且它们之间有一个间隔。

411
00:24:48,350 --> 00:24:48,710
Right?
对吗？

412
00:24:49,990 --> 00:24:51,540
If you have segments,
如果你有分段，

413
00:24:51,550 --> 00:24:52,700
if you don't have the gap,
如果你没有间隙，

414
00:24:53,950 --> 00:24:55,820
if you're sorry, if you don't have the segments,
如果你很抱歉，如果你没有这些片段，

415
00:24:56,040 --> 00:24:59,710
that gap will occupy space in the physical memory.
这个间隙将占据物理内存空间。

416
00:25:01,180 --> 00:25:02,860
Facebook would have been used empty space,
Facebook会利用空闲空间。

417
00:25:02,870 --> 00:25:07,080
can be used to allocate to other processes,
可以用于分配给其他进程。

418
00:25:07,410 --> 00:25:08,470
other applications.
其他应用程序。

419
00:25:09,570 --> 00:25:12,440
However, if I have these two segments,
然而，如果我有这两个段落，

420
00:25:12,450 --> 00:25:16,700
now each segment can have the one segment can have data,
现在每个段可以有一个段可以有数据。

421
00:25:16,710 --> 00:25:18,440
one segment can serve the stack.
一个段可以用来作为栈。

422
00:25:18,850 --> 00:25:22,630
And then they are going to be mapped on the physical memory.
然后它们将被映射到物理内存上。

423
00:25:22,970 --> 00:25:24,620
The gap I don't need to map it.
这个间隙我不需要映射它。

424
00:25:24,630 --> 00:25:28,340
I don't need to just waste the space on the physical memory.
我不需要浪费物理内存空间。

425
00:25:34,350 --> 00:25:35,810
So now,
所以现在，

426
00:25:36,460 --> 00:25:38,730
the one thing to notice here is,
这里需要注意的一件事是，

427
00:25:38,740 --> 00:25:43,770
I said you are located segments for the stack and the data.
我说过你需要为栈和数据分配内存段。

428
00:25:44,310 --> 00:25:52,230
But if allocate and how allocate the stack has a certain size and allocate that
但是如果分配和如何分配栈有一个确定的大小，并且分配它。

429
00:25:52,600 --> 00:25:55,990
physical memory for the stack at that given size.
给定大小的堆栈的物理内存。

430
00:25:56,000 --> 00:25:59,110
What happens when the stack growth and that stock growth?
当堆栈增长和栈增长时会发生什么？

431
00:25:59,120 --> 00:26:03,420
Because they call more functions of, say, recursive programs.
因为它们调用了更多的函数，比如递归程序。

432
00:26:03,710 --> 00:26:08,560
Every call puts the arguments and put the return values and supports
每次调用都会传递参数并返回值，并提供支持。

433
00:26:08,570 --> 00:26:09,640
on the stack.
在栈上。

434
00:26:12,610 --> 00:26:13,640
How do I do that?
我该怎么做呢？

435
00:26:14,130 --> 00:26:19,510
Well, in the sense that when i'm going to grow the stack, for instance,
嗯，就像当我要增加栈的大小时，例如，

436
00:26:19,940 --> 00:26:27,720
then i'm going to access and others outside the limit that will generate
那么我将要访问和超出限制的其他内容，这将会产生

437
00:26:27,730 --> 00:26:28,480
an exception.
一个异常。

438
00:26:29,060 --> 00:26:31,930
The exception will be treated by the operating system,
异常将由操作系统处理。

439
00:26:32,610 --> 00:26:34,800
which is going to grow the stack.
哪个将会增加堆栈的大小。

440
00:26:36,660 --> 00:26:42,320
There is a limit on modify the base and provide more room now.
现在修改基础并提供更多空间有限制。

441
00:26:42,690 --> 00:26:46,190
So the program can add put more things on the stack,
所以程序可以将更多的东西放入堆栈中，

442
00:26:46,200 --> 00:26:47,810
the same thing for the kids.
对于孩子们来说也是一样的。

443
00:26:49,100 --> 00:26:50,250
There is a question,
有一个问题，

444
00:26:53,140 --> 00:26:57,210
why did we not translate barracks in the first line on the previous slide?
为什么我们在前一张幻灯片的第一行没有翻译"barracks"这个词呢？

445
00:26:58,370 --> 00:26:59,920
That's a very good question.
这是一个非常好的问题。

446
00:26:59,930 --> 00:27:01,640
Why didn't translate barracks?
为什么没有翻译兵营？

447
00:27:02,170 --> 00:27:04,090
Remember, what I said,
记住，我说的话，

448
00:27:04,840 --> 00:27:06,720
everything is in the registers,
所有的东西都在寄存器中，

449
00:27:07,620 --> 00:27:08,860
is virtual addresses.
是虚拟地址。

450
00:27:08,870 --> 00:27:10,380
These are all virtual addresses,
这些都是虚拟地址。

451
00:27:11,790 --> 00:27:16,660
because the rule is that the addresses are only translated when I
因为规则是只有在需要时才会进行地址转换。

452
00:27:16,670 --> 00:27:18,020
am going to access a memo.
我要访问一个备忘录。

453
00:27:20,440 --> 00:27:22,400
In this case, I am not accessing the memory.
在这种情况下，我没有访问内存。

454
00:27:22,820 --> 00:27:25,370
Virus is just a virtual address.
病毒只是一个虚拟地址。

455
00:27:26,340 --> 00:27:26,750
Right?
对吗？

456
00:27:28,030 --> 00:27:29,820
I don't need to access the memory for that.
我不需要访问内存来完成这个任务。

457
00:27:30,200 --> 00:27:33,520
When I need to access the memory is when i'm going to read the content
当我需要访问内存时，是因为我要读取其中的内容。

458
00:27:34,840 --> 00:27:36,120
as a virtual others.
作为虚拟助教。

459
00:27:36,790 --> 00:27:39,790
And then I need to call to find the corresponding physical address,
然后我需要调用函数来查找相应的物理地址。

460
00:27:40,580 --> 00:27:41,890
and then on a good translation.
然后进行一个好的翻译。

461
00:27:43,080 --> 00:27:45,010
But everything what is in the process,
但是一切都是在进程中的，

462
00:27:47,380 --> 00:27:50,130
in the registers,
在寄存器中，

463
00:27:50,580 --> 00:27:54,790
it's a virtual address space.
这是一个虚拟地址空间。

464
00:28:04,950 --> 00:28:07,870
Of course, you need to put to protect the segment table.
当然，你需要保护段表。

465
00:28:07,880 --> 00:28:12,000
Only the operating system has to be able to modify it.
只有操作系统才能修改它。

466
00:28:14,350 --> 00:28:15,320
And also,
而且，

467
00:28:15,330 --> 00:28:19,760
it provides us the operating system provides protections for different segments,
操作系统为不同的段提供保护。

468
00:28:20,430 --> 00:28:25,940
for instance, to make the code segment being agreed only.
例如，使代码段仅被同意。

469
00:28:29,260 --> 00:28:29,720
Now,
现在，

470
00:28:30,570 --> 00:28:31,970
let's say we do a context switching.
假设我们进行一次上下文切换。

471
00:28:31,980 --> 00:28:32,170
Now.
现在。

472
00:28:33,350 --> 00:28:36,950
What do we need to do to say very start on contact switching when you have
当你拥有一个联系人切换时，我们需要做什么来确保非常开始？

473
00:28:36,960 --> 00:28:37,870
a process context switching?
进程上下文切换

474
00:28:42,880 --> 00:28:50,590
Besides that we need to to save a
除此之外，我们还需要保存一个

475
00:28:50,600 --> 00:28:56,730
bunch of things like file identifiers and things like that.
一堆东西，比如文件标识符之类的东西。

476
00:28:58,340 --> 00:29:05,630
The other thing we need to torn out the segment table,
另外一件事是我们需要撕毁段表。

477
00:29:06,300 --> 00:29:08,350
because the segment table, as I shown, you,
因为段表，如我所示给你看的，

478
00:29:08,810 --> 00:29:10,820
in the previous slide,
在前一张幻灯片中，

479
00:29:10,830 --> 00:29:11,900
in the previous example,
在之前的例子中，

480
00:29:11,910 --> 00:29:14,580
you have one segment table per virtual address space,
每个虚拟地址空间有一个段表。

481
00:29:14,590 --> 00:29:18,460
and you have one virtual address space for the process of the application.
你的应用程序有一个虚拟地址空间。

482
00:29:21,190 --> 00:29:24,230
You switch context with your process.
你通过切换进程来切换上下文。

483
00:29:25,920 --> 00:29:29,260
You have also to save the segment table,
你还需要保存段表。

484
00:29:29,270 --> 00:29:31,380
because the next process is going to run,
因为接下来要运行下一个进程了。

485
00:29:31,730 --> 00:29:33,810
is going to have its own segment table.
将会有自己的段表。

486
00:29:36,490 --> 00:29:41,660
Also, like I mentioned earlier on some of the segments of the process,
还有，就像我之前提到的进程的一些段落一样，

487
00:29:41,670 --> 00:29:48,330
which is is which is no longer running,
哪一个是不再运行的？

488
00:29:48,780 --> 00:29:55,780
can be stored on the disk in order to make room for the segments of the new
为了为新的段腾出空间，可以将其存储在磁盘上。

489
00:29:56,190 --> 00:29:58,300
of the next process being around.
下一个进程即将到来。

490
00:30:02,560 --> 00:30:04,670
Again, this is what happens is that, again,
再次，这是发生的情况，再次，

491
00:30:04,680 --> 00:30:06,430
if not all segments within memory,
如果内存中没有所有的段，

492
00:30:06,670 --> 00:30:08,590
you save them on the disk and you swap them.
你将它们保存在磁盘上并进行交换。

493
00:30:08,600 --> 00:30:09,750
So basically,
基本上，

494
00:30:10,730 --> 00:30:13,560
you say p one, c process, p one.
你说 p one, c 进程, p one.

495
00:30:18,520 --> 00:30:23,160
It's is we switch from con this process beyond to be two,
我们要将这个进程从一个条件转移到另一个条件。

496
00:30:23,930 --> 00:30:31,790
then we can save the segment of process p one on the disk to make room
然后我们可以将进程p的段保存在磁盘上，以腾出空间。

497
00:30:31,800 --> 00:30:35,830
for the segment of process p two to be brought in the memory.
将进程p的第二个段调入内存。

498
00:30:39,240 --> 00:30:40,630
If you have to do that,
如果你必须这样做，

499
00:30:41,170 --> 00:30:44,690
the context switch costs will grow dramatically.
上下文切换的成本将会大幅增加。

500
00:30:46,240 --> 00:30:46,580
Okay?
好的？

501
00:30:47,620 --> 00:30:52,290
You need to be very careful about what you switch off or what you swap
你需要非常小心地选择关闭或交换的内容。

502
00:30:52,300 --> 00:30:54,850
out and swapping on swapping,
换出和换入的交换操作，

503
00:30:56,000 --> 00:30:59,320
because you really want to minimize your operation on the disk.
因为你真的想要尽量减少对磁盘的操作。

504
00:30:59,570 --> 00:31:01,170
And we are going to learn about that.
我们将要学习关于这个的内容。

505
00:31:01,650 --> 00:31:03,470
The next, a couple of lectures.
接下来是几节课。

506
00:31:07,880 --> 00:31:10,590
Problem is fragmentation,
问题是碎片化。

507
00:31:10,600 --> 00:31:12,670
problems with segmentation.
分段错误的问题。

508
00:31:12,680 --> 00:31:16,380
One of the biggest problem is fragmentation,
其中一个最大的问题是碎片化。

509
00:31:16,390 --> 00:31:20,410
because now you need to start a different,
因为现在你需要开始一个不同的任务。

510
00:31:21,490 --> 00:31:27,180
you need to have to be able to have to store and to fit segments
你需要能够存储和适应段。

511
00:31:27,190 --> 00:31:28,900
of different sizes in memory.
在内存中存储不同大小的数据块。

512
00:31:29,750 --> 00:31:31,260
If you remember the last lecture,
如果你还记得上一堂课的内容，

513
00:31:31,270 --> 00:31:33,540
we had an example in which you gave,
我们有一个你提供的例子。

514
00:31:33,550 --> 00:31:35,140
you believe a lot of gaps.
你相信了很多空白。

515
00:31:35,730 --> 00:31:41,220
You can get to a point in which you have many gaps in the physical memory,
你可能会遇到物理内存中存在许多空洞的情况。

516
00:31:41,230 --> 00:31:48,450
but none of the gaps can be big enough to start a new segment,
但是这些间隙中没有一个足够大以启动一个新的段落。

517
00:31:48,460 --> 00:31:50,770
rather to start a new segment.
最好开始一个新的段落。

518
00:31:51,130 --> 00:31:54,540
Despite the fact that if you add them all the gap, if you add up,
尽管将它们全部相加的话，如果你把它们加起来，

519
00:31:54,550 --> 00:31:59,940
all the gaps is much more than what is needed by one by that segment.
所有的间隙都比该段所需的间隙多得多。

520
00:32:00,170 --> 00:32:04,050
But I think about you have 100 gaps, each gap.
但是我认为你有100个间隙，每个间隙。

521
00:32:04,060 --> 00:32:05,290
It's one gigabyte.
这是一千兆字节。

522
00:32:06,970 --> 00:32:11,280
You have 100 gigabytes in total of available memory.
您总共有100千兆字节的可用内存。

523
00:32:11,290 --> 00:32:15,310
But now you have one segment which requires two gigabytes.
但是现在你有一个需要两个千兆字节的段。

524
00:32:17,290 --> 00:32:19,270
You have plenty of available space,
你有很多可用的空间。

525
00:32:19,730 --> 00:32:22,560
but none of the available spaces,
但是没有任何可用的空间，

526
00:32:23,060 --> 00:32:24,170
contiguous basis.
连续基础。

527
00:32:24,180 --> 00:32:28,740
It's large enough to start that segment to gigabyte segment.
这个段落足够大，可以将其划分为千兆字节的段。

528
00:32:31,280 --> 00:32:32,330
So how do you do that?
那么你是如何做到的呢？

529
00:32:32,620 --> 00:32:38,120
You can take one of the segments which are there to addition to one
你可以选择其中一个段落，将其加到另一个段落中。

530
00:32:38,130 --> 00:32:39,680
of these one gigabyte gap.
其中有一个1GB的间隙。

531
00:32:39,690 --> 00:32:42,160
And you are going to start on the disk.
你将要开始使用磁盘了。

532
00:32:42,170 --> 00:32:44,640
You are swapping out to make more room,
你正在进行换页操作以腾出更多空间。

533
00:32:44,980 --> 00:32:46,420
or you can move segments around.
或者你可以移动段落。

534
00:32:50,400 --> 00:32:55,160
So there are 2 kinds of fragmentation.
所以有两种类型的碎片化。

535
00:32:55,170 --> 00:32:57,160
Both of them were space,
它们两个都是空的。

536
00:32:57,950 --> 00:32:59,500
internal fragmentation.
内部碎片化。

537
00:32:59,510 --> 00:33:02,700
You don't need all the memory within allocated chunks.
你不需要使用分配块中的所有内存空间。

538
00:33:02,710 --> 00:33:04,060
And this is also,
这也是的，

539
00:33:05,010 --> 00:33:07,480
this is all this and then external,
这是全部的内容，然后是外部的。

540
00:33:07,490 --> 00:33:09,520
which is free gaps between allocating chance.
分配机会之间的空闲间隙。

541
00:33:09,530 --> 00:33:11,880
So I think this example I mentioned to you,
所以我认为我之前提到的这个例子，

542
00:33:12,110 --> 00:33:14,210
I was talking about the external fragmentation.
我在谈论外部碎片化问题。

543
00:33:17,630 --> 00:33:21,260
And next, we are going to talk also about internal fragmentation.
接下来，我们还要讨论内部碎片化问题。

544
00:33:26,240 --> 00:33:26,760
Okay.
好的。

545
00:33:29,490 --> 00:33:30,080
So basically,
基本上，

546
00:33:30,090 --> 00:33:35,440
this is about another view about the general how the address translation happens.
这是关于地址转换发生的另一种观点。

547
00:33:36,010 --> 00:33:40,240
This providing a little more intuition by showing two visual address
这样做可以通过展示两个可视化地址来提供更多直观的理解。

548
00:33:40,250 --> 00:33:42,760
spaces mapped to the same physical address space.
将空间映射到相同的物理地址空间。

549
00:33:44,790 --> 00:33:45,330
Okay?
好的？

550
00:33:45,820 --> 00:33:50,790
And the these programs on and programs to or this process on and process
这些程序开启和关闭的程序，或者这个进程开启和关闭的进程。

551
00:33:50,800 --> 00:33:54,030
to the virtual address spaces to each of them.
将虚拟地址空间分配给它们中的每一个。

552
00:33:54,550 --> 00:33:56,710
You can look absolutely identical.
你们可以看起来完全一样。

553
00:33:57,820 --> 00:34:02,020
Think about your on the same application to instances of the same application.
考虑一下你在同一个应用程序的两个实例上的情况。

554
00:34:03,540 --> 00:34:04,910
But the translation,
但是翻译，

555
00:34:04,920 --> 00:34:07,220
while in the virtual spaces are identical,
虽然在虚拟空间中是相同的，

556
00:34:07,230 --> 00:34:09,320
you have in both virtual spaces,
你在两个虚拟空间中都有。

557
00:34:09,330 --> 00:34:11,080
the same thing as the same addresses,
相同的事情就是相同的地址。

558
00:34:11,830 --> 00:34:12,970
virtual addresses.
虚拟地址。

559
00:34:13,460 --> 00:34:18,670
When you are going to map these virtual addresses to the physical outer space,
当你要将这些虚拟地址映射到物理地址空间时，

560
00:34:18,960 --> 00:34:20,090
when you are going to translate them,
当你准备好翻译时，

561
00:34:20,100 --> 00:34:23,130
you are going to translate in such a way that they are not going to conflict.
你要翻译的方式是确保它们不会产生冲突。

562
00:34:29,220 --> 00:34:32,180
So now, with segmentation,
现在，使用分段技术，

563
00:34:32,190 --> 00:34:35,340
we have this with external fragmentation.
我们遇到了外部碎片化的问题。

564
00:34:38,710 --> 00:34:46,890
Sometimes it's harder to to allocate storage to variable sized chunks.
有时候为变长块分配存储空间更加困难。

565
00:34:48,930 --> 00:34:50,400
There is a solution for that,
这个问题有一个解决方案。

566
00:34:51,050 --> 00:34:52,370
and a solution for that,
以及对此的解决方案，

567
00:34:52,380 --> 00:34:53,650
which is very simple.
这非常简单。

568
00:34:54,170 --> 00:34:57,390
It's about, instead of allocating variable,
这是关于不再分配变量的问题，

569
00:34:57,400 --> 00:34:58,550
says chunks,
说"块"，

570
00:34:59,020 --> 00:35:00,860
you allocate fixed size chunks.
你分配固定大小的块。

571
00:35:01,380 --> 00:35:03,160
And these are called pages.
这些被称为页面。

572
00:35:06,260 --> 00:35:10,090
Every chunk of physical memory is a cable and be the same that it has
每个物理内存块都是一根电缆，并且它们都是相同的。

573
00:35:10,100 --> 00:35:11,250
the same size.
相同大小。

574
00:35:12,520 --> 00:35:19,690
And this can allow you to specially to simplify a lot of things.
这可以让你特别简化很多事情。

575
00:35:20,690 --> 00:35:21,780
For instance,
例如，

576
00:35:22,060 --> 00:35:23,530
how do you handle allocation?
你是如何处理分配的？

577
00:35:24,120 --> 00:35:27,840
One way to handle the allocation is to have a bit vector.
处理分配的一种方法是使用位向量。

578
00:35:28,820 --> 00:35:33,200
And each bit in the vector represents 1 page.
每个位在向量中代表一个页面。

579
00:35:33,720 --> 00:35:37,510
The value zero is that whether that page has been allocated
值为零表示该页面是否已被分配。

580
00:35:37,520 --> 00:35:38,870
from the physical memory,
从物理内存中，

581
00:35:39,830 --> 00:35:41,570
one, if it was allocated.
一，如果它已经被分配了。

582
00:35:42,170 --> 00:35:44,770
So if you want to find a page,
如果你想找到一个页面，

583
00:35:44,780 --> 00:35:47,080
you in physical memory, you can allocate,
你在物理内存中，你可以分配内存。

584
00:35:47,090 --> 00:35:51,400
you just find a zero in this bit vector.
你只需要在这个位向量中找到一个零。

585
00:35:55,570 --> 00:35:58,000
Now, what about the size of the pages?
现在，页面的大小如何？

586
00:35:59,200 --> 00:36:01,030
If the pages are too large?
如果页面太大怎么办？

587
00:36:02,140 --> 00:36:04,060
Again, all pages have the same size.
再次强调，所有页面的大小都相同。

588
00:36:04,070 --> 00:36:04,820
What is the problem?
问题是什么？

589
00:36:05,430 --> 00:36:07,200
What is the problems that pages are too large?
页面过大会导致以下问题：

590
00:36:17,920 --> 00:36:19,960
Waste, spice, internal fragmentation.
浪费、香料、内部碎片化。

591
00:36:19,970 --> 00:36:20,920
Excellent.
非常好。

592
00:36:24,140 --> 00:36:32,020
So I buy beef and edison and and cost of context switching can be higher if
所以我买了牛肉和爱迪生，而且上下文切换的成本可能会更高，如果...

593
00:36:32,030 --> 00:36:34,450
you need to swap that page out.
你需要将那个页面换出。

594
00:36:35,070 --> 00:36:35,290
Right?
对吗？

595
00:36:35,530 --> 00:36:35,980
That's correct.
没错。

596
00:36:37,380 --> 00:36:41,290
But the main thing is about internal fragmentation,
但是主要问题是关于内部碎片化。

597
00:36:41,300 --> 00:36:42,530
because if you think about,
因为如果你仔细思考一下，

598
00:36:42,900 --> 00:36:46,470
if you have this page, you say you have a page of one gigabyte.
如果你有这个页面，你说你有一个1GB的页面。

599
00:36:46,890 --> 00:36:50,660
If your program is only one megabyte,
如果你的程序只有一兆字节大小，

600
00:36:50,670 --> 00:36:53,740
you waste enormous a lot of most of the space.
你浪费了大量的空间。

601
00:36:54,510 --> 00:36:56,030
So you want small babies.
所以你想要小宝宝。

602
00:36:59,650 --> 00:37:01,280
The problem with the small pages,
小页面的问题是，

603
00:37:01,290 --> 00:37:02,920
what is the problem with the small pages?
小页面有什么问题？

604
00:37:08,370 --> 00:37:09,080
Any guess?
有什么猜测吗？

605
00:37:14,590 --> 00:37:17,020
Lots of accounting, more translation is, yes.
很多会计工作，还有更多的翻译工作，是的。

606
00:37:17,480 --> 00:37:18,400
Lots of accounting.
大量的会计工作。

607
00:37:18,410 --> 00:37:21,500
Ii wouldn't say more translations and larger base table.
我不会说更多的翻译和更大的基础表。

608
00:37:21,820 --> 00:37:23,360
You already know about it.
你已经知道了。

609
00:37:24,510 --> 00:37:24,940
Yes.
是的。

610
00:37:25,240 --> 00:37:30,170
But it's accounting is hard like you have to deal with more things.
但是会计学很难，就像你必须处理更多的事情一样。

611
00:37:36,040 --> 00:37:36,590
Let's see.
让我们看看。

612
00:37:38,120 --> 00:37:40,230
Now, how do you do the translation?
现在，你如何进行翻译呢？

613
00:37:40,240 --> 00:37:45,700
But there are no men more translation because in theory, right?
但是在理论上，没有比机器更好的翻译了，对吗？

614
00:37:45,710 --> 00:37:48,860
Because you still need to be every virtual address.
因为你仍然需要处理每个虚拟地址。

615
00:37:48,870 --> 00:37:51,270
You need to translate your physical address.
您需要将您的物理地址翻译成中文。

616
00:37:52,940 --> 00:37:57,160
The little bit of truth of that the higher overhead per translation could be.
每个翻译的开销更高可能是一点点真实的。

617
00:37:58,230 --> 00:38:00,610
But the number of translation is basically the same.
但是翻译的数量基本上是一样的。

618
00:38:03,770 --> 00:38:05,570
Yeah, some cash can be that as well.
是的，有些现金也可以这样。

619
00:38:07,910 --> 00:38:12,140
So how is a translation we spend works with beijing?
那么我们与北京的翻译合作进展如何？

620
00:38:13,390 --> 00:38:15,150
It's very similarly segmentation,
这非常类似于分段。

621
00:38:15,160 --> 00:38:17,130
but with a few differences.
但是有一些不同之处。

622
00:38:17,140 --> 00:38:19,250
So first of all, you have a base table.
首先，你有一个基本表。

623
00:38:21,750 --> 00:38:25,380
And the virtual address, as again, is in two parts.
而虚拟地址，同样也分为两个部分。

624
00:38:25,960 --> 00:38:27,940
We have a virtual patient number and an officer,
我们有一个虚拟患者编号和一个官员。

625
00:38:29,620 --> 00:38:30,890
but there is a difference.
但是有一个区别。

626
00:38:32,560 --> 00:38:35,600
The offset is not added to obeys address.
偏移量没有被添加到目标地址上。

627
00:38:36,080 --> 00:38:38,310
The offset of the address remains the same.
地址的偏移量保持不变。

628
00:38:38,880 --> 00:38:42,410
So is be with translation when you use beijing.
当你在使用北京时，翻译就会起作用。

629
00:38:42,700 --> 00:38:43,450
What happens?
发生了什么事情？

630
00:38:43,460 --> 00:38:46,310
It's only the virtual page part,
只是虚拟页面的部分，

631
00:38:46,320 --> 00:38:47,990
the first field changes.
第一个字段发生了变化。

632
00:38:48,550 --> 00:38:48,930
Right?
对吗？

633
00:38:49,590 --> 00:38:54,020
A virtual page number is replaced by a physical patient.
一个虚拟页号被一个物理页替换。

634
00:38:55,500 --> 00:38:56,030
That's it.
就是这样。

635
00:38:56,910 --> 00:38:59,290
So the same like previously,
和之前一样，

636
00:38:59,670 --> 00:39:01,420
the first speech, in this case,
第一次演讲，在这种情况下，

637
00:39:01,430 --> 00:39:02,580
a virtual page number,
虚拟页号

638
00:39:02,590 --> 00:39:03,860
in the previous case,
在之前的情况下，

639
00:39:03,870 --> 00:39:05,460
was a segment number,
是一个段号。

640
00:39:05,920 --> 00:39:08,150
are going to index in the page table.
将要在页表中进行索引。

641
00:39:08,700 --> 00:39:09,730
But in the page table,
但是在页表中，

642
00:39:09,740 --> 00:39:10,850
what you are going to fail,
你将要失败的是什么？

643
00:39:10,860 --> 00:39:12,850
if I find you have a page number,
如果我发现你有页码，

644
00:39:12,860 --> 00:39:14,450
which is a physical page number,
这是一个物理页号。

645
00:39:15,000 --> 00:39:17,400
you are going to take that physical patient number,
你将要获取那个物理患者编号，

646
00:39:17,410 --> 00:39:21,300
and you are going to concatenate with the offset of the visual address,
然后你将与视觉地址的偏移量连接起来。

647
00:39:21,650 --> 00:39:23,080
the offset of the physical address,
物理地址的偏移量

648
00:39:23,090 --> 00:39:26,340
and the offset of the physical address are the same.
物理地址的偏移量是相同的。

649
00:39:31,720 --> 00:39:36,510
Typical page sizes are between four kilobytes and 16 kilobytes are quite small.
典型的页面大小通常在4KB到16KB之间，属于相当小的范围。

650
00:39:36,810 --> 00:39:37,830
Four kilobytes means what?
四千字节是什么意思？

651
00:39:37,840 --> 00:39:39,630
12 beats you need, 12 beats,
你需要的是12个节拍，12个节拍。

652
00:39:40,020 --> 00:39:41,860
and 16 kilobytes you need.
你需要16千字节。

653
00:39:43,070 --> 00:39:46,270
But another14 bits.
但是另外还有14位。

654
00:39:52,730 --> 00:39:55,860
So if you have even smaller pages,
如果你有更小的页面，

655
00:39:56,420 --> 00:39:56,820
right?
对的？

656
00:39:57,110 --> 00:39:59,060
This is where you see the number.
这是你看到数字的地方。

657
00:39:59,430 --> 00:40:01,100
The problem is a small pages.
问题是页面太小。

658
00:40:01,110 --> 00:40:03,400
So you have a 32 bit address.
所以你有一个32位地址。

659
00:40:04,110 --> 00:40:07,220
You are going to use one by one kilobyte pages,
你将使用逐个千字节页面。

660
00:40:07,230 --> 00:40:08,860
so you can need 10 bits offset.
所以你需要10位偏移量。

661
00:40:09,330 --> 00:40:10,780
It's what you need a 10 bits offset.
你需要一个10位的偏移量。

662
00:40:12,010 --> 00:40:13,340
Therefore, the gift,
因此，这个礼物，

663
00:40:13,830 --> 00:40:15,500
the virtual page number,
虚拟页号

664
00:40:15,510 --> 00:40:17,220
the number of visa is 22 bits,
签证号码为22位。

665
00:40:17,230 --> 00:40:19,200
32-10, 202 bits.
32-10，共计202位。

666
00:40:19,620 --> 00:40:22,760
Therefore, the base table have 4 million century huge.
因此，基表有400万个世纪级巨大的数据。

667
00:40:25,230 --> 00:40:29,180
And just think about if you have 64 bits, others,
想一想，如果你有64位，其他人...

668
00:40:35,120 --> 00:40:36,790
in order to do that, for instance,
为了做到这一点，例如，

669
00:40:37,000 --> 00:40:45,660
you are also going to not allocate space for the maximum size space table.
你还要为最大尺寸的空间表不分配空间。

670
00:40:46,830 --> 00:40:51,790
So you are going to just grow this page table as you add not more pages to it.
所以当你添加新页面时，你只需要扩展这个页表。

671
00:40:53,150 --> 00:40:54,380
Therefore, you are going to have,
因此，你将会有，

672
00:40:54,390 --> 00:40:56,420
in addition to the page table pointer,
除了页表指针之外，

673
00:40:56,430 --> 00:40:59,210
which represents the start of the page table,
这表示页表的起始位置。

674
00:40:59,650 --> 00:41:02,410
also the paste stable size, which is,
还有粘贴的稳定大小，也就是...

675
00:41:02,500 --> 00:41:04,440
as the name implied,
正如名称所示，

676
00:41:04,450 --> 00:41:05,560
the size of the paste table,
粘贴表的大小

677
00:41:05,570 --> 00:41:08,690
which can be increased that you add more tables,
可以通过添加更多的表格来增加。

678
00:41:09,180 --> 00:41:11,570
or as you allocate more pages than you have a lot.
或者当你分配的页面超过你拥有的数量时。

679
00:41:11,580 --> 00:41:16,320
So that afforded your allocate more entries,
这样可以为您分配更多的条目。

680
00:41:16,960 --> 00:41:18,670
you add more entries to the base table.
你需要向基本表中添加更多的条目。

681
00:41:21,930 --> 00:41:23,200
Also, with this page,
此外，使用这个页面，

682
00:41:23,210 --> 00:41:27,880
you are going to have a bunch of bits which represents some.
你将会拥有一堆表示某些东西的位(bit)。

683
00:41:30,010 --> 00:41:33,820
We are going to discuss them or a little bit later.
我们稍后会讨论它们。

684
00:41:35,160 --> 00:41:36,670
Keep in mind about these beats.
记住这些要点。

685
00:41:39,720 --> 00:41:41,240
We are going to give an example,
我们将给出一个例子，

686
00:41:41,250 --> 00:41:43,180
a few slides.
几张幻灯片。

687
00:41:44,400 --> 00:41:44,850
Later.
稍后。

688
00:41:47,460 --> 00:41:49,210
It's a very simple page table.
这是一个非常简单的页表。

689
00:41:51,810 --> 00:41:53,330
You have a four by space.
你有一个四乘四的空间。

690
00:41:53,420 --> 00:41:54,930
It's a trivial example.
这是一个简单的例子。

691
00:41:55,300 --> 00:41:56,820
You have this on the virtual memory.
你在谈论虚拟内存。

692
00:41:56,830 --> 00:42:02,500
You have 4 pages from starting from 04, and 8.
你从04开始有4页，还有8页。

693
00:42:03,070 --> 00:42:06,580
Then you have a page table only with three entries, right?
那么你只有一个只有三个条目的页表，对吗？

694
00:42:06,590 --> 00:42:11,520
Because you have 3 pages in the virtual memo.
因为你在虚拟内存中有3个页面。

695
00:42:13,390 --> 00:42:20,570
Assume that the address space here it has equivalent of eight beats.
假设这里的地址空间相当于八个字节。

696
00:42:20,580 --> 00:42:22,370
So he's 64 bytes.
所以他是64字节。

697
00:42:24,040 --> 00:42:25,230
So the address,
所以这个地址，

698
00:42:25,430 --> 00:42:29,840
if you need for the page table, again, if you have four beats,
如果你需要页面表，再次强调，如果你有四个节拍，

699
00:42:29,850 --> 00:42:31,560
you need only two beats, right?
你只需要两拍，对吗？

700
00:42:32,250 --> 00:42:33,720
To represent 4 bytes,
表示4个字节，

701
00:42:34,910 --> 00:42:35,950
to address 4 bytes.
寻址4个字节。

702
00:42:36,120 --> 00:42:40,140
Therefore, the last two beats represent the offset,
因此，最后两个节拍代表偏移量。

703
00:42:40,150 --> 00:42:46,160
and the first six beats to represent what represent the page number
前六拍代表了页码的含义。

704
00:42:48,220 --> 00:42:50,660
for if you want.
如果你想的话。

705
00:42:50,890 --> 00:42:53,300
A is that the other is zero here.
A 是非零的，另一个是零。

706
00:42:53,850 --> 00:42:56,480
If you want to translate that at zero,
如果你想要零延迟地翻译这个的话，

707
00:42:56,780 --> 00:43:03,180
then the page number of identify the first entry in the table.
然后确定表中第一个条目的页码。

708
00:43:03,480 --> 00:43:06,130
The first century in the table contained four.
表格中的第一列包含了四个。

709
00:43:06,530 --> 00:43:06,820
Now,
现在，

710
00:43:06,830 --> 00:43:12,360
four is a new physical patient numbers who are going to conquer concatinate,
四是一个新的物理患者编号，他们将要征服连接操作。

711
00:43:12,370 --> 00:43:16,560
these four with the offset, which is zero.
这四个的偏移量为零。

712
00:43:17,160 --> 00:43:19,600
You are going to get zero,
你将得到零分。

713
00:43:19,610 --> 00:43:21,200
x one zero.
x one zero 可以翻译为 "十"。

714
00:43:26,630 --> 00:43:27,450
The same thing,
同样的事情，

715
00:43:27,780 --> 00:43:34,110
similar things happen if you want to access the first address,
如果你想访问第一个地址，类似的情况会发生。

716
00:43:34,600 --> 00:43:38,930
the address for the virtual address for the future address for now
现在的虚拟地址对应的未来地址的地址

717
00:43:38,940 --> 00:43:40,330
is going to lead you,
将要引领你，

718
00:43:40,340 --> 00:43:43,490
because the offset which one is going to lead you to the second entry
因为偏移量会将你引导到第二个条目。

719
00:43:43,500 --> 00:43:44,570
in the page table.
在页表中。

720
00:43:44,780 --> 00:43:47,530
The second in being the base table contains threes who
第二个作为基本表格包含了三个人。

721
00:43:47,540 --> 00:43:49,410
are going to concatenate three with zero,
你要将三和零连接起来吗？

722
00:43:49,420 --> 00:43:50,730
which is the offset.
偏移量是多少？

723
00:43:51,030 --> 00:43:54,270
You are going to get to the address zero,
你将要到达地址零。

724
00:43:54,280 --> 00:43:57,820
c physical address, and so forth.
c 物理地址，等等。

725
00:44:00,610 --> 00:44:01,410
Any questions?
有任何问题吗？

726
00:44:05,480 --> 00:44:06,110
Question here?
这里有一个问题吗？

727
00:44:06,120 --> 00:44:09,750
Why were space size issues and between four kilobytes and 16 kilobytes?
为什么空间大小问题在4KB到16KB之间？

728
00:44:10,160 --> 00:44:12,400
This is, again, always a trade off.
这仍然是一个权衡取舍的问题。

729
00:44:13,050 --> 00:44:14,420
The smaller is a table,
越小的是一张桌子。

730
00:44:14,880 --> 00:44:17,440
the smaller the page, the smaller the internal fragmentation,
页面越小，内部碎片越小。

731
00:44:17,450 --> 00:44:20,520
so the less wasted space.
所以尽量减少浪费空间。

732
00:44:21,200 --> 00:44:22,480
However, the smaller the page,
然而，页面越小，

733
00:44:22,490 --> 00:44:24,120
the larger the page tables are.
页面表越大。

734
00:44:24,920 --> 00:44:25,880
So therefore,
因此，

735
00:44:25,890 --> 00:44:29,290
it's much more context switching actually can be more expensive.
实际上，频繁的上下文切换可能会更加昂贵。

736
00:44:34,700 --> 00:44:35,380
Good question.
好问题。

737
00:44:40,020 --> 00:44:44,180
And these are some other translation,
这是一些其他的翻译：

738
00:44:44,570 --> 00:44:46,770
translating the address five.
翻译地址为 "five"。

739
00:44:46,780 --> 00:44:48,530
It's going to translate to all the others,
它将被翻译成其他所有语言。

740
00:44:48,540 --> 00:44:49,610
in this case,
在这种情况下，

741
00:44:50,070 --> 00:44:54,240
is basically 11717.
基本上是11717。

742
00:44:54,690 --> 00:44:56,530
And I think there is another example.
我认为还有另一个例子。

743
00:44:56,540 --> 00:44:58,450
Nine is going to be the same.
九将保持不变。

744
00:44:59,060 --> 00:44:59,540
Sorry.
抱歉。

745
00:45:00,360 --> 00:45:04,370
Previous case, the address six was trans translating to the address one,
之前的情况是，地址六被转换为地址一。

746
00:45:04,900 --> 00:45:05,820
16.
16.

747
00:45:05,830 --> 00:45:06,900
And the second case,
第二种情况是，

748
00:45:06,910 --> 00:45:13,550
the address nine is going to translate to address five,
地址九将被翻译为地址五。

749
00:45:14,280 --> 00:45:15,140
physical address five.
物理地址五。

750
00:45:35,120 --> 00:45:39,190
There is anonymous question asking about if the zero,
有一个匿名问题询问零是否是正数。

751
00:45:39,200 --> 00:45:42,510
x 12345678,
x 12345678,

752
00:45:43,180 --> 00:45:44,660
the others could,
其他人可以。

753
00:45:44,670 --> 00:45:47,860
the first 123456 can be the offset.
第一个123456可以作为偏移量。

754
00:45:48,660 --> 00:45:49,120
Now,
现在，

755
00:45:50,050 --> 00:45:51,760
the again,
再次，

756
00:45:51,770 --> 00:45:56,450
the offset are are the last beat in the address.
偏移量是地址中的最后一个字节。

757
00:45:57,680 --> 00:45:58,210
Okay?
好的？

758
00:45:59,130 --> 00:46:01,760
In this particular case, again, the offset,
在这种特殊情况下，再次提到偏移量，

759
00:46:03,000 --> 00:46:06,000
if you look at the first one example here,
如果你看一下这里的第一个例子，

760
00:46:07,050 --> 00:46:08,930
the offset is 10,
偏移量为10。

761
00:46:09,860 --> 00:46:11,170
are the black beats.
这是黑色的节拍。

762
00:46:12,590 --> 00:46:14,540
The page number are the bits,
页号是以位为单位的。

763
00:46:14,550 --> 00:46:15,580
are the red bits.
是红色的位。

764
00:46:18,630 --> 00:46:21,690
So the offset is two, in this case.
在这种情况下，偏移量为2。

765
00:46:21,700 --> 00:46:25,480
And the page number is one.
页面编号是1。

766
00:46:26,540 --> 00:46:29,860
And basic number one selects the second ending the base table,
基本要求一是选择第二个结束基表。

767
00:46:29,870 --> 00:46:30,580
which is three.
这是三。

768
00:46:30,590 --> 00:46:31,660
So it's 11.
所以现在是11点。

769
00:46:32,560 --> 00:46:35,130
And the offset remains 10.
偏移量仍然为10。

770
00:46:35,700 --> 00:46:37,010
Now I have 1110,
现在我有1110。

771
00:46:37,020 --> 00:46:44,760
which is basically e what about sharing?
这基本上是关于共享的问题。

772
00:46:46,260 --> 00:46:49,370
If you want to share a page between processes?
如果你想在进程之间共享一个页面？

773
00:46:50,630 --> 00:46:52,460
These are pretty easy.
这些很简单。

774
00:46:53,270 --> 00:46:53,750
Right?
对吗？

775
00:46:55,410 --> 00:46:58,600
You have each of the processes has its own page label.
每个进程都有自己的页面标签。

776
00:46:59,080 --> 00:47:01,710
If you want to share the same pages,
如果你想共享相同的页面，

777
00:47:01,720 --> 00:47:06,340
then the corresponding entries are going to point to the same physical table.
那么对应的条目将指向同一个物理表。

778
00:47:07,700 --> 00:47:10,660
It very elegant.
非常优雅。

779
00:47:13,040 --> 00:47:14,090
Where is page sharing?
页面共享在哪里？

780
00:47:14,100 --> 00:47:14,610
Yours?
你的？

781
00:47:15,390 --> 00:47:25,520
Generally, region of the processes of every for the processes,
通常情况下，每个进程的区域对于进程来说是独立的。

782
00:47:25,530 --> 00:47:28,280
you have a general region, as you remember.
你有一个大致的区域，就像你记得的那样。

783
00:47:28,290 --> 00:47:30,900
So every process has the same,
所以每个进程都有相同的

784
00:47:30,910 --> 00:47:35,170
all the processes they have to see that you are going to share this code,
所有的进程都必须知道你将要共享这段代码。

785
00:47:35,180 --> 00:47:37,900
the kernel code across all the processes,
所有进程中的内核代码

786
00:47:38,440 --> 00:47:40,390
because the same code is not going to change.
因为相同的代码不会改变。

787
00:47:43,480 --> 00:47:44,070
You can,
你可以。

788
00:47:48,370 --> 00:47:50,040
by the way, this is protected, right?
顺便问一下，这是受保护的，对吧？

789
00:47:50,050 --> 00:47:52,280
Is like the kernel will have.
就像内核会有的那样。

790
00:47:56,500 --> 00:47:59,330
The process only can access at the user level and are talking
该进程只能在用户级别访问并进行通信。

791
00:47:59,340 --> 00:48:00,650
about the kernel region.
关于内核区域。

792
00:48:00,660 --> 00:48:03,530
I'm not talking about kernel region being accessed by the process.
我不是在谈论进程访问内核区域的问题。

793
00:48:03,540 --> 00:48:08,010
I'm talking about the kernel regions associated with the process,
我在谈论与进程相关的内核区域。

794
00:48:08,020 --> 00:48:10,370
which is accessed by the kernel during the context,
在上下文切换期间由内核访问的是什么？

795
00:48:10,380 --> 00:48:16,150
which during different processes running the same binary,
在不同进程运行相同二进制文件时，

796
00:48:19,970 --> 00:48:26,750
you don't need to duplicate that because the code is read only user level libraries,
你不需要复制它，因为代码是只读的用户级库。

797
00:48:26,760 --> 00:48:27,790
like I mentioned,
就像我之前提到的一样，

798
00:48:28,260 --> 00:48:30,350
or even sharing the data between you,
甚至可以在你们之间共享数据，

799
00:48:30,360 --> 00:48:32,750
you can share the data between the processes.
你可以在进程之间共享数据。

800
00:48:32,760 --> 00:48:34,610
You can use a share memory.
你可以使用共享内存。

801
00:48:41,160 --> 00:48:42,710
This is another example.
这是另一个例子。

802
00:48:42,720 --> 00:48:44,710
This is a summary of beijing.
这是北京的概述。

803
00:48:46,310 --> 00:48:47,540
On the left hand side,
在左侧

804
00:48:47,550 --> 00:48:49,500
you have the virtual memory view.
你有虚拟内存视图。

805
00:48:49,510 --> 00:48:50,500
On the right hand side.
在右侧。

806
00:48:50,510 --> 00:48:52,060
You have the physical memory view.
你拥有物理内存视图。

807
00:48:53,650 --> 00:48:56,200
In the middle, you have the base table.
在中间，你有基本表。

808
00:48:57,890 --> 00:49:00,780
You see that many entries in the tables are now,
你会发现表格中有许多条目现在是空的。

809
00:49:01,320 --> 00:49:03,070
but this is a full page table.
但这是一个完整的页表。

810
00:49:03,720 --> 00:49:08,770
And here we are assuming and eight beats address.
在这里，我们假设使用八位地址。

811
00:49:08,780 --> 00:49:12,410
And now the offset are the last three beats.
现在偏移量是最后三拍。

812
00:49:12,420 --> 00:49:14,900
So the base size, it's about three,
基本大小，大约是三。

813
00:49:15,260 --> 00:49:16,300
it's 8 bytes.
它是8个字节。

814
00:49:16,750 --> 00:49:20,160
And the patient number is 5 bits.
患者编号为5位。

815
00:49:21,740 --> 00:49:23,970
You are going to have 2.5.
你将会得到2.5。

816
00:49:23,980 --> 00:49:28,630
You have 72 entries in the page table up to.
你的页表中有72个条目。

817
00:49:30,230 --> 00:49:30,750
Okay.
好的。

818
00:49:31,210 --> 00:49:32,680
Now, the one thing,
现在，有一件事，

819
00:49:33,070 --> 00:49:34,420
and on the right hand side,
在右侧，

820
00:49:35,710 --> 00:49:37,740
you have, again, like the physical memory.
你再次拥有了物理内存。

821
00:49:38,540 --> 00:49:40,690
One thing here, I just want to show you.
有一件事情，我只是想给你看一下。

822
00:49:40,700 --> 00:49:42,410
And i'm so earlier on,
而且我来得很早，

823
00:49:42,420 --> 00:49:44,650
I said that the stack,
我说的是栈，

824
00:49:45,060 --> 00:49:48,090
how the stack and the heap grows here.
在这里，堆栈和堆是如何增长的。

825
00:49:49,700 --> 00:49:52,890
Now, the stack again, grows downwards.
现在，栈再次向下增长。

826
00:49:52,900 --> 00:49:54,610
So gonna go grows,
所以要继续成长，

827
00:49:55,530 --> 00:49:57,160
going to lower addresses.
向较低的地址移动。

828
00:49:57,770 --> 00:49:59,290
And you see here,
你看到这里，

829
00:49:59,420 --> 00:50:00,690
the stack,
栈

830
00:50:00,700 --> 00:50:02,050
it's on the right hand side.
它在右侧。

831
00:50:02,330 --> 00:50:06,470
And with with what I represented here is a gray,
我在这里所代表的是一个灰色的东西。

832
00:50:06,480 --> 00:50:09,110
the pages which they are all the allocate,
这些页面都已经被分配了。

833
00:50:09,800 --> 00:50:12,790
only the pages which are white are not allocated yet.
只有白色的页面尚未分配。

834
00:50:13,530 --> 00:50:16,480
So let's see what happens and how you are going to grow the stock.
那么让我们看看会发生什么，以及你将如何增加股票的增长。

835
00:50:17,450 --> 00:50:17,880
Now,
现在，

836
00:50:17,890 --> 00:50:22,570
the problem is that let's say that I want to grow the stack by 2 pages,
问题是，假设我想将栈增加2页，

837
00:50:22,580 --> 00:50:25,730
I decided to grow the stack by 2 pages in the virtual memory.
我决定在虚拟内存中将栈增加2页。

838
00:50:26,000 --> 00:50:29,110
The virtual memory, I can very conveniently grow the style,
虚拟内存非常方便地可以扩展容量。

839
00:50:29,120 --> 00:50:31,030
because I have enough space in the virtual memory.
因为我在虚拟内存中有足够的空间。

840
00:50:31,560 --> 00:50:33,030
However, is a physical memory.
然而，它是一种物理内存。

841
00:50:33,040 --> 00:50:34,910
If I am going to try to grow it,
如果我打算尝试种植它，

842
00:50:35,860 --> 00:50:37,610
I can allocate page.
我可以分配页面。

843
00:50:38,380 --> 00:50:40,170
You can allocate another page.
你可以分配另一页。

844
00:50:41,020 --> 00:50:44,590
Maybe you have only room for another page there if you want to locate
如果你想要定位，可能只有另一页的空间。

845
00:50:44,600 --> 00:50:47,070
continuously that the pages to the stack.
不断地将页面压入堆栈。

846
00:50:47,620 --> 00:50:51,880
But the point is a page a with a translation that these pages
但关键是一个页面与这些页面的翻译

847
00:50:51,890 --> 00:50:55,170
do not need to be allocated continuously.
不需要连续分配。

848
00:50:55,390 --> 00:50:55,810
Right?
对吗？

849
00:50:56,340 --> 00:50:58,010
Therefore, the only thing you can do,
因此，你唯一能做的事情是，

850
00:50:58,660 --> 00:50:59,850
the only thing you need to do,
你需要做的唯一事情是，

851
00:50:59,860 --> 00:51:04,250
you need to find the room for two other pages.
你需要找到另外两页的空间。

852
00:51:04,570 --> 00:51:06,980
And you are going to allocate these pages for the stock.
你将为股票分配这些页面。

853
00:51:07,370 --> 00:51:10,500
But again, they don't need to be contiguous, right?
但是再说一遍，它们不需要是连续的，对吗？

854
00:51:10,870 --> 00:51:12,620
Whatever is contiguous in the virtual memory,
无论在虚拟内存中是连续的，

855
00:51:12,630 --> 00:51:14,940
doesn't need to be contiguous in the physical.
在物理上不需要连续。

856
00:51:34,620 --> 00:51:35,130
Now,
现在，

857
00:51:35,940 --> 00:51:37,790
the biggest problem is the challenge,
最大的问题是挑战。

858
00:51:37,800 --> 00:51:39,470
the type of table size.
表的大小类型。

859
00:51:39,480 --> 00:51:41,030
If you in the simplest version,
如果你采用最简单的版本，

860
00:51:41,040 --> 00:51:44,210
in the simple instantiation,
在简单实例化中，

861
00:51:44,220 --> 00:51:46,060
in the simplest implementation,
在最简单的实现中，

862
00:51:46,070 --> 00:51:47,180
the type of size,
大小的类型

863
00:51:47,440 --> 00:51:51,780
but if it's equal with a number of babies in the virtual memory,
但如果它等于虚拟内存中的婴儿数量，

864
00:51:53,820 --> 00:51:56,160
and this can be absolutely huge.
而且这可能是非常巨大的。

865
00:52:00,000 --> 00:52:01,470
Let's give take an example.
让我们举个例子。

866
00:52:02,410 --> 00:52:04,360
You have 32 beats address space,
你有32位的地址空间。

867
00:52:06,240 --> 00:52:09,430
you have four gigabytes at others,
你在其他地方有四个千兆字节。

868
00:52:09,440 --> 00:52:10,630
mutual address space.
共享地址空间。

869
00:52:17,470 --> 00:52:20,580
These are just a unit for you to remember.
这些只是一些你需要记住的单元。

870
00:52:21,510 --> 00:52:22,940
The one things to remember here.
这里需要记住的一件事是。

871
00:52:22,950 --> 00:52:30,720
And one confusion i've all seen often is that when you are talking
我经常看到的一个困惑是当你谈论时

872
00:52:30,730 --> 00:52:31,650
about the memory,
关于内存，

873
00:52:32,620 --> 00:52:35,740
we are talking about the power of two units.
我们正在讨论二进制单位的幂次。

874
00:52:38,010 --> 00:52:40,640
One kilobyte is ten to power ten,
一千字节是10的10次方。

875
00:52:41,960 --> 00:52:43,420
one megabyte to power ten,
一兆字节的十次方

876
00:52:45,590 --> 00:52:46,890
and gigabyte to power set.
将字节转换为位。

877
00:52:48,570 --> 00:52:52,510
I when we are talking about bandwidth,
当我们谈论带宽时，

878
00:52:55,570 --> 00:53:02,160
and how much capacity network capacity we are talking in power of that?
我们在讨论的网络容量是多少功率？

879
00:53:05,260 --> 00:53:07,800
1 kilobyte or 1 kilobit.
1千字节或1千比特。

880
00:53:08,340 --> 00:53:09,900
It's 1,000 bits,
这是1,000比特。

881
00:53:11,060 --> 00:53:12,180
one gigabyte,
一千兆字节

882
00:53:12,700 --> 00:53:15,040
one gigabit represent,
一千兆位表示，

883
00:53:17,610 --> 00:53:19,970
but it's1 billion bits.
但这是10亿比特。

884
00:53:23,900 --> 00:53:27,310
So now assume the typical pay size is four kilobytes.
现在假设典型的页大小为四千字节。

885
00:53:27,820 --> 00:53:29,050
It's to power them.
这是为了给它们供电。

886
00:53:29,060 --> 00:53:36,730
We need ten beats for to address any byte in a 4 kilobyte page.
我们需要十个时钟周期来访问4千字节页面中的任意一个字节。

887
00:53:37,450 --> 00:53:38,610
So there are four.
所以有四个。

888
00:53:42,800 --> 00:53:45,310
Sorry, we need to have what i'm talking about.
抱歉，我们需要明确你所说的是什么。

889
00:53:45,940 --> 00:53:48,400
If the page is four kilobytes,
如果页面大小为四千字节，

890
00:53:48,410 --> 00:53:50,970
this means to power 12.
这意味着乘以12的幂。

891
00:53:51,770 --> 00:53:56,100
Therefore, I need 12 beats to address any bite within a page.
因此，我需要12个节拍来寻址页面中的任何字节。

892
00:53:56,110 --> 00:53:58,610
So the offset is stern beats.
所以偏移量是严格的节拍。

893
00:53:58,980 --> 00:54:00,150
And therefore,
因此，

894
00:54:00,790 --> 00:54:02,350
if the offset mister beats,
如果偏移量错误

895
00:54:04,510 --> 00:54:06,300
the page number,
页码

896
00:54:07,270 --> 00:54:08,360
it's 30.
是30。

897
00:54:09,100 --> 00:54:11,280
2-12 is 20 bits.
2-12 是 20 位。

898
00:54:12,220 --> 00:54:12,890
Now,
现在，

899
00:54:15,120 --> 00:54:21,620
the base table size can have as big as 4 megabytes.
基本表的大小可以达到4兆字节。

900
00:54:25,700 --> 00:54:26,020
Right?
对吗？

901
00:54:26,510 --> 00:54:27,660
Why is 4 megabytes?
为什么是4兆字节？

902
00:54:29,600 --> 00:54:37,390
Because each of the entry in the page table needs to have 20 bits.
因为页表中的每个条目都需要有20位。

903
00:54:39,920 --> 00:54:42,220
Then you are also going to have some other,
那么你还会有其他的任务。

904
00:54:42,230 --> 00:54:45,130
like you see some other flags associated.
就像你看到其他相关的标志一样。

905
00:54:45,140 --> 00:54:47,710
So you have 30° for each end.
每个端点都有30°。

906
00:54:49,140 --> 00:54:50,160
So it's 4 bytes,
所以它是4个字节。

907
00:54:50,640 --> 00:54:52,440
and you have to power 20 entries.
你需要为20个条目提供电源。

908
00:54:52,980 --> 00:54:54,340
So it's 4 megabytes the top.
所以最大是4兆字节。

909
00:54:57,710 --> 00:54:59,180
This was a lot of memory.
这占用了很多内存。

910
00:55:00,430 --> 00:55:02,420
Now think about this was in the past,
现在想想这是过去的事情了，

911
00:55:02,430 --> 00:55:05,840
and you have said little bit as the standard.
你说的有一点是正确的。

912
00:55:05,850 --> 00:55:07,760
But now the standard is 64 bits.
但现在的标准是64位。

913
00:55:08,780 --> 00:55:09,900
There is no way, right?
没有办法，对吗？

914
00:55:11,250 --> 00:55:13,200
If you try to do the same thing here,
如果你在这里尝试做同样的事情，

915
00:55:13,580 --> 00:55:15,680
you are going to have 30 extra bytes,
你将会有额外的30个字节。

916
00:55:16,780 --> 00:55:18,920
which is only for the pace table.
这仅适用于页表。

917
00:55:18,930 --> 00:55:19,280
Actually,
实际上，

918
00:55:19,290 --> 00:55:22,620
you don't have enough physical memory for that physical to store
你的物理内存不足以存储该物理页。

919
00:55:22,630 --> 00:55:24,380
that the pace label.
那是速度标签。

920
00:55:26,870 --> 00:55:28,130
This is really a lot of space.
这真的是很大的空间。

921
00:55:28,360 --> 00:55:29,450
What is the solution here?
这里的解决方案是什么？

922
00:55:31,830 --> 00:55:33,820
By the way, all this space is empty.
顺便说一下，这个空间都是空的。

923
00:55:34,790 --> 00:55:35,980
Most of this, no, not always,
大部分情况下，不，不总是。

924
00:55:35,990 --> 00:55:37,240
most of the space is empty,
大部分的空间是空的。

925
00:55:37,760 --> 00:55:39,360
because they don't have as many base tables,
因为它们没有那么多基本表格，

926
00:55:39,370 --> 00:55:40,880
but I do have very few space tables,
但是我确实有很少的空间表格。

927
00:55:41,550 --> 00:55:41,900
right?
对的？

928
00:55:43,450 --> 00:55:50,130
Which are actually allocated a so this is a big problem.
实际上已经分配了这么多，这是一个大问题。

929
00:55:50,140 --> 00:55:51,570
And we are looking out for a solution,
我们正在寻找一个解决方案，

930
00:55:54,000 --> 00:55:57,350
a little bit of a discussion about base table before going forward.
在继续之前，先简单讨论一下基本表。

931
00:55:59,480 --> 00:56:02,470
So what do you need to switch on the page label?
那么你需要打开页面标签吗？

932
00:56:03,390 --> 00:56:04,990
What do you need to do this?
你需要做什么来完成这个任务？

933
00:56:05,230 --> 00:56:06,370
When the context switch happens?
上下文切换发生在什么时候？

934
00:56:06,380 --> 00:56:07,750
What do we need to do?
我们需要做什么？

935
00:56:11,120 --> 00:56:14,470
You have a page for the table point as the page label pointer,
你有一个页面用作表格指针的页面标签。

936
00:56:14,640 --> 00:56:17,710
the beginning of the page table,
页表的开始部分，

937
00:56:18,290 --> 00:56:19,160
the limit,
限制

938
00:56:20,280 --> 00:56:21,450
the size of the page table.
页面表的大小。

939
00:56:24,090 --> 00:56:24,780
Again,
再次，

940
00:56:25,830 --> 00:56:28,870
remember about the dual mode operation.
记住双模式操作。

941
00:56:28,880 --> 00:56:36,590
And because you these space tables can be only
因为你这些空间表只能是这样的

942
00:56:39,100 --> 00:56:42,300
modified and accessed by the kernel,
由内核修改和访问

943
00:56:42,600 --> 00:56:48,140
you cannot let an application access the space labels,
你不能让一个应用程序访问空间标签。

944
00:56:49,070 --> 00:56:51,020
because then they can change the page table,
因为这样他们就可以更改页表。

945
00:56:51,030 --> 00:56:55,670
and they can.to anywhere to any other address,
它们可以到任何地方，到任何其他地址。

946
00:56:56,110 --> 00:57:00,510
including the kennel or the address of another applications.
包括狗舍或其他应用程序的地址。

947
00:57:02,250 --> 00:57:07,420
And now let's look at the pros and cons.
现在让我们来看一下利与弊。

948
00:57:09,280 --> 00:57:10,490
On the pro side.
在正面方面。

949
00:57:11,590 --> 00:57:13,270
It's a very simple memory allocation.
这是一个非常简单的内存分配。

950
00:57:13,280 --> 00:57:15,470
Remember, you have a bit vector in zero or one,
记住，你有一个由零或一组成的位向量。

951
00:57:15,480 --> 00:57:18,390
whether the page is allocated or not in the physical memory.
判断页面是否在物理内存中分配。

952
00:57:19,660 --> 00:57:22,260
The bit vector contains 1 bit for each physical,
位向量包含每个物理页的1个位。

953
00:57:23,390 --> 00:57:24,820
for each page in the physical memo,
对于物理内存中的每一页，

954
00:57:26,830 --> 00:57:31,440
easy to share the cons we seen.
很容易分享我们所看到的缺点。

955
00:57:32,050 --> 00:57:33,970
The other space is very sparse.
另一个空间非常稀疏。

956
00:57:34,630 --> 00:57:35,920
The base table can be huge.
基本表可能非常庞大。

957
00:57:46,630 --> 00:57:48,480
It's again, if the base table is peace big,
如果基表非常大的话，

958
00:57:48,490 --> 00:57:51,400
then you need also probably the context which you cannot keep all the time
那么你可能还需要上下文，但你不可能一直记得所有的上下文信息。

959
00:57:51,410 --> 00:57:52,080
in the memory.
在内存中。

960
00:57:52,420 --> 00:57:54,090
If the process is painful,
如果这个过程是痛苦的，

961
00:57:54,860 --> 00:57:58,290
is that there is a base level of a process.
这是指进程的基本级别。

962
00:58:01,040 --> 00:58:09,740
If the process was is now switched off and is no longer using the cpu you
如果进程现在已经关闭并且不再使用CPU，那么

963
00:58:09,750 --> 00:58:10,460
may want,
可能想要

964
00:58:10,470 --> 00:58:11,620
it was preempted.
它被抢占了。

965
00:58:11,630 --> 00:58:16,440
You may want to take the page table of that process and swap on the disk.
你可能想要获取该进程的页表并将其交换到磁盘上。

966
00:58:16,880 --> 00:58:18,100
But if that is large,
但如果那个很大的话，

967
00:58:18,320 --> 00:58:19,550
then the overhead is very large.
那么开销就非常大。

968
00:58:22,380 --> 00:58:24,540
So the deal we are here,
所以我们在这里的交易是

969
00:58:24,550 --> 00:58:25,660
the best table,
最好的桌子

970
00:58:27,910 --> 00:58:29,720
the paging as a technique,
分页作为一种技术，

971
00:58:29,730 --> 00:58:31,980
it's elegant solution,
这是一个优雅的解决方案。

972
00:58:32,690 --> 00:58:34,210
very simple to implement,
非常简单实现。

973
00:58:35,440 --> 00:58:38,710
provides low internal fragmentation.
提供低内部碎片化。

974
00:58:39,560 --> 00:58:41,520
If the pages are small.
如果页面很小。

975
00:58:42,350 --> 00:58:43,590
On the downside,
不过，

976
00:58:44,500 --> 00:58:49,170
the problem we encounter is when we have big,
我们遇到的问题是当我们有大型的数据时，

977
00:58:49,180 --> 00:58:51,960
it is because the page tables can be huge.
这是因为页表可能非常庞大。

978
00:58:54,900 --> 00:58:56,000
So what is the solution?
那么解决方案是什么呢？

979
00:58:57,830 --> 00:58:58,320
Right?
对吗？

980
00:58:58,670 --> 00:59:03,440
The solution is you repair that the same technique I do like you recursive,
解决方案是修复与我相同的技术，就像你递归一样。

981
00:59:03,450 --> 00:59:04,160
they do it.
他们做了。

982
00:59:05,140 --> 00:59:06,900
It's multilevel beijing.
这是多层次的北京。

983
00:59:07,330 --> 00:59:07,690
Right?
对吗？

984
00:59:08,160 --> 00:59:10,900
Look, if the page labels are very large,
如果页面标签非常大的话，

985
00:59:11,390 --> 00:59:14,590
then why don't we have a base table for that base table?
那为什么我们不为那个基本表再建立一个基本表呢？

986
00:59:14,600 --> 00:59:14,880
Right?
对吗？

987
00:59:16,500 --> 00:59:18,530
Or you can combine painting segmentation?
或者你可以结合绘画分割技术。

988
00:59:23,860 --> 00:59:27,740
These are the two solutions.
这是两个解决方案。

989
00:59:28,360 --> 00:59:31,410
A segment mapping, you are going to have segments.
段映射，你将拥有段。

990
00:59:31,420 --> 00:59:32,990
And in the segments,
在分段中，

991
00:59:33,000 --> 00:59:34,190
you are going to have,
你将要拥有，

992
00:59:36,210 --> 00:59:37,720
you page the segments,
你分页了段落。

993
00:59:40,390 --> 00:59:44,050
and then in the page table as you are going to the page tables.
然后在访问页表时，你会进入页表。

994
00:59:45,760 --> 00:59:49,230
And let's look about how this is work.
让我们来看看这是如何工作的。

995
00:59:59,710 --> 01:00:02,620
As a core remembers that the page table is a map
作为一个核心，记住页表是一个映射。

996
01:00:02,630 --> 01:00:05,620
between the virtual page number and the physical page.
虚拟页号和物理页号之间的对应关系。

997
01:00:07,800 --> 01:00:08,700
This is where it is.
这就是它的位置。

998
01:00:11,800 --> 01:00:14,030
A simple page table is just a look up table.
一个简单的页表就是一个查找表。

999
01:00:16,890 --> 01:00:18,840
Vpn, the virtual page number.
VPN，即虚拟页号。

1000
01:00:18,850 --> 01:00:20,120
It's an index in this table,
这是表中的一个索引。

1001
01:00:20,130 --> 01:00:22,000
which contains a physical page number.
其中包含一个物理页号。

1002
01:00:25,470 --> 01:00:27,420
By the way, what are the map structures?
顺便问一下，地图结构是什么？

1003
01:00:27,430 --> 01:00:28,100
When you think of?
你在想什么？

1004
01:00:30,750 --> 01:00:33,310
There are many of them, trees, hash table, and so forth.
有很多种数据结构，例如树、哈希表等等。

1005
01:00:34,890 --> 01:00:37,690
But obviously, these are more complicated,
但显然，这些更加复杂。

1006
01:00:37,700 --> 01:00:38,930
means higher overhead,
意味着更高的开销

1007
01:00:39,350 --> 01:00:42,340
even though they can have slower storage overhead.
尽管它们可能会有较慢的存储开销。

1008
01:00:43,010 --> 01:00:46,330
The beautiful things about the very stable is very quick to access it.
非常稳定的优点之一是非常快速地访问它。

1009
01:00:47,130 --> 01:00:47,290
Right?
对吗？

1010
01:00:47,300 --> 01:00:49,650
It's just a needless.
这只是多余的。

1011
01:00:51,530 --> 01:00:54,160
If you use the trees and hash tables,
如果你使用树和哈希表，

1012
01:00:54,170 --> 01:00:55,280
and we'll see about that.
我们会看看的。

1013
01:00:57,380 --> 01:00:58,890
They are much more space efficient.
它们在空间利用上更高效。

1014
01:00:58,900 --> 01:01:00,530
You don't need to maintain all the entries,
你不需要维护所有的条目，

1015
01:01:00,540 --> 01:01:02,450
which for it, there is no table.
对于它来说，没有表格。

1016
01:01:03,530 --> 01:01:05,810
But accessing those is much more expensive.
但是访问这些的成本要高得多。

1017
01:01:07,840 --> 01:01:08,780
There is a trade off here.
这里存在一个权衡。

1018
01:01:13,980 --> 01:01:17,730
One simple solution is like we alluded, we mentioned,
一个简单的解决方案就像我们所暗示的，我们提到的那样。

1019
01:01:17,740 --> 01:01:23,930
is to have to do the problem of having very big page tables is to page
拥有非常大的页表是处理页的问题之一。

1020
01:01:24,210 --> 01:01:25,260
these page tables.
这些页表。

1021
01:01:27,210 --> 01:01:30,870
Basically, here is a two level page labels.
基本上，这是一个两级页标签。

1022
01:01:30,880 --> 01:01:33,380
And here is that instead of now,
而这是代替现在的。

1023
01:01:33,390 --> 01:01:40,110
the address has three fields at the end of the offset, like before,
地址在偏移量的末尾有三个字段，与之前一样。

1024
01:01:40,120 --> 01:01:41,110
no difference here.
这里没有任何区别。

1025
01:01:42,040 --> 01:01:49,050
But what was previously corresponding to the page number?
之前对应于页号的是什么？

1026
01:01:49,930 --> 01:01:51,760
Now you split into two fields,
现在你分成了两个领域，

1027
01:01:52,140 --> 01:01:57,900
which corresponds to virtual page numbers of page indexes for the two level
这对应于两级页索引的虚拟页号。

1028
01:01:57,910 --> 01:01:58,500
pages.
页面。

1029
01:02:02,190 --> 01:02:03,450
The first ten beats,
前十拍

1030
01:02:03,460 --> 01:02:04,500
in this case,
在这种情况下，

1031
01:02:05,570 --> 01:02:12,750
represents a virtual p one index in the index,
在索引中表示一个虚拟页的索引。

1032
01:02:12,760 --> 01:02:14,430
in the first level table,
在第一级表中，

1033
01:02:15,160 --> 01:02:15,890
page table.
页表。

1034
01:02:17,980 --> 01:02:19,730
This is going to take,
这可能需要一些时间。

1035
01:02:19,740 --> 01:02:26,580
you is going to contain an address to
你将包含一个地址

1036
01:02:27,320 --> 01:02:31,810
a page containing the page table entries at the second level.
一个包含第二级页表项的页面。

1037
01:02:36,350 --> 01:02:36,960
Okay?
好的？

1038
01:02:38,480 --> 01:02:41,870
In order to compute now the entire physical address,
为了现在计算整个物理地址，

1039
01:02:41,880 --> 01:02:48,790
use a few an index to find the address of the page containing
使用几个索引来查找包含页面的地址

1040
01:02:53,000 --> 01:02:54,530
the physical page number,
物理页号

1041
01:02:56,370 --> 01:02:57,980
which is stored in the second level.
这个数据存储在第二级。

1042
01:03:01,570 --> 01:03:05,840
This physical page number is going to be concatenate with the offset like before.
这个物理页号将会和偏移量像之前一样连接起来。

1043
01:03:06,550 --> 01:03:08,210
And now you have the physical address.
现在你有了物理地址。

1044
01:03:11,390 --> 01:03:11,820
Okay?
好的？

1045
01:03:13,430 --> 01:03:15,420
It's the same thing.
这是同样的事情。

1046
01:03:15,430 --> 01:03:21,010
The only difference is that now you split the physical page number into a part,
唯一的区别是现在你将物理页号分成了两部分，

1047
01:03:21,020 --> 01:03:26,070
which is going to index into a page table,
将要索引到一个页表中的地址，

1048
01:03:27,370 --> 01:03:28,330
first level page table,
一级页表

1049
01:03:28,340 --> 01:03:33,150
which contains the address of a second level page table.
其中包含了一个二级页表的地址。

1050
01:03:33,160 --> 01:03:39,600
And the second field in this page number is going to index
这个页面编号的第二个字段将用作索引。

1051
01:03:39,610 --> 01:03:41,600
in this second level page table.
在这个二级页表中。

1052
01:03:42,100 --> 01:03:43,450
And at that entry,
在那个入口处，

1053
01:03:43,750 --> 01:03:46,250
corresponding entry are going to hand physical page now.
对应的条目现在将要分配物理页面。

1054
01:03:50,190 --> 01:03:52,190
And you can have many moral levels.
你可以有许多道德层次。

1055
01:03:54,390 --> 01:03:55,860
Now, these are some announcements.
现在，这是一些公告。

1056
01:03:55,870 --> 01:04:00,820
We are just 15 minutes before the class ends,
我们离课程结束只剩下15分钟了。

1057
01:04:00,830 --> 01:04:03,060
but here are some announcements.
但是这里有一些公告。

1058
01:04:03,070 --> 01:04:04,540
We release a midterm scores,
我们发布了期中考试成绩。

1059
01:04:05,730 --> 01:04:10,120
and please check piazza for degrading policies.
请查看 Piazza 上的降级政策。

1060
01:04:11,900 --> 01:04:13,950
I think you did quite well,
我认为你做得相当不错，

1061
01:04:15,080 --> 01:04:23,100
the scores and the distribution is very much in line with that of the past midterms.
成绩和分布与过去的期中考试非常一致。

1062
01:04:23,620 --> 01:04:24,770
In the recent years,
近年来，

1063
01:04:28,050 --> 01:04:32,120
the project two design documentary member is due by this at the end
项目二的设计文档成员截止日期是在本周末。

1064
01:04:32,130 --> 01:04:33,160
of this friday.
本周五。

1065
01:04:34,210 --> 01:04:38,300
The homeless three is due on sunday at the end of the day.
无家可归的三人组的截止日期是周日，截止时间是当天晚上。

1066
01:04:40,930 --> 01:04:43,590
If you want an extra credit.,
如果你想要额外的学分，

1067
01:04:43,960 --> 01:04:50,820
please feel free is a mid semester survey and check on piazza for details.
请随意填写中期调查，并在Piazza上查看详细信息。

1068
01:04:51,460 --> 01:04:52,810
So it's free.
所以它是免费的。

1069
01:04:53,270 --> 01:04:54,020
Three extra credit.
三个额外学分。

1070
01:04:55,790 --> 01:04:56,660
The next lecture,
下一堂课，

1071
01:04:56,670 --> 01:05:02,730
i'll be out of town at nathan pemperton with a senior phd student,
我将和一位高级博士生一起去纳森·彭珀顿镇出差。

1072
01:05:02,740 --> 01:05:09,110
which you expect boston architectures and systems is going to beach this class.
你期望波士顿的架构和系统将在这门课上取得突破。

1073
01:05:09,550 --> 01:05:10,850
He's a fantastic teacher.
他是一位非常棒的老师。

1074
01:05:11,310 --> 01:05:11,780
Fun.
有趣。

1075
01:05:12,540 --> 01:05:15,250
I really urge you to attend his lecture.
我真的强烈建议你参加他的讲座。

1076
01:05:16,200 --> 01:05:19,310
He is there going to be a lot more fun than my lectures?
他在那里会比我的讲座更有趣吗？

1077
01:05:22,150 --> 01:05:23,180
He's a great presenter.
他是一个很棒的演讲者。

1078
01:05:26,580 --> 01:05:31,130
I remember that iii mentioned to you now that in a page table entry,
我记得iii现在向你提到，在页表项中，

1079
01:05:31,140 --> 01:05:34,370
besides the besides of physical page number,
除了物理页号之外，

1080
01:05:35,360 --> 01:05:37,430
we are going also to have some bits.
我们也将拥有一些位。

1081
01:05:43,190 --> 01:05:44,460
And here is an example.
这里是一个例子。

1082
01:05:44,860 --> 01:05:46,120
Let's take our previous examples.
让我们来看一下之前的例子。

1083
01:05:46,650 --> 01:05:52,160
If you are going to have an offside offset of the or you have a 32 beats address,
如果你要设置一个偏移量为offside的地址，或者你有一个32位的地址，

1084
01:05:53,410 --> 01:05:54,730
the offset is 12 bits,
偏移量为12位。

1085
01:05:54,740 --> 01:05:58,400
so the physical page number is 20 bits.
物理页号是20位。

1086
01:06:00,680 --> 01:06:02,060
So now,
现在，

1087
01:06:05,070 --> 01:06:06,470
in a base table,
在一个基本表中，

1088
01:06:07,030 --> 01:06:09,860
what you need the physical page number,
你需要物理页号。

1089
01:06:09,870 --> 01:06:11,660
which is this 20 bits.
这是20位的二进制数。

1090
01:06:11,670 --> 01:06:15,220
So what about the rest of the rest of 12 bits?
那剩下的12位是什么情况？

1091
01:06:16,050 --> 01:06:17,510
For the rest of the 12 beats?
剩下的12拍呢？

1092
01:06:17,520 --> 01:06:22,020
You are going to have a bunch of flags which are used.
你将会有一堆被使用的标志。

1093
01:06:23,400 --> 01:06:28,430
They have different use that they can use it in different ways.
它们有不同的用途，可以以不同的方式使用。

1094
01:06:30,150 --> 01:06:31,540
But here it's an example.
但是这里有一个例子。

1095
01:06:31,550 --> 01:06:34,020
And this is from intel architecture.
这是来自英特尔架构的。

1096
01:06:36,430 --> 01:06:41,090
So these are examples about this beats.
这些是关于这个节拍的例子。

1097
01:06:41,100 --> 01:06:49,710
And we are going to start from the this significant means zero is p this
我们将从这个重要的意义开始，零被表示为p。

1098
01:06:49,720 --> 01:06:50,590
is present.
已经存在。

1099
01:06:51,390 --> 01:06:52,580
It's the same as valid.
它与"valid"是相同的。

1100
01:06:53,140 --> 01:06:55,500
Is a page present in physical memory or not?
一个页面是否存在于物理内存中？

1101
01:06:56,120 --> 01:06:57,580
W write a book.
我写一本书。

1102
01:06:58,200 --> 01:07:00,840
Can you write on this page or not?
你能在这个页面上写吗？

1103
01:07:00,850 --> 01:07:05,130
If it's zero, then it's read only its user accessible,
如果为零，则只读取其用户可访问的内容。

1104
01:07:05,140 --> 01:07:07,690
this page accessible only by user.
此页面仅限用户访问。

1105
01:07:12,220 --> 01:07:14,210
Pwt page write transparent.
PWT（页面写入透明）

1106
01:07:14,220 --> 01:07:15,770
This is related with a cash.
这与现金有关。

1107
01:07:15,780 --> 01:07:21,490
Typical you have cash is to to reduce the latency to access the data.
典型的缓存的作用是为了减少访问数据的延迟。

1108
01:07:22,000 --> 01:07:22,460
Right?
对吗？

1109
01:07:22,990 --> 01:07:24,540
When you have caches a problem,
当你遇到缓存问题时，

1110
01:07:24,550 --> 01:07:28,740
the question is about how you are going to update the physical memory,
问题是关于您如何更新物理内存的。

1111
01:07:28,750 --> 01:07:30,840
the data in the physical memory.
物理内存中的数据。

1112
01:07:30,850 --> 01:07:31,190
Right?
对吗？

1113
01:07:34,460 --> 01:07:36,450
There are two ways here we are going to learn.
我们将学习两种方法。

1114
01:07:36,460 --> 01:07:40,410
But one way is that whenever we are going to access and we
但有一种方法是，每当我们要访问时，我们可以

1115
01:07:40,420 --> 01:07:42,850
are going to write to the cache and modify the data,
将要写入缓存并修改数据。

1116
01:07:42,860 --> 01:07:47,170
we are also going to modify the data in the physical memory.
我们还将修改物理内存中的数据。

1117
01:07:49,080 --> 01:07:52,450
And this is page writes, transparent,
这是一个透明的页面。

1118
01:07:53,410 --> 01:07:55,720
bcd space cash disabled.
BCD空间现金禁用。

1119
01:07:57,330 --> 01:07:59,120
You cannot catch the pages.
你无法捕捉页面。

1120
01:07:59,560 --> 01:08:02,790
A its access page has been accessed recently.
最近访问了它的访问页面。

1121
01:08:02,800 --> 01:08:05,730
This is used also for cashing.
这也用于缓存。

1122
01:08:06,120 --> 01:08:07,340
But I think it's accessed recently.
但我认为它最近被访问过。

1123
01:08:07,350 --> 01:08:10,090
And the next two is the same, first of all, cash.
接下来的两个是一样的，首先是现金。

1124
01:08:11,560 --> 01:08:15,300
You want to know whether the pages access recently and whether is dirty
你想知道最近访问的页面以及是否是脏页。

1125
01:08:15,610 --> 01:08:16,200
was written,
被写成了,

1126
01:08:17,060 --> 01:08:22,590
and the physical memory associated with physical memory was not updated.
与物理内存相关联的物理内存没有被更新。

1127
01:08:23,150 --> 01:08:25,180
So you need to know about that.
所以你需要了解这个。

1128
01:08:25,190 --> 01:08:26,830
And then you are going,
然后你要走了

1129
01:08:27,500 --> 01:08:31,550
we may decide to page that to this is.
我们可能决定将这个页面换到那个位置。

1130
01:08:33,460 --> 01:08:34,720
Okay, how do I say?
好的，我该怎么说呢？

1131
01:08:34,730 --> 01:08:36,080
So these two beats,
所以这两个节拍，

1132
01:08:37,110 --> 01:08:43,380
the only thing you need to know now are used when deciding what page
在决定页面时，你现在需要知道的唯一事情是什么。

1133
01:08:43,770 --> 01:08:45,070
to swap out of the
换出（swap out）

1134
01:08:45,080 --> 01:08:47,150
memory to make the room for me pages.
为我腾出内存页的空间。

1135
01:08:48,590 --> 01:08:49,110
Fundamentally,
从根本上说，

1136
01:08:49,120 --> 01:08:55,800
you do not want to swap up a page of a process which will be accessed india.
你不想交换一个将要在印度访问的进程的页面。

1137
01:09:02,840 --> 01:09:03,990
I it's a question.
这是一个问题。

1138
01:09:12,110 --> 01:09:13,430
The pcd means,
PCD 是指 "Pre-charge delay"，即预充电延迟。

1139
01:09:13,440 --> 01:09:18,370
the question is obesity means it's about obesity means the pcd means
问题是肥胖意味着什么，它是关于肥胖意味着什么的，PCD是什么意思。

1140
01:09:18,380 --> 01:09:19,810
that the page is not cached.
该页面未被缓存。

1141
01:09:21,440 --> 01:09:25,070
Again, the reason you may choose to not cash a page is that, for instance,
再次，你选择不缓存页面的原因可能是，例如，

1142
01:09:25,080 --> 01:09:26,590
in multiprocessor systems,
在多处理器系统中，

1143
01:09:27,070 --> 01:09:28,070
multicore systems,
多核系统

1144
01:09:28,080 --> 01:09:34,270
when you have concurrency on on the same page,
当你在同一页上有并发时，

1145
01:09:34,280 --> 01:09:36,990
you have a page with a shared to different processes,
你有一个被不同进程共享的页面。

1146
01:09:37,360 --> 01:09:39,290
which run on different processors.
运行在不同处理器上。

1147
01:09:39,910 --> 01:09:42,640
And they can concurrently access that page.
他们可以同时访问该页面。

1148
01:09:43,210 --> 01:09:45,360
And if you want to update the page,
如果你想要更新页面，

1149
01:09:45,610 --> 01:09:48,430
if it's cashed each process in each process of cash,
如果每个进程的每个进程都被缓存了现金，

1150
01:09:48,810 --> 01:09:50,900
then you have a cache coherence problem.
那么你遇到了缓存一致性问题。

1151
01:09:51,520 --> 01:09:53,110
If you want to simplify that problem,
如果你想简化这个问题，

1152
01:09:53,120 --> 01:09:54,750
if you want to remove that problem,
如果你想解决那个问题，

1153
01:09:54,760 --> 01:09:57,710
you can say this page is never going to be cash.
你可以说这个页面永远不会被缓存。

1154
01:10:05,140 --> 01:10:10,390
Example of how to use pd invalid pd es is that it's, again,
使用pd invalid pd es的示例是，再次强调它是无效的。

1155
01:10:10,400 --> 01:10:14,880
even this one can in the imply different things and the operating system
即使这个词可以暗示不同的含义，但在操作系统中可以有不同的解释。

1156
01:10:14,890 --> 01:10:16,600
besides how to use these flags
除了如何使用这些标志之外

1157
01:10:21,150 --> 01:10:21,710
once.
一次。

1158
01:10:23,090 --> 01:10:28,340
And one we use is that which I didn't mention is that the address space
我们使用的另一个是我没有提到的地址空间。

1159
01:10:28,350 --> 01:10:29,460
is actually not valid,
实际上是无效的。

1160
01:10:29,470 --> 01:10:29,940
right?
对的吗？

1161
01:10:32,650 --> 01:10:34,040
It doesn't is not allocated.
它没有被分配。

1162
01:10:34,050 --> 01:10:36,760
But another way is basically say the page director,
但另一种方式基本上是指页面导向器。

1163
01:10:36,770 --> 01:10:38,590
it's that page,
那个页面是这样的，

1164
01:10:38,830 --> 01:10:40,760
it's not in the memo, it's on the disk.
这不在备忘录中，而是在磁盘上。

1165
01:10:41,150 --> 01:10:41,420
Right?
对吗？

1166
01:10:41,590 --> 01:10:48,470
In that case, you need it a it's a a it's a trap to the operating system,
在这种情况下，你需要将它作为一个陷阱传递给操作系统。

1167
01:10:48,480 --> 01:10:49,030
exception.
异常。

1168
01:10:49,040 --> 01:10:52,320
It results into a trap to the operating system.
这会对操作系统造成陷阱。

1169
01:10:52,330 --> 01:10:55,480
And the operating system is going to figure out where is the biggest start,
操作系统将会找出最大的起始位置。

1170
01:10:55,490 --> 01:10:56,800
and it's going to bring it to memory.
然后它将把它加载到内存中。

1171
01:11:00,000 --> 01:11:01,900
This is going to be used by the main page.
这将被主页使用。

1172
01:11:02,230 --> 01:11:03,420
We are going to learn about that.
我们将要学习这个。

1173
01:11:03,960 --> 01:11:09,780
Another use here is about copy and write for the pd basically,
另一个用途是基本上关于页表的复制和写入。

1174
01:11:09,790 --> 01:11:10,540
when you fork,
当你进行fork操作时，

1175
01:11:10,930 --> 01:11:12,180
remember that the fork,
记住，fork操作

1176
01:11:12,590 --> 01:11:14,740
when you fork a process, a fork process copy,
当你fork一个进程时，会创建一个副本进程，

1177
01:11:14,750 --> 01:11:16,890
actually the parent process, right?
实际上是父进程，对吗？

1178
01:11:17,140 --> 01:11:18,130
It has everything.
它拥有一切。

1179
01:11:19,320 --> 01:11:22,350
And now the question is that do you want to copy it right away?
现在的问题是，你是否想立即复制它？

1180
01:11:23,100 --> 01:11:23,540
Right?
对吗？

1181
01:11:24,790 --> 01:11:26,500
Are you going to copy everything?
你打算抄全部内容吗？

1182
01:11:26,510 --> 01:11:29,060
And it's not smart to do it, because,
这样做是不明智的，因为，

1183
01:11:29,440 --> 01:11:29,950
for instance,
例如，

1184
01:11:29,960 --> 01:11:34,350
the code of the process of the parent process is the same code.
父进程的代码和子进程的代码是相同的。

1185
01:11:34,360 --> 01:11:36,510
You are the child process is going to execute.
你是将要执行的子进程。

1186
01:11:36,520 --> 01:11:38,550
The code is read only, so you can only to copy.
这段代码是只读的，所以你只能复制。

1187
01:11:39,590 --> 01:11:42,150
But the same is also true about the data.
但是对于数据来说也是一样的。

1188
01:11:42,780 --> 01:11:47,380
But I I do want to copy to move that to copy the data from the process
但是我确实想要复制并移动数据从该进程中。

1189
01:11:47,390 --> 01:11:49,690
at a space to the child at the space.
在一个空间给孩子留出空间。

1190
01:11:50,150 --> 01:11:54,010
The answer there is that only if the child ideally only of the child access,
答案是，只有当子进程仅限于子进程访问时。

1191
01:11:54,770 --> 01:11:55,010
right?
对的？

1192
01:11:55,020 --> 01:11:56,010
And write it, right?
是的，需要将其写下来。

1193
01:11:56,620 --> 01:11:59,740
So when that's what,
那么，当那个时候，

1194
01:11:59,750 --> 01:12:00,900
so initially,
所以最初，

1195
01:12:02,500 --> 01:12:04,050
when you are going to create,
你打算什么时候创建？

1196
01:12:04,060 --> 01:12:09,190
if you because you want to reduce the overhead to create at the forecast process,
如果你因为想要减少创建预测过程的开销而这样做，

1197
01:12:09,580 --> 01:12:13,500
the four process can share the entire address that via address space
这四个进程可以共享整个通过地址空间的地址。

1198
01:12:13,510 --> 01:12:16,400
to the parent process.
给父进程。

1199
01:12:16,410 --> 01:12:18,480
So the reads are very,
所以读取操作非常的，

1200
01:12:19,160 --> 01:12:22,950
there are going to the same memory is memory efficient is fast,
将相同的数据存储在同一块内存中既节省内存又快速。

1201
01:12:24,110 --> 01:12:24,840
right before.
就在之前。

1202
01:12:27,700 --> 01:12:36,350
But then the only one you can start doing it is when you write it.
但是你能开始做的唯一时间是在你写它的时候。

1203
01:12:36,360 --> 01:12:40,460
So when you write a page, now,
现在，当你写一个页面时，

1204
01:12:40,470 --> 01:12:49,230
only now you are going to create a copy of that page for the child.
现在你要为孩子创建该页面的副本。

1205
01:12:50,010 --> 01:12:53,110
And now the child can write and read from that copy.
现在孩子可以从那个副本中写入和读取数据。

1206
01:12:54,830 --> 01:12:56,110
But as long as you want to read,
只要你想读，

1207
01:12:56,120 --> 01:13:00,770
you can read from the same memory, physical memory,
你可以从同一块物理内存中读取数据。

1208
01:13:00,780 --> 01:13:04,540
which is shared a a with a balance.
这是一个共享的账户，具有余额。

1209
01:13:07,120 --> 01:13:08,790
Another use case here.
这里还有另一个使用案例。

1210
01:13:09,110 --> 01:13:10,820
It's a zero field on demand.
这是一个零场需求。

1211
01:13:10,830 --> 01:13:11,860
So say,
所以说，

1212
01:13:12,800 --> 01:13:14,110
you allocate,
你分配

1213
01:13:15,500 --> 01:13:18,490
say, ten gigabytes of memory and you want to initialize the zero.
假设你有十个千兆字节的内存，并且你想要将其初始化为零。

1214
01:13:20,610 --> 01:13:24,930
Just that it initialization can take seconds many seconds.
只是初始化可能需要几秒钟甚至更长时间。

1215
01:13:26,650 --> 01:13:28,170
Just to do this initialization,
只是为了进行这个初始化操作，

1216
01:13:29,770 --> 01:13:31,680
you don't want to pay the overhead,
你不想支付额外开销。

1217
01:13:31,690 --> 01:13:33,800
then when you are going to order allocation,
那么当你要进行分配时，

1218
01:13:34,900 --> 01:13:37,770
instead of you can do zero fill on demand.
可以改为你可以按需进行零填充。

1219
01:13:40,490 --> 01:13:44,040
The os now that this pages needs to be zero,
操作系统现在需要将该页面清零。

1220
01:13:44,050 --> 01:13:45,960
but initially doesn't make them zero.
但最初并不将它们设为零。

1221
01:13:46,680 --> 01:13:48,920
It may seem zero only on your axis average.
在你的坐标轴平均值上，它可能看起来是零。

1222
01:13:50,470 --> 01:13:51,530
And that's perfectly fine,
这完全没问题，

1223
01:13:51,540 --> 01:13:56,800
because you amortize zeroing it or even better,
因为你将其摊销为零，甚至更好的是，

1224
01:13:56,810 --> 01:14:01,960
maybe the application is not going to ever touch every bite,
也许应用程序永远不会接触到每一个字节。

1225
01:14:02,920 --> 01:14:04,980
which is allocating these standard devices.
是谁在分配这些标准设备。

1226
01:14:05,750 --> 01:14:06,020
Right?
对吗？

1227
01:14:06,980 --> 01:14:09,170
Say this, again, some smart ways to use this video.
再说一遍，一些使用这个视频的聪明方法。

1228
01:14:13,830 --> 01:14:16,070
So sharing with multiple level pages,
所以多级页面共享，

1229
01:14:18,370 --> 01:14:18,740
sorry.
对不起。

1230
01:14:19,700 --> 01:14:20,070
Oops.
哎呀。

1231
01:14:20,870 --> 01:14:21,790
You can see here,
你可以在这里看到，

1232
01:14:22,640 --> 01:14:26,600
you have two processes.
你有两个进程。

1233
01:14:27,290 --> 01:14:34,740
You have this each process has its own base table at rt
每个进程都有自己的基表在运行时。

1234
01:14:36,850 --> 01:14:38,160
the first level page,
第一级页

1235
01:14:38,660 --> 01:14:40,420
you can see for each process,
你可以查看每个进程的信息。

1236
01:14:40,430 --> 01:14:46,500
it's pointed from you have the base table pointer for employees, part,
你需要为员工和零件的基本表指针进行指向。

1237
01:14:46,810 --> 01:14:48,960
base table pointer, crime,
基本表指针，犯罪，

1238
01:14:49,380 --> 01:14:52,450
for the two base labels,
对于这两个基本标签，

1239
01:14:52,460 --> 01:14:53,650
different base labels,
不同的基本标签

1240
01:14:53,660 --> 01:14:55,050
first level base tables.
第一级基本表。

1241
01:14:56,080 --> 01:14:59,510
Each of them, they have point to second level page tables.
每个页面表都指向二级页表。

1242
01:14:59,520 --> 01:15:04,740
And what you can see here that some of the second level page tables are shared.
在这里你可以看到一些二级页表是共享的。

1243
01:15:05,210 --> 01:15:13,800
Obviously, all the pages to each entries in the shared space tables,
显然，共享空间表中的每个条目都有对应的页面。

1244
01:15:14,300 --> 01:15:16,120
.2are also shared.
还有0.2也是共享的。

1245
01:15:16,490 --> 01:15:16,790
Right?
对吗？

1246
01:15:21,290 --> 01:15:22,380
And finally,
最后，

1247
01:15:24,130 --> 01:15:24,670
you remember,
你记得吗？

1248
01:15:24,680 --> 01:15:31,580
I we started with this solving this problem that the page tables
我们开始解决这个问题，即页面表的问题。

1249
01:15:32,210 --> 01:15:34,120
can become extremely large.
可以变得非常庞大。

1250
01:15:35,140 --> 01:15:36,010
If we have,
如果我们有的话，

1251
01:15:37,380 --> 01:15:42,090
and many of the entries are from these huge base tables are now,
现在，许多条目来自这些巨大的基础表。

1252
01:15:42,440 --> 01:15:44,080
so contains no Information.
所以不包含任何信息。

1253
01:15:45,140 --> 01:15:52,270
And we said that the two level page table is going to solve that,
我们说过，双级页表将解决这个问题。

1254
01:15:52,280 --> 01:15:53,430
address that problem,
解决这个问题，

1255
01:15:53,440 --> 01:15:55,110
or at least alleviate that problem.
或者至少缓解这个问题。

1256
01:15:55,470 --> 01:15:56,580
Here is an example.
这是一个例子。

1257
01:15:57,010 --> 01:15:58,760
If you remember, this is an example,
如果你还记得的话，这是一个例子。

1258
01:15:58,770 --> 01:16:01,080
and let me just try to go back here.
让我试着回到这里。

1259
01:16:03,470 --> 01:16:04,860
This is a previous example.
这是一个之前的例子。

1260
01:16:04,870 --> 01:16:08,010
So this is the example which are going to have,
这是我们将要使用的示例。

1261
01:16:08,020 --> 01:16:10,810
if you can see you,
如果你能看到自己，

1262
01:16:11,220 --> 01:16:13,420
this was a 111 level table.
这是一个111级别的表格。

1263
01:16:13,430 --> 01:16:16,180
So you have, I think, 32 entries,
所以你有，我想，32个条目。

1264
01:16:16,190 --> 01:16:17,580
many of these centuries are now.
许多世纪现在已经过去了。

1265
01:16:18,230 --> 01:16:18,670
Right?
对吗？

1266
01:16:19,830 --> 01:16:23,030
This is a corresponding example.
这是一个相应的例子。

1267
01:16:34,780 --> 01:16:40,630
That's this is a corresponding example you can see.
这是一个相应的例子，你可以看到。

1268
01:16:40,640 --> 01:16:41,670
And you can count.
而且你会数数。

1269
01:16:42,030 --> 01:16:44,280
You have much fuels.
你有很多燃料。

1270
01:16:44,290 --> 01:16:49,410
It requires to appear less storage for storing these space labels.
需要减少存储这些空间标签所需的空间。

1271
01:16:50,360 --> 01:16:50,690
Right?
对吗？

1272
01:16:51,410 --> 01:16:54,250
And certainly, you have much more fewer malignants.
而且，你确实有更少的恶性疾病。

1273
01:17:02,210 --> 01:17:03,400
Let's continue.
让我们继续吧。

1274
01:17:03,410 --> 01:17:05,360
We have just a few more minutes.
我们只剩下几分钟了。

1275
01:17:06,110 --> 01:17:11,870
And this also tells you about how the translation is done.
这也告诉你关于翻译是如何进行的。

1276
01:17:12,870 --> 01:17:14,260
In this particular case,
在这种特定情况下，

1277
01:17:14,270 --> 01:17:19,080
we have for the first page, the level page table,
我们有第一页的级别页表。

1278
01:17:19,090 --> 01:17:21,440
we use three beats for the second level two beats,
我们在第二级使用三拍，第二级使用两拍。

1279
01:17:21,450 --> 01:17:24,110
and for the offset 3 bits.
对于偏移量的3位。

1280
01:17:26,960 --> 01:17:28,270
So in the best case, an article,
在最理想的情况下，一篇文章，

1281
01:17:28,280 --> 01:17:31,790
the size of the page tables is a number of pages used by the program
页面表的大小是程序使用的页面数量。

1282
01:17:32,070 --> 01:17:33,480
in the spiritual memory.
在精神记忆中。

1283
01:17:33,750 --> 01:17:35,160
Unlike the previous case,
与之前的情况不同，

1284
01:17:35,170 --> 01:17:42,160
in which the number of pages was the one available in the physical memory,
在这种情况下，页面的数量与物理内存中可用的页面数量相同。

1285
01:17:44,120 --> 01:17:49,440
the price to pay here is that you have one more additional memory access,
这里需要付出的代价是多了一个额外的内存访问。

1286
01:17:49,990 --> 01:17:50,350
right?
对的？

1287
01:17:51,250 --> 01:17:54,370
Because they need to do index on both space labels,
因为他们需要在两个空间标签上进行索引。

1288
01:17:55,640 --> 01:17:56,400
advanced level.
高级水平。

1289
01:18:06,020 --> 01:18:15,560
How about about segments and pages?
关于段和页，你是想了解什么？

1290
01:18:15,570 --> 01:18:15,880
Right?
对吗？

1291
01:18:15,890 --> 01:18:17,880
This is another way to do it, right?
这是另一种方法，对吗？

1292
01:18:17,890 --> 01:18:19,510
Like we have two level tables.
就像我们有两个级别的表格一样。

1293
01:18:19,520 --> 01:18:24,090
But another way to sell to solve similar problems is have to combine
但是解决类似问题的另一种方法是将其结合起来销售。

1294
01:18:24,100 --> 01:18:26,330
segmentation with spaging.
分段与分页结合的分段分页机制。

1295
01:18:27,010 --> 01:18:28,110
In this case, again,
在这种情况下，再次，

1296
01:18:28,120 --> 01:18:32,300
you have the address is split into three fields,
你的地址被分成了三个字段。

1297
01:18:32,560 --> 01:18:35,260
but the first field represent a segment number.
但是第一个字段表示段号。

1298
01:18:35,270 --> 01:18:38,390
The second field represents a virtual page number,
第二个字段表示虚拟页号。

1299
01:18:38,400 --> 01:18:39,550
resumes a segment,
恢复一个段落

1300
01:18:40,030 --> 01:18:41,250
and then you have the offset.
然后你有偏移量。

1301
01:18:42,610 --> 01:18:45,170
It's a very similar approach.
这是一个非常相似的方法。

1302
01:18:49,570 --> 01:18:50,240
It's again here.
又是我。

1303
01:18:50,250 --> 01:18:52,160
What do you need to save and store?
您需要保存和存储什么内容？

1304
01:18:52,170 --> 01:18:53,200
When contact switching?
什么时候进行上下文切换？

1305
01:18:53,210 --> 01:18:54,680
You need to store the segment table.
你需要存储段表。

1306
01:18:54,690 --> 01:18:57,570
You need to start the page table for that process.
你需要为该进程启动页表。

1307
01:18:58,270 --> 01:19:00,990
How do you share the data across different segments?
如何在不同的段之间共享数据？

1308
01:19:01,490 --> 01:19:06,640
When you have these both segments and pay and Beijing?
当你有这两个片段并支付了费用，你会在北京吗？

1309
01:19:07,500 --> 01:19:11,250
It's the same very similar way that I you are going to have
这是非常相似的方式，你将会拥有它。

1310
01:19:11,260 --> 01:19:12,490
from two different processes.
来自两个不同的进程。

1311
01:19:13,310 --> 01:19:19,910
They can share the pages by simply having the base
他们可以通过简单地拥有基址来共享页面。

1312
01:19:24,920 --> 01:19:26,070
by sharing the segment,
通过共享段，

1313
01:19:26,080 --> 01:19:26,390
right?
是的，正确的。

1314
01:19:26,900 --> 01:19:28,600
If you understand a bunch of pages,
如果你能理解一堆页面，

1315
01:19:28,610 --> 01:19:31,600
you are going to put all these pages in the same segment,
你将把所有这些页面放在同一个段中。

1316
01:19:31,850 --> 01:19:38,180
then you are going to share the same very soon.
那么你很快就会分享相同的东西了。

1317
01:19:41,100 --> 01:19:44,130
Let me do this one last slide,
让我做最后一张幻灯片。

1318
01:19:44,140 --> 01:19:46,170
and then I am going to stop here.
然后我就要停在这里了。

1319
01:19:46,850 --> 01:19:50,230
When you have multilevel translation pages,
当你有多级翻译页面时，

1320
01:19:50,240 --> 01:19:52,150
what are the pros and cons?
优点和缺点是什么？

1321
01:19:52,620 --> 01:19:53,260
Okay?
好的？

1322
01:19:53,690 --> 01:19:58,970
The big PRO is that you get to is much less space for the page labels.
最大的优点是你可以为页面标签节省很多空间。

1323
01:19:59,960 --> 01:20:00,280
Right?
对吗？

1324
01:20:00,920 --> 01:20:01,390
That's it.
就是这样。

1325
01:20:02,000 --> 01:20:04,270
The phone number, the Beijing in themselves,
电话号码是北京的

1326
01:20:04,280 --> 01:20:07,430
they have the big advantage that it's fixed size.
它们的一个巨大优势是固定大小。

1327
01:20:07,750 --> 01:20:09,450
So they retain to some simplicity,
所以它们保持了一些简单性，

1328
01:20:09,460 --> 01:20:12,110
you have no external fragmentation,
你没有外部碎片化。

1329
01:20:12,120 --> 01:20:13,590
have only internal fragmentation.
只有内部碎片化。

1330
01:20:14,750 --> 01:20:21,160
The cause is that the page tables can be huge,
原因是页表可能非常庞大，

1331
01:20:21,730 --> 01:20:24,740
because they need to be continuous because you need to indexing with them.
因为它们需要连续，你需要使用它们进行索引。

1332
01:20:25,650 --> 01:20:26,210
Therefore,
因此，

1333
01:20:26,220 --> 01:20:31,660
you need to have multiple level of labels in order to get
你需要有多个层级的标签才能实现。

1334
01:20:31,670 --> 01:20:33,980
the memory allocation with the two to get
使用两个进行内存分配

1335
01:20:34,530 --> 01:20:37,780
efficient memory allocation for the page tables.
高效的页面表内存分配。

1336
01:20:40,390 --> 01:20:44,900
But the big problem is that now you need to have multiple look UPS for translation,
但是现在的一个大问题是你需要进行多次查找来进行翻译。

1337
01:20:44,910 --> 01:20:50,650
because you need to look to have a look up for each page level.
因为你需要为每个页面级别进行查找。

1338
01:20:54,750 --> 01:20:58,480
Let's stop here again.
让我们再次停下来。

1339
01:20:59,700 --> 01:21:01,940
Please attend Nathan lecture on Thursday,
请在周四参加Nathan的讲座。

1340
01:21:01,950 --> 01:21:06,340
and i'll see you next Monday.
我下周一见。

1341
01:21:08,760 --> 01:21:08,870
Thanks.
谢谢。

1342
01:21:08,880 --> 01:21:10,430
So we are done.
我们完成了。

1343
01:21:10,440 --> 01:21:13,820
Let me just some recording.
让我录一下。

