1
00:00:13,060 --> 00:00:13,450
Hello,
你好，

2
00:00:14,580 --> 00:00:17,330
hope everyone had a great, long weekend.
希望大家度过了一个愉快的长周末。

3
00:00:18,670 --> 00:00:22,330
We'll start today is the first lecture of the glass.
今天我们将开始本学期的第一堂课。

4
00:00:24,060 --> 00:00:25,290
During this lecture,
在本次讲座中，

5
00:00:25,300 --> 00:00:33,540
we are going to finish our discussion on threads and processes from last time.
我们将继续上次关于线程和进程的讨论。

6
00:00:34,300 --> 00:00:38,710
And then we are going to start the discussion on file systems.
然后我们将开始对文件系统进行讨论。

7
00:00:39,560 --> 00:00:42,710
In particular, we are going to go over a high level file,
具体来说，我们将讨论一个高级文件。

8
00:00:43,270 --> 00:00:44,810
io and streams.
输入/输出和流。

9
00:00:46,280 --> 00:00:47,620
As always, please.
一如既往，请提供英文文本。

10
00:00:47,920 --> 00:00:52,990
If you have questions asking the q and a I will stop
如果你有问题，请直接提问，我会停下来回答。

11
00:00:53,210 --> 00:00:56,250
periodically during the lecture to answer these questions.
在讲座期间定期回答这些问题。

12
00:00:57,970 --> 00:00:59,850
So is that being said, let's start.
所以说，让我们开始吧。

13
00:01:02,210 --> 00:01:05,340
So we discussed quite a bit of about threads.
所以我们讨论了很多关于线程的内容。

14
00:01:08,100 --> 00:01:09,370
And by now,
到现在为止，

15
00:01:09,380 --> 00:01:16,730
the threads are the execution entity which run
线程是执行实体，用于运行任务。

16
00:01:17,580 --> 00:01:25,120
some code within an address context and or
在地址上下文中的一些代码

17
00:01:25,670 --> 00:01:26,470
within a process.
在一个进程内部。

18
00:01:27,710 --> 00:01:36,150
So this threads in the same address space in the same process,
所以这些线程在同一个进程的相同地址空间中。

19
00:01:37,000 --> 00:01:40,310
share the content of the memory.
共享内存的内容。

20
00:01:42,050 --> 00:01:44,800
This means global variables, heap,
这指的是全局变量、堆、

21
00:01:46,040 --> 00:01:48,800
as well as other resources, like file,
以及其他资源，如文件，

22
00:01:48,810 --> 00:01:50,480
descriptors and other connections.
描述符和其他连接。

23
00:01:50,490 --> 00:01:55,200
And their state are the same time.
它们的状态同时相同。

24
00:01:56,070 --> 00:02:01,280
A thread has each thread has private state,
每个线程都有私有状态。

25
00:02:01,680 --> 00:02:09,610
and that state capture the execution of a particular and this
并且该状态捕获了特定执行的过程

26
00:02:09,620 --> 00:02:13,180
information is stored in what they called thread control block.
信息存储在所谓的线程控制块中。

27
00:02:14,060 --> 00:02:15,650
Like we discussed in the past,
正如我们之前讨论过的，

28
00:02:15,660 --> 00:02:17,540
it contains the cpu registers,
它包含了CPU寄存器。

29
00:02:17,550 --> 00:02:20,180
including the program counters and the execution stack.
包括程序计数器和执行栈。

30
00:02:22,090 --> 00:02:25,410
Now next, we are going to talk a little bit more about the execution stack.
接下来，我们将更详细地讨论执行栈。

31
00:02:26,480 --> 00:02:27,730
What does it contain?
它包含什么内容？

32
00:02:28,560 --> 00:02:33,180
Why is it part of the thread privacy?
为什么这是线程隐私的一部分？

33
00:02:36,570 --> 00:02:40,090
At the high level, the execution stack stores?
在高层次上，执行栈存储了什么？

34
00:02:40,680 --> 00:02:49,040
The parameters arguments passed only call a function and the return address
参数是传递给函数的参数和返回地址。

35
00:02:49,050 --> 00:02:49,800
from that function.
从那个函数中。

36
00:02:51,910 --> 00:02:53,700
Here is a very simple example.
这是一个非常简单的例子。

37
00:02:54,610 --> 00:02:55,730
On the left hand side,
在左侧

38
00:02:57,080 --> 00:02:58,790
you have three functions,
你有三个函数，

39
00:02:58,800 --> 00:03:01,760
ab and c and on the left,
在左边的ab和c上，

40
00:03:02,210 --> 00:03:04,270
we have some labels.
我们有一些标签。

41
00:03:04,280 --> 00:03:09,030
And they think about this label like addresses for the particular line
他们将这个标签视为特定行的地址。

42
00:03:09,040 --> 00:03:09,710
in the code.
在代码中。

43
00:03:14,820 --> 00:03:20,010
And the red rectangle illustrates the code,
而红色矩形表示了代码，

44
00:03:20,020 --> 00:03:23,000
the line we are currently executing.
我们当前正在执行的行。

45
00:03:24,020 --> 00:03:29,530
So let's start by invoking function a with argument one.
那么让我们从使用参数为一的函数a开始。

46
00:03:33,640 --> 00:03:36,870
Now, you see, on the right hand side, you see the stack.
现在，你看到了，右边是栈。

47
00:03:39,710 --> 00:03:40,720
What happens here?
这里发生了什么？

48
00:03:40,730 --> 00:03:45,550
We push the argument of a on the stack, the value.
我们将a的参数值推入栈中。

49
00:03:45,760 --> 00:03:46,190
It's what?
这是什么？

50
00:03:46,200 --> 00:03:46,670
One.
一。

51
00:03:47,200 --> 00:03:52,530
And then we also pushed the return address after a it's executed.
然后，在执行完之后，我们还将返回地址推入栈中。

52
00:03:53,370 --> 00:03:57,440
The return address here is exit and you can see the exit.
这里的返回地址是exit，你可以看到exit。

53
00:03:57,970 --> 00:04:04,930
It's the address in memory right after a one is okay,
这是一个在内存中紧跟在一个地址之后的地址，没问题。

54
00:04:06,710 --> 00:04:14,330
because stamp is one on execute a then we take this branch and execute b
因为stamp是在执行a之后，我们会执行这个分支并执行b。

55
00:04:15,040 --> 00:04:18,750
when he called b now there is no argument passed to be.
当他调用 b 时，现在没有参数传递给 be。

56
00:04:18,760 --> 00:04:22,490
So on the start, we are only going to push the address.
所以在开始时，我们只需要推送地址。

57
00:04:23,500 --> 00:04:27,980
We need to go back after executing b this is a plus two,
执行完b之后，我们需要回到这里，这是一个加二的操作。

58
00:04:29,290 --> 00:04:31,340
b call c again,
再次调用C函数b。

59
00:04:31,350 --> 00:04:33,340
no argument is passed here to see.
这里没有传递任何参数来查看。

60
00:04:33,960 --> 00:04:38,360
We just wish the return are the return address after the executive.
我们希望返回的是执行完后的返回地址。

61
00:04:38,370 --> 00:04:38,720
See.
看见了。

62
00:04:40,340 --> 00:04:45,600
See, it's calling a again with argument two.
看，它再次调用了带有参数二的函数a。

63
00:04:46,310 --> 00:04:48,670
Now we put the argument on the stack,
现在我们将参数放入堆栈中，

64
00:04:49,370 --> 00:04:54,220
and the return others is you+1 after a of two executed.
在执行两个操作之后，返回值为你加1的其他人。

65
00:04:56,310 --> 00:05:00,520
And now an aids executive stamp with the argument of two,
现在是一枚关于艾滋病的执行文件，附带两个论点。

66
00:05:01,390 --> 00:05:05,700
we are going to run the final,
我们即将进行期末考试。

67
00:05:06,110 --> 00:05:07,260
the others.
其他人。

68
00:05:07,510 --> 00:05:11,610
We are going to run print f we are going to skip calling b
我们将运行打印函数，跳过调用 b。

69
00:05:15,370 --> 00:05:16,710
the output right now,
当前的输出结果是

70
00:05:16,720 --> 00:05:19,230
because stamp is through the printer.
因为邮票是通过打印机印刷的。

71
00:05:19,240 --> 00:05:23,440
Here, you also can see on the bottom,
在这里，你还可以在底部看到。

72
00:05:23,450 --> 00:05:25,740
right out,
立即出发

73
00:05:25,750 --> 00:05:27,460
the outputs being printed.
正在打印的输出结果。

74
00:05:29,150 --> 00:05:32,050
We are going to bring to.
我们打算带来。

75
00:05:32,060 --> 00:05:35,610
Now a finishes be a finish is being executed.
现在一个任务正在执行完成。

76
00:05:36,020 --> 00:05:38,840
Now, we look at that stack where you need to return.
现在，我们来看一下需要返回的堆栈。

77
00:05:39,090 --> 00:05:40,980
So we need to return to c poisson,
所以我们需要返回到C语言的泊松分布函数。

78
00:05:41,270 --> 00:05:43,420
because that was then the next thing,
因为那是接下来要做的事情，

79
00:05:43,430 --> 00:05:49,710
the next line after a two was invoked.
在调用"two"之后的下一行。

80
00:05:50,340 --> 00:05:50,840
Okay?
好的？

81
00:05:51,810 --> 00:05:52,690
Now see it terminates.
现在看它终止了。

82
00:05:52,700 --> 00:05:56,170
So again, we look at the stack where we need to go.
所以再次，我们看一下我们需要去的堆栈。

83
00:05:56,730 --> 00:05:59,140
So we need to go to be+1.
所以我们需要前往be+1。

84
00:05:59,830 --> 00:06:06,680
And now we terminate b so we need to go back to the instruction of right
现在我们终止 b，所以我们需要回到 right 指令的位置。

85
00:06:06,690 --> 00:06:08,200
after bill was invoked.
在调用了Bill之后。

86
00:06:08,740 --> 00:06:12,450
And now this is sprint f but now the tempest one,
现在是sprint f，但现在是tempest版本。

87
00:06:12,460 --> 00:06:16,940
because this is from the first invocation of a you can look also this
因为这是来自a的第一次调用，你也可以查看这个。

88
00:06:16,950 --> 00:06:18,300
at this on the stack.
在堆栈上的这个位置。

89
00:06:19,110 --> 00:06:20,980
Now we are done.
现在我们完成了。

90
00:06:22,060 --> 00:06:24,450
The output is going to be two and one.
输出将是两个和一个。

91
00:06:25,580 --> 00:06:26,050
Okay?
好的？

92
00:06:28,860 --> 00:06:30,730
The stack is extremely important.
栈非常重要。

93
00:06:30,740 --> 00:06:32,970
It holds not only variables,
它不仅保存变量，

94
00:06:32,980 --> 00:06:35,130
and the arguments are returned.
并且返回参数。

95
00:06:36,860 --> 00:06:42,020
The return address after we exit the function.
在我们退出函数后的返回地址。

96
00:06:43,020 --> 00:06:43,970
But in this way,
但是这样的话，

97
00:06:43,980 --> 00:06:47,890
it also allows for recursive writing your recursive programs.
它还允许递归编写递归程序。

98
00:06:49,110 --> 00:06:52,520
Really, this is the key of all modern languages.
实际上，这是所有现代语言的关键。

99
00:06:54,220 --> 00:06:55,690
One thing to note, though,
需要注意的一点是，

100
00:06:55,700 --> 00:07:00,270
is that the stack grows down.
栈是向下增长的。

101
00:07:00,280 --> 00:07:03,510
You start from means you start from high addresses.
"从起始位置开始"意味着你从高地址开始。

102
00:07:05,310 --> 00:07:06,700
Then as we push on the stack,
当我们将数据推入栈时，

103
00:07:06,710 --> 00:07:09,780
the address is going to go down will decrease.
地址将会下降，即减少。

104
00:07:10,190 --> 00:07:10,650
Okay?
好的？

105
00:07:11,980 --> 00:07:16,520
If we look here as a memory layout for to spread which running
如果我们将这里作为一个内存布局来展开运行的话

106
00:07:16,530 --> 00:07:18,930
the same processes in the same process,
相同的进程在同一个进程中，

107
00:07:19,740 --> 00:07:21,380
you see that, again,
你看到了，再次，

108
00:07:22,070 --> 00:07:24,310
here, the two threads,
这里有两个线程，

109
00:07:25,120 --> 00:07:26,510
they share the code,
它们共享代码，

110
00:07:26,520 --> 00:07:28,260
the global data, the heap,
全局数据，堆

111
00:07:28,730 --> 00:07:31,680
but they don't stare the stack,
但是它们不会直接访问栈。

112
00:07:31,690 --> 00:07:39,110
because the stack contains the execution state of that thread.
因为栈包含了线程的执行状态。

113
00:07:43,920 --> 00:07:45,510
We have to set off stacks.
我们需要设置栈。

114
00:07:45,860 --> 00:07:49,490
But now obviously, one question is that when you start these stacks,
但现在显然有一个问题，那就是当你启动这些栈时，

115
00:07:49,500 --> 00:07:50,250
where do you put that?
你把它放在哪里？

116
00:07:50,260 --> 00:07:50,810
Right?
对吗？

117
00:07:51,400 --> 00:07:55,880
Because you need to put them such a way that has enough room to grow.
因为你需要将它们放置在有足够空间生长的地方。

118
00:07:57,150 --> 00:07:57,530
Okay?
好的？

119
00:07:58,370 --> 00:08:06,770
So you need to make sure that you need to live in a room to grow.
所以你需要确保你需要住在一个房间里才能成长。

120
00:08:07,190 --> 00:08:07,500
Also,
另外，

121
00:08:07,510 --> 00:08:13,910
you need to make sure that one stack will not right over another stack so far.
你需要确保一个栈不会覆盖另一个栈太远。

122
00:08:14,540 --> 00:08:17,540
In this case, you should make sure the stack one,
在这种情况下，你应该确保栈是正确的。

123
00:08:17,790 --> 00:08:18,900
as it grows,
随着它的增长，

124
00:08:19,140 --> 00:08:22,210
is not going to go and overwrite stack, too.
也不会去覆盖堆栈。

125
00:08:24,180 --> 00:08:28,500
So how may two questions here?
这里有两个问题吗？

126
00:08:28,510 --> 00:08:31,680
What happens if the threads violates this?
如果线程违反了这个规定会发生什么？

127
00:08:31,690 --> 00:08:36,430
You can answer that on the question and answers thread.
你可以在问题和答案的帖子上回答这个问题。

128
00:08:45,970 --> 00:08:46,650
No answer.
没有回答。

129
00:08:46,660 --> 00:08:50,770
So what happened?
发生了什么事情？

130
00:08:55,340 --> 00:08:57,010
That corruption, second fault.
那个损坏，第二个故障。

131
00:08:57,770 --> 00:08:58,100
Right?
对吗？

132
00:08:58,110 --> 00:08:58,710
Why?
为了方便中文用户理解和阅读，我将英文内容翻译成中文。这样可以提供更好的帮助和支持。

133
00:08:58,720 --> 00:09:03,070
Because if you override a on the start, what happens?
因为如果你在开始时覆盖了a，会发生什么？

134
00:09:03,080 --> 00:09:03,350
Right?
对吗？

135
00:09:03,360 --> 00:09:04,630
If you override,
如果你重写了一个方法，

136
00:09:05,230 --> 00:09:13,990
you can override the return address of a function involved by a particular thread.
你可以覆盖特定线程中涉及的函数的返回地址。

137
00:09:15,250 --> 00:09:16,960
Now you are going to have garbage there,
现在你那里会有垃圾。

138
00:09:16,970 --> 00:09:18,440
and then you are going to go back.
然后你要回去。

139
00:09:18,450 --> 00:09:20,320
You are going to execute some random code.
你将要执行一些随机代码。

140
00:09:20,780 --> 00:09:23,570
We can even try to executing the round of the code
我们甚至可以尝试执行一轮代码的循环。

141
00:09:23,980 --> 00:09:27,050
of a different process or operating system.
来自不同进程或操作系统的

142
00:09:27,060 --> 00:09:30,170
And in case in which are going to get segmentation for,
在需要进行分段的情况下，

143
00:09:33,430 --> 00:09:34,420
how might you catch
你如何捕捉？

144
00:09:45,410 --> 00:09:45,820
violations?
违规行为？

145
00:09:46,250 --> 00:09:51,370
Got pages that's quite sophisticated stack canary.
有一些非常复杂的堆栈保护机制，被称为"堆栈金丝雀"。

146
00:09:51,730 --> 00:09:53,920
So you need, if you can.
所以你需要，如果你能的话。

147
00:09:55,260 --> 00:09:57,290
Yeah, user is very good.
是的，用户非常好。

148
00:10:00,170 --> 00:10:03,800
We can use if there are different mechanics.
如果有不同的机制，我们可以使用。

149
00:10:04,470 --> 00:10:13,350
But fundamentally, you want to make sure that we can use bounds,
但从根本上讲，您希望确保我们可以使用边界。

150
00:10:13,570 --> 00:10:15,080
like we discussed in the past,
正如我们之前讨论过的那样，

151
00:10:16,070 --> 00:10:21,750
each stack is confined to a particular region of memory,
每个栈被限制在特定的内存区域中。

152
00:10:24,220 --> 00:10:29,440
so that you make sure that and you make sure that region,
以便你确保并确保该地区，

153
00:10:29,450 --> 00:10:33,290
its own only by one thread by that particular stack.
只能由一个特定线程在其自己的堆栈上执行。

154
00:10:33,950 --> 00:10:34,330
Right?
对吗？

155
00:10:35,580 --> 00:10:36,930
Then you cannot go out,
那么你就不能出去了。

156
00:10:37,100 --> 00:10:42,430
therefore, you cannot step over as a stock
因此，你不能将其作为股票跨越。

157
00:10:46,340 --> 00:10:47,970
that will add overhead,
这将增加额外开销。

158
00:10:47,980 --> 00:10:49,490
because now you need to check.
因为现在你需要检查。

159
00:10:50,130 --> 00:10:54,520
It also had some memory protection for the stack.
它还对栈进行了一些内存保护。

160
00:10:55,330 --> 00:10:57,120
We are going to talk more about that,
我们将会更详细地讨论这个问题，

161
00:10:57,570 --> 00:10:58,920
and there is a trade off there,
这里存在一个权衡。

162
00:10:58,930 --> 00:11:01,280
but most your questions,
但是大多数你的问题，

163
00:11:01,430 --> 00:11:04,150
your answer to start out of the other corner.
你的答案是从另一个角落开始。

164
00:11:13,170 --> 00:11:13,980
So now,
所以现在，

165
00:11:15,780 --> 00:11:18,530
we are going to touch on a very important aspect,
我们将要涉及一个非常重要的方面，

166
00:11:18,540 --> 00:11:22,240
and we are going to talk about this a lot of times.
我们将会多次讨论这个话题。

167
00:11:22,250 --> 00:11:23,890
And it's not only important.
而且这不仅仅重要。

168
00:11:23,900 --> 00:11:24,880
It's also painful.
这也很痛苦。

169
00:11:26,460 --> 00:11:34,230
And this is it happens because
这是发生的原因。

170
00:11:35,440 --> 00:11:40,710
we want to provide this kind of great abstractions to the programmer
我们希望为程序员提供这种优秀的抽象化能力

171
00:11:40,720 --> 00:11:42,720
in which each thread,
在其中每个线程中，

172
00:11:43,240 --> 00:11:49,700
its own cpu and you want to provide, on one hand,
它自己的CPU，并且你希望在一方面提供，

173
00:11:50,100 --> 00:11:57,260
this obstruction like act like illusionist.
这种阻碍就像魔术师一样行动。

174
00:11:58,280 --> 00:12:00,600
And on the other hand,
另一方面，

175
00:12:00,610 --> 00:12:01,640
in reality,
实际上，

176
00:12:01,650 --> 00:12:08,330
you don't have as many core as a threat you have in order to provide that obstruction,
你没有足够的核心来提供所需的阻塞。

177
00:12:08,340 --> 00:12:09,780
the way you do it,
你的做法方式

178
00:12:10,180 --> 00:12:11,660
like we discuss in the past,
正如我们之前讨论的那样，

179
00:12:12,210 --> 00:12:17,250
is to interleave the threads on a limited number.
是将线程交错执行在有限的数量上。

180
00:12:20,230 --> 00:12:20,740
Okay?
好的？

181
00:12:22,810 --> 00:12:24,680
Now the problem, what is the problem?
现在的问题是什么？

182
00:12:24,690 --> 00:12:27,400
The problem is that if you are interleave the threads,
问题在于如果你交错执行线程，

183
00:12:27,410 --> 00:12:32,250
this means that you need to stop to suspend a thread to run another thread.
这意味着你需要停止挂起一个线程来运行另一个线程。

184
00:12:33,080 --> 00:12:37,990
And seeing the tooth in the threads you are running can share
当你在运行的线程中看到这个问题时，可以分享一下你的想法。

185
00:12:38,000 --> 00:12:39,470
the same address space.
相同的地址空间。

186
00:12:39,980 --> 00:12:46,650
Then they can modify the same location in the memory.
然后他们可以修改内存中的相同位置。

187
00:12:48,750 --> 00:12:51,310
As a result, they can step on each other toes.
因此，他们可能会互相踩到对方的脚趾。

188
00:12:52,850 --> 00:12:56,800
And because you don't know exactly when the threats
因为你不知道威胁发生的确切时间

189
00:12:56,810 --> 00:13:00,560
are going to be interrupted at what instructions to be suspended,
将在哪些指令被中断时被暂停执行？

190
00:13:01,630 --> 00:13:05,270
this kind of interaction is also unpredictable,
这种互动也是不可预测的，

191
00:13:06,020 --> 00:13:06,870
non deterministic.
非确定性的。

192
00:13:08,620 --> 00:13:09,810
So that's the idea.
那就是这个想法。

193
00:13:12,080 --> 00:13:14,430
For instance, this is a piece with us.
例如，这是我们的一部分。

194
00:13:14,440 --> 00:13:16,230
You have three instructions here.
你这里有三条指令。

195
00:13:17,430 --> 00:13:21,420
Now, this is in a thread which at some point will be suspended.
现在，这是在一个线程中，该线程在某个时刻将被挂起。

196
00:13:22,430 --> 00:13:29,100
One possible execution is to go through the completion and all these instructions.
一个可能的执行方式是按顺序执行所有这些指令和完成操作。

197
00:13:29,690 --> 00:13:33,520
But another possible execution is after execute the first instruction,
但是另一个可能的执行顺序是在执行完第一条指令之后，

198
00:13:33,530 --> 00:13:35,600
which is x equals x plus one.
x等于x加一。

199
00:13:35,950 --> 00:13:39,460
The study suspending and as a strategy to run instead,
将学习暂停作为一种策略来代替运行。

200
00:13:40,740 --> 00:13:45,640
or this thread can be suspended after the first instruction
或者在第一条指令之后，该线程可以被挂起。

201
00:13:47,310 --> 00:13:48,850
are going to be executed.
将要被执行。

202
00:13:53,060 --> 00:13:56,420
You can have a myriad of way in the stress italy,
你可以在意大利体验无数种方式来减压。

203
00:13:57,090 --> 00:13:57,530
right?
对的？

204
00:13:58,200 --> 00:14:00,230
Like you see here, see,
就像你在这里看到的一样，看到了吗，

205
00:14:01,510 --> 00:14:03,540
you can also, in some cases,
在某些情况下，你也可以

206
00:14:03,550 --> 00:14:06,020
the stress can each of them go through completion,
每个人都能承受的压力不同，

207
00:14:06,030 --> 00:14:07,260
because they are very short.
因为它们非常简短。

208
00:14:08,090 --> 00:14:09,610
Or if you have enough course,
或者如果你有足够的课程，

209
00:14:09,950 --> 00:14:11,370
then they are not interleaving,
那么它们就不是交错执行的。

210
00:14:11,380 --> 00:14:13,690
because israel is going to run on score.
因为以色列将要依靠分数运行。

211
00:14:14,520 --> 00:14:14,900
Right?
对吗？

212
00:14:15,300 --> 00:14:18,140
But the interesting part is see when they are going to italy.
但有趣的是看他们什么时候去意大利。

213
00:14:19,160 --> 00:14:19,500
Right?
对吗？

214
00:14:20,980 --> 00:14:23,910
And again,
再次，

215
00:14:23,920 --> 00:14:26,310
the point here is that as a programmer,
这里的重点是作为一个程序员，

216
00:14:26,710 --> 00:14:29,510
you do not know when the study suspended,
你不知道学习暂停的时间。

217
00:14:30,150 --> 00:14:32,940
because operating system, in particular,
因为操作系统，特别是

218
00:14:32,950 --> 00:14:36,900
the scheduler has no idea about the semantics of your program,
调度器对于你的程序的语义一无所知。

219
00:14:36,910 --> 00:14:37,980
so you cannot do anything.
所以你什么都做不了。

220
00:14:37,990 --> 00:14:40,260
So from operating system,
所以从操作系统的角度来看，

221
00:14:40,600 --> 00:14:43,710
point of view is a bunch of instructions.
观点是一系列指令。

222
00:14:43,720 --> 00:14:45,470
And at any given time,
在任何给定的时间，

223
00:14:45,480 --> 00:14:46,510
it can,
它可以。

224
00:14:46,900 --> 00:14:48,810
in theory, it can interrupt you.
理论上，它可以打断你。

225
00:14:48,820 --> 00:14:53,810
It can suspend your thread and run another thread instead on the same core.
它可以暂停你的线程，并在同一个核心上运行另一个线程。

226
00:14:55,010 --> 00:14:55,450
Okay?
好的？

227
00:14:56,890 --> 00:14:58,800
So now,
所以现在，

228
00:14:59,120 --> 00:15:02,170
there are 2 kinds of threats you can think in this world.
在这个世界上，你可以思考到两种威胁。

229
00:15:02,950 --> 00:15:07,670
There are threads which modifies different variables so that the variables
有一些线程修改不同的变量，以便使这些变量

230
00:15:07,680 --> 00:15:08,310
they modify,
他们修改，

231
00:15:08,320 --> 00:15:11,110
they are to be joined that independence.
它们将被合并为独立的实体。

232
00:15:12,870 --> 00:15:16,720
And they are going to provide determine these things us,
他们将为我们确定这些事情。

233
00:15:17,190 --> 00:15:19,590
because it doesn't matter when they are suspended.
因为当它们被挂起时并不重要。

234
00:15:20,150 --> 00:15:22,570
They are not going to use the same variables.
他们不会使用相同的变量。

235
00:15:23,070 --> 00:15:25,230
So they are not going to interfere with each other.
所以它们不会相互干扰。

236
00:15:26,200 --> 00:15:27,720
And then there are cooperating threats.
然后还有合作威胁。

237
00:15:27,730 --> 00:15:30,720
And these are the interesting ones and the difficult ones.
这些是有趣的和困难的。

238
00:15:31,080 --> 00:15:32,110
We share state.
我们共享状态。

239
00:15:32,560 --> 00:15:33,470
We share the state.
我们共享状态。

240
00:15:35,570 --> 00:15:39,270
Now, the goal is how to design a program,
现在的目标是如何设计一个程序。

241
00:15:39,280 --> 00:15:40,430
which is correct.
哪个是正确的。

242
00:15:41,140 --> 00:15:45,390
No matter when a cooperating threads are suspended,
无论合作线程何时被暂停，

243
00:15:45,960 --> 00:15:48,590
you are going to get a predictable,
你将获得一个可预测的结果。

244
00:15:48,920 --> 00:15:50,160
a correct result.
一个正确的结果。

245
00:15:54,680 --> 00:16:02,100
Let's let's take a aaa few simple examples to illustrate the point.
让我们举几个简单的例子来说明这一点。

246
00:16:04,020 --> 00:16:06,210
And by the way,
顺便一提，

247
00:16:06,220 --> 00:16:08,720
when two threads,
当两个线程

248
00:16:09,590 --> 00:16:11,820
interleave and modify the same variables.
交错和修改相同的变量。

249
00:16:11,830 --> 00:16:14,140
Many times we refer to that as race condition,
很多时候我们将其称为竞态条件。

250
00:16:14,150 --> 00:16:17,030
because one thread races against the other thread.
因为一个线程与另一个线程竞争。

251
00:16:17,930 --> 00:16:19,650
Now, in this first example,
现在，在这个第一个例子中，

252
00:16:19,970 --> 00:16:21,110
is to have two threads,
是要有两个线程，

253
00:16:21,120 --> 00:16:24,150
a and b and these threads modify a different variable,
a和b以及这些线程修改了不同的变量。

254
00:16:24,940 --> 00:16:34,270
study modify x that be y this is an example of independent threads here,
研究修改x使其成为y，这是一个独立线程的示例。

255
00:16:34,790 --> 00:16:37,660
because again, they write,
因为再次，他们写道，

256
00:16:37,930 --> 00:16:40,450
they modify and they read different variables.
他们修改和读取不同的变量。

257
00:16:43,450 --> 00:16:44,360
For instance,
例如，

258
00:16:44,970 --> 00:16:50,330
no matter how the scheduler interleaved these threads,
无论调度程序如何交错执行这些线程，

259
00:16:51,000 --> 00:16:54,150
the output for thread a will be always fun.
线程a的输出将始终是"fun"。

260
00:16:58,500 --> 00:17:02,120
But now let me ask you,
但是现在让我问你，

261
00:17:02,130 --> 00:17:04,530
in this example, what is the output?
在这个例子中，输出是什么？

262
00:17:05,580 --> 00:17:07,150
So you have again to threads.
所以你又有了两个线程。

263
00:17:07,520 --> 00:17:09,770
But now they share one variable,
但现在它们共享一个变量，

264
00:17:09,780 --> 00:17:11,030
which is why.
这就是为什么。

265
00:17:12,640 --> 00:17:13,100
Okay?
好的？

266
00:17:13,770 --> 00:17:15,570
Both of them read and more,
他们两个都阅读得很多，而且还有其他的。

267
00:17:15,820 --> 00:17:20,780
but thread b reads and modify y and a reads.
但是线程B读取并修改了y，而线程A读取了y。

268
00:17:20,790 --> 00:17:21,140
Why?
为了方便中文用户理解和阅读，我会将英文内容翻译成中文。这样可以更好地帮助您解决问题和获取所需的信息。

269
00:17:22,550 --> 00:17:27,010
Let's assume initially that x is zero and y zero.
假设初始时，x和y都为零。

270
00:17:30,280 --> 00:17:31,870
The question, in this case,
在这种情况下，问题是

271
00:17:32,660 --> 00:17:34,300
for these cooperative threads,
对于这些协作线程，

272
00:17:35,070 --> 00:17:42,850
what are the possible values of x why don't you take of
x的可能取值是什么，为什么你不考虑它呢？

273
00:17:42,860 --> 00:17:50,540
23 minutes and think and please write down the
23分钟思考并请写下来。

274
00:17:50,550 --> 00:17:51,180
values?
数值？

275
00:17:53,160 --> 00:17:54,950
You believe x can get?
你相信 x 可以实现吗？

276
00:18:00,560 --> 00:18:01,960
Yes, that's correct.
是的，没错。

277
00:18:01,970 --> 00:18:03,840
135.
抱歉，我不明白你的意思。请提供更多的上下文或问题。

278
00:18:04,900 --> 00:18:05,530
That's perfect.
太好了。

279
00:18:06,700 --> 00:18:09,010
Thank you, right?
谢谢，对吗？

280
00:18:09,020 --> 00:18:11,960
So because if the first,
因此，由于第一个原因，

281
00:18:11,970 --> 00:18:21,060
if thread a executes first and the first instruction is executed to completion,
如果线程a首先执行，并且第一条指令被完整执行完成，

282
00:18:21,630 --> 00:18:22,750
then y was zero,
那么y为零，

283
00:18:23,110 --> 00:18:24,500
x would be up.
x将会上升。

284
00:18:27,390 --> 00:18:29,300
But there are other possible executions.
但是还有其他可能的执行方式。

285
00:18:29,750 --> 00:18:33,210
For instance, the first instruction of strategy can execute.
例如，策略的第一条指令可以执行。

286
00:18:33,220 --> 00:18:34,570
Y is equal to.
Y 等于。

287
00:18:35,280 --> 00:18:38,350
And then the instruction of a can execute.
然后a的指令可以执行。

288
00:18:39,070 --> 00:18:44,650
Now, x is y which are set by thread b to choose x will be three.
现在，x是由线程b设置的y，以选择x将是三。

289
00:18:45,630 --> 00:18:49,560
Or thread b can execute all boston instruction first,
或者线程B可以先执行所有的波士顿指令，

290
00:18:49,570 --> 00:18:56,190
and then thread a and if thread big one or execute all instruction first,
然后线程A开始执行，如果线程A是优先级较高的线程，或者执行所有指令的线程。

291
00:18:56,540 --> 00:18:58,630
then y will be four.
那么y将会是四。

292
00:18:59,760 --> 00:19:05,720
So x instead a that is y value of 4 plus 1 is 5,
所以，将x替换为y的值，即4加1等于5。

293
00:19:05,850 --> 00:19:07,270
x is five.
x 是五。

294
00:19:09,370 --> 00:19:12,520
Now, you can see that even in this simple example,
现在，你可以看到即使在这个简单的例子中，

295
00:19:13,020 --> 00:19:14,300
means you are going,
这句话的意思是你要离开。

296
00:19:14,310 --> 00:19:22,170
things are getting complicated when they said share the same value.
当他们说要共享相同的值时，事情变得复杂了。

297
00:19:23,900 --> 00:19:27,940
Now you can imagine that for a more realistic program,
现在你可以想象一下，对于一个更加真实的程序，

298
00:19:27,950 --> 00:19:29,780
this is even much more complex.
这个甚至更加复杂。

299
00:19:34,150 --> 00:19:35,500
If there is a question here,
如果这里有一个问题，

300
00:19:35,510 --> 00:19:37,460
how do threads share a variable?
线程如何共享变量？

301
00:19:37,470 --> 00:19:39,460
If a thread is the unit of execution?
如果一个线程是执行的单位？

302
00:19:39,470 --> 00:19:41,900
Wouldn't local variable be local to be thread?
局部变量不是只对线程本地的吗？

303
00:19:42,900 --> 00:19:44,320
This is a good question,
这是一个很好的问题，

304
00:19:44,330 --> 00:19:52,830
but i'm going to go back here To answer this question.
但是我会回答这个问题。

305
00:19:56,810 --> 00:19:57,840
The answer is here.
答案在这里。

306
00:19:59,210 --> 00:20:01,010
As you can see, it's, again,
正如你所看到的，又是这样，

307
00:20:03,320 --> 00:20:05,320
all threading the same process,
所有线程属于同一个进程。

308
00:20:05,790 --> 00:20:08,720
share the code the data,
分享代码和数据。

309
00:20:09,290 --> 00:20:10,530
go on the file descriptors.
继续处理文件描述符。

310
00:20:12,530 --> 00:20:16,020
Why they don't share are the registers.
为什么他们不共享寄存器。

311
00:20:16,900 --> 00:20:18,740
They don't share the stack,
它们不共享栈。

312
00:20:20,440 --> 00:20:26,970
but the stack only contains the temporary variables,
但是栈只包含临时变量，

313
00:20:28,980 --> 00:20:32,490
the argument which are passed to the functions and the return parameters.
传递给函数的参数和返回参数。

314
00:20:33,100 --> 00:20:33,460
It does.
是的。

315
00:20:33,470 --> 00:20:35,060
A stack does not contain.
栈不包含。

316
00:20:36,030 --> 00:20:39,920
The global variables are in the data segment here.
全局变量在这里位于数据段。

317
00:20:41,440 --> 00:20:42,710
In this example,
在这个例子中，

318
00:20:42,720 --> 00:20:45,130
I just gave one.
我刚刚给了一个。

319
00:20:47,290 --> 00:20:50,440
This we are talking about x and y are global variables.
我们正在讨论的是全局变量 x 和 y。

320
00:20:52,730 --> 00:20:58,120
All the global variables are shared by all the thread in the process.
所有的全局变量都被进程中的所有线程共享。

321
00:21:05,080 --> 00:21:06,210
Going farther.
走得更远。

322
00:21:08,640 --> 00:21:10,570
Let me just go in.
让我进去一下。

323
00:21:13,120 --> 00:21:14,110
There is another question.
还有一个问题。

324
00:21:14,120 --> 00:21:21,060
Let me take this as a do thread share the skip as well,
让我把这个当作一个“do”线程来分享，同时也跳过它。

325
00:21:22,450 --> 00:21:24,430
the thread share the heap as well.
线程也共享堆内存。

326
00:21:24,990 --> 00:21:30,200
So if one thread allocate something on the heap,
那么如果一个线程在堆上分配了一些内存，

327
00:21:30,660 --> 00:21:37,030
it can give the pointer to another thread which can read the data,
它可以将指针传递给另一个线程，该线程可以读取数据。

328
00:21:37,370 --> 00:21:40,790
allocated from the heap,
从堆中分配的

329
00:21:40,800 --> 00:21:44,030
from the day of agree the data allocated by the first threat.
从同意第一个线程分配数据的那一天开始。

330
00:21:47,280 --> 00:21:49,310
How do different processes communicate?
不同进程如何进行通信？

331
00:21:49,620 --> 00:21:51,140
We are going to learn about that.
我们将要学习这个。

332
00:21:51,770 --> 00:21:55,370
They can communicate by reading and writing on the file system.
他们可以通过在文件系统上读写来进行通信。

333
00:21:55,710 --> 00:21:58,320
They can communicate with sockets, pipes.
它们可以通过套接字、管道进行通信。

334
00:21:58,740 --> 00:22:00,370
There are many ways they can communicate,
他们有很多种方式可以进行沟通，

335
00:22:00,380 --> 00:22:05,030
and there is actually also mechanics to provide shared memory between processes.
实际上，还有一种机制可以在进程之间提供共享内存。

336
00:22:07,100 --> 00:22:08,120
We'll talk more about that.
我们会进一步讨论这个问题。

337
00:22:10,140 --> 00:22:13,730
Thanks for your questions.
谢谢你的问题。

338
00:22:15,020 --> 00:22:18,420
Now, if you write a program which you have multiple threads,
现在，如果你编写一个程序，其中包含多个线程，

339
00:22:18,890 --> 00:22:23,740
we share the same the same data,
我们共享相同的数据，

340
00:22:24,260 --> 00:22:29,220
then you need somehow to coordinate among them to make sure that you get
然后你需要以某种方式协调他们，以确保你得到

341
00:22:29,230 --> 00:22:30,300
the same results,
相同的结果

342
00:22:30,570 --> 00:22:32,570
no matter how the threats are intermittent.
无论威胁是如何间歇性的。

343
00:22:33,060 --> 00:22:33,270
Right?
对吗？

344
00:22:33,280 --> 00:22:35,190
So what means you need to synchronize?
所以你需要进行同步的意思是什么？

345
00:22:35,630 --> 00:22:36,680
One to a woman,
给一个女人。

346
00:22:36,690 --> 00:22:38,740
a threat should access what?
威胁应该访问什么？

347
00:22:39,630 --> 00:22:40,010
Right?
对吗？

348
00:22:44,420 --> 00:22:49,780
And aa particular way to think to synchronize that is
一种特定的思考方式来进行同步的方法是

349
00:22:49,790 --> 00:22:52,400
that to make sure that only
这样可以确保只有

350
00:22:52,410 --> 00:22:55,010
one thread is doing one thing at a time.
一个线程一次只能做一件事情。

351
00:22:57,200 --> 00:22:58,590
This is mutual exclusion,
这是互斥。

352
00:22:58,890 --> 00:22:59,890
will have examples.
会有示例。

353
00:23:01,410 --> 00:23:05,120
Another important concept is critical section.
另一个重要的概念是临界区。

354
00:23:06,750 --> 00:23:08,930
You can define a section in the code,
你可以在代码中定义一个区块，

355
00:23:09,610 --> 00:23:12,420
which it's a critical section,
这是一个关键区域。

356
00:23:12,430 --> 00:23:20,880
which this means that section can be only executed by one thread at a time.
这意味着该部分只能由一个线程同时执行。

357
00:23:21,850 --> 00:23:25,920
You cannot have the two threads executing instruction
你不能让两个线程同时执行指令。

358
00:23:25,930 --> 00:23:30,460
from the critical section at a different time at the same time.
在不同的时间同时从临界区访问。

359
00:23:30,790 --> 00:23:39,300
Another way to think about is that from the programmer.of view,
另一种思考方式是从程序员的角度来看，

360
00:23:39,310 --> 00:23:43,250
all the instruction is the critical section.
所有的指令都是临界区。

361
00:23:43,260 --> 00:23:45,730
They are executed sequentially.
它们按顺序执行。

362
00:23:46,610 --> 00:23:47,360
Okay?
好的？

363
00:23:48,460 --> 00:23:55,440
No one else will modify the variables of which are in the critical section
没有其他人会修改临界区中的变量。

364
00:23:56,850 --> 00:23:58,570
from the stripe executing it.
从执行条纹。

365
00:24:01,900 --> 00:24:09,510
And then how do you in for these critical sections?
那么你是如何进入这些临界区的呢？

366
00:24:10,010 --> 00:24:10,920
And again,
再次，

367
00:24:10,930 --> 00:24:15,080
critical section and mutual exclusion out of the two sides of the same coin,
关键区域和互斥是同一个硬币的两面。

368
00:24:15,530 --> 00:24:18,160
you in order to have a critical section,
为了拥有一个临界区，你需要：

369
00:24:18,370 --> 00:24:19,920
need to implement a critical section,
需要实现一个临界区

370
00:24:19,930 --> 00:24:24,980
you need to have mutual exclusion beginnings that whilst thread execute
你需要有互斥的开始，以确保线程执行时的互斥性。

371
00:24:24,990 --> 00:24:25,900
the critical section,
临界区

372
00:24:25,910 --> 00:24:28,860
another thread cannot execute the instruction that could become a section.
另一个线程无法执行可能成为一个临界区的指令。

373
00:24:29,290 --> 00:24:31,280
And then how at the lower level,
然后在较低的层次上，

374
00:24:31,290 --> 00:24:33,480
how you implement a mutual exclusion.
如何实现互斥。

互斥是一种用于保护共享资源免受并发访问的机制。以下是一些常见的互斥实现方法：

1. 临界区：使用临界区（Critical Section）来保护共享资源。在进入临界区之前，线程需要获取一个锁或信号量。一旦线程进入临界区，其他线程将被阻塞，直到该线程离开临界区。

2. 互斥锁：使用互斥锁（Mutex）来实现互斥。互斥锁是一种同步原语，只允许一个线程进入临界区。当一个线程获取到互斥锁时，其他线程将被阻塞，直到该线程释放锁。

3. 信号量：使用信号量（Semaphore）来实现互斥。信号量是一种计数器，用于控制对共享资源的访问。当信号量的值为1时，表示资源可用，线程可以进入临界区。当信号量的值为0时，表示资源已被占用，线程需要等待。

4. 读写锁：使用读写锁（Read-Write Lock）来实现互斥。读写锁允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。当有线程正在写入时，其他线程无法读取或写入。

这些方法都可以实现互斥，但具体选择哪种方法取决于应用程序的需求和性能要求。

375
00:24:33,490 --> 00:24:35,640
And therefore, because section is choosing blocks.
因此，由于部分正在选择块。

376
00:24:36,640 --> 00:24:37,270
Basically,
基本上，

377
00:24:37,280 --> 00:24:41,780
the concept is that when you are going to enter a critical section,
这个概念是当你要进入一个临界区时，

378
00:24:41,790 --> 00:24:43,260
you are going to acquire a lock.
你将要获取一个锁。

379
00:24:44,720 --> 00:24:45,240
Now,
现在，

380
00:24:45,250 --> 00:24:49,080
and everyone who has to enter the critical session has to acquire the law
每个进入关键会话的人都必须遵守规定。

381
00:24:49,090 --> 00:24:49,920
before entering it.
在进入之前。

382
00:24:50,420 --> 00:24:51,440
If you have the lock,
如果你拥有锁，

383
00:24:51,450 --> 00:24:52,540
no one else can under.
没有其他人能够理解。

384
00:24:52,980 --> 00:24:55,130
When you x is a critical section, you release a lock.
当你访问一个临界区时，你释放一个锁。

385
00:24:56,740 --> 00:24:57,130
Okay?
好的？

386
00:24:59,080 --> 00:25:00,430
This locks,
这个锁定了。

387
00:25:00,700 --> 00:25:02,330
operation, like typically,
操作，通常情况下，

388
00:25:02,340 --> 00:25:04,170
it's not acquire and released,
不是获取和释放，

389
00:25:04,180 --> 00:25:05,440
are atomic,
是原子的，

390
00:25:05,820 --> 00:25:10,590
but meaning that something is atomic is that you cannot,
但是"atomic"的意思是指某个操作是原子性的，也就是说你不能够

391
00:25:11,120 --> 00:25:13,800
you cannot be the sad with executing blocker.
你不能对执行阻塞器感到难过。

392
00:25:13,810 --> 00:25:21,180
Choir cannot be suspended in the middle of executing clock,
在执行时钟的过程中，无法暂停合唱团。

393
00:25:21,190 --> 00:25:23,450
acquire the same about local release.
获取相同的本地版本。

394
00:25:27,250 --> 00:25:30,710
And we are going to learn how we are going to implement these logs later.
我们将在后面学习如何实现这些日志。

395
00:25:33,110 --> 00:25:34,980
For the p threads, libraries,
对于p个线程，库函数，

396
00:25:34,990 --> 00:25:40,710
you do have the lock primitive.
你确实有锁原语。

397
00:25:41,390 --> 00:25:45,790
You have a piece of mutex in when you are going to create a me lock,
当你要创建一个"me"锁时，你需要使用一个互斥锁。

398
00:25:45,800 --> 00:25:47,610
and then you can acquire the lock.
然后你可以获取锁。

399
00:25:47,850 --> 00:25:50,500
And by piece thread, mutex lock,
通过分片线程、互斥锁，

400
00:25:50,510 --> 00:25:52,200
and piece thread mutex unlock,
解释：
"and" 是一个逻辑运算符，表示 "和"。
"piece" 在这里指的是 "片段" 或 "部分"。
"thread" 指的是 "线程"，在计算机操作系统中，线程是程序执行的最小单位。
"mutex" 是 "互斥锁" 的缩写，用于控制多个线程对共享资源的访问。
"unlock" 是 "解锁" 的意思，指的是释放互斥锁。

翻译：
"and piece thread mutex unlock" 可以翻译为 "并且片段线程互斥锁解锁"。

401
00:25:52,210 --> 00:25:53,560
you release a lock.
你释放了一个锁。

402
00:25:55,020 --> 00:25:55,440
Okay?
好的？

403
00:25:56,330 --> 00:26:02,260
You are going to do this in homework on here.
你将在这里完成这个作业。

404
00:26:02,270 --> 00:26:03,340
It's a simple example.
这是一个简单的例子。

405
00:26:03,350 --> 00:26:07,780
This is a piece of code from the code I shown last time,
这是我上次展示的代码中的一部分。

406
00:26:08,300 --> 00:26:12,530
in which we apply that we have the critical section here.
在这里我们应用了临界区。

407
00:26:12,960 --> 00:26:15,550
For my common is common plus,
对于我的common是common plus

408
00:26:16,870 --> 00:26:18,680
common plus, common.
常见的加法，常见的。

409
00:26:18,690 --> 00:26:21,340
Sorry, it's a global variable, if you remember.
抱歉，这是一个全局变量，如果你还记得的话。

410
00:26:22,950 --> 00:26:26,100
So now you may ask yourself,
那么现在你可能会问自己，

411
00:26:26,510 --> 00:26:28,020
why do we have?
为什么我们需要它？

412
00:26:28,030 --> 00:26:29,500
It's in that?
在那里吗？

413
00:26:29,750 --> 00:26:30,820
It's just a single line.
这只是一行代码。

414
00:26:32,180 --> 00:26:36,970
Why do you need to protect by locks as these are single line of code?
为什么需要通过锁来保护这些单行代码？

415
00:26:37,980 --> 00:26:41,080
The reason,
原因是，

416
00:26:41,430 --> 00:26:44,660
again, we are going to discuss more about this in the future.
再次强调，我们将在未来进一步讨论这个问题。

417
00:26:44,670 --> 00:26:46,010
This is just a preview.
这只是一个预览。

418
00:26:46,720 --> 00:26:48,730
Is that this line,
这是这一行吗？

419
00:26:50,040 --> 00:26:51,520
my common is equal,
我的常见是相等的。

420
00:26:51,690 --> 00:26:53,800
my is common plus,
我的是Common Plus。

421
00:26:54,880 --> 00:26:58,920
is basically composed by multiple instructions.
基本上由多个指令组成。

422
00:27:00,600 --> 00:27:02,780
Processor instructions.
处理器指令。

423
00:27:05,710 --> 00:27:06,700
Therefore,
因此，

424
00:27:07,160 --> 00:27:12,870
you can be interrupted in the middle of executing this instruction,
在执行这条指令的过程中，你可能会被中断。

425
00:27:13,210 --> 00:27:14,650
is this line of code.
这是一行代码。

426
00:27:16,370 --> 00:27:19,710
And that can lead to inaccurate results.
这可能导致不准确的结果。

427
00:27:20,960 --> 00:27:22,920
Like, for instance, this line,
例如，比如这一行，

428
00:27:24,280 --> 00:27:29,880
what may do is going to access common from the main memory,
主要是从主存中访问共享资源。

429
00:27:30,640 --> 00:27:32,210
bring it in a register.
将其存入一个寄存器中。

430
00:27:32,920 --> 00:27:36,300
I'd want to that value,
我想获取那个值。

431
00:27:36,730 --> 00:27:40,660
and then store the value back in the memory.
然后将该值存回内存中。

432
00:27:43,170 --> 00:27:44,560
If you are interrupted,
如果你被打断了，

433
00:27:45,000 --> 00:27:51,250
after you brought the value in of the memory of the common in register,
在将共享内存中的值加载到寄存器后，

434
00:27:52,480 --> 00:27:52,880
right?
对的？

435
00:27:53,180 --> 00:27:54,940
And someone else read and write it.
还有其他人来阅读和写入它。

436
00:27:56,320 --> 00:27:59,030
When you are going to be resume execution,
当你准备恢复执行时，

437
00:27:59,710 --> 00:28:01,830
you are going to execute the old value,
你将要执行旧值。

438
00:28:01,840 --> 00:28:03,070
which is the registers.
寄存器是什么。

439
00:28:04,960 --> 00:28:06,320
And then write it back.
然后将其写回。

440
00:28:06,490 --> 00:28:08,880
You can override the value of a different thread.
你可以覆盖其他线程的值。

441
00:28:14,050 --> 00:28:17,950
Another way to another primitive besides lock.
除了锁之外，还有另一种原语的方式。

442
00:28:17,960 --> 00:28:20,670
And again, don't tell you are going to talk more about.
再次强调，不要告诉你会多说些什么。

443
00:28:20,680 --> 00:28:22,110
This is just to give you a sense.
这只是为了让你有个概念。

444
00:28:22,120 --> 00:28:27,990
And also because you are going to use in you have to deal with this
而且因为你要使用它，所以你必须处理这个问题。

445
00:28:28,000 --> 00:28:28,860
in homework one.
在作业一中。

446
00:28:30,690 --> 00:28:34,390
Another way to implement locks is similar force.
另一种实现锁的方式类似于强制。

447
00:28:34,700 --> 00:28:36,480
Think about the generalized locks.
思考一下广义锁。

448
00:28:37,210 --> 00:28:39,510
This was defined by diaspora.
这是由散居社区定义的。

449
00:28:39,790 --> 00:28:42,080
One of the parents of computer science,
计算机科学的创始人之一，

450
00:28:42,290 --> 00:28:44,160
all the way in 60s, yours.
在60年代一路走来，属于你的。

451
00:28:45,930 --> 00:28:50,520
This is also amazing organization primitive using original unix and windows.
这也是使用原始的Unix和Windows的令人惊叹的组织原语。

452
00:28:51,070 --> 00:28:51,540
Okay?
好的？

453
00:28:52,620 --> 00:28:54,410
The way to think about this,
对此的思考方式是，

454
00:28:54,420 --> 00:28:55,910
you have these two primitives,
你有这两个原语，

455
00:28:55,920 --> 00:29:01,880
b and b they be comes from program to test,
b和b是来自测试程序的。

456
00:29:01,890 --> 00:29:08,860
and we were hogan to increment from dutch dash that I was a dutch,
我们本来打算从荷兰开始逐步增加，因为我是荷兰人。

457
00:29:09,360 --> 00:29:09,980
was dutch.
是荷兰人。

458
00:29:12,360 --> 00:29:19,850
Basically, the way they are working is that p thought
基本上，他们的工作方式是这样的：p认为

459
00:29:25,520 --> 00:29:26,430
tries to decrement.
尝试递减。

460
00:29:27,300 --> 00:29:33,230
And if the value of the semaphore is zero, then it blocks.
如果信号量的值为零，则会阻塞。

461
00:29:34,310 --> 00:29:37,180
It's waiting for that value for the center,
它正在等待中心的值。

462
00:29:37,190 --> 00:29:38,620
for to be increment.
为了递增。

463
00:29:40,250 --> 00:29:41,510
And if one is increment,
如果其中一个被增加了，

464
00:29:42,100 --> 00:29:42,890
it's unlocked.
它已解锁。

465
00:29:43,870 --> 00:29:47,590
And is the great and the value is determined.
这是伟大的，价值是由它决定的。

466
00:29:48,800 --> 00:29:53,160
And we it's increment is the value of the semaphore.
当我们对信号量进行增加操作时，它的值会增加。

467
00:29:53,560 --> 00:30:00,100
And if there is any p waiting b is going to signal to it,
如果有任何等待的进程p，b将会向它发送信号。

468
00:30:00,110 --> 00:30:02,560
so it can decrement and continue.
所以它可以递减并继续执行。

469
00:30:03,950 --> 00:30:08,300
Here is a piece of code which shows you how thread join is implemented.
这是一段代码，展示了如何实现线程的加入（join）功能。

470
00:30:08,980 --> 00:30:09,420
You remember,
你记得，

471
00:30:09,430 --> 00:30:15,340
for the third join means that I am waiting for a thread to finish.
第三个join表示我正在等待一个线程完成。

472
00:30:16,570 --> 00:30:18,330
In this case,
在这种情况下，

473
00:30:20,090 --> 00:30:23,930
basically, the thread join is implementing are doing some of four down.
基本上，线程的join实现了四个主要功能。

474
00:30:25,160 --> 00:30:30,640
The similar for it seem it's set one.
类似的东西似乎已经设置好了。

475
00:30:31,690 --> 00:30:37,190
And this is the critical circle section, right?
这是关键区域的部分，对吗？

476
00:30:37,200 --> 00:30:41,880
Is like in something like your summer fall down.
就像是你的夏天坠落一样。

477
00:30:42,310 --> 00:30:43,190
What does that mean here?
这在这里是什么意思？

478
00:30:43,200 --> 00:30:44,270
Some are for down.
有些是用于下降的。

479
00:30:45,750 --> 00:30:48,650
Here is going to decline the summer for one.
这里将要拒绝一个夏季。

480
00:30:48,980 --> 00:30:50,900
From 1 to 0, you are going to have zero.
从1到0，你将会得到零。

481
00:30:51,350 --> 00:30:53,860
You are going to enter the critical section.
你即将进入临界区。

482
00:30:53,870 --> 00:30:56,560
Notice that, again, this part,
请注意，再次强调，这部分，

483
00:30:57,200 --> 00:31:00,440
the mutual exclusion part is implemented by all the threats,
互斥部分由所有线程实现。

484
00:31:01,020 --> 00:31:01,370
right?
对的？

485
00:31:02,580 --> 00:31:07,080
And only one thread can enter the critical section.
只有一个线程可以进入临界区。

486
00:31:08,900 --> 00:31:09,290
Right?
对吗？

487
00:31:10,730 --> 00:31:16,970
Because one, it wants one system once thread entered this critical section.
因为它希望在一个系统中，一旦一个线程进入了这个临界区域。

488
00:33:26,540 --> 00:33:27,240
Everyone?
大家？

489
00:33:27,250 --> 00:33:28,280
Sorry about that.
抱歉。

490
00:33:28,930 --> 00:33:31,520
I got disconnected.
我断线了。

491
00:33:50,440 --> 00:33:52,510
Please add the questions,
请添加问题。

492
00:33:52,520 --> 00:33:55,670
and let me try to answer the questions.
让我来尝试回答这些问题。

493
00:34:03,210 --> 00:34:07,550
Again, sorry about that them up.
再次抱歉让他们失望。

494
00:34:09,040 --> 00:34:09,370
Okay.
好的。

495
00:34:09,380 --> 00:34:10,810
So please,
所以，请

496
00:34:12,440 --> 00:34:17,950
I there are a few questions I haven't answered and I no longer see
我还有几个问题没有回答，但我现在看不到了。

497
00:34:17,960 --> 00:34:20,170
them after reconnecting.
重新连接后，将它们恢复。

498
00:34:21,240 --> 00:34:22,640
So please ask them again.
所以请再问一次。

499
00:34:24,770 --> 00:34:27,530
So let's move on.
那么我们继续吧。

500
00:34:31,160 --> 00:34:31,610
Okay?
好的？

501
00:34:36,040 --> 00:34:36,830
Basically, here,
基本上，在这里，

502
00:34:36,840 --> 00:34:40,430
if we want to implement the signaling for the strategy join,
如果我们想要实现策略加入的信号传递，

503
00:34:40,440 --> 00:34:41,870
like I mentioned earlier,
正如我之前提到的，

504
00:34:41,880 --> 00:34:43,110
you can use a semi force.
你可以使用半强制。

505
00:34:43,620 --> 00:34:44,660
When a straight finishes,
当一条直线完成时，

506
00:34:44,670 --> 00:34:46,970
he just bring the summer for up.
他只是为我们带来了夏天。

507
00:34:48,250 --> 00:34:49,240
Therefore,
因此，

508
00:34:51,520 --> 00:34:54,190
okay, so sorry, thank you taking your step back.
没关系，很抱歉，谢谢你的退让。

509
00:34:55,480 --> 00:34:56,510
In this particular.
在这个特定的情况下。

510
00:34:56,520 --> 00:34:57,630
So initially,
最初，

511
00:34:57,640 --> 00:34:59,550
what we saw is a previous example.
我们所看到的是一个之前的例子。

512
00:34:59,560 --> 00:35:01,750
I don't know how much you lost from what I said.
我不知道你从我说的话中损失了多少。

513
00:35:02,180 --> 00:35:03,970
We are implementing a critical section.
我们正在实现一个临界区。

514
00:35:04,380 --> 00:35:07,170
This is the first example about using similar force to implement
这是关于使用类似力来实现的第一个示例。

515
00:35:07,180 --> 00:35:10,960
the critical section where only once thread at a time can execute
临界区是指只允许一个线程执行的部分

516
00:35:10,970 --> 00:35:12,320
in the critical section.
在临界区。

517
00:35:12,900 --> 00:35:16,390
The second example is implement on the thread join,
第二个例子是使用线程的join方法实现的。

518
00:35:17,030 --> 00:35:18,440
and with the thread join,
使用线程的join方法，

519
00:35:18,670 --> 00:35:21,130
the way we implemented it is like, first of all,
我们的实现方式是这样的，首先，

520
00:35:21,140 --> 00:35:23,470
the semaphore now it's initialize to zero, not one.
信号量现在被初始化为零，而不是一。

521
00:35:24,140 --> 00:35:26,040
And when a threat finish,
当威胁结束时，

522
00:35:26,050 --> 00:35:29,090
it is is going to increment the semaphore right?
它将要增加信号量，对吗？

523
00:35:29,380 --> 00:35:34,840
The main thread which created the other threads and ways for the stress to finish,
主线程创建了其他线程，并提供了完成压力的方式。

524
00:35:35,130 --> 00:35:37,340
is going only to call some up or down.
只会调用一些向上或向下的操作。

525
00:35:37,810 --> 00:35:39,410
And initially,
最初，

526
00:35:39,420 --> 00:35:41,730
if the threat no threat has finished,
如果威胁已经结束，

527
00:35:42,100 --> 00:35:44,900
the sum of four is zero and remains zero,
四个数的和为零，并且保持为零。

528
00:35:45,250 --> 00:35:48,840
the same the main thread calling thread join is blocked.
相同的主线程调用线程的join被阻塞。

529
00:35:51,960 --> 00:35:53,560
When I started finishes,
当我开始完成时，

530
00:35:53,570 --> 00:35:55,320
then this is decrement it,
那么这就是将其减少。

531
00:35:56,830 --> 00:35:58,420
which is exactly the behavior you want.
这正是你想要的行为。

532
00:36:10,220 --> 00:36:11,570
So there is one connection,
所以有一个连接，

533
00:36:12,180 --> 00:36:13,130
one question.
一个问题。

534
00:36:13,180 --> 00:36:15,730
Some of us don't have an owner like locks,
我们中的一些人没有像锁一样的所有者

535
00:36:15,740 --> 00:36:19,450
do I this is depends on the implementation,
这取决于具体的实现。

536
00:36:19,460 --> 00:36:21,410
is nothing fundamental about blocks,
块本身没有什么根本性的东西。

537
00:36:21,420 --> 00:36:23,010
also enough for us to have an owner.
我们拥有一个所有者已经足够了。

538
00:36:23,860 --> 00:36:24,950
The one,
一个

539
00:36:29,000 --> 00:36:30,440
the only important things,
唯一重要的事情是，

540
00:36:30,710 --> 00:36:31,380
even for locks,
即使是对于锁来说，

541
00:36:31,390 --> 00:36:36,460
is to make sure that only one thread can get a lock at a given time.
是为了确保在给定时间内只有一个线程可以获得锁。

542
00:36:37,860 --> 00:36:40,730
In our context, the next question, in our context,
在我们的背景下，下一个问题，在我们的背景下，

543
00:36:40,740 --> 00:36:43,450
you can potentially have infinitely many threads, right?
你可以潜在地拥有无限多的线程，对吗？

544
00:36:43,910 --> 00:36:46,540
Then was the difference between our concept of threat
那么我们对威胁概念的理解有何不同呢？

545
00:36:46,550 --> 00:36:48,300
and the limited harder threats.
以及更加有限的困难威胁。

546
00:36:48,310 --> 00:36:51,060
Like acpu has 12 courts or 24 threats.
像一个CPU有12个核心或者24个线程。

547
00:36:53,650 --> 00:36:56,640
It's, again, the thread is the programming construct,
再次强调，线程是一种编程结构，

548
00:36:57,150 --> 00:36:57,510
right?
对的？

549
00:36:58,090 --> 00:37:01,560
And you can have infinitely an infinite number,
你可以拥有无限多个无限的数量。

550
00:37:02,270 --> 00:37:03,310
not an infinite,
不是无限的。

551
00:37:03,320 --> 00:37:05,180
nothing can be infinite here.
这里没有什么是无限的。

552
00:37:06,960 --> 00:37:10,320
But you can have a very large number of threats, let's say, 1,000.
但是你可能会面临非常多的威胁，比如说1,000个。

553
00:37:11,010 --> 00:37:14,780
But at the same time, you have four cores and four and one core,
但同时，你有四个核心和四个加一核心。

554
00:37:15,770 --> 00:37:18,990
say it can execute only one side at a time.
它一次只能执行一边。

555
00:37:19,290 --> 00:37:19,730
Right?
对吗？

556
00:37:20,330 --> 00:37:23,260
So basically,
基本上，

557
00:37:23,270 --> 00:37:25,060
the difference here is that, again,
这里的区别在于，再次，

558
00:37:25,070 --> 00:37:27,260
the thread is a programming construct,
线程是一种编程构造，

559
00:37:27,270 --> 00:37:29,180
is what you create in a program.
程序中你所创建的东西。

560
00:37:29,940 --> 00:37:31,460
And a core.
还有一个核心。

561
00:37:32,240 --> 00:37:34,030
It's what you have physically, right?
这是你实际拥有的东西，对吗？

562
00:37:34,440 --> 00:37:36,440
And you need to deal with our constraints.
而且你需要处理我们的限制。

563
00:37:36,680 --> 00:37:39,710
You can run at a given time, for example, only for a stretch.
你可以在指定的时间运行，例如，只运行一段时间。

564
00:37:40,350 --> 00:37:44,050
That's how you need to design their living to map all these 1,000 threads.
这就是你需要设计他们的生活方式来映射这1,000个线程的方式。

565
00:37:44,060 --> 00:37:49,240
You have at the application level as a programmer level to this four course.
作为一个程序员，你在应用层面上有这四门课程的水平。

566
00:37:49,250 --> 00:37:52,240
And the way to do it, like I mentioned many times by interleaving,
就像我多次提到的那样，通过交错的方式来完成。

567
00:37:52,920 --> 00:37:57,140
by running a thread for a little bit and running another thread and so forth.
通过运行一个线程一段时间，然后运行另一个线程，依此类推。

568
00:37:57,890 --> 00:37:59,590
Maybe there's a question here.
也许这里有一个问题。

569
00:37:59,880 --> 00:38:03,660
It's also related with what the concept of hypothetic.
这也与假设的概念有关。

570
00:38:04,810 --> 00:38:05,300
Okay?
好的？

571
00:38:06,050 --> 00:38:07,510
Now hyper threading we haven't talked,
现在我们还没有讨论超线程技术。

572
00:38:07,520 --> 00:38:12,300
and we are not going to talk during the class by hyper threading.
我们在课堂上不会讨论超线程。

573
00:38:12,550 --> 00:38:14,140
It is a harder concept.
这是一个较难的概念。

574
00:38:14,600 --> 00:38:20,150
And this allows accord to execute a certain time,
这样可以让accord在特定的时间执行。

575
00:38:24,070 --> 00:38:30,620
but it doesn't modify the fact that the number of threads that the harbor
但这并不改变港口所能容纳的线程数量的事实

576
00:38:31,540 --> 00:38:31,980
can run
可以运行

577
00:38:31,990 --> 00:38:34,400
at a given time is limited.
在给定的时间内是有限的。

578
00:38:34,410 --> 00:38:37,330
It will only say that instead of running,
它只会显示而不会运行，

579
00:38:37,600 --> 00:38:41,020
I I have four cores instead of running 4/3 of the time.
我有四个核心，而不是运行4/3的时间。

580
00:38:41,030 --> 00:38:42,500
Now I can run 1/3 of the time.
现在我可以运行的时间是三分之一。

581
00:38:45,430 --> 00:38:47,220
So there is no fundamental difference.
所以没有根本的区别。

582
00:38:49,880 --> 00:38:50,590
Let's move on.
让我们继续吧。

583
00:38:50,600 --> 00:38:56,350
We are the so now we talk about threads.
我们现在来讨论线程。

584
00:38:56,360 --> 00:39:00,410
Now let's look a little bit step back and talk more about our processes.
现在让我们稍微退后一步，更多地谈谈我们的进程。

585
00:39:02,610 --> 00:39:10,610
The process is an environment in which you execute your code and have
进程是一个执行代码并具有环境的实体。

586
00:39:10,620 --> 00:39:11,570
the restricted rights.
受限权利。

587
00:39:13,910 --> 00:39:15,430
So process, remember,
所以进程，记住，

588
00:39:16,540 --> 00:39:18,820
contains one or more threads,
包含一个或多个线程

589
00:39:19,580 --> 00:39:24,820
because a stress as a unit of execution and a single other space,
因为一个进程作为执行的单位和一个单独的内存空间，

590
00:39:25,450 --> 00:39:29,670
the other space is protected from other spaces,
其他空间受到其他空间的保护。

591
00:39:29,680 --> 00:39:31,110
owned by other processes.
被其他进程所拥有。

592
00:39:32,920 --> 00:39:35,250
It also owns a file process,
它还拥有一个文件进程。

593
00:39:35,260 --> 00:39:37,980
also own the resources like file descriptors,
还拥有像文件描述符这样的资源，

594
00:39:37,990 --> 00:39:40,290
network connection.
网络连接。

595
00:39:40,300 --> 00:39:40,730
Okay?
好的？

596
00:39:41,470 --> 00:39:42,990
When you run a program,
当你运行一个程序时，

597
00:39:43,000 --> 00:39:45,150
the program execute within a process.
程序在一个进程中执行。

598
00:39:46,470 --> 00:39:49,430
And an application like we're discussing the past,
而且，就像我们之前讨论过的那样，一个应用程序，

599
00:39:49,750 --> 00:39:56,070
can iran on more than one processes can have more than on processes?
伊朗可以在多个进程上运行吗？可以拥有多个进程吗？

600
00:39:57,130 --> 00:39:57,370
Right?
对吗？

601
00:39:57,380 --> 00:40:03,420
Remember, is an example about trivial example is facebook.
记住，这只是一个关于微不足道的例子，以Facebook为例。

602
00:40:03,430 --> 00:40:04,460
It's one application,
这是一个应用程序。

603
00:40:04,470 --> 00:40:07,140
but there are many processes that are not even running
但是有很多进程甚至没有在运行。

604
00:40:07,150 --> 00:40:09,220
onto the same machine that running on different measures.
在同一台机器上运行在不同度量上的情况下。

605
00:40:10,500 --> 00:40:10,740
Right?
对吗？

606
00:40:16,170 --> 00:40:19,280
In all of them and in operating systems,
在所有这些中以及操作系统中，

607
00:40:19,810 --> 00:40:21,240
today's operating systems,
今天的操作系统，

608
00:40:21,920 --> 00:40:24,880
everything which turns out outside the kernel,
一切在内核之外发生的事情，

609
00:40:26,630 --> 00:40:27,420
it's a process.
这是一个进程。

610
00:40:28,300 --> 00:40:30,900
The kernel, if you remember, is a part of the operating system,
如果你还记得的话，内核是操作系统的一部分。

611
00:40:30,910 --> 00:40:33,060
which is based always a resident in the memory.
这是指始终驻留在内存中的操作系统。

612
00:40:34,770 --> 00:40:35,240
Now,
现在，

613
00:40:37,030 --> 00:40:41,580
the processes have a similar mechanism to create other processes.
进程具有类似的机制来创建其他进程。

614
00:40:43,890 --> 00:40:46,500
You also have for processes,
你还有四个进程。

615
00:40:46,510 --> 00:40:51,040
fork in command to create another process.
在命令中使用fork创建另一个进程。

616
00:40:53,000 --> 00:40:57,150
But what is the fundamental difference between forking a process
但是分叉进程和创建进程的根本区别是什么？

617
00:40:57,160 --> 00:40:59,270
or forking or creating a new threat?
还是分叉或创建一个新的线程？

618
00:41:01,720 --> 00:41:06,520
The fundamental difference is that when you create a new thread that thread,
基本的区别在于，当你创建一个新的线程时，该线程

619
00:41:06,850 --> 00:41:08,780
like we just discussed,
就像我们刚刚讨论的那样，

620
00:41:09,070 --> 00:41:15,450
share the code and the global variables and other resources
分享代码、全局变量和其他资源

621
00:41:16,580 --> 00:41:20,420
with the other thread in the same process,
与同一进程中的其他线程一起，

622
00:41:21,300 --> 00:41:24,500
the thread which created it.
创建它的线程。

623
00:41:24,510 --> 00:41:26,320
But in the case of a process,
但是对于一个进程来说，

624
00:41:26,330 --> 00:41:27,880
if a process creates another process,
如果一个进程创建了另一个进程，

625
00:41:29,290 --> 00:41:31,570
the new processes and new address that are
新的进程和新的地址

626
00:41:31,580 --> 00:41:36,080
different other space and share nothing with the process which created it
不同的其他空间，并且与创建它的进程不共享任何内容

627
00:41:39,780 --> 00:41:42,140
in order to go around this limitation,
为了绕过这个限制，

628
00:41:42,490 --> 00:41:44,850
while the fork is doing it,
在fork执行时，

629
00:41:46,600 --> 00:41:51,060
copies the everything the current process of the parent process had
复制当前进程的父进程的所有内容

630
00:41:51,070 --> 00:41:52,020
to the child process.
给子进程。

631
00:41:52,990 --> 00:41:54,460
It copies a crowd,
它复制了一群人。

632
00:41:54,470 --> 00:42:01,370
it copies the resources with the process who created another process is
它将资源与创建另一个进程的进程一起复制。

633
00:42:01,380 --> 00:42:02,600
a new process.
一个新的进程。

634
00:42:04,110 --> 00:42:04,580
Okay?
好的？

635
00:42:06,640 --> 00:42:07,870
If a process one,
如果一个进程一，

636
00:42:07,880 --> 00:42:09,350
crisis process two,
危机处理二，

637
00:42:10,710 --> 00:42:11,610
using fork,
使用fork函数，

638
00:42:12,090 --> 00:42:18,790
the for corporation will copy the code and the access to the resources
该公司将复制代码并访问资源。

639
00:42:18,800 --> 00:42:21,850
that process one has to process two.
进程一必须处理进程二。

640
00:42:24,510 --> 00:42:27,100
Therefore, the process to execute the same code.
因此，执行相同代码的过程。

641
00:42:30,300 --> 00:42:32,430
And now, when you call fork,
现在，当你调用fork函数时，

642
00:42:33,140 --> 00:42:35,240
it returns immediately.
它立即返回。

643
00:42:35,820 --> 00:42:38,020
And it's,
而且，

644
00:42:38,030 --> 00:42:40,020
depending the value it returns,
根据它返回的值，

645
00:42:40,030 --> 00:42:46,190
depends on whether the fork it's in the child process or is a parent process.
这取决于fork是在子进程中还是在父进程中。

646
00:42:47,930 --> 00:42:54,220
If it's a parent processor for returns the process identifier of the child.
如果它是一个父处理器，则返回子进程的进程标识符。

647
00:42:55,090 --> 00:42:56,530
If it's in the child process,
如果它在子进程中，

648
00:42:56,540 --> 00:42:58,180
it returns zero.
它返回零。

649
00:42:59,500 --> 00:43:00,970
If it's a rise and zero,
如果是上升和零,

650
00:43:01,420 --> 00:43:07,350
then it's an error.
那么这就是一个错误。

651
00:43:13,630 --> 00:43:15,820
Now, let's look at this simple example.
现在，让我们来看一个简单的例子。

652
00:43:18,320 --> 00:43:23,480
So you basically called fork here,
所以你在这里基本上调用了fork函数。

653
00:43:24,400 --> 00:43:29,060
and it returns cpid and if cpid is zero,
它返回 cpid，如果 cpid 是零，

654
00:43:29,070 --> 00:43:31,660
you do something and bbc cpid equals zero,
当你执行某个操作时，BBC的CPID等于零。

655
00:43:31,670 --> 00:43:36,370
you do something else again when you call fork.
当你调用fork时，你又做了一些其他的事情。

656
00:43:38,630 --> 00:43:40,340
And you in this process,
在这个过程中，你也参与其中，

657
00:43:40,350 --> 00:43:42,040
this runs into a process.
这会进入一个进程。

658
00:43:42,050 --> 00:43:44,600
A new process is created,
创建了一个新的进程。

659
00:43:47,130 --> 00:43:50,830
and that new process is going to run the same code,
而且这个新进程将运行相同的代码，

660
00:43:50,840 --> 00:43:52,930
because the code will be copied in the new process.
因为代码将被复制到新的进程中。

661
00:43:54,320 --> 00:43:55,570
Is the first process,
第一个进程是

662
00:43:55,890 --> 00:43:57,160
which is apparent process.
明显的进程是指在系统中可见的正在运行的进程。

663
00:43:57,820 --> 00:44:02,570
The cpid will be the identifier of a child process.
cpid将是子进程的标识符。

664
00:44:03,160 --> 00:44:04,220
It'll be greater than zero.
它将大于零。

665
00:44:04,470 --> 00:44:07,980
This is what you are going to be to happen in the parent process.
这是父进程即将发生的事情。

666
00:44:09,620 --> 00:44:10,900
The alice branch,
Alice 分支，

667
00:44:11,960 --> 00:44:14,780
the cpid zero happen and will be run.
CPID为零的进程发生并将被执行。

668
00:44:14,790 --> 00:44:17,120
This instruction will be run in the child process.
这条指令将在子进程中运行。

669
00:44:23,760 --> 00:44:25,300
What you are going to get here,
在这里，你将会得到什么

670
00:44:27,060 --> 00:44:27,260
right?
对的？

671
00:44:27,910 --> 00:44:29,460
What is the output you are going to see?
你将会看到什么输出？

672
00:44:29,470 --> 00:44:30,860
You are going to get from this card I
你将从这张卡中获得我

673
00:44:43,750 --> 00:44:44,620
need,
需要

674
00:44:47,500 --> 00:44:48,730
but you should try it.
但是你应该试一试。

675
00:44:49,650 --> 00:44:50,760
So very likely,
非常有可能，

676
00:44:50,770 --> 00:44:51,840
what will happen here?
这里会发生什么？

677
00:44:51,850 --> 00:44:59,360
You are going to see the first process of parents say you can see the
你将要看到父进程的第一个输出，它说你可以看到。

678
00:44:59,370 --> 00:45:03,270
parent will see parent 1234,
家长将看到家长1234。

679
00:45:03,900 --> 00:45:04,500
top to ten.
从上到下的前十名。

680
00:45:04,510 --> 00:45:05,580
And then from,
然后从

681
00:45:06,030 --> 00:45:10,820
ii see that there are some answers better and 10 times.
我看到有一些答案比其他答案好10倍。

682
00:45:10,830 --> 00:45:15,250
And not the.
而不是。

683
00:45:16,090 --> 00:45:17,890
Now the parent will do it 10 times,
现在父进程将执行这个操作10次，

684
00:45:17,900 --> 00:45:19,710
and the child will do 10 times.
孩子将会做10次。

685
00:45:19,720 --> 00:45:23,290
And this is what you are going to get.
这就是你将要得到的。

686
00:45:25,750 --> 00:45:29,380
The parent to do then and then tell trans something like.
然后父进程执行，并向子进程传递一些信息。

687
00:45:30,290 --> 00:45:31,520
And however,
然而，

688
00:45:31,530 --> 00:45:34,280
if you are asleep will something
如果你正在睡觉，会发生什么事情

689
00:45:43,760 --> 00:45:43,800
change.
改变。

690
00:45:45,550 --> 00:45:46,540
That's a great question.
这是一个很好的问题。

691
00:45:46,550 --> 00:45:47,540
So it was a question.
所以这是一个问题。

692
00:45:47,550 --> 00:45:49,460
When is a child code executive?
一个子代码何时被执行？

693
00:45:50,040 --> 00:45:51,270
When is the child called executive?
什么时候称为执行程序？

694
00:45:51,280 --> 00:45:54,510
The child is a different process with the difference which is on stress.
这个孩子是一个不同的进程，与其他进程的不同之处在于它处于压力状态。

695
00:45:56,700 --> 00:45:57,540
That's a good question.
这是一个很好的问题。

696
00:45:57,830 --> 00:46:01,820
The answer is on the operating system is titled execute.
操作系统中的答案被称为执行。

697
00:46:03,060 --> 00:46:05,870
The side of the other process is a schedule of deciding it.
另一个进程的一侧是决定它的调度计划。

698
00:46:07,630 --> 00:46:09,940
That's exactly what the question tries to say.
这正是问题试图表达的意思。

699
00:46:10,460 --> 00:46:11,560
But try to illustrate.
但是尽量进行说明。

700
00:46:13,460 --> 00:46:15,370
If you just print one after another,
如果你只是一个接一个地打印，

701
00:46:16,200 --> 00:46:18,500
then the code is green code.
那么这段代码是绿色的代码。

702
00:46:20,240 --> 00:46:24,710
Can run fast enough.
可以跑得够快。

703
00:46:24,720 --> 00:46:28,460
So it's not the process is not suspended.
所以进程并没有被挂起。

704
00:46:29,910 --> 00:46:31,950
That's I likely what you are going to see,
这可能是你将要看到的。

705
00:46:31,960 --> 00:46:37,660
you are going to see the parent consecutively printing from 1 to 10
你将会看到父进程连续打印从1到10的数字。

706
00:46:37,670 --> 00:46:39,180
and then the child from 1 to 10
然后是从1到10的孩子。

707
00:46:42,560 --> 00:46:43,520
or the other around.
或者反过来。

708
00:46:44,590 --> 00:46:46,060
However, if you could sleep,
然而，如果你能睡觉的话，

709
00:46:46,920 --> 00:46:53,860
then that's enough time for the parent to be suspended as a child running
那么这段时间足够让父进程暂停，作为一个正在运行的子进程。

710
00:46:55,290 --> 00:46:56,530
and the other way around.
反过来也一样。

711
00:46:56,540 --> 00:46:59,610
So we are going to see an interleave interleaving,
所以我们将要看到一个交错的交错。

712
00:46:59,980 --> 00:47:02,700
the printer from the parent and the child.
来自父进程和子进程的打印机。

713
00:47:02,710 --> 00:47:04,620
We are going to see them into living.
我们将会去看望他们。

714
00:47:09,060 --> 00:47:10,280
It's another view.
这是另一种观点。

715
00:47:14,770 --> 00:47:15,880
This is a view.
这是一个视图。

716
00:47:15,890 --> 00:47:20,310
It's executing as an exact will talk a little bit about the exact.
它正在执行作为一个确切的，我们稍微谈谈确切的一点。

717
00:47:20,320 --> 00:47:21,630
But for this purpose,
但是为了这个目的，

718
00:47:23,510 --> 00:47:27,270
it's again, you say, see, here is a parent execute.
又是这样，你说，看，这里是一个父进程执行。

719
00:47:27,620 --> 00:47:31,240
Now, look at the if function is reversed,
现在，让我们来看一下 if 函数被反转的情况，

720
00:47:31,610 --> 00:47:32,680
if checks first,
如果先检查

721
00:47:32,690 --> 00:47:38,380
whether the pid return from there is the return from the fork is zero.
从那里返回的pid是否是fork返回的零。

722
00:47:39,010 --> 00:47:40,360
We know if the return is zero,
我们知道如果返回值为零，

723
00:47:40,370 --> 00:47:42,280
the code is executed by the child.
代码由子进程执行。

724
00:47:43,110 --> 00:47:43,900
This is exact.
这是准确的。

725
00:47:46,170 --> 00:47:48,110
Lcpid different than zero,
Lcpid不为零，

726
00:47:48,120 --> 00:47:52,220
hopefully is greater than zero than you, the parent.
希望的是，子进程的值大于零，而父进程的值不大于零。

727
00:47:52,230 --> 00:47:54,380
It's a like, you think, white in this case.
这是一个类似的想法，你认为，在这种情况下是白色的。

728
00:47:56,430 --> 00:47:59,450
And we are going to what exact is doing.
我们要做的具体是什么？

729
00:47:59,460 --> 00:48:04,030
And we'll learn we'll talk more about it briefly.
我们将会简要地更多地讨论它。

730
00:48:07,190 --> 00:48:08,040
Exact.
准确的。

731
00:48:08,430 --> 00:48:15,560
It's running a program that program will replace the code of the child
它正在运行一个程序，该程序将替换子进程的代码。

732
00:48:15,570 --> 00:48:17,080
with the program itself.
与程序本身相关。

733
00:48:19,670 --> 00:48:23,370
Think about right now,
现在请你思考一下，

734
00:48:23,380 --> 00:48:25,780
the fork replicated,
fork复制了进程，

735
00:48:25,790 --> 00:48:31,820
duplicated the code of the parent to the child now is the exact we are
将父进程的代码复制到子进程中，现在它们完全相同。

736
00:48:31,830 --> 00:48:33,740
just some sense of conceptually
只是一些概念上的理解

737
00:48:33,750 --> 00:48:39,210
we override the child code with a code of the program we want to execute.
我们用我们想要执行的程序的代码覆盖子代码。

738
00:48:41,390 --> 00:48:45,220
And this is what happens when you implement the shell.
当你实现shell时，会发生以下情况。

739
00:48:45,230 --> 00:48:48,330
And you are going to do you do that in your homework?
你会在你的作业中这样做吗？

740
00:48:49,490 --> 00:48:49,920
Right?
对吗？

741
00:48:50,430 --> 00:48:53,500
What happened is a shell is a path, the shell,
发生的是一个shell是一个路径，即shell。

742
00:48:53,510 --> 00:48:55,180
or you type in the comments.
或者你可以在评论中输入。

743
00:48:56,070 --> 00:48:57,440
And you type your comment.
然后你输入你的评论。

744
00:48:58,210 --> 00:48:58,650
Right?
对吗？

745
00:48:59,070 --> 00:48:59,930
What happens?
发生了什么事情？

746
00:49:03,210 --> 00:49:04,650
The shell process,
Shell进程，

747
00:49:05,520 --> 00:49:07,110
forks, another process,
forks, 另一个进程,

748
00:49:07,120 --> 00:49:12,350
and the 4th process is going to use exact to run the program you want to run.
第四个进程将使用exact来运行您想要运行的程序。

749
00:49:14,440 --> 00:49:14,900
Okay?
好的？

750
00:49:15,660 --> 00:49:22,750
This weight is similar with a join that join like its way it's waiting
这个权重类似于一个连接，就像它的方式一样，它在等待。

751
00:49:23,230 --> 00:49:24,600
for the child to finish.
等待孩子完成。

752
00:49:28,580 --> 00:49:29,050
Make sense?
有意义吗？

753
00:49:29,380 --> 00:49:31,090
I'll answer the questions immediately.
我会立即回答这些问题。

754
00:49:32,980 --> 00:49:36,550
So where it wait for process to finish,
它在等待进程完成的地方。

755
00:49:36,560 --> 00:49:39,790
these are some other ap is exit,
这些是其他已退出的应用程序。

756
00:49:39,800 --> 00:49:41,230
your terminates approach,
你的终止方法，

757
00:49:41,240 --> 00:49:43,830
the process you have also exit for these threads.
你所拥有的进程也退出了这些线程。

758
00:49:44,740 --> 00:49:48,250
Then you have this command which is killed.
然后你有一个被终止的命令。

759
00:49:48,500 --> 00:49:50,840
I can kill a particular process.
我可以终止一个特定的进程。

760
00:49:51,070 --> 00:49:52,900
If I send this kind of signal,
如果我发送这种信号，

761
00:49:53,530 --> 00:49:55,560
like, for instance, the operating system,
例如，操作系统，

762
00:49:55,570 --> 00:49:57,280
this is how it kills a process.
这是它如何终止一个进程的方式。

763
00:49:58,030 --> 00:50:01,670
For one reason or another sends a kill signatory.
由于某种原因发送了一个终止信号。

764
00:50:02,740 --> 00:50:04,690
And then if you are a process,
然后，如果你是一个进程，

765
00:50:04,700 --> 00:50:08,630
you get aa aa signal,
你收到了一个 aa aa 信号。

766
00:50:09,340 --> 00:50:12,770
then you can actually sometimes can do something about the signal.
在某些情况下，你实际上可以对信号采取一些措施。

767
00:50:15,020 --> 00:50:16,000
We'll talk more about it.
我们会进一步讨论这个问题。

768
00:50:18,090 --> 00:50:21,070
But this, again,
但是，再次提到这一点，

769
00:50:21,080 --> 00:50:23,790
a simple program in which,
一个简单的程序，其中，

770
00:50:26,710 --> 00:50:30,220
again, for acpid call zero everything within that branch.
再次，对于acpid调用，请将该分支内的所有内容归零。

771
00:50:30,610 --> 00:50:32,000
It's executed by the child,
它由子进程执行。

772
00:50:32,010 --> 00:50:36,640
so the child executive and gets it by apiid princess pid and then exit
所以子进程通过apiid princess pid获取它，然后退出。

773
00:50:36,650 --> 00:50:37,840
with a42,
使用a42

774
00:50:37,850 --> 00:50:41,610
which is a a it's a return code.
这是一个返回代码。

775
00:50:42,040 --> 00:50:43,130
Whatever you want to pick,
无论你想选择什么，

776
00:50:43,980 --> 00:50:46,610
the code executed by the parent.
由父进程执行的代码。

777
00:50:48,070 --> 00:50:51,360
It's waiting for the child breaks.
它正在等待子进程结束。

778
00:50:53,150 --> 00:50:53,950
This is a wait.
这是一个等待操作。

779
00:50:56,190 --> 00:50:58,480
And now, like I mentioned,
现在，就像我之前提到的，

780
00:50:58,490 --> 00:51:03,220
when you get an action as aaa signal,
当你收到一个名为aaa的信号时，

781
00:51:03,720 --> 00:51:04,780
as a process,
作为一个进程，

782
00:51:04,790 --> 00:51:06,100
you can do something about it.
你可以采取一些行动。

783
00:51:06,850 --> 00:51:09,300
How you can do about it,
你对此有什么打算？

784
00:51:10,130 --> 00:51:10,940
you intercept.
你拦截。

785
00:51:13,070 --> 00:51:16,300
For instance, you get this is a sink interrupt.
例如，你收到了一个中断信号。

786
00:51:17,210 --> 00:51:22,000
You can also send from a user process to another user process that can send
您还可以从一个用户进程发送到另一个可以发送的用户进程。

787
00:51:22,010 --> 00:51:22,640
this signal.
这个信号。

788
00:51:23,530 --> 00:51:27,120
And in basically,
基本上，

789
00:51:27,130 --> 00:51:28,140
you can associate,
你可以关联

790
00:51:28,830 --> 00:51:31,880
you can say that when you get this thing interrupt,
当你收到这个中断时，你可以这样说。

791
00:51:32,150 --> 00:51:34,390
you are going to execute a piece of code.
你将要执行一段代码。

792
00:51:35,270 --> 00:51:37,740
You write a function which execute this piece of code,
你需要编写一个函数来执行这段代码。

793
00:51:38,990 --> 00:51:45,950
then use a secret action to pass the address of that function,
然后使用一个秘密操作来传递该函数的地址。

794
00:51:47,080 --> 00:51:52,490
to be invoked when I seeking it's when you receive using the process
在接收到使用该进程时被调用的时候，我正在寻找它。

795
00:51:52,500 --> 00:51:55,440
to receive the seeking that.
接收寻求请求。

796
00:51:58,080 --> 00:51:58,500
Okay?
好的？

797
00:52:00,380 --> 00:52:04,540
If you don't have registered for a seeking,
如果您还没有注册寻求帮助，

798
00:52:04,910 --> 00:52:07,400
this call back to handle it,
这是一个回调函数来处理它。

799
00:52:07,940 --> 00:52:09,070
the processors die.
处理器死机。

800
00:52:09,650 --> 00:52:09,890
Right?
对吗？

801
00:52:10,210 --> 00:52:11,100
As otherwise,
否则，

802
00:52:12,710 --> 00:52:16,800
you may want to keep the process around and do something about it.
你可能希望保留该进程并对其进行一些操作。

803
00:52:19,140 --> 00:52:24,900
There are many signals I told seeking seeking is also,
有很多信号我告诉寻求寻求也是的。

804
00:52:26,930 --> 00:52:31,890
it's when you do ctrl c when you have a program and runs into controversy
当你在运行一个程序时，遇到争议时，你可以使用Ctrl+C。

805
00:52:31,900 --> 00:52:33,250
that generate ac int,
生成交流电整数。

806
00:52:35,720 --> 00:52:38,240
the program, if you don't do anything, it will be killed.
如果你不做任何操作，程序将被终止。

807
00:52:38,610 --> 00:52:39,870
But if you do something,
但是如果你做了某事，

808
00:52:40,450 --> 00:52:42,810
c control c you intercept it.
c 控制 c 你拦截它。

809
00:52:42,820 --> 00:52:46,830
You doesn't need to kill the process.
你不需要终止该进程。

810
00:52:48,970 --> 00:52:49,970
Six step,
六个步骤

811
00:52:50,020 --> 00:52:53,860
its control z you stop the process.
按下Ctrl+Z可以暂停进程。

812
00:52:58,130 --> 00:53:02,070
When you seek term is when you have a shell command and you want to kill it,
当你说"seek term"时，意思是你有一个shell命令，并且想要终止它。

813
00:53:02,600 --> 00:53:05,820
there are secure and six stop to terminate the process.
有六个安全的终止进程的方法。

814
00:53:06,180 --> 00:53:12,270
You cannot cannot intercept the cigar by cigar action.
你不能通过吸烟行为来拦截雪茄。

815
00:53:12,890 --> 00:53:15,670
So this will terminate your process.
这将终止您的进程。

816
00:53:16,130 --> 00:53:17,180
These are, in general,
总的来说，这些是

817
00:53:17,190 --> 00:53:22,030
what is used by the operating system to terminate the process a process.
操作系统用什么来终止一个进程？

818
00:53:26,240 --> 00:53:29,480
Let me just talk briefly here and see what are the questions.
让我简要地谈一下，看看有什么问题。

819
00:53:33,550 --> 00:53:35,100
Rp set, mutex lock,
Rp集合，互斥锁

820
00:53:35,110 --> 00:53:38,020
and the unlocking implement with a semi force is, again,
而使用半力解锁的实施方式是，再次，

821
00:53:38,030 --> 00:53:40,020
is dependent on the operating system.
依赖于操作系统。

822
00:53:41,650 --> 00:53:46,100
We are going to learn different implementation for lock and unlock.
我们将学习不同的锁定和解锁实现方式。

823
00:53:47,990 --> 00:53:51,190
How do you know the scheduler one switch in the middle of the parents?
你是如何知道调度器在父进程中间进行切换的？

824
00:53:51,410 --> 00:53:53,280
For look, you do not know.
对于外表，你并不了解。

825
00:53:53,290 --> 00:53:54,950
And that's exactly the point.
这正是关键所在。

826
00:53:54,960 --> 00:53:58,780
I said what I mentioned in the previous example that if you don't have
我在之前的例子中提到过，如果你没有...

827
00:53:58,790 --> 00:54:00,740
the sleep with a high probability,
以高概率休眠。

828
00:54:00,750 --> 00:54:05,200
what you are going to see is that the parent output from the parent,
你将要看到的是来自父进程的输出。

829
00:54:05,410 --> 00:54:07,810
the follow up, the printing that ten values,
后续操作是打印十个值。

830
00:54:08,490 --> 00:54:09,620
and then from the child.
然后从子进程开始。

831
00:54:09,970 --> 00:54:15,240
But there is a very small probability that you can also be interrupted.
但是有很小的概率你也可能会被打断。

832
00:54:15,590 --> 00:54:16,210
During that.
在那期间。

833
00:54:16,220 --> 00:54:16,450
Look,
看着吧，

834
00:54:17,300 --> 00:54:19,460
the point is that you insert the slips,
关键是你要插入这些纸条，

835
00:54:19,840 --> 00:54:22,380
then now the entire loop will take you 10 seconds.
那么现在整个循环将花费你10秒的时间。

836
00:54:23,000 --> 00:54:23,350
Therefore,
因此，

837
00:54:24,440 --> 00:54:28,670
you are guaranteed to be interrupted by the child, the parent by the child,
你肯定会被孩子打断，父母也会被孩子打断。

838
00:54:28,680 --> 00:54:29,830
and the child by the parent,
由父进程创建的子进程，

839
00:54:33,580 --> 00:54:34,370
the child.
孩子。

840
00:54:34,380 --> 00:54:38,330
So does the child always has apid zero?
孩子进程的进程ID（pid）是否总是为零？

841
00:54:38,340 --> 00:54:40,680
Remember, the child is a process.
记住，孩子是一个进程。

842
00:54:41,170 --> 00:54:43,690
The process has appeared as an identifier.
该进程已出现为一个标识符。

843
00:54:43,930 --> 00:54:45,840
What we have is here, what we are on earth.
我们拥有的是此刻，我们存在于地球上。

844
00:54:46,110 --> 00:54:50,140
See, talking here about the pid is a return of the fork function.
在这里谈论的是进程ID是fork函数的返回值。

845
00:54:52,360 --> 00:55:00,000
Basically, the return for functions in the child process doesn't return.
基本上，子进程中的函数返回不会返回。

846
00:55:00,500 --> 00:55:02,520
The child process.
子进程。

847
00:55:02,530 --> 00:55:03,920
Id return is zero.
返回的id为零。

848
00:55:07,090 --> 00:55:08,730
It doesn't mean the process id is zero.
这并不意味着进程ID为零。

849
00:55:09,960 --> 00:55:13,760
In return, it mean, we are only saying that the fork, let me repeat.
回报意味着我们只是在说fork，让我重复一遍。

850
00:55:13,770 --> 00:55:23,050
The fork is a child code returns when executed, return is zero.
当执行 fork 时，子代码返回的返回值为零。

851
00:55:24,790 --> 00:55:26,900
When executing fork is apparent,
当执行fork时，显然

852
00:55:30,190 --> 00:55:30,970
return,
返回,

853
00:55:32,170 --> 00:55:33,850
child process identifier.
子进程标识符。

854
00:55:47,270 --> 00:55:50,910
How does a parent on calling wait?
父进程在调用wait时会发生什么？

855
00:55:50,920 --> 00:55:54,520
And now who to wait?
现在等谁呢？

856
00:55:54,890 --> 00:55:55,890
Who to wait for?
等待谁？

857
00:55:57,480 --> 00:55:59,580
Ii believe if I remember correctly,
我相信如果我记得正确的话，

858
00:55:59,590 --> 00:56:05,060
the you can specify that in white.
你可以在白色中指定。

859
00:56:08,860 --> 00:56:09,620
We'll see that.
我们会看到的。

860
00:56:15,380 --> 00:56:16,820
Let me continue a little,
让我继续一下，

861
00:56:17,120 --> 00:56:19,680
and i'll stop for more questions.
我会停下来等待更多问题。

862
00:56:22,980 --> 00:56:28,570
The a shell a it's a job control system that it's what you're getting a terminal.
shell是一个作业控制系统，它是你在终端上使用的东西。

863
00:56:28,580 --> 00:56:31,820
You have the prompt that the shell from there,
你可以在那里使用shell提示符。

864
00:56:31,830 --> 00:56:35,630
you can execute other programs and or other comments.
你可以执行其他程序或添加其他注释。

865
00:56:40,800 --> 00:56:43,550
You are going to build your own shell in homework, too.
你也要在作业中构建自己的shell。

866
00:56:43,560 --> 00:56:48,940
And you are going to use a fork and exec to create new processes to create
你将使用fork和exec来创建新的进程。

867
00:56:48,950 --> 00:56:51,000
programs like we mentioned earlier on,
我们之前提到的类似的程序，

868
00:56:51,010 --> 00:56:51,280
right?
对的？

869
00:56:53,200 --> 00:56:56,220
Your shell will fork a child,
你的shell将会fork一个子进程，

870
00:56:56,540 --> 00:57:01,210
which will use exact to execute the program ok
这将使用exact来执行程序。

871
00:57:06,520 --> 00:57:08,250
so this process versus threads.
所以这是进程与线程的比较。

872
00:57:12,090 --> 00:57:15,700
One question here is why have four can exact system,
这里的一个问题是为什么需要四个精确的系统。

873
00:57:15,710 --> 00:57:16,780
colorful processes,
多彩的进程

874
00:57:16,790 --> 00:57:20,430
but just a piece thread create function for a thread.
但只是一个用于创建线程的函数片段。

875
00:57:25,570 --> 00:57:28,600
The answer is here, but again, to summarize,
答案在这里，但是再次总结一下，

876
00:57:28,990 --> 00:57:35,480
the main reason for that is that with threads,
主要原因是使用线程，

877
00:57:36,030 --> 00:57:38,230
if one thread create another thread,
如果一个线程创建另一个线程，

878
00:57:38,680 --> 00:57:45,260
the new thread share the circle and share the global variables and the heap,
新线程共享圆和共享全局变量以及堆内存。

879
00:57:45,600 --> 00:57:48,370
which with a sandwich created it right?
这是一个有三明治的问题吗？

880
00:57:48,880 --> 00:57:50,360
While in the case,
在这种情况下，

881
00:57:52,190 --> 00:57:56,190
in the and then also the p thread,
在 "and then also the p thread" 中，

882
00:57:57,170 --> 00:57:59,040
you give the crowd to execute,
你将任务交给人群执行，

883
00:57:59,670 --> 00:58:00,060
right?
对的？

884
00:58:01,010 --> 00:58:02,620
You give a new greater thread,
你创建了一个新的更大的线程。

885
00:58:02,630 --> 00:58:03,700
you give the curve,
你给出了曲线。

886
00:58:03,710 --> 00:58:05,860
the function to be executed by the thread.
线程要执行的函数。

887
00:58:07,400 --> 00:58:09,700
In the case of fork,
在fork的情况下，

888
00:58:10,220 --> 00:58:12,040
when you create a new process,
当你创建一个新的进程时，

889
00:58:12,050 --> 00:58:17,720
because the new there is no sharing between two processes.
因为新的进程之间没有共享。

890
00:58:17,730 --> 00:58:19,600
They have different other spaces.
它们有不同的其他空间。

891
00:58:20,020 --> 00:58:23,770
You are going to duplicate the code and the resources from the parent
你需要复制父级的代码和资源。

892
00:58:23,780 --> 00:58:24,700
to the child.
给孩子。

893
00:58:25,410 --> 00:58:26,140
But now,
但是现在，

894
00:58:26,700 --> 00:58:29,170
the parent and child execute the same code.
父进程和子进程执行相同的代码。

895
00:58:29,180 --> 00:58:33,130
So to execute a different kind of code for a program, you need,
因此，要为程序执行不同类型的代码，你需要

896
00:58:33,520 --> 00:58:35,110
you are going to call exact.
你打算打电话给谁？

897
00:58:35,790 --> 00:58:36,270
Right?
对吗？

898
00:58:36,490 --> 00:58:36,900
We speak.
我们说话。

899
00:58:36,910 --> 00:58:39,940
There is no need for such that such thing.
没有必要这样做。

900
00:58:40,230 --> 00:58:42,020
Because first of all,
首先，因为

901
00:58:42,770 --> 00:58:47,500
there is no need for function id because they shared the threads share
不需要函数 id，因为线程共享它们的资源

902
00:58:47,510 --> 00:58:48,900
the same address space.
相同的地址空间。

903
00:58:49,820 --> 00:58:51,700
And then it's also,
然后还有一个问题，

904
00:58:51,710 --> 00:58:53,100
when you create a thread,
当你创建一个线程时，

905
00:58:53,110 --> 00:58:57,580
you.out to the few give also the address of the function,
你输出给少数人时，也要给出函数的地址。

906
00:58:57,590 --> 00:59:00,330
the state should execute,
状态应该执行。

907
00:59:03,290 --> 00:59:05,990
by the way, and as a note, in windows,
顺便提一下，在Windows操作系统中，

908
00:59:06,250 --> 00:59:07,990
instead of what we have create process.
与我们创建进程的方式不同。

909
00:59:12,530 --> 00:59:13,760
Here is a question for you.
这是一个问题给你。

910
00:59:13,770 --> 00:59:16,440
If we have two tasks to run concurrently,
如果我们有两个任务需要同时运行，

911
00:59:16,450 --> 00:59:18,880
do iran them in separate threads of iranians?
在伊朗，他们是否将伊朗人分成不同的线程？

912
00:59:19,390 --> 00:59:24,030
In separate process?
在单独的进程中吗？

913
00:59:25,410 --> 00:59:28,020
Again, I shouldn't have the head the answer here,
再次强调，我不应该在这里给出答案。

914
00:59:28,030 --> 00:59:29,140
but it depends.
但这取决于情况。

915
00:59:29,730 --> 00:59:31,770
Is how much isolation you want to have.
你想要多少隔离？

916
00:59:32,050 --> 00:59:33,440
The threads are lighter weight.
线程的负担更轻。

917
00:59:34,260 --> 00:59:35,320
Why is that lighter weight?
为什么它更轻量级？

918
00:59:36,590 --> 00:59:41,110
Because they don't share all because they don't have a lot of state
因为它们不共享所有资源，因为它们没有很多状态。

919
00:59:41,120 --> 00:59:41,980
associated with them.
与它们相关联。

920
00:59:42,380 --> 00:59:43,610
So when you switch them,
所以当你切换它们时，

921
00:59:44,300 --> 00:59:49,540
When the skipper switch from one side to another doesn't need to save
当船长从一侧切换到另一侧时，不需要保存

922
00:59:49,550 --> 00:59:50,740
all the context.
所有的上下文。

923
00:59:51,070 --> 00:59:54,270
Essentially, the process, it's just a teeny bit of context,
基本上，进程只是一点点的上下文信息。

924
00:59:54,280 --> 00:59:55,350
especially the thread.
尤其是线程。

925
00:59:57,840 --> 00:59:58,620
It's much faster.
它速度快多了。

926
00:59:58,630 --> 00:59:59,700
On the other hand,
另一方面，

927
00:59:59,710 --> 01:00:01,590
the process that is much stronger isolated.
更强烈隔离的进程。

928
01:00:01,950 --> 01:00:06,010
Again, each process lives in its own other space.
同样，每个进程都存在于自己的独立空间中。

929
01:00:07,250 --> 01:00:09,640
Let me just see a few more questions
让我再看几个问题。

930
01:00:15,590 --> 01:00:17,280
since let's share other spaces,
既然让我们分享其他空间，

931
01:00:17,290 --> 01:00:19,350
but nor stack,
但不是栈。

932
01:00:19,360 --> 01:00:22,310
do the stack start a different offset, absolutely.
栈的起始偏移是不同的，绝对如此。

933
01:00:23,750 --> 01:00:24,510
The stack.
栈。

934
01:00:26,480 --> 01:00:34,100
They do that a different processes.
他们通过不同的进程来完成这个任务。

935
01:00:35,240 --> 01:00:43,950
And if you remember from here, right?
如果你还记得的话，是从这里开始的，对吗？

936
01:00:43,960 --> 01:00:44,910
From this figure,
从这个图中，

937
01:01:00,870 --> 01:01:02,040
something is very slow.
某些东西非常慢。

938
01:01:02,730 --> 01:01:04,020
Here you have two stacks,
这里有两个栈，

939
01:01:04,030 --> 01:01:05,060
a the different.
一个不同的。

940
01:01:05,070 --> 01:01:08,890
They start a different they have different stack pointers,
它们启动时有不同的栈指针。

941
01:01:10,640 --> 01:01:12,000
start a different addresses.
从不同的地址开始。

942
01:01:19,340 --> 01:01:19,780
Okay?
好的？

943
01:01:21,050 --> 01:01:28,780
So let me see that I think there are some question about on the chat.
所以让我看看，我认为聊天中有一些问题。

944
01:01:34,120 --> 01:01:35,550
Yes, the new stack frames,
是的，新的栈帧，

945
01:01:35,560 --> 01:01:37,710
the new stacks out in the same address space,
新的栈在相同的地址空间中。

946
01:01:37,720 --> 01:01:39,910
but start at different points and different addresses.
但是从不同的起点和不同的地址开始。

947
01:01:41,210 --> 01:01:43,610
What happens to the stack when you make a new thread?
当你创建一个新线程时，栈会发生什么变化？

948
01:01:45,420 --> 01:01:46,850
When you create a new thread,
当你创建一个新线程时，

949
01:01:47,960 --> 01:01:50,770
you create a new stack for that thread.
你为该线程创建一个新的栈。

950
01:01:51,380 --> 01:01:53,960
We should not interfere with the stack of the current strategy.
我们不应该干涉当前策略的堆栈。

951
01:01:57,550 --> 01:02:02,400
I think it's pretty much it if I didn't answer any questions because that
如果我没有回答任何问题，我认为这就差不多了。

952
01:02:02,410 --> 01:02:03,750
is connect and everything else.
是连接和其他一切。

953
01:02:05,530 --> 01:02:12,740
Let me know some announcements.
请告诉我一些公告。

954
01:02:12,750 --> 01:02:16,920
The project zero is the project zero is due this thursday.
项目零的截止日期是本周四。

955
01:02:18,130 --> 01:02:19,160
Today from now,
从现在开始的今天，

956
01:02:20,250 --> 01:02:24,860
it's again, it needs to be done on your own like homework.
这次又是一样的，需要你自己完成，就像作业一样。

957
01:02:25,170 --> 01:02:28,160
Is the only one you need to do on your own.
这是你唯一需要自己完成的任务。

958
01:02:28,170 --> 01:02:31,340
All the other projects are group projects.
所有其他项目都是小组项目。

959
01:02:32,440 --> 01:02:36,030
Group assignments will be released by end of day this wednesday.
小组作业将在本周三的最后一天发布。

960
01:02:37,210 --> 01:02:37,750
A discussion,
一次讨论

961
01:02:37,760 --> 01:02:43,080
a section attendance is mandatory and with cameras on if you are remarked
某个部分的出勤是强制性的，并且如果你被注意到了，摄像头会开启。

962
01:02:44,650 --> 01:02:52,570
and start already planning with your group how to best collaborate on the project,
并且开始与你的小组一起计划如何最好地在项目上进行合作，

963
01:02:52,580 --> 01:02:54,130
especially if you are remote,
尤其是如果你是远程的，

964
01:02:54,800 --> 01:02:57,200
virtual coffee hours with a camera,
使用摄像头进行虚拟咖啡时间

965
01:02:57,210 --> 01:02:58,880
regular brainstorm meeting,
定期头脑风暴会议

966
01:02:59,820 --> 01:03:03,070
and try to meet multiple times a week.
并尝试每周多次见面。

967
01:03:03,540 --> 01:03:09,260
Most of the problems between from our experience with the groups happens
我们在与团队合作的经验中遇到的大部分问题都源于此。

968
01:03:09,270 --> 01:03:10,460
because communication.
因为沟通。

969
01:03:11,490 --> 01:03:14,840
It turns out that not everyone in the group is on the same page,
结果发现，小组中并不是每个人都意见一致，

970
01:03:14,850 --> 01:03:21,030
not everyone understood the same thing like what everyone has to do and buy
并不是每个人都理解得一样，就像每个人都要做什么和买什么一样。

971
01:03:21,040 --> 01:03:24,070
what and what to do.
是什么和要做什么。

972
01:03:24,880 --> 01:03:26,950
So over communicate over community,
所以要在社区中进行过度沟通，

973
01:03:26,960 --> 01:03:32,860
there is nothing like too much communication for your group to be successful
对于团队的成功来说，没有过多的沟通这样的事情。

974
01:03:58,870 --> 01:04:02,940
for the rest of this lecture,
在本节课的剩余时间里，

975
01:04:02,950 --> 01:04:04,980
we are starting to talk about.
我们开始讨论。

976
01:04:05,230 --> 01:04:09,290
We are diving into file systems, file abstraction.
我们正在深入研究文件系统和文件抽象化。

977
01:04:11,290 --> 01:04:12,200
In particular,
特别是，

978
01:04:12,210 --> 01:04:16,520
we are only going to talk about high level file io and these are streams.
我们只会讨论高级文件输入输出，这些是流。

979
01:04:17,680 --> 01:04:21,570
We are going to talk more about files next lecture on saturday.
我们下一堂课将更多地讨论文件的内容，时间是周六。

980
01:04:23,660 --> 01:04:24,320
So now,
所以现在，

981
01:04:25,330 --> 01:04:26,450
basically,
基本上，

982
01:04:26,980 --> 01:04:34,250
we are a lot of concepts we are going to work on are inherited
我们要讨论的许多概念都是继承而来的。

983
01:04:35,490 --> 01:04:37,550
from original unix.
来自原始的Unix。

984
01:04:39,860 --> 01:04:42,760
And indeed, why not linux is unique?
为什么 Linux 是独一无二的呢？

985
01:04:44,730 --> 01:04:48,800
Like we discussed ios or out mac os it's on top.
正如我们讨论的那样，iOS或者我们的macOS是顶级操作系统。

986
01:04:49,830 --> 01:04:53,060
It's a unique system of the call and even windows.
这是一个独特的调用系统，甚至与Windows不同。

987
01:04:54,030 --> 01:04:57,260
It's now more and more similar to you to unix.
它现在越来越像Unix了。

988
01:04:57,790 --> 01:04:59,380
Then it was 20 years ago.
那是20年前的事了。

989
01:05:00,940 --> 01:05:03,980
The main.about the unix,
关于Unix的主要内容是什么？

990
01:05:03,990 --> 01:05:06,650
and this is brilliant idea at this day,
而且这是一个在今天非常出色的想法。

991
01:05:07,120 --> 01:05:13,990
is to provide as much as possible a homogeneous abstraction across
的目标是尽可能提供一个统一的抽象层面，使其尽量一致。

992
01:05:14,380 --> 01:05:17,680
different io devices.
不同的输入输出设备。

993
01:05:18,570 --> 01:05:20,890
And that concept is about a five,
这个概念是关于一个五的概念。

994
01:05:21,640 --> 01:05:23,390
which is a stream of bytes.
这是一个字节流。

995
01:05:24,540 --> 01:05:32,080
This is not only the files on your disk,
这不仅仅是你磁盘上的文件，

996
01:05:32,620 --> 01:05:35,490
but also the way you operate.
还有你的操作方式。

997
01:05:35,730 --> 01:05:40,300
And the api when you send messages or receive messages,
发送消息或接收消息时的API

998
01:05:41,300 --> 01:05:46,010
or you send data up to the send a file to the printer to be printed,
或者你将数据发送到打印机以打印文件。

999
01:05:46,840 --> 01:05:49,420
or you get input from the terminal.
或者你从终端获取输入。

1000
01:05:50,740 --> 01:05:51,650
All of these,
所有这些，

1001
01:05:52,890 --> 01:05:59,970
you interact with all of these different devices in a very similar way.
你与所有这些不同的设备以非常相似的方式进行交互。

1002
01:06:02,550 --> 01:06:03,750
You can think, again,
你可以再次思考一下，

1003
01:06:03,760 --> 01:06:07,110
at a high level that everything is a file and you interact with them,
在高层次上，一切皆为文件，你与它们进行交互。

1004
01:06:09,040 --> 01:06:13,030
the base system calls then are open,
然后基本系统调用是open，

1005
01:06:13,560 --> 01:06:15,730
read, write, and close.
读取、写入和关闭。

1006
01:06:16,040 --> 01:06:18,430
It's open, file, clothes, file,
它是开着的，文件，衣服，文件，

1007
01:06:18,440 --> 01:06:20,270
read from file, write a file,
从文件中读取，写入文件。

1008
01:06:22,170 --> 01:06:24,830
some of the devices, so not have some of these operations.
有些设备可能不具备某些操作功能。

1009
01:06:25,420 --> 01:06:27,080
Like for instance, for a printer,
例如，对于打印机来说，

1010
01:06:27,090 --> 01:06:28,400
you have open,
你已经打开了。

1011
01:06:28,670 --> 01:06:31,910
call close and write, not read.
调用 close 和 write，而不是 read。

1012
01:06:32,420 --> 01:06:35,180
For the input terminal, you have read, but not write.
对于输入终端，你可以读取但不能写入。

1013
01:06:35,540 --> 01:06:36,060
Okay.
好的。

1014
01:06:42,030 --> 01:06:48,620
And then you have also this kind of cached all apiiocepl
然后你还有这种缓存所有apiiocepl的方式

1015
01:06:49,740 --> 01:06:53,440
for to customary configured different devices.
为了适应不同的设备进行常规配置。

1016
01:06:54,260 --> 01:06:54,600
Right?
对吗？

1017
01:06:57,680 --> 01:07:03,050
It's again for people who are interested in a little bit of history.
这是给对历史有一点兴趣的人们的再次提醒。

1018
01:07:03,060 --> 01:07:06,690
And actually to get given is very useful given for this class to get
实际上，获得这个课程的指导非常有用。

1019
01:07:07,000 --> 01:07:12,930
come context about how things evolved and why you can read this unique,
关于事物如何演变以及为什么你能阅读这个独特的内容的一些背景信息

1020
01:07:12,940 --> 01:07:15,170
the unix time sharing system,
Unix时间共享系统，

1021
01:07:15,570 --> 01:07:19,650
which is very old book that is almost 50 years,
这是一本非常古老的书，已经有将近50年的历史了。

1022
01:07:19,860 --> 01:07:21,370
very old paper.
非常古老的论文。

1023
01:07:21,640 --> 01:07:23,390
But it's extremely influential paper.
但这是一篇非常有影响力的论文。

1024
01:07:23,730 --> 01:07:25,080
And it's quite amazing.
而且这真是令人惊叹。

1025
01:07:25,090 --> 01:07:28,840
It's again, we are still using the same concept,
又是这个问题，我们仍然在使用相同的概念。

1026
01:07:28,850 --> 01:07:36,140
fundamentally like this paper described,
基本上就像这篇论文所描述的那样，

1027
01:07:36,690 --> 01:07:38,580
again, almost 50 years ago.
再说一次，将近50年前。

1028
01:07:41,490 --> 01:07:43,200
If you have1 hour,
如果你有1小时的时间，

1029
01:07:43,210 --> 01:07:45,240
this is a fantastic paper of it.
这是一篇非常棒的论文。

1030
01:07:46,890 --> 01:07:48,290
You'll hear more about politics.
你将会听到更多关于政治的事情。

1031
01:07:48,300 --> 01:07:50,370
What is politics is portable operating system?
什么是可移植操作系统？

1032
01:07:51,600 --> 01:07:53,590
Interface, excuse me, for unix.
接口，对不起，针对Unix操作系统。

1033
01:07:56,740 --> 01:07:58,880
It defines kind of a standard.
它定义了一种标准。

1034
01:07:59,090 --> 01:08:01,280
It's an effort of standardizing.
这是一种标准化的努力。

1035
01:08:01,910 --> 01:08:06,660
It was an effort to standardize different unix flavors.
这是为了标准化不同的Unix版本而做出的努力。

1036
01:08:07,540 --> 01:08:11,000
27 or 25 years ago,
27年或25年前，

1037
01:08:11,010 --> 01:08:13,520
there are a lot of unique flavors,
有很多独特的口味。

1038
01:08:14,060 --> 01:08:15,110
different companies.
不同的公司。

1039
01:08:15,120 --> 01:08:16,910
They have their own unique version.
他们有自己独特的版本。

1040
01:08:17,490 --> 01:08:24,210
Politics was the effort to standardize a subset of ap is across this.
政治是在这个领域中努力标准化一部分应用程序的努力。

1041
01:08:25,250 --> 01:08:27,840
Unix is okay.
Unix很好。

1042
01:08:28,590 --> 01:08:30,860
So the file of file system abstraction.
文件系统抽象的文件。

1043
01:08:32,020 --> 01:08:36,950
So it's a name collection of data in a file system.
所以它是文件系统中的一个数据名称集合。

1044
01:08:37,430 --> 01:08:40,780
And the posits file data is a sequence of bikes.
posits文件中的数据是一系列自行车的序列。

1045
01:08:41,990 --> 01:08:44,890
Could be text binary.
可以是文本二进制化。

1046
01:08:45,520 --> 01:08:49,230
You can have a serialized objects, almost anything.
你可以序列化几乎任何对象。

1047
01:08:50,160 --> 01:08:51,680
In addition to the file data,
除了文件数据之外，

1048
01:08:51,690 --> 01:08:52,720
you have meta data.
你有元数据。

1049
01:08:53,440 --> 01:08:56,490
And the meta data associated with a file,
以及与文件相关的元数据，

1050
01:08:56,800 --> 01:08:58,890
contain things like the size of the file.
包含文件的大小等信息。

1051
01:08:59,380 --> 01:09:01,020
When was the last time modified?
最后一次修改是什么时候？

1052
01:09:01,030 --> 01:09:02,220
Who is our owner?
我们的所有者是谁？

1053
01:09:02,430 --> 01:09:05,310
Security information who has access control and so forth.
安全信息，包括访问控制等。

1054
01:09:07,040 --> 01:09:08,920
The files are stored in folders,
文件存储在文件夹中，

1055
01:09:09,730 --> 01:09:10,150
right?
对的？

1056
01:09:10,610 --> 01:09:12,700
The folder contains farthest and directory.
该文件夹包含最远和目录。

1057
01:09:13,030 --> 01:09:15,260
A director is a special kind of fire,
导演是一种特殊的火焰，

1058
01:09:15,930 --> 01:09:21,680
and the directories are organized in an article fashion,
目录以文章的方式进行组织，

1059
01:09:22,050 --> 01:09:22,990
as you very well know.
正如你非常了解的那样。

1060
01:09:23,780 --> 01:09:24,240
Okay.
好的。

1061
01:09:26,260 --> 01:09:28,930
There are also concepts of links and volumes,
还有链接和卷的概念。

1062
01:09:28,940 --> 01:09:30,130
hard links of links.
链接的硬链接。

1063
01:09:30,140 --> 01:09:32,700
We are going to learn about those later.
我们稍后会学习这些内容。

1064
01:09:36,700 --> 01:09:37,160
Now,
现在，

1065
01:09:38,090 --> 01:09:42,050
every process has its own current working directory.
每个进程都有自己的当前工作目录。

1066
01:09:42,850 --> 01:09:43,290
Okay?
好的？

1067
01:09:43,940 --> 01:09:50,310
When you start aaa program from a current directory,
当你从当前目录启动 aaa 程序时，

1068
01:09:50,960 --> 01:09:53,980
that typically is a current working directory of that program.
通常是该程序的当前工作目录。

1069
01:09:53,990 --> 01:10:00,190
So if you just read and write without providing a path.
如果您只是读取和写入而没有提供路径。

1070
01:10:00,840 --> 01:10:02,810
Then you read and write on the current director.
那么你可以在当前目录下进行读写操作。

1071
01:10:05,470 --> 01:10:06,030
Now,
现在，

1072
01:10:06,280 --> 01:10:11,990
you can also refer like you very well known to a file using the absolute directory.
你也可以使用绝对路径来引用你非常熟悉的文件。

1073
01:10:12,260 --> 01:10:16,640
In that case, the current direct working directory it's ignored.
在这种情况下，当前的直接工作目录将被忽略。

1074
01:10:18,440 --> 01:10:18,790
Again,
请再次说明您的问题。

1075
01:10:18,800 --> 01:10:21,670
the current talking director you can see thinking
当前的对话导演正在思考中。

1076
01:10:21,680 --> 01:10:23,470
about like an environment variable,
关于环境变量，

1077
01:10:23,860 --> 01:10:24,260
right?
是的，正确的。

1078
01:10:24,510 --> 01:10:26,180
Which is set when the program is started.
程序启动时设置的是什么？

1079
01:10:29,420 --> 01:10:34,640
And you can have relative specify relative paths to the current directory.
你可以使用相对路径来指定相对于当前目录的路径。

1080
01:10:35,390 --> 01:10:41,900
But I dot slash means you go one level up
但是"../"表示你向上一级。

1081
01:10:44,000 --> 01:10:45,900
and deal.
并处理。

1082
01:10:45,910 --> 01:10:49,970
That means home directory and so forth.
这意味着主目录等等。

1083
01:10:52,740 --> 01:10:54,780
And the storage,
还有存储设备，

1084
01:10:55,380 --> 01:10:59,950
it's actually a has a pretty complex architecture.
它实际上具有相当复杂的架构。

1085
01:11:02,740 --> 01:11:05,370
It goes all the way from io drivers,
它从io驱动程序开始，一直延伸到...

1086
01:11:05,380 --> 01:11:07,530
and this is controlled all these devices.
并且这个控制所有这些设备。

1087
01:11:08,170 --> 01:11:13,240
Then you have the file system which is implemented,
然后你有一个已经实现的文件系统。

1088
01:11:13,650 --> 01:11:16,010
functionally implementing the operating system.
功能性地实现操作系统。

1089
01:11:16,330 --> 01:11:17,000
That is called,
那被称为，

1090
01:11:17,010 --> 01:11:20,790
this is the interface provided by the operating system through which
这是操作系统提供的接口，通过它可以进行以下操作：

1091
01:11:20,800 --> 01:11:24,960
the user level programs can invoke
用户级程序可以调用

1092
01:11:26,700 --> 01:11:28,450
file system operations.
文件系统操作。

1093
01:11:29,080 --> 01:11:33,030
Then you have the low level io and high level io in provide
提供的功能中有低级IO和高级IO。

1094
01:11:33,040 --> 01:11:36,890
different levels of abstractions of the file system to the application.
文件系统对应用程序的不同抽象层级。

1095
01:11:38,630 --> 01:11:45,830
So here we are going to start from a high level io right?
所以我们要从高级 I/O 开始吗？

1096
01:11:46,810 --> 01:11:48,280
And again,
再次，

1097
01:11:48,290 --> 01:11:51,340
a stream is a sequence of bytes.
流是一系列字节的序列。

1098
01:11:53,140 --> 01:11:53,560
That's it.
就是这样。

1099
01:11:54,140 --> 01:11:54,510
Right?
对吗？

1100
01:11:56,260 --> 01:12:04,240
And how you open a file for in the stream format for this a with a stream
如何以流格式打开文件并使用流进行操作？

1101
01:12:04,250 --> 01:12:06,640
api you use f open,
你使用的 API 是 f open。

1102
01:12:07,240 --> 01:12:12,820
you include sto this represents containers contains the api
你可以使用 `#include <sto.h>` 来引入包含 API 的容器。

1103
01:12:15,040 --> 01:12:21,580
the file related file stream file ap is f open,
与文件流相关的文件AP是fopen。

1104
01:12:21,590 --> 01:12:28,740
obviously, is part of sdo dot h and as the of open take,
显然，它是sdo.h的一部分，并且作为open函数的一部分被调用。

1105
01:12:29,050 --> 01:12:30,170
several arguments,
几个参数

1106
01:12:30,740 --> 01:12:31,950
one is a file name,
一个是文件名

1107
01:12:33,190 --> 01:12:33,480
right?
对的？

1108
01:12:34,040 --> 01:12:35,160
Which is the name of the file.
文件的名称是什么？

1109
01:12:35,170 --> 01:12:37,640
And here you can, especially if you don't specify the pass.
在这里你可以这样做，尤其是如果你没有指定密码。

1110
01:12:37,870 --> 01:12:41,220
Again, you are referring to a file in the current directory.
再次强调，你正在引用当前目录中的文件。

1111
01:12:41,230 --> 01:12:43,740
If you specify an absolute path,
如果您指定了绝对路径，

1112
01:12:43,990 --> 01:12:46,600
then is a current directory ignore.
当前目录被忽略。

1113
01:12:48,140 --> 01:12:50,640
And you have also a mode,
而且你还有一个模式，

1114
01:12:51,430 --> 01:12:51,900
right?
对的？

1115
01:12:52,510 --> 01:12:54,340
The mode, it tells,
模式，它告诉

1116
01:12:55,530 --> 01:12:56,580
basically,
基本上，

1117
01:12:58,940 --> 01:12:59,620
what is this?
这是CS162计算机操作系统的助教。

1118
01:13:01,550 --> 01:13:03,780
What you can do is this file.
你可以做的是这个文件。

1119
01:13:04,610 --> 01:13:04,910
Right?
对吗？

1120
01:13:06,170 --> 01:13:06,960
You can,
你可以。

1121
01:13:07,610 --> 01:13:09,040
what kind of file is this one?
这是什么类型的文件？

1122
01:13:10,160 --> 01:13:13,780
You can have text files or binary files, right?
你可以有文本文件或二进制文件，对吗？

1123
01:13:14,450 --> 01:13:16,040
With the text files,
使用文本文件，

1124
01:13:16,050 --> 01:13:21,080
the code is interpreted as being a character with a binary file is a bike.
这段代码被解释为一个字符，二进制文件是一辆自行车。

1125
01:13:21,660 --> 01:13:24,110
Sorry, that it's not interpreter.
抱歉，这不是一个解释器。

1126
01:13:24,350 --> 01:13:27,400
It's not interpreted when you print it,
当你打印它时，它不会被解释。

1127
01:13:27,410 --> 01:13:28,480
when you try to print it.
当你尝试打印它时。

1128
01:13:31,830 --> 01:13:36,340
In addition from the type of that is of the fibers that is text or binary,
除了文本或二进制类型的纤维之外，

1129
01:13:38,540 --> 01:13:42,130
what is the kind of operation which are allowed on the fire?
火可以进行哪些操作？

1130
01:13:43,160 --> 01:13:44,600
R is for it,
R代表它，

1131
01:13:45,760 --> 01:13:45,960
right?
是的，正确的。

1132
01:13:45,970 --> 01:13:48,350
Is for obviously modifying,
这是显然要进行修改的。

1133
01:13:49,390 --> 01:13:50,340
append.
追加。

1134
01:13:50,680 --> 01:13:54,200
It's for writing only at the end of the file.
这是用于在文件末尾进行写入的。

1135
01:13:59,560 --> 01:14:01,160
Then you can write,
那么你可以写：

1136
01:14:01,770 --> 01:14:05,040
you can also open a file boss for read and write.
你也可以打开一个文件，用于读取和写入。

1137
01:14:07,130 --> 01:14:11,960
You can also take into account what happens if I open a file,
你还可以考虑一下如果我打开一个文件会发生什么。

1138
01:14:11,970 --> 01:14:13,320
but the file doesn't take this.
但是文件不接受这个。

1139
01:14:13,920 --> 01:14:16,940
You can get an error file not found, or you can.
你可能会遇到文件未找到的错误。

1140
01:14:17,230 --> 01:14:22,700
I have a use another option to say if it file doesn't exist created
如果文件不存在，我可以使用另一种选项来创建它。

1141
01:14:22,710 --> 01:14:24,460
and as an amplifier.
并且作为一个放大器。

1142
01:14:25,340 --> 01:14:25,680
Right?
对吗？

1143
01:14:30,350 --> 01:14:34,030
So when you open the file, what you are,
当你打开文件时，你所做的是什么？

1144
01:14:35,160 --> 01:14:39,340
you are going to get a pointer to the file data structure.
你将获得一个指向文件数据结构的指针。

1145
01:14:40,270 --> 01:14:43,220
Also, you are going to get a pointer, right?
另外，你会得到一个指针，对吧？

1146
01:14:43,230 --> 01:14:45,540
You represent the state of the file.
你代表文件的状态。

1147
01:14:46,110 --> 01:14:50,740
Open file is represented by the pointer and it to the current byte
打开文件由指针表示，并指向当前字节。

1148
01:14:51,290 --> 01:14:56,050
in the file that you are going to read or write.
在你要读取或写入的文件中。

1149
01:15:02,860 --> 01:15:09,740
There are also several specialized files,
还有几种专门的文件类型，

1150
01:15:12,570 --> 01:15:15,830
standard being standard doubt, standard error.
标准是标准，怀疑是标准错误。

1151
01:15:16,310 --> 01:15:16,810
Okay?
好的？

1152
01:15:17,280 --> 01:15:18,350
Standard beam is,
标准梁是一种常见的结构元素，通常用于支撑和传递负载。它通常具有长方形或I形的截面，可以根据需要定制长度和尺寸。标准梁通常由钢材或木材制成，具有高强度和刚性，能够承受大量的重量和压力。它们广泛应用于建筑、桥梁、机械设备和其他工程领域。

1153
01:15:18,360 --> 01:15:19,430
obviously from input,
显然从输入中，

1154
01:15:19,440 --> 01:15:21,580
from the terminal sound out.
从终端发出声音。

1155
01:15:21,590 --> 01:15:25,910
It's also when you write out to the terminal standard error when you write
当你写入标准错误输出时，也是这样。

1156
01:15:25,920 --> 01:15:27,350
and is error.
并且是错误的。

1157
01:15:28,470 --> 01:15:29,620
And again,
再次，

1158
01:15:29,630 --> 01:15:31,460
the important point to now here,
这里需要注意的重点是，

1159
01:15:31,800 --> 01:15:37,010
it's again, is treated all this input from your keyboard output,
再次强调，所有从键盘输入的内容都会被处理并输出。

1160
01:15:37,020 --> 01:15:37,730
the terminal.
终端。

1161
01:15:38,550 --> 01:15:41,410
They are all treated as fires.
它们都被视为火灾。

1162
01:15:45,830 --> 01:15:49,430
And this standard being a standard out enable composition in unix.
这个标准使得在Unix中能够进行标准输出的组合。

1163
01:15:50,040 --> 01:15:52,120
Because everything is a file.
因为一切皆为文件。

1164
01:15:52,770 --> 01:15:55,440
Therefore, you can pipe.
因此，你可以使用管道。

1165
01:15:56,800 --> 01:15:59,440
You can create a pipeline of commands,
你可以创建一个命令的流水线。

1166
01:15:59,850 --> 01:16:00,410
because in general,
因为一般来说，

1167
01:16:00,420 --> 01:16:04,330
each command is going to read from a file and write to a file.
每个命令都会从一个文件中读取数据，并将结果写入另一个文件中。

1168
01:16:08,430 --> 01:16:12,560
For instance, here you have cat, hello text, grab word.
例如，这里有cat、hello text和grab word。

1169
01:16:13,740 --> 01:16:14,570
What does it mean?
这句话的意思是什么？

1170
01:16:14,890 --> 01:16:17,730
Cat, hello text is basically is going to,
Cat, 你好文本基本上是要去的。

1171
01:16:17,740 --> 01:16:22,780
if you just execute that is going to write on the terminal the content
如果你只是执行，它会将内容写入终端。

1172
01:16:22,790 --> 01:16:23,770
of the file,
文件的

1173
01:16:23,780 --> 01:16:27,900
hello dot x but because determine the content,
你好，由于无法确定内容，

1174
01:16:28,260 --> 01:16:33,770
what hello the standard out where the file is written,
标准输出是指文件被写入的位置。

1175
01:16:33,780 --> 01:16:35,010
it's also a file.
它也是一个文件。

1176
01:16:35,310 --> 01:16:37,520
You can pipe in the grip world,
你可以在grep命令中使用管道操作符。

1177
01:16:37,730 --> 01:16:43,480
which take as the input of a file to look for the occurrences of the world.
该程序以文件作为输入，用于查找单词的出现次数。

1178
01:16:43,990 --> 01:16:45,030
Exclamation.,
感叹词。

1179
01:16:46,350 --> 01:16:47,130
exclamation mark.
感叹号。

1180
01:16:56,670 --> 01:16:58,010
A a little bit more.
再多一点点。

1181
01:16:58,020 --> 01:16:59,610
The api is a little bit richer.
这个 API 更加丰富一些。

1182
01:16:59,620 --> 01:17:00,730
Once you open it,
一旦你打开它，

1183
01:17:01,740 --> 01:17:06,830
you can do aaa lot of things with the data in that file,
你可以对那个文件中的数据做很多事情。

1184
01:17:09,470 --> 01:17:11,570
f for c right?
是的，fahrenheit 转换为 celsius。

1185
01:17:11,950 --> 01:17:14,840
It puts a character.
它输出一个字符。

1186
01:17:14,850 --> 01:17:20,830
It's writes a character as a current location in the file.
它将一个字符写入文件的当前位置。

1187
01:17:22,800 --> 01:17:23,210
Right?
对吗？

1188
01:17:23,220 --> 01:17:26,690
Remember, this fp is returned by f open,
记住，这个fp是由fopen返回的。

1189
01:17:26,990 --> 01:17:29,280
this pointer to the file data structures.
这个指针指向文件数据结构。

1190
01:17:29,920 --> 01:17:33,400
F put s an entire string,
F put s 将整个字符串放入

1191
01:17:35,220 --> 01:17:37,530
a set of characters, which end with a zero.
一组以零结尾的字符。

1192
01:17:39,440 --> 01:17:41,460
In the file from the current position,
从当前位置开始的文件中，

1193
01:17:42,750 --> 01:17:46,680
f get c and f get s goods are reversing,
f get c 和 f get s 的货物颠倒了。

1194
01:17:46,690 --> 01:17:48,840
read from the current position in the file,
从文件的当前位置开始读取数据。

1195
01:17:48,850 --> 01:17:51,120
or read from the current position for a set,
或者从当前位置开始读取一组数据，

1196
01:17:51,540 --> 01:17:57,280
for for a given set of characters.
给定一组字符。

1197
01:17:58,870 --> 01:17:59,550
So greece,
希腊，

1198
01:17:59,560 --> 01:18:03,760
a given set of characters from the given position and put them in a string.
从给定位置开始，将给定字符集合中的字符取出并放入一个字符串中。

1199
01:18:06,930 --> 01:18:12,020
When you are going to write global to the current position,
当你要将全局变量写入当前位置时，

1200
01:18:12,400 --> 01:18:14,090
the current position is implemented.
当前位置已实现。

1201
01:18:14,540 --> 01:18:17,290
If you are going to that to call for efforts,
如果你打算这样呼吁努力的话，

1202
01:18:17,300 --> 01:18:19,970
multiple times is not going to overwrite.
多次操作不会覆盖。

1203
01:18:20,120 --> 01:18:21,590
Write in the same position.
以同样的位置写下来。

1204
01:18:21,600 --> 01:18:23,450
It writes as a subsequent position.
它作为一个后续位置进行写入。

1205
01:18:27,200 --> 01:18:32,500
This first set of ap is are character oriented.
这一组应用程序是面向字符的。

1206
01:18:32,510 --> 01:18:38,360
Then we have block oriented if you can operate on a bunch of elements.
如果您可以对一组元素进行操作，那么我们就有了块导向（block oriented）的操作。

1207
01:18:38,370 --> 01:18:42,450
This is, if you think about is very useful and you have records,
这是一个非常有用的功能，如果你考虑到它并且有记录的话。

1208
01:18:43,450 --> 01:18:45,290
your file is a bunch of records,
你的文件是一堆记录，

1209
01:18:46,070 --> 01:18:46,510
right?
对的？

1210
01:18:47,960 --> 01:18:50,670
She's like poor man database,
她就像一个贫穷的人类数据库，

1211
01:18:51,350 --> 01:18:52,260
but I do have records.
但是我确实有记录。

1212
01:18:52,890 --> 01:18:56,940
Then you want to read and write a bunch of records of the time.
然后你想要读取和写入一堆时间记录。

1213
01:18:58,830 --> 01:19:02,870
In this case, you need to give the number of the elements you want,
在这种情况下，您需要提供您想要的元素的数量。

1214
01:19:03,280 --> 01:19:05,940
the number of records you want to read, right?
你想要读取的记录数量，对吗？

1215
01:19:06,170 --> 01:19:08,180
And also the size of each record.
还有每个记录的大小。

1216
01:19:09,750 --> 01:19:17,630
And then the last A it's of AP is are format it.
然后最后一个A是AP的格式。

1217
01:19:18,190 --> 01:19:20,740
But I remember when you do a print f right?
但是我记得你是用 printf 对吧？

1218
01:19:21,240 --> 01:19:23,830
You are going to format the string,
你要对字符串进行格式化。

1219
01:19:24,370 --> 01:19:24,930
right?
对的？

1220
01:19:25,200 --> 01:19:26,100
The output string.
输出字符串。

1221
01:19:27,180 --> 01:19:29,380
And f scan f is, again,
而f扫描f是再次的。

1222
01:19:29,390 --> 01:19:32,020
it reads a formatted string.
它读取一个格式化的字符串。

1223
01:19:33,510 --> 01:19:33,910
Okay?
好的？

1224
01:19:40,530 --> 01:19:49,760
This is an example of having a character by character io this is about reading,
这是一个逐字符进行输入输出的示例，关于读取。

1225
01:19:53,800 --> 01:19:57,220
copying from an input to an output.
从输入复制到输出。

1226
01:19:57,860 --> 01:20:04,280
You get your open input and output files files.
你可以获取你的输入和输出文件。

1227
01:20:04,780 --> 01:20:07,330
Then you get one character from the input,
然后你从输入中获取一个字符，

1228
01:20:07,340 --> 01:20:10,210
and then you write the character to the output.
然后你将字符写入输出。

1229
01:20:10,970 --> 01:20:12,550
And then once you are done,
然后一旦你完成了，

1230
01:20:12,950 --> 01:20:16,190
then you close the input and the output.
然后你关闭输入和输出。

1231
01:20:18,680 --> 01:20:21,680
So that and how do you know is done?
那么，你是如何知道这件事已经完成了呢？

1232
01:20:22,710 --> 01:20:28,130
When you run, when you get to the end of the files,
当你运行时，当你到达文件的末尾时，

1233
01:20:28,880 --> 01:20:31,870
you get a year end of file eof
你遇到了文件末尾 (EOF)

1234
01:20:41,230 --> 01:20:42,350
this is an example,
这是一个例子，

1235
01:20:42,360 --> 01:20:48,670
again, to do blog blog by blog io in this case, again,
再次，在这种情况下，通过博客IO来完成博客的操作。再次。

1236
01:20:48,680 --> 01:20:51,740
you opened again to input and output.
你再次打开了输入和输出。

1237
01:20:52,190 --> 01:20:56,100
And now you are going to,
现在你要做的是，

1238
01:20:57,020 --> 01:20:57,630
right,
好的，

1239
01:20:58,210 --> 01:20:59,200
in this case,
在这种情况下，

1240
01:21:00,410 --> 01:21:02,940
you write by,
你写的是什么？

1241
01:21:03,460 --> 01:21:04,470
like, I like,
喜欢，我喜欢，

1242
01:21:04,480 --> 01:21:06,750
array of bytes or you read array of bytes.
字节数组或者你读取字节数组。

1243
01:21:07,170 --> 01:21:08,510
Do you have a buffer size?
你有缓冲区大小吗？

1244
01:21:08,900 --> 01:21:11,850
And say this is, I don't know, it's 10, 24,
这是，我不知道，是10点24分。

1245
01:21:11,860 --> 01:21:13,050
so it's one kilobyte.
所以它是一千字节。

1246
01:21:13,720 --> 01:21:16,300
You write the size of each record.
你需要写下每个记录的大小。

1247
01:21:16,310 --> 01:21:17,410
It's one character.
这是一个字符。

1248
01:21:17,970 --> 01:21:18,340
Right?
对吗？

1249
01:21:19,620 --> 01:21:22,890
Here, you are going to,
在这里，你将要

1250
01:21:26,040 --> 01:21:26,430
again,
再次，

1251
01:21:26,440 --> 01:21:31,840
to read and write from a file at the level of a brighter blog granularity,
在更高级别的粒度上从文件中读取和写入数据

1252
01:21:32,200 --> 01:21:34,460
where a blog granularity, again, a buffer granularity,
博客的粒度是指博客的大小或范围，而缓冲区的粒度是指缓冲区的大小或范围。

1253
01:21:34,470 --> 01:21:36,280
which is he had one kilobyte.
他拥有一个千字节。

1254
01:21:46,460 --> 01:21:47,010
It's again,
又是这样，

1255
01:21:48,140 --> 01:21:51,210
this is most and I'm going to end up with this.
这是最后的结果，我将以此结束。

1256
01:21:51,780 --> 01:21:56,750
This is for you to keep in mind when you are going to work on the homework,
这是你在开始做作业时需要记住的事情。

1257
01:21:56,760 --> 01:21:58,820
when you are going to work on the projects,
你打算什么时候开始做这些项目？

1258
01:21:59,350 --> 01:22:02,000
be paranoid, try to be defensive,
保持警惕，尽量采取防御措施，

1259
01:22:02,010 --> 01:22:03,280
try to think hard,
努力思考一下，

1260
01:22:03,730 --> 01:22:06,840
and try to capture every error.
并尝试捕获每个错误。

1261
01:22:07,370 --> 01:22:07,800
Right?
对吗？

1262
01:22:08,280 --> 01:22:11,340
That's why you call us function call when you call on,
这就是为什么当你调用函数时，你称之为函数调用。

1263
01:22:11,910 --> 01:22:14,420
or when you open a file and so forth.
或者当你打开一个文件等等。

1264
01:22:15,130 --> 01:22:17,300
Just check for errors.
请检查是否有错误。

1265
01:22:18,040 --> 01:22:20,040
This will save you a lot of pain,
这将为你节省很多痛苦，

1266
01:22:21,160 --> 01:22:25,720
even if you need to write a few more line of code,
即使你需要写几行额外的代码，

1267
01:22:26,050 --> 01:22:28,010
and this will also add you a better grade.
这也会给你增加更好的成绩。

1268
01:22:30,070 --> 01:22:31,620
Please check on the return values.
请检查返回值。

1269
01:22:35,930 --> 01:22:37,230
Let's stop here.
我们停在这里吧。

1270
01:22:42,270 --> 01:22:44,810
We'll just this one.
我们只需要这一个。

1271
01:22:44,820 --> 01:22:45,370
What we done,
我们所做的是什么？

1272
01:22:45,380 --> 01:22:50,360
what we learned here is we learn about the threads are the os unit
我们在这里学到的是线程是操作系统的基本单位。

1273
01:22:50,370 --> 01:22:53,140
of concurrency and abstract a
并发性和抽象化

1274
01:22:53,150 --> 01:23:00,050
virtual CPU and the threat contains all the state related to its executions.
虚拟CPU包含与其执行相关的所有状态信息。

1275
01:23:00,400 --> 01:23:04,260
And the processes contain over more threads and another space.
而进程中包含了更多的线程和另外的空间。

1276
01:23:04,760 --> 01:23:09,220
And all assets, all the threads in the same process.
所有资源，以及同一进程中的所有线程。

1277
01:23:09,590 --> 01:23:13,910
They share the same code and the same variables,
它们共享相同的代码和相同的变量。

1278
01:23:14,250 --> 01:23:16,690
global variables, all the global variables,
全局变量，所有的全局变量，

1279
01:23:18,470 --> 01:23:19,290
and the politics tidy.
并且政治整洁。

1280
01:23:19,300 --> 01:23:20,210
Everything is a file.
一切皆文件。

1281
01:23:21,630 --> 01:23:23,120
Thank you.
谢谢你。

1282
01:23:27,690 --> 01:23:28,450
Let's see.
让我们看看。

1283
01:23:33,770 --> 01:23:36,940
So I see no new questions.
所以我看到没有新的问题。

1284
01:23:36,950 --> 01:23:40,480
So with this will end up and see you all on Saturday.
所以就这样结束了，周六见。

1285
01:23:42,060 --> 01:23:42,540
Thank you.
谢谢你。

