1
00:00:09,960 --> 00:00:12,310
Welcome everyone to the second lecture.
欢迎大家来到第二次讲座。

2
00:00:14,700 --> 00:00:15,890
Today we are going to learn
今天我们要学习的内容是

3
00:00:15,900 --> 00:00:19,970
about the four fundamental oils operating system concepts.
关于四个基本的操作系统概念。

1. 进程（Process）：进程是操作系统中的一个执行实体，代表着正在运行的程序。每个进程都有自己的地址空间和资源，操作系统通过调度算法来管理和分配进程的执行时间。

2. 线程（Thread）：线程是进程中的一个执行单元，一个进程可以包含多个线程。线程共享进程的地址空间和资源，但每个线程有自己的栈空间和程序计数器。多线程可以提高程序的并发性和响应性。

3. 内存管理（Memory Management）：内存管理是操作系统负责管理和分配内存资源的机制。它包括内存分配、内存保护、内存回收和虚拟内存等功能，以确保进程能够正常运行并且不互相干扰。

4. 文件系统（File System）：文件系统是操作系统中用于管理和组织文件的机制。它提供了文件的创建、读取、写入和删除等操作，以及文件的目录结构和权限管理。文件系统使得用户可以方便地访问和管理存储在磁盘上的数据。

4
00:00:22,300 --> 00:00:27,090
As always, please ask your questions on q and a channel.
请始终在问答频道上提出您的问题。

5
00:00:28,820 --> 00:00:32,770
I will stop from time to time to read the questions and answer them.
我会不时停下来阅读问题并回答它们。

6
00:00:34,430 --> 00:00:36,500
First, let me start with some announcements.
首先，让我开始一些通知。

7
00:00:36,510 --> 00:00:42,630
So I will have for now one office hours on mondays between noon and 1:00 pm
所以我现在每周一中午12点到1点有一个办公时间。

8
00:00:42,640 --> 00:00:45,990
and there is more demand are going to add more of its hours.
并且由于需求增加，我们将增加其服务时间。

9
00:00:47,900 --> 00:00:53,750
Next monday, it's in our office towers, actually, that should be monday,
下周一，我们在办公楼里，确切地说，应该是星期一。

10
00:00:53,760 --> 00:00:54,550
not wednesday.
不是星期三。

11
00:00:55,200 --> 00:00:57,960
It don't be an office hour, memorial day,
这不是办公时间，是纪念日。

12
00:00:57,970 --> 00:00:59,100
and we'll add,
我们将添加，

13
00:00:59,110 --> 00:01:00,680
it will be office hour,
将会有办公时间。

14
00:01:00,690 --> 00:01:01,840
will be a zoom.
将会是一个Zoom会议。

15
00:01:03,000 --> 00:01:08,740
I will add the link to the zoom on the class web page.
我会在课程网页上添加 Zoom 的链接。

16
00:01:10,600 --> 00:01:14,670
Just a reminder that the drop deadline is this friday,
这是一个提醒，退课截止日期是本周五。

17
00:01:15,410 --> 00:01:16,620
early drop deadline.
提前退课截止日期。

18
00:01:17,400 --> 00:01:17,980
Please.
请。

19
00:01:21,910 --> 00:01:24,500
If you are thinking about dropping this class,
如果你正在考虑退课的话，

20
00:01:24,510 --> 00:01:25,660
do it right away,
立即去做。

21
00:01:26,310 --> 00:01:31,130
because this will let other people from the waiting list to enroll in the class.
这样可以让等候名单上的其他人报名参加课程。

22
00:01:34,360 --> 00:01:35,790
Finally, please,
最后，请

23
00:01:35,800 --> 00:01:41,340
after the drop deadline start to sign up for the groups.
在退课截止日期之后开始进行小组报名。

24
00:01:42,500 --> 00:01:43,380
Remember,
请记住，

25
00:01:46,430 --> 00:01:55,440
we ask you to have four people in a group and try that all people to attend.
我们要求每个小组有四个人，并尽量确保每个人都能参加。

26
00:01:55,450 --> 00:01:57,320
These are the same sections.
这些是相同的章节。

27
00:01:57,660 --> 00:01:58,960
This is preferable.
这是更可取的。

28
00:01:59,660 --> 00:02:01,960
Or maybe if that's not possible,
或者如果这不可能的话，

29
00:02:01,970 --> 00:02:06,220
if there are two sections taught by the same theory,
如果有两个由同一位教授教授的课程部分，

30
00:02:08,130 --> 00:02:12,660
this is in order to have consistent feedback for your projects.
这是为了给你的项目提供一致的反馈。

31
00:02:15,900 --> 00:02:17,660
During the semester.
在学期期间。

32
00:02:35,200 --> 00:02:37,790
Again, there are some quick questions on the chart.
再次，图表上有一些简短的问题。

33
00:02:39,270 --> 00:02:44,100
Please ask questions on the q and a channel, not on the chart, but now,
请在问答频道提问，而不是在图表上提问，但现在，

34
00:02:44,740 --> 00:02:47,690
one question is that can we have today's lecture slice,
一个问题是，我们可以有今天的课程片段吗？

35
00:02:47,700 --> 00:02:51,570
firstly to piazza due to website being done?
首先，关于Piazza网站完成的问题，我需要进一步了解。您是指Piazza网站正在进行维护或者出现故障吗？请提供更多细节，以便我能够帮助您。

36
00:02:51,580 --> 00:02:54,970
Well, hopefully, the website will come back up,
希望网站能够恢复正常运行。

37
00:02:54,980 --> 00:02:56,930
but yes,
但是是的，

38
00:02:56,940 --> 00:02:58,570
we can pause them on piazza.
我们可以在 Piazza 上暂停它们。

39
00:02:58,580 --> 00:03:00,990
And a second question is,
第二个问题是，

40
00:03:01,000 --> 00:03:05,450
when all the pia section preferences form would be released,
所有的 PIA（Problem and Interactive Analysis）小组选择表格将会在什么时候发布？

41
00:03:06,470 --> 00:03:10,870
not sure any da happy a rather than if you are.
如果你是快乐的话，我宁愿不确定。

42
00:03:12,310 --> 00:03:16,120
Here, please answer this question.
好的，请问有什么问题需要我回答？

43
00:03:16,130 --> 00:03:16,720
If not,
如果不是的话，

44
00:03:18,050 --> 00:03:18,680
alan,
是的，有什么我可以帮助你的吗？

45
00:03:19,790 --> 00:03:20,850
you ask this question,
你问了这个问题，

46
00:03:20,860 --> 00:03:23,490
please also proceed and get outside and we get the answer there.
请继续前进并走到室外，我们在那里得到答案。

47
00:03:35,240 --> 00:03:40,470
What do I to section by the same ta so what I mean here is that if not all people,
我是指如果不是所有的人，我应该怎么办才能将他们分成相同的组？

48
00:03:40,480 --> 00:03:41,750
if there are t as,
如果有t个as，

49
00:03:42,250 --> 00:03:45,420
that would be t as or some of the t as I have two sections.
那将是TAs或者一些TAs，因为我有两个小组。

50
00:03:47,780 --> 00:03:52,050
If not, all of you in the same group can go to the same section,
如果不是的话，你们同组的所有人可以去同一个部分。

51
00:03:52,980 --> 00:03:59,330
pick two sections which are taught by the same pa will the class
选择两个由同一位助教教授的课程部分。

52
00:03:59,340 --> 00:04:02,250
expand to get all the people on the wait list?
请扩展以获取等候名单上的所有人员。

53
00:04:03,180 --> 00:04:04,460
This class, again,
这门课，再次，

54
00:04:04,470 --> 00:04:06,180
although it's online, is limited,
虽然它是在线的，但是有限制。

55
00:04:06,190 --> 00:04:13,990
because the ta resources and the staff of the class doesn't actually have
因为助教资源和课程教职人员实际上没有

56
00:04:14,000 --> 00:04:21,910
any kind of is not the way we do not decide who is going to get
任何形式的决定权不在我们手中，我们无法决定谁会得到。

57
00:04:21,920 --> 00:04:22,870
from the wait list,
从等候名单中，

58
00:04:23,600 --> 00:04:26,230
who is going to get in at all in the class.
谁会进入这个班级呢？

59
00:04:27,220 --> 00:04:28,650
Is the department decision?
这是部门的决定吗？

60
00:04:30,230 --> 00:04:31,840
Please ask them.
请问他们。

61
00:04:32,970 --> 00:04:38,680
We can do much about it when I say I refer to the staff of the class,
当我说"我们可以做很多事情"时，我指的是班级的工作人员。

62
00:04:40,370 --> 00:04:42,530
myself and the t as and adidas.
我自己和T恤以及阿迪达斯。

63
00:04:44,340 --> 00:04:45,980
Let's move on.
我们继续吧。

64
00:04:50,880 --> 00:04:57,710
And last thing I want to say is that please avoid private piazza posts.
最后我想说的是，请避免发送私人的 Piazza 帖子。

65
00:04:58,450 --> 00:04:59,760
Because in many cases,
因为在许多情况下，

66
00:04:59,770 --> 00:05:01,920
you are not the only one to have a question,
你不是唯一一个有问题的人，

67
00:05:01,930 --> 00:05:04,800
many other people who have the or have the same questions.
许多其他人有相同的问题或疑问。

68
00:05:05,770 --> 00:05:07,360
If it's a personal questions,
如果这是一个个人问题，

69
00:05:08,890 --> 00:05:11,230
you should use a private pizza post.
你应该使用一个私人的披萨邮件。

70
00:05:11,670 --> 00:05:13,710
But otherwise, please try as much as possible,
但是其他情况下，请尽量努力。

71
00:05:13,720 --> 00:05:14,870
not to use it.
不要使用它。

72
00:05:20,110 --> 00:05:24,760
So let's go and start with the lecture.
那么让我们开始讲座吧。

73
00:05:25,760 --> 00:05:27,070
What is an operating system?
操作系统是一种软件，它管理计算机硬件和软件资源，并为用户和应用程序提供统一的接口。操作系统负责管理和分配计算机的内存、处理器、存储和输入/输出设备等资源，以便有效地运行和协调各种任务和程序。它还提供了文件系统、网络功能和安全性控制等核心服务，使计算机系统能够高效地运行和交互。

74
00:05:27,080 --> 00:05:30,630
We discussed a little bit last time during the last lecture.
上次在上课期间我们讨论了一点。

75
00:05:31,810 --> 00:05:33,680
This is one slide from the last lecture,
这是上一堂课的一张幻灯片。

76
00:05:33,690 --> 00:05:38,690
basically saying that the operating system is a software receipt
基本上是说操作系统是一个软件收据。

77
00:05:38,700 --> 00:05:40,700
between hardware and the applications.
硬件和应用程序之间的联系。

78
00:05:42,770 --> 00:05:45,970
It's implements and provides to the application.
它实现并提供给应用程序。

79
00:05:45,980 --> 00:05:50,420
A bunch of very useful functionality provides an easy,
一堆非常有用的功能提供了一种简单、

80
00:05:50,430 --> 00:05:53,410
convenient abstraction to the applications.
对应用程序来说是方便的抽象。

81
00:05:53,820 --> 00:05:59,350
So make it much easier to write the applications and using the raw hardware,
使编写应用程序和使用原始硬件变得更加容易。

82
00:06:00,200 --> 00:06:04,720
protect access of between the application and between the application
保护应用程序之间和应用程序之间的访问

83
00:06:04,730 --> 00:06:07,440
and the operating system to the sharing sources,
并将操作系统共享给其他资源。

84
00:06:08,630 --> 00:06:13,400
provide security and application and provide communication among logical entities.
提供安全性和应用程序，并在逻辑实体之间提供通信。

85
00:06:14,450 --> 00:06:16,770
And if you remember, we also have this slide,
如果你还记得的话，我们还有这张幻灯片，

86
00:06:18,040 --> 00:06:21,510
which basically says about how you can look at the operating system
这句话基本上是在说你如何看待操作系统。

87
00:06:21,520 --> 00:06:24,430
between based on the function it provides.
根据它提供的功能之间的区别。

88
00:06:25,550 --> 00:06:27,670
I wanna on a certain function it provides.
我想了解它提供的某个特定功能。

89
00:06:28,040 --> 00:06:32,340
So in one way to look at is like illusionist,
从某种角度来看，就像是魔术师一样。

90
00:06:32,910 --> 00:06:41,590
this is when the operating system magically abstract the hardware to the application.
这是操作系统将硬件神奇地抽象为应用程序的时候。

91
00:06:42,430 --> 00:06:50,190
And it provides an illusion that the application use a dedicated machine
它提供了一种假象，让应用程序感觉像在使用一台专用的机器。

92
00:06:51,350 --> 00:06:59,350
with an infinite memory and has access to all the files
具有无限内存并可以访问所有文件

93
00:07:00,980 --> 00:07:04,770
and other resources on the same dedicated machines.
以及在同一台专用机器上的其他资源。

94
00:07:05,840 --> 00:07:09,700
So that's a very convenient abstraction for the users
这对用户来说是一个非常方便的抽象化。

95
00:07:09,710 --> 00:07:11,300
and for the application developer.
还有应用程序开发者。

96
00:07:12,860 --> 00:07:14,010
In reality,
实际上，

97
00:07:14,180 --> 00:07:15,290
an application,
一个应用程序

98
00:07:15,340 --> 00:07:17,290
sorry, the system,
抱歉，系统出现了问题。

99
00:07:17,300 --> 00:07:22,710
the harder is shared between multiple applications and multiple users.
硬件是多个应用程序和多个用户之间共享的。

100
00:07:23,070 --> 00:07:24,520
So therefore,
因此，

101
00:07:24,530 --> 00:07:30,760
you need to arbitrate the access of the resources and share resources
你需要调节资源的访问并共享资源。

102
00:07:30,770 --> 00:07:32,200
between these applications.
在这些应用程序之间。

103
00:07:33,200 --> 00:07:37,750
This is when the operating system plays a role of the referee.
这是操作系统充当裁判的时候。

104
00:07:40,250 --> 00:07:44,860
So he needs to provide isolation between the processes and the applications.
因此，他需要在进程和应用程序之间提供隔离。

105
00:07:45,340 --> 00:07:51,240
And you need to protect one process from another and the operating system
你需要保护一个进程免受其他进程和操作系统的影响。

106
00:07:51,250 --> 00:07:52,020
from processes.
来自进程。

107
00:07:52,550 --> 00:07:54,360
And finally,
最后，

108
00:07:54,370 --> 00:07:59,360
this application in these processes often to implement more sophisticated functionality,
这个应用程序在这些进程中经常实现更复杂的功能。

109
00:07:59,370 --> 00:08:02,160
they need to communicate with each other.
他们需要彼此进行沟通。

110
00:08:03,350 --> 00:08:04,940
They need to share resources.
他们需要共享资源。

111
00:08:05,290 --> 00:08:12,400
And they need to use stimuli be used as same services.
他们需要使用刺激物来作为相同的服务。

112
00:08:12,410 --> 00:08:17,060
And these are all of the operating system to provide the services.
这些都是操作系统提供的服务。

113
00:08:17,070 --> 00:08:23,570
You can think about providing the glue which keep together and make
你可以考虑提供粘合剂，将它们黏在一起并形成

114
00:08:23,950 --> 00:08:26,060
this application to work together.
这个应用程序可以一起工作。

115
00:08:26,070 --> 00:08:29,240
So it provides a storage, right?
所以它提供存储功能，对吗？

116
00:08:29,730 --> 00:08:33,680
Which can be used by every application it provides within those systems.
这可以被系统中的每个应用程序使用。

117
00:08:33,990 --> 00:08:35,140
And we provide networking,
我们还提供网络服务，

118
00:08:35,150 --> 00:08:38,770
which helps the applications communicate with each other.
这有助于应用程序彼此之间的通信。

119
00:08:41,840 --> 00:08:44,680
So that's pretty much we are.
这就是我们的情况。

120
00:08:45,320 --> 00:08:47,340
And next,
接下来，

121
00:08:47,780 --> 00:08:51,010
let me just stop here to see other than any other questions.
让我在这里停一下，看看是否还有其他问题。

122
00:08:51,020 --> 00:08:52,610
No new questions.
没有新的问题。

123
00:08:57,810 --> 00:09:01,570
And let's go a little bit through the operating system history.
让我们简要回顾一下操作系统的历史。

124
00:09:01,580 --> 00:09:02,090
Again,
请再说一遍。

125
00:09:02,100 --> 00:09:07,110
the operating system abstracting away the harder and making the job
操作系统将困难的部分抽象化，简化工作。

126
00:09:07,120 --> 00:09:10,750
of the application developer easier making it much easier to develop
这使得应用开发者的工作更加简单，大大提高了开发的便利性。

127
00:09:10,760 --> 00:09:11,710
this application.
这个应用程序。

128
00:09:12,120 --> 00:09:17,530
This was from very early on since the first computers have been developed.
这是从计算机首次开发以来的早期阶段开始的。

129
00:09:18,670 --> 00:09:19,140
Okay?
好的？

130
00:09:19,640 --> 00:09:21,430
There are several distinct phases.
有几个明显的阶段。

131
00:09:22,660 --> 00:09:25,050
The first phase, which I alluded last time,
上次我提到的第一阶段

132
00:09:25,480 --> 00:09:29,050
is that when harder was very expensive and human such, it.
那是在很久以前，硬件非常昂贵而且人力资源也很紧缺。

133
00:09:29,290 --> 00:09:36,390
So this picture shows a you see a pretty large room that's the room which
这张图片显示了一个相当大的房间，这是那个房间。

134
00:09:36,400 --> 00:09:37,910
hosted the entire computer.
托管整个计算机。

135
00:09:38,210 --> 00:09:38,430
Right?
对吗？

136
00:09:38,440 --> 00:09:39,750
You need a big room,
你需要一个大房间，

137
00:09:41,080 --> 00:09:44,800
almost like a warehouse room to host the entire computer.
几乎像一个仓库房间，用来容纳整个计算机。

138
00:09:45,220 --> 00:09:45,620
Right?
对吗？

139
00:09:46,130 --> 00:09:47,950
These are extremely expensive.
这些非常昂贵。

140
00:09:47,960 --> 00:09:49,950
This very early computers,
这些非常早期的计算机，

141
00:09:49,960 --> 00:09:53,840
maybe you heard about like any arc in 50s,
也许你听说过50年代的某个弧形。

142
00:09:55,460 --> 00:09:59,270
millions or tens of millions of dollars in today's money.
数百万或数千万美元的现金价值。

143
00:10:00,810 --> 00:10:07,500
Then this was a age in which you have very expensive computers and humans
那么这是一个拥有非常昂贵的计算机和人类的时代。

144
00:10:07,510 --> 00:10:09,150
are allowed to be cheap.
可以便宜。

145
00:10:10,180 --> 00:10:11,060
Right?
对吗？

146
00:10:13,250 --> 00:10:19,880
What means that is that you want to optimize to use very efficiently as a computer.
这意味着你想要优化计算机的使用效率。

147
00:10:20,320 --> 00:10:24,270
You don't want to necessarily to optimize the time of the humans,
你并不一定要优化人类的时间

148
00:10:24,700 --> 00:10:26,020
because they are cheap, remember.
因为它们便宜，记住了。

149
00:10:26,290 --> 00:10:26,640
Right?
对吗？

150
00:10:27,140 --> 00:10:28,760
So if they need to,
如果他们需要的话，

151
00:10:29,430 --> 00:10:37,430
humans need to to spend more time to optimize their programs and to make
人类需要花更多时间来优化他们的程序和提高效率。

152
00:10:37,440 --> 00:10:41,090
the hardware usage more efficient than so be.
硬件使用更高效。

153
00:10:41,570 --> 00:10:42,600
It is perfectly fine.
没问题。

154
00:10:43,810 --> 00:10:45,090
This was, again,
这又是

155
00:10:45,100 --> 00:10:48,090
the age when thomas watson,
托马斯·沃森的年龄

156
00:10:48,100 --> 00:10:52,380
the founder and chairman of ibm in 1943,
1943年IBM的创始人和董事长

157
00:10:53,750 --> 00:10:57,950
was saying that I think there is a world market for maybe five computers.
我认为可能只有五台计算机的全球市场。

158
00:11:04,180 --> 00:11:09,240
Thomas watson also is calls award a greater salesman by the time
托马斯·沃森也被誉为当时最杰出的销售员

159
00:11:09,250 --> 00:11:10,760
of his death in 56.
他在56年去世。

160
00:11:12,250 --> 00:11:16,770
Then the next big stage is in 80s, 70s, and 80s,
接下来的一个重要阶段是在80年代和70年代。

161
00:11:16,780 --> 00:11:19,600
and is the rise of the personal computer,
个人电脑的崛起，

162
00:11:20,160 --> 00:11:20,610
right?
对的？

163
00:11:21,110 --> 00:11:22,990
In mid 70s,
在70年代中期，

164
00:11:24,540 --> 00:11:32,540
that when the first apple was released seven and I think it was 76,
第一款苹果电脑发布的时间是七十六年，我想是在1976年。

165
00:11:33,870 --> 00:11:41,780
you have ibmp cs and compatible computers being released when hardware
硬件发布时，你会有IBM PC和兼容计算机。

166
00:11:41,790 --> 00:11:44,340
was becoming cheaper and human more expensive.
变得更便宜，而人力变得更昂贵。

167
00:11:44,350 --> 00:11:48,990
Now everyone was having access wanted to a computer.
现在每个人都想要获得一台计算机。

168
00:11:49,290 --> 00:11:52,380
And you have a computer on every desk in every home.
而且在每个家庭的每张桌子上都有一台电脑。

169
00:11:52,800 --> 00:11:55,040
That was a vision of bill gates,
那是比尔·盖茨的愿景。

170
00:11:55,050 --> 00:11:58,420
a founder and of microsoft.
微软的创始人。

171
00:11:59,340 --> 00:11:59,770
Finally,
最后，

172
00:11:59,780 --> 00:12:04,490
we are today when the hardware is really cheap and humans are really expensive.
在硬件价格便宜而人力成本昂贵的今天。

173
00:12:05,250 --> 00:12:07,440
Here we are talking about,
我们现在正在讨论的是，

174
00:12:08,600 --> 00:12:13,050
you have not only about your phone or tablet of your p cs,
你不仅需要关注你的手机、平板电脑或个人电脑。

175
00:12:13,400 --> 00:12:19,600
but we are talking about more and more of devices around you.
但是我们正在谈论你周围越来越多的设备。

176
00:12:19,890 --> 00:12:22,540
They have they have processors,
他们有处理器，

177
00:12:22,550 --> 00:12:27,190
your tv your automotive,
你的电视，你的汽车，

178
00:12:27,690 --> 00:12:28,700
your car,
你的车，

179
00:12:28,980 --> 00:12:35,590
and each of these platforms and devices,
以及这些平台和设备中的每一个，

180
00:12:35,900 --> 00:12:40,670
they do have an operating system on which they will implement,
他们确实有一个操作系统，他们将在其上进行实现。

181
00:12:40,990 --> 00:12:44,180
or developers implement specialized application in the control
或者开发人员在控制中实现专门的应用程序

182
00:12:44,190 --> 00:12:47,260
of your thermal state to your tv and so forth.
将您的热状态传输到您的电视等设备上。

183
00:12:51,420 --> 00:12:55,280
The other think what happens?
另外还有什么事情发生了吗？

184
00:12:55,720 --> 00:13:01,750
And we'll see that this kind of different phases led
我们会看到这种不同的阶段导致了

185
00:13:01,760 --> 00:13:04,350
to different requirements on the operating systems.
根据操作系统的不同要求。

186
00:13:04,820 --> 00:13:07,690
The other thing it's also was driven,
另外一件事也是被驱动的。

187
00:13:07,700 --> 00:13:11,410
and also these distinct phases is by the hardware,
而且这些不同的阶段是由硬件完成的。

188
00:13:14,360 --> 00:13:17,670
becoming more and more plentiful, faster, and faster,
变得越来越丰富，越来越快速。

189
00:13:17,680 --> 00:13:18,790
and cheaper and cheaper.
越来越便宜。

190
00:13:19,830 --> 00:13:27,600
This led to from computers who are hosted in one huge room to compute a
这导致了从放置在一个巨大房间中的计算机到进行计算的计算机的转变。

191
00:13:27,610 --> 00:13:30,440
switch can be on your watch,
开关可以在你的手表上。

192
00:13:30,450 --> 00:13:30,840
right?
对的？

193
00:13:34,800 --> 00:13:38,160
And this lead,
而这导致了，

194
00:13:38,490 --> 00:13:42,320
for instance, when in the early brace of the big computer,
例如，在早期大型计算机的时候，

195
00:13:43,790 --> 00:13:46,410
the main way to use them as batch processing.
主要的使用方式是批处理。

196
00:13:47,010 --> 00:13:47,430
Right?
对吗？

197
00:13:47,870 --> 00:13:53,400
And what was bash processing means is that you put your job in a cure,
bash处理的意思是将任务放入一个队列中进行处理。

198
00:13:53,410 --> 00:13:56,840
you can actually have you went there to some punish cards,
你实际上可以将你去那里的经历写成一些惩罚卡。

199
00:13:56,950 --> 00:13:58,990
which one is your ipo program?
您的问题是关于IPO（Initial Public Offering）计划的。

200
00:13:59,410 --> 00:14:02,460
And you gives a program to the operators,
并且您向操作员提供了一个程序，

201
00:14:02,470 --> 00:14:05,510
and you come the next day to get the results.
然后你第二天回来获取结果。

202
00:14:05,520 --> 00:14:05,730
Right?
对吗？

203
00:14:05,740 --> 00:14:11,330
This is what we mean is that from time of the program or is not that important,
我们的意思是，程序的时间并不那么重要。

204
00:14:11,340 --> 00:14:12,570
then because it was cheap.
因为它便宜。

205
00:14:13,250 --> 00:14:16,740
And the computer time was very expensive.
而且计算机时间非常昂贵。

206
00:14:17,340 --> 00:14:19,370
You want to have very high utilization.
你希望实现非常高的利用率。

207
00:14:19,380 --> 00:14:23,170
And one way to have high utilization is that always you have a program to run,
而实现高利用率的一种方法是始终有一个程序在运行，

208
00:14:23,180 --> 00:14:26,260
so you have a queue of programs which are submitted,
所以你有一个程序队列，这些程序是被提交的，

209
00:14:26,490 --> 00:14:27,900
and you run it one by one,
然后你逐个运行它们。

210
00:14:27,910 --> 00:14:30,500
and then you are going to get the results and it finished.
然后你将会得到结果并且完成。

211
00:14:30,750 --> 00:14:33,220
It takes hours for everyone sometime days.
每个人都需要花费几个小时，有时甚至几天的时间。

212
00:14:34,760 --> 00:14:39,190
Then it's going to be multi programming and the multi programming beans.
那么它将是多道程序设计和多道程序设计的实例。

213
00:14:39,200 --> 00:14:43,010
Now you have they are a little bit cheaper.
现在它们便宜了一点点。

214
00:14:43,240 --> 00:14:46,550
And then you want to start to use,
然后你想要开始使用，

215
00:14:46,790 --> 00:14:49,110
there are computers in a more interactive way.
有一种更加交互式的方式来使用计算机。

216
00:14:52,410 --> 00:14:56,040
Multi programming means now that instead of one program at a time,
多道程序设计意味着现在不再是一次只能运行一个程序，

217
00:14:56,050 --> 00:14:59,040
you have multiple programs running at the same time.
你同时运行了多个程序。

218
00:14:59,050 --> 00:15:00,040
You have that one.
你明白了。

219
00:15:00,360 --> 00:15:03,880
So the time you wait for the program to finish can be reduced.
因此，你等待程序完成的时间可以缩短。

220
00:15:04,760 --> 00:15:06,190
And then it's time sharing,
然后就是时间共享。

221
00:15:06,200 --> 00:15:09,860
which now you are using the computer in a more interactive way.
现在你正在以更加互动的方式使用计算机。

222
00:15:10,200 --> 00:15:13,090
But as you have terminals which are connected with the computer,
但是由于你们有与计算机连接的终端设备，

223
00:15:13,490 --> 00:15:14,320
and in that case,
在那种情况下，

224
00:15:14,650 --> 00:15:20,290
the computer after wait after the human to type to write the program
计算机在等待人类输入并编写程序之后。

225
00:15:20,300 --> 00:15:22,210
and then to execute the program,
然后执行程序，

226
00:15:23,810 --> 00:15:25,120
you have, obviously,
显然，你拥有

227
00:15:25,130 --> 00:15:29,240
the personal computer is where you have a computer dedicated per human.
个人计算机是指每个人拥有一个专用的计算机。

228
00:15:29,680 --> 00:15:31,150
In that case,
在这种情况下，

229
00:15:31,460 --> 00:15:34,770
the computer now is either 99% of the time,
计算机现在占用了99%的时间。

230
00:15:34,780 --> 00:15:38,590
because it's waiting for you for the humans to take some action,
因为它正在等待人类采取一些行动。

231
00:15:39,480 --> 00:15:43,700
so for the computer to respond and so forth.
所以计算机能够响应等等。

232
00:15:43,710 --> 00:15:47,740
And then obiquitous devices are obviously the devices I mentioned rio,
然后，显然，普适设备就是我提到的Rio设备。

233
00:15:48,070 --> 00:15:53,400
like your thermostate and devices in your car and things like that.
比如你的恒温器、汽车上的设备等等。

234
00:15:54,770 --> 00:15:55,170
Okay?
好的？

235
00:15:59,010 --> 00:16:04,640
The operating system is a huge variety of operating systems in terms of complexity.
操作系统在复杂性方面有各种各样的类型。

236
00:16:04,940 --> 00:16:10,090
You can imagine that the operating system to control on your thermal state
你可以想象操作系统控制你的热量状态。

237
00:16:10,100 --> 00:16:12,880
is probably much simpler than operating system
可能比操作系统要简单得多

238
00:16:12,890 --> 00:16:16,030
to control super computer.
控制超级计算机。

239
00:16:18,840 --> 00:16:22,510
A small lawyers can be just have hundreds of lines of code
一个小型的律师助手程序可能只有几百行代码。

240
00:16:22,520 --> 00:16:26,080
while larger ones can have tens of million slides of code.
较大的项目可能有数百万行代码的幻灯片。

241
00:16:26,890 --> 00:16:27,910
And they are very,
而且他们非常，

242
00:16:27,920 --> 00:16:34,710
very expensive to develop because of the cost of development or is from scratch.
非常昂贵的开发，因为开发成本高或者是从零开始。

243
00:16:35,450 --> 00:16:36,800
It is very high.
这非常高。

244
00:16:36,810 --> 00:16:39,860
Actually, most modern operating system have a long lineage.
实际上，大多数现代操作系统都有悠久的血统。

245
00:16:40,290 --> 00:16:40,730
Right?
对吗？

246
00:16:41,320 --> 00:16:45,250
You can trace back the lineage long tens of years,
你可以追溯到几十年前的血统。

247
00:16:45,260 --> 00:16:46,990
the decades ago.
几十年前。

248
00:16:47,200 --> 00:16:50,150
But I saw that in linear means I was there for that.
但是我看到在线性意义上，我在那里。

249
00:16:51,350 --> 00:16:54,340
Operating system from today are some improved version
从今天开始，操作系统已经有了一些改进的版本。

250
00:16:54,350 --> 00:16:56,140
of some very old operating systems.
一些非常古老的操作系统。

251
00:16:57,870 --> 00:17:00,180
This is one lineage,
这是一个血统。

252
00:17:00,190 --> 00:17:02,020
which is mostly aa stink.
这主要是一种臭味。

253
00:17:02,030 --> 00:17:04,240
Now, this was from baltics.
现在，这是来自波罗的海地区的信息。

254
00:17:04,250 --> 00:17:10,120
It's so the one of the most the first operating system,
这是一个最早的操作系统之一。

255
00:17:10,130 --> 00:17:14,620
which was multitasking multi program and time shared.
这是一种多任务、多程序和时间共享的操作系统。

256
00:17:17,640 --> 00:17:19,040
This is an ancestor of unix,
这是Unix的祖先。

257
00:17:19,050 --> 00:17:22,120
and this is then you have adnt unease.
这是你感到不安的原因。

258
00:17:22,410 --> 00:17:32,260
Better claim is bsd unique is old critics annoy us in absd then you have actually,
更好的主张是，BSD独特性是老旧批评家们在批评我们时的一种恼人的方式，然而实际上，

259
00:17:33,180 --> 00:17:35,330
from mike, he says, michael, ken,
来自迈克的消息，他说迈克尔、肯，

260
00:17:35,340 --> 00:17:37,510
we are going to to learn a little bit about.
我们将要学习一点关于...的知识。

261
00:17:37,520 --> 00:17:41,620
It is still developed by kennedy mellon universities and ips this is
它仍然由卡内基梅隆大学和IPS开发。

262
00:17:41,630 --> 00:17:44,580
plus unix bsd you see here up.
此处展示了Unix、BSD以及其他相关内容。

263
00:17:44,710 --> 00:17:48,380
This is berkeley standard distribution is what will be as this stands for.
这是伯克利标准发行版的意思。

264
00:17:49,040 --> 00:17:53,980
Then the source used to develop next step.
接下来的步骤将使用这个源代码进行开发。

265
00:17:53,990 --> 00:17:57,220
I'm not sure how many people heard about next step.
我不确定有多少人听说了下一步的计划。

266
00:17:57,710 --> 00:18:04,170
They saw the company that steve jobs founded after.
他们看到了史蒂夫·乔布斯创立的公司之后的情况。

267
00:18:04,600 --> 00:18:11,480
He was pushed Out from apple the first time around.
他第一次被苹果公司开除了。

268
00:18:12,590 --> 00:18:17,210
And eventually next step was acquired by apple,
最终，下一步被苹果收购了。

269
00:18:17,220 --> 00:18:18,230
I think,
我认为，

270
00:18:18,240 --> 00:18:20,270
in 1997.
在1997年。

271
00:18:20,650 --> 00:18:23,650
And this is how steve jobs came back to apple.
这就是史蒂夫·乔布斯回到苹果的方式。

272
00:18:24,060 --> 00:18:29,930
And then like they say there is this history and this now is next step is
然后就像他们说的，有这个历史，现在是下一步。

273
00:18:29,940 --> 00:18:31,930
as a basis of apple or
作为苹果或

274
00:18:31,940 --> 00:18:39,840
s ten and iphone ios then is this other a lineage
这是关于S10和iPhone iOS的问题，然后又涉及到了其他的一个血统。

275
00:18:39,850 --> 00:18:41,560
from in linux?
在Linux中？

276
00:18:41,570 --> 00:18:47,470
The stars developed by andrew tannenbaum from region university
这些星星是由安德鲁·坦纳鲍姆从区域大学开发的。

277
00:18:47,480 --> 00:18:49,510
or free university in
或者免费大学在

278
00:18:50,650 --> 00:18:51,680
amsterdam.
阿姆斯特丹。

279
00:18:52,410 --> 00:18:54,160
Again, I think in 80s,
我再说一遍，我认为是在80年代。

280
00:18:54,790 --> 00:18:58,740
this is engaged and linux and android operating system,
这涉及到嵌入式操作系统 Linux 和 Android。

281
00:18:59,030 --> 00:19:01,820
and many flavor of linux fuel.
还有许多种类的Linux发行版。

282
00:19:02,970 --> 00:19:04,440
Now, and you use today.
现在，你使用今天。

283
00:19:06,140 --> 00:19:07,750
And then,
然后，

284
00:19:08,050 --> 00:19:10,270
finally, this lineage from,
最后，这个血统来自于

285
00:19:11,910 --> 00:19:17,750
again, this is operating system develop for home computer is very early on.
再次强调，这是为家用计算机开发的操作系统，非常早期的阶段。

286
00:19:17,760 --> 00:19:21,500
This is first on acpm again, in 70s,
这是ACPM再次出现的第一次，在70年代。

287
00:19:22,100 --> 00:19:25,170
this is an bolster ms does.
这是一个支持微软操作系统的助教。

288
00:19:25,180 --> 00:19:26,450
This is microsoft,
这是微软公司。

289
00:19:26,460 --> 00:19:29,520
does is a microsoft first operating system.
这是一个错误的陈述。微软的第一个操作系统是MS-DOS（Microsoft Disk Operating System），它于1981年发布。

290
00:19:30,100 --> 00:19:34,650
And the reason for why microsoft is a company which is today,
微软成为今天的公司的原因是什么？

291
00:19:36,190 --> 00:19:37,530
and then windows,
然后是Windows。

292
00:19:38,510 --> 00:19:41,200
this is a lineage,
这是一个血统，

293
00:19:41,210 --> 00:19:43,450
microsoft operating system, lineage,
微软操作系统，血统，

294
00:19:43,910 --> 00:19:47,190
ok it's again, a very few,
好的，这次又是非常少的。

295
00:19:47,760 --> 00:19:51,680
obviously, all the operating system are going to work today.
显然，所有的操作系统今天都会正常工作。

296
00:19:52,170 --> 00:20:01,540
You can track down back to probably two or three ancient operating systems.
你可以追溯到大约两到三个古老的操作系统。

297
00:20:11,640 --> 00:20:12,750
Here is a question.
这是一个问题。

298
00:20:13,280 --> 00:20:18,740
What are examples of tasks that computers will be used for in the batch scenarios?
在批处理场景中，计算机将用于以下任务的示例：

1. 数据处理：计算机可以用于处理大量数据，例如批量转换文件格式、数据清洗、数据分析等。

2. 批量作业：计算机可以执行批量作业，例如批量打印文件、批量生成报告、批量发送电子邮件等。

3. 批量计算：计算机可以用于执行大规模的计算任务，例如批量图像处理、批量模拟、批量数值计算等。

4. 批量备份和恢复：计算机可以用于批量备份和恢复数据，例如批量备份数据库、批量备份文件系统等。

5. 批量编译和构建：计算机可以用于批量编译和构建软件，例如批量编译源代码、批量构建软件包等。

6. 批量测试：计算机可以用于批量测试软件，例如批量运行测试用例、批量生成测试报告等。

这些只是一些示例，实际上，在批处理场景中，计算机可以用于执行各种类型的任务，以提高效率和自动化处理。

299
00:20:20,630 --> 00:20:22,650
So even today,
即使在今天，

300
00:20:22,660 --> 00:20:26,090
when some of the supercomputers, which are, again, very expensive,
当一些超级计算机，再次强调，非常昂贵的时候，

301
00:20:26,100 --> 00:20:27,890
today they are using the batch mode.
今天他们正在使用批处理模式。

302
00:20:28,990 --> 00:20:29,620
For instance,
例如，

303
00:20:29,630 --> 00:20:36,780
today you can submit a job which perform a very expensive simulation.
今天你可以提交一个执行非常耗费资源的模拟任务。

304
00:20:37,400 --> 00:20:37,940
Fluid dynamics.
流体力学。

305
00:20:37,950 --> 00:20:41,630
For instance, you want to simulate an airplane engine,
例如，您想模拟一个飞机发动机，

306
00:20:43,050 --> 00:20:47,660
or you can submit a batch to process some huge amount of data which
或者您可以提交一个批处理任务来处理大量的数据。

307
00:20:47,670 --> 00:20:48,620
will take hours.
需要花费几个小时。

308
00:20:49,440 --> 00:20:54,570
These are some examples of batch scenarios.
这些是一些批处理场景的示例。

309
00:21:02,730 --> 00:21:09,200
This is another figure by physically showing how in time,
这是另一个图示，通过物理展示来说明时间上的变化。

310
00:21:09,250 --> 00:21:13,730
some of the you have on the x axis is a time,
你在x轴上的一些是时间。

311
00:21:13,740 --> 00:21:15,470
and then on the y axis,
然后在y轴上，

312
00:21:15,730 --> 00:21:20,120
going from very large main frames of very large computers
从非常大的大型计算机的大型主机转变而来

313
00:21:20,130 --> 00:21:24,140
to handheld and obiquitous devices.
到手持设备和无处不在的设备。

314
00:21:24,720 --> 00:21:25,150
Right?
对吗？

315
00:21:25,590 --> 00:21:31,680
You can see here also showing you different functionality provided
这里还展示了提供的不同功能。

316
00:21:31,690 --> 00:21:33,320
by the operating systems
通过操作系统

317
00:21:33,530 --> 00:21:39,290
and the progression of the operating system here from olympics to unix.
这里讲述了操作系统从奥林匹克到Unix的发展过程。

318
00:21:43,600 --> 00:21:43,990
Okay?
好的？

319
00:21:45,040 --> 00:21:49,060
So the main thing we are going to learn in this lecture are
在这节课中，我们主要要学习的是

320
00:21:49,070 --> 00:21:52,500
these four fundamental operating system constants.
这四个操作系统的基本常数。

321
00:21:54,750 --> 00:21:57,100
We alluded to them in the last lecture,
在上一堂课中，我们提到了它们。

322
00:21:57,110 --> 00:21:59,300
but now we are going to go in more of that.
但是现在我们要更深入地讨论这个问题。

323
00:22:00,750 --> 00:22:02,160
The first one is thread.
第一个是线程。

324
00:22:03,920 --> 00:22:10,640
This provides you execution context like it fully describes a program state,
这提供了执行上下文，就像完整描述了程序状态一样。

325
00:22:10,870 --> 00:22:15,070
which means it's all the state which is needed to run the program,
这意味着它是运行程序所需的所有状态。

326
00:22:16,970 --> 00:22:18,400
then is address space.
然后是地址空间。

327
00:22:19,870 --> 00:22:26,130
The other space is the program,
另一个空间是程序空间。

328
00:22:26,220 --> 00:22:28,330
the set of others,
其他人的集合

329
00:22:29,410 --> 00:22:34,480
memory addresses within which is a program executed, right?
程序执行的内存地址范围，对吗？

330
00:22:35,200 --> 00:22:38,110
The code of the program has to be studied in memory.
程序的代码必须在内存中进行研究。

331
00:22:38,120 --> 00:22:41,070
The data of the program is going to be started in memory.
程序的数据将要被加载到内存中。

332
00:22:41,250 --> 00:22:43,170
The output has to be stored in memory,
输出必须存储在内存中。

333
00:22:44,640 --> 00:22:46,150
then is a process.
"then" 是一个进程。

334
00:22:47,390 --> 00:22:54,830
A process is basically consisting of this other space and a threat.
一个进程基本上由这个其他空间和一个线程组成。

335
00:22:55,560 --> 00:22:55,940
Right?
对吗？

336
00:22:57,030 --> 00:23:01,990
But it's consists of all the resources which are required by a program
但它包含了程序所需的所有资源

337
00:23:02,710 --> 00:23:04,110
and all the state,
以及所有的状态，

338
00:23:04,500 --> 00:23:06,710
which is required by the program to run.
这是程序运行所必需的。

339
00:23:09,450 --> 00:23:11,210
And finally, the dual mode,
最后，双模式，

340
00:23:11,220 --> 00:23:13,690
operation and protection,
操作和保护

341
00:23:14,240 --> 00:23:18,770
this is refers about how is your operating system coexist
这是关于操作系统如何共存的问题。

342
00:23:18,780 --> 00:23:22,220
on the same hardware with the processes?
在相同的硬件上运行进程吗？

343
00:23:22,530 --> 00:23:28,890
And how is the operating system protecting protective from the processes?
操作系统如何保护进程的安全性？

344
00:23:29,590 --> 00:23:31,060
Because they use their processes.
因为它们使用它们的进程。

345
00:23:31,070 --> 00:23:33,020
If there is no such protection,
如果没有这样的保护措施，

346
00:23:33,030 --> 00:23:35,500
it can change the state of the operating system.
它可以改变操作系统的状态。

347
00:23:35,640 --> 00:23:37,880
The operating system can crash,
操作系统可能会崩溃，

348
00:23:37,890 --> 00:23:39,720
so everything hurts like,
所以一切都痛得像，

349
00:23:40,250 --> 00:23:41,820
so how you are going to avoid that.
那么你打算如何避免这种情况发生呢？

350
00:23:43,930 --> 00:23:44,470
So,
所以，

351
00:23:46,120 --> 00:23:46,560
sorry,
对不起，

352
00:23:46,570 --> 00:23:51,470
so let's look a little bit about all the journey from writing the program
那么让我们稍微了解一下从编写程序开始的整个过程。

353
00:23:51,480 --> 00:23:52,590
to executing the program.
执行程序。

354
00:23:54,680 --> 00:23:55,820
You are writing the program.
你正在编写程序。

355
00:23:55,830 --> 00:24:00,940
This is you already wrote now many programs by now,
到目前为止，你已经编写了很多程序。

356
00:24:01,710 --> 00:24:02,740
you edit the program,
你编辑了程序。

357
00:24:02,750 --> 00:24:04,340
use your editor in max,
请在Max中使用您的编辑器。

358
00:24:04,350 --> 00:24:05,820
or your favorite editor,
或者你最喜欢的编辑器，

359
00:24:05,830 --> 00:24:08,480
or by charm or visual code,
或者通过魅力或视觉代码，

360
00:24:08,490 --> 00:24:09,760
or things like that.
或类似的事情。

361
00:24:10,260 --> 00:24:12,050
Then you compile is a code.
然后你编译这段代码。

362
00:24:12,650 --> 00:24:14,020
And as a code is interpreter,
作为一个代码解释器，

363
00:24:14,030 --> 00:24:16,250
interpreted like python.
解释型语言，类似于Python。

364
00:24:16,260 --> 00:24:18,420
But if you have ac code,
但是如果你有AC代码，

365
00:24:19,360 --> 00:24:22,220
you compile it and you get an executable,
你编译它，得到一个可执行文件。

366
00:24:22,820 --> 00:24:23,240
right?
对的吗？

367
00:24:24,890 --> 00:24:27,340
Which is a code, executable,
哪个是可执行的代码？

368
00:24:27,690 --> 00:24:30,230
contains a code which can be interpreted.
包含可以解释的代码。

369
00:24:30,550 --> 00:24:33,840
And it can be around by the processors understands.
并且它可以被处理器理解。

370
00:24:34,760 --> 00:24:34,990
Right?
对吗？

371
00:24:35,000 --> 00:24:41,550
And now this executable is loaded in the memory of the computer.
现在这个可执行文件已经加载到计算机的内存中了。

372
00:24:42,360 --> 00:24:43,740
And then it's executive.
然后就是执行阶段。

373
00:24:44,330 --> 00:24:47,640
But when it's loaded in memory,
但是当它加载到内存中时，

374
00:24:47,650 --> 00:24:53,150
there are several segments of the memory or several partitions of the memory,
内存中有几个段或者几个分区。

375
00:24:53,400 --> 00:24:56,310
where a different kind of data is stored,
不同类型的数据存储在哪里，

376
00:24:57,020 --> 00:25:05,250
one as each each one part is where you keep the partitions.
每个分区的一部分是用来存储分区的地方。

377
00:25:06,120 --> 00:25:06,670
You sorry,
对不起，

378
00:25:07,240 --> 00:25:10,030
where you want partition is where you keep the code,
你想要分区的地方就是你保存代码的地方。

379
00:25:10,430 --> 00:25:12,630
the instructions of the program.
程序的指令。

380
00:25:13,310 --> 00:25:16,070
Then you have where you keep the data.
那么你需要知道数据存储在哪里。

381
00:25:18,590 --> 00:25:20,380
The data you statistically defined.
你所定义的数据进行了统计。

382
00:25:20,390 --> 00:25:22,540
But I for instance, you say,
但是，例如，你说，

383
00:25:22,550 --> 00:25:28,950
and when you create of an array or variables, this is,
当你创建一个数组或变量时，这是指

384
00:25:29,450 --> 00:25:30,610
and it's static,
而且它是静态的，

385
00:25:31,500 --> 00:25:32,090
then hip.
那么嘿。

386
00:25:32,100 --> 00:25:33,890
It's where you define.
这是你定义的地方。

387
00:25:34,580 --> 00:25:37,420
You create dynamic data structures.
你创建动态数据结构。

388
00:25:37,800 --> 00:25:40,370
Like, for instance, this is when you allocate memory,
比如，这是当你分配内存时，

389
00:25:42,040 --> 00:25:44,860
when you allocate memory, this happens at the run time.
当你分配内存时，这是在运行时发生的。

390
00:25:45,180 --> 00:25:46,300
Before the program,
在程序运行之前，

391
00:25:46,310 --> 00:25:48,500
after the program starts executed.
程序开始执行后。

392
00:25:49,300 --> 00:25:53,790
Therefore, the heap is going to change during the run time,
因此，在运行时堆将发生变化。

393
00:25:53,800 --> 00:25:57,070
depending of how much dynamic memory you are allocating
根据你分配的动态内存大小而定

394
00:25:57,080 --> 00:25:58,870
for your dynamic data structures.
为了你的动态数据结构。

395
00:26:00,070 --> 00:26:02,190
Finally, you have a stack.
最后，你有一个栈。

396
00:26:02,200 --> 00:26:04,050
The stack is it's used,
栈是用来存储数据的。

397
00:26:04,060 --> 00:26:07,170
and you use, for instance,
例如，你可以使用

398
00:26:07,180 --> 00:26:12,030
to store the variables,
存储变量

399
00:26:12,040 --> 00:26:14,510
you are going to declare within a function.
你打算在一个函数内部声明。

400
00:26:14,990 --> 00:26:19,660
It's also used to store the return address when you call a function.
当你调用一个函数时，它也被用来存储返回地址。

401
00:26:20,070 --> 00:26:21,690
After the function is done,
函数执行完毕后，

402
00:26:21,950 --> 00:26:24,620
you need to know where you go back in the program.
你需要知道在程序中返回的位置。

403
00:26:25,730 --> 00:26:26,040
Again,
请再说一遍。

404
00:26:26,050 --> 00:26:33,110
we'll discuss a lot of more about each of these different types of data
我们将会更详细地讨论每种不同类型的数据。

405
00:26:33,120 --> 00:26:34,230
and memory.
和内存。

406
00:26:35,060 --> 00:26:37,820
And finally, here you have the operating system, memory,
最后，这里有操作系统和内存。

407
00:26:38,950 --> 00:26:47,380
ok so that's pretty much it.
好的，基本上就是这样。

408
00:26:47,390 --> 00:26:56,820
Let me stop and see ok no new questions, please.
让我停下来看看，好的，没有新的问题，请。

409
00:26:56,830 --> 00:26:57,260
Again.
再次。

410
00:26:57,630 --> 00:26:58,830
Keep your question coming.
请继续提出你的问题。

411
00:27:02,120 --> 00:27:02,450
Great.
太好了。

412
00:27:07,590 --> 00:27:09,060
How you execute the program?
你如何执行程序？

413
00:27:09,790 --> 00:27:14,180
If you remember, and this is from 61 c if you remember,
如果你还记得的话，这是来自61c的。如果你还记得的话，这是来自61c的。

414
00:27:14,810 --> 00:27:19,560
you basically have a bunch of instructions which are in memory,
你基本上有一堆存储在内存中的指令。

415
00:27:19,970 --> 00:27:23,930
then you have a program counter calls opc which point
那么你有一个程序计数器叫做opc，它指向一个位置。

416
00:27:23,940 --> 00:27:28,420
out to the current instruction being executed from memory.
从内存中读取当前正在执行的指令。

417
00:27:29,560 --> 00:27:34,440
So what happens when you take the instruction,
当你执行这条指令时会发生什么呢？

418
00:27:34,670 --> 00:27:37,730
which you fetch the instruction,
在这里你获取指令，

419
00:27:38,120 --> 00:27:40,730
which is pointed to by the program counter,
指向程序计数器所指向的位置，

420
00:27:41,320 --> 00:27:44,580
and then this instruction is decoded,
然后这条指令被解码，

421
00:27:45,060 --> 00:27:46,650
and then it's executed.
然后它被执行。

422
00:27:47,280 --> 00:27:49,020
This is basically down here.
这基本上就是下面的内容。

423
00:27:49,030 --> 00:27:51,950
You see the processor, right?
你能看到处理器，对吗？

424
00:27:51,960 --> 00:27:53,010
A core.
一个核心。

425
00:27:53,740 --> 00:28:00,770
And the core typically consists from an alio,
核心通常由一个alio组成。

426
00:28:01,320 --> 00:28:02,730
aromatic logic unit,
芳香逻辑单元

427
00:28:03,120 --> 00:28:06,970
which performs the operation, addition, subtraction, and things like that.
它执行加法、减法等操作。

428
00:28:07,320 --> 00:28:08,820
And a bunch of registers,
还有一堆寄存器，

429
00:28:09,070 --> 00:28:11,220
where are the arguments of these operations?
这些操作的参数在哪里？

430
00:28:11,640 --> 00:28:12,470
In many cases,
在许多情况下，

431
00:28:12,480 --> 00:28:17,710
and registers are very fast to address because they are there very low latency.
寄存器的寻址非常快速，因为它们具有非常低的延迟。

432
00:28:20,150 --> 00:28:23,780
And then while after you execute an instruction,
在执行指令后，然后

433
00:28:23,790 --> 00:28:26,300
the program counter is increment it.
程序计数器被递增。

434
00:28:26,600 --> 00:28:28,060
You are going to the next instruction.
你即将执行下一条指令。

435
00:28:30,650 --> 00:28:31,320
Very simple.
非常简单。

436
00:28:34,870 --> 00:28:39,590
This is another review here about on the right hand side,
这是另一个关于右侧的评论。

437
00:28:39,600 --> 00:28:43,350
you are going to have the memory with a bunch of instructions and a bunch
你将会有一块内存，其中包含一系列的指令和一系列的数据。

438
00:28:43,360 --> 00:28:46,100
of data on the right hand side.
右侧的数据。

439
00:28:46,330 --> 00:28:47,910
On the left hand side, sorry.
在左手边，抱歉。

440
00:28:48,470 --> 00:28:52,980
You have what is a processor which is fetching the execution,
你有一个处理器，它正在获取执行的指令。

441
00:28:53,420 --> 00:28:56,420
fetching the instruction and execute the instruction?
获取指令并执行指令

442
00:28:56,840 --> 00:28:59,700
And there you have on the left hand side,
左手边就有了，

443
00:28:59,710 --> 00:29:03,000
a bunch of registers are zero to our 71.
一堆寄存器的值都是零到71。

444
00:29:03,680 --> 00:29:07,870
And you have another set of register from f zero grab 30.
你还有另一组来自f零抓取30的寄存器。

445
00:29:08,110 --> 00:29:10,530
The difference typically between the set of registry
通常情况下，注册表集合之间的区别在于

446
00:29:10,540 --> 00:29:14,370
because of the second set of register is for floating point operations.
因为第二组寄存器是用于浮点操作的。

447
00:29:16,420 --> 00:29:20,170
The r zero to our 31 typically are for fixed point operations.
r0到r31通常用于定点操作。

448
00:29:20,180 --> 00:29:22,340
And then you have the program count.
然后你有一个叫做count的程序。

449
00:29:24,360 --> 00:29:27,650
It's, again, you face the instruction at the program counter.
你再次面对程序计数器上的指令。

450
00:29:27,660 --> 00:29:29,680
You decoded, you execute it,
你解码了，你执行它，

451
00:29:29,690 --> 00:29:31,200
possibly using the registers.
可能使用寄存器。

452
00:29:31,430 --> 00:29:34,520
Some of the argument of the instruction can be addressed in memory.
指令的一些参数可以在内存中寻址。

453
00:29:34,940 --> 00:29:38,350
And when I say results to the registers or memory,
当我说将结果存储到寄存器或内存中时，

454
00:29:38,710 --> 00:29:41,790
and then you go to the next instruction and repeat.
然后你继续执行下一条指令并重复这个过程。

455
00:29:47,090 --> 00:29:49,320
So let me see about questions.
那么让我看看问题。

456
00:29:54,860 --> 00:29:58,810
The question, is there one program counterpart thread?
问题是，是否存在一个程序对应的线程？

457
00:29:59,330 --> 00:30:04,960
The program counters is typically a registered in the car in the processor?
程序计数器通常是处理器中的一个寄存器吗？

458
00:30:05,450 --> 00:30:08,840
It's typically only one program counters may be true if you have
如果你只有一个程序计数器，通常只有一个可能是真的。

459
00:30:08,850 --> 00:30:10,000
a user program counter,
用户程序计数器

460
00:30:10,010 --> 00:30:10,880
but it's one.
但这是一个。

461
00:30:11,580 --> 00:30:12,250
What happens?
发生了什么事情？

462
00:30:12,260 --> 00:30:15,690
And we are going to see later in this lecture that when you are going to do
在本节课后我们将会看到，当你要做的时候

463
00:30:15,700 --> 00:30:16,530
context switching,
上下文切换

464
00:30:16,540 --> 00:30:20,250
what is called when you go to another to start executing a thread.
当你转到另一个线程开始执行时，这被称为线程切换。

465
00:30:20,640 --> 00:30:25,570
The first traction you do you take is to load the program counter,
你所做的第一个操作是加载程序计数器。

466
00:30:25,870 --> 00:30:29,340
which he says somewhere in memory is a current program counter
他说在内存中有一个当前的程序计数器

467
00:30:29,350 --> 00:30:34,480
of the thread corresponding to the thread into the processor program
对应于处理器程序中的线程的线程

468
00:30:34,490 --> 00:30:34,960
account.
账户。

469
00:30:36,010 --> 00:30:36,400
Right?
对吗？

470
00:30:37,410 --> 00:30:40,900
But a program counter from the processor point of view,
从处理器的角度来看，程序计数器

471
00:30:41,260 --> 00:30:42,300
it's only one.
只有一个。

472
00:30:42,310 --> 00:30:43,350
It's not perspective.
这不是透视问题。

473
00:30:48,910 --> 00:30:56,500
So let me
让我来

474
00:30:56,510 --> 00:31:01,920
just the thread of control.
线程控制。

475
00:31:01,930 --> 00:31:05,910
Again, this contains a state required to run the program.
这里再次提到了运行程序所需的状态。

476
00:31:06,580 --> 00:31:07,650
What does it mean?
这句话的意思是什么？

477
00:31:09,100 --> 00:31:10,520
Is basically,
基本上，

478
00:31:13,100 --> 00:31:14,030
it contains,
它包含，

479
00:31:16,550 --> 00:31:16,910
sorry,
抱歉，有什么我可以帮助您的吗？

480
00:31:18,550 --> 00:31:20,430
it contains a program counter,
它包含一个程序计数器，

481
00:31:20,440 --> 00:31:26,050
and then it contains also pointers to where all these other kinds
然后它还包含指向所有这些其他类型的位置的指针。

482
00:31:26,060 --> 00:31:27,890
of regions in memory start,
内存中的区域起始位置

483
00:31:28,410 --> 00:31:32,360
like, for instance, contains for the stack pointer.
比如，包含了栈指针。

484
00:31:32,860 --> 00:31:36,980
The stack pointer is basically where the stack starts from.
栈指针基本上是指示栈起始位置的指针。

485
00:31:37,500 --> 00:31:39,050
It contains a hip pointer,
这是一个髋部撞击伤。

486
00:31:39,060 --> 00:31:41,250
is the address from the world.
这个地址来自世界吗？

487
00:31:41,260 --> 00:31:43,040
The hip starts growing.
臀部开始增长。

488
00:31:46,020 --> 00:31:53,240
And it contains also what is in registers that I
它还包含了寄存器中的内容。

489
00:31:53,760 --> 00:31:57,160
because the state in the register is used by the instructions.
因为寄存器中的状态被指令使用。

490
00:32:00,150 --> 00:32:01,690
And assert is executing,
当assert语句执行时，

491
00:32:01,700 --> 00:32:03,010
like I mentioned earlier,
就像我之前提到的一样，

492
00:32:03,020 --> 00:32:05,750
when its resident on the processor,
当它驻留在处理器上时，

493
00:32:05,760 --> 00:32:10,650
when the state is the stress state is loaded in the processor.
当处理器加载应力状态时。

494
00:32:14,260 --> 00:32:15,860
Pc read this program counter,
计算机读取程序计数器。

495
00:32:16,330 --> 00:32:18,880
all the address of the greatest instruction in the thread.
线程中最大指令的所有地址。

496
00:32:19,270 --> 00:32:19,990
And again,
再一次，

497
00:32:20,230 --> 00:32:24,520
register whole sum of the root state of the threat is called the state.
将威胁的根状态的总和注册为状态。

498
00:32:27,480 --> 00:32:31,360
That's kind of the what the thread is about.
这就是这个线程的主题所在。

499
00:32:31,370 --> 00:32:36,770
So all the state which is needed to execute that program counter state
所以执行该程序所需的所有状态，包括程序计数器状态。

500
00:32:36,780 --> 00:32:37,810
of the registers,
寄存器的

501
00:32:38,530 --> 00:32:45,480
key. for stack pointers and a few others.
关键。用于堆栈指针和其他一些指针。

502
00:32:48,670 --> 00:32:57,220
Now, the address space is basically the memory addresses or the memory
现在，地址空间基本上是指内存地址或内存空间。

503
00:32:57,230 --> 00:33:05,170
regions where the data and the code of the programs
数据和程序代码所在的区域

504
00:33:05,180 --> 00:33:05,810
are stored.
被存储。

505
00:33:11,540 --> 00:33:17,040
The addresses are typically,
这些地址通常是，

506
00:33:17,050 --> 00:33:20,090
it's the size of the memory.
这是内存的大小。

507
00:33:20,100 --> 00:33:23,170
Addressable memories is very important of the size of the memory.
可寻址内存对于内存的大小非常重要。

508
00:33:23,180 --> 00:33:25,530
The man, the size of the addressable memory,
这个人，可寻址内存的大小，

509
00:33:26,670 --> 00:33:30,100
is given by the number of bits of the processor.
给定的处理器位数决定了其位数。

510
00:33:30,110 --> 00:33:30,980
Typically,
通常情况下，

511
00:33:31,590 --> 00:33:38,160
if you have a 30 bits processor that are to power 32 or 4 billion addresses,
如果你有一个30位的处理器，它可以支持32或40亿个地址，

512
00:33:39,580 --> 00:33:44,100
which means4 megabytes of memory.
这意味着4兆字节的内存。

513
00:33:45,090 --> 00:33:46,500
If it's byte addressable,
如果是字节寻址的话，

514
00:33:47,410 --> 00:33:49,860
if it's 64 bits is to power 64,
如果是64位的话，意味着它的计算能力是64的幂。

515
00:33:49,870 --> 00:33:51,610
which is a huge amount of memory.
这是一个巨大的内存量。

516
00:33:52,050 --> 00:33:52,500
Okay?
好的？

517
00:33:52,790 --> 00:33:54,100
This is addressable memory,
这是可寻址的内存。

518
00:33:54,110 --> 00:33:55,340
like we are going to see.
就像我们即将看到的那样。

519
00:33:55,350 --> 00:33:57,340
This is different from the physical memory.
这与物理内存不同。

520
00:33:58,020 --> 00:33:59,790
The physical memory can be
物理内存可以被

521
00:33:59,800 --> 00:34:04,110
smaller and typically smaller than the addressable memories.
小而通常比可寻址内存更小。

522
00:34:04,360 --> 00:34:07,310
And but then you are going to have a process.
然后你将会有一个进程。

523
00:34:07,320 --> 00:34:08,560
You are going to learn.
你将要学习。

524
00:34:08,570 --> 00:34:09,310
It's called visualization.
这被称为可视化。

525
00:34:10,530 --> 00:34:11,840
And address translation.
地址转换。

526
00:34:11,850 --> 00:34:15,080
We are going to even talk about this style, this lecture,
我们将要讨论这种风格，这个讲座。

527
00:34:15,470 --> 00:34:19,280
which is going to create you the image and the illusion that you have
这将为您创造出您拥有的形象和幻觉。

528
00:34:19,290 --> 00:34:22,960
access to the entire addressable memory in a smaller physical memory.
在较小的物理内存中访问整个可寻址内存空间。

529
00:34:28,880 --> 00:34:31,910
What happens when you read or write to an address?
当你读取或写入一个地址时会发生什么？

530
00:34:33,940 --> 00:34:37,590
Maybe nothing,
也许什么都没有。

531
00:34:38,640 --> 00:34:43,890
or you act like a a regular memory means that you read the value
或者你像一个普通的内存一样工作，意味着你读取数值。

532
00:34:43,900 --> 00:34:46,860
from that memory and you write the value to that memory.
从那个内存中读取值，并将该值写入那个内存。

533
00:34:47,890 --> 00:34:49,880
But perhaps you can ignore rights.
但也许你可以忽略权利。

534
00:34:49,890 --> 00:34:57,570
For instance, if you if you are processes writing to address,
例如，如果你的进程正在写入地址，

535
00:34:57,580 --> 00:34:59,490
it doesn't belong to that process,
它不属于该进程。

536
00:34:59,910 --> 00:35:01,590
then maybe it's going to be ignored.
那么可能会被忽略掉。

537
00:35:02,630 --> 00:35:05,500
Or maybe it causes eye operations.
或者它可能导致眼部手术。

538
00:35:06,570 --> 00:35:12,940
As you'll see that other memory mapped input output
正如你所看到的，其他的内存映射输入输出

539
00:35:14,320 --> 00:35:17,350
designs and architectures in which,
设计和架构中，

540
00:35:17,360 --> 00:35:21,190
for instance, if you want to communicate to a device like a keyboard,
例如，如果您想与键盘这样的设备进行通信，

541
00:35:21,200 --> 00:35:24,390
you want to read from a keyboard or you want to communicate with a printer.
你想从键盘上读取输入还是与打印机进行通信？

542
00:35:24,830 --> 00:35:27,150
There are certain defined,
有一些明确定义的，

543
00:35:27,420 --> 00:35:30,780
pre defined memory addresses where you have to write.
预定义的内存地址，您需要在其中写入数据。

544
00:35:31,160 --> 00:35:34,470
For instance, it's a pretty fine memory address you read from.
例如，你从一个非常好的内存地址中读取。

545
00:35:34,480 --> 00:35:37,710
And that's what you are going to get the input from the keyboard,
这是你将从键盘获取输入的方式，

546
00:35:38,270 --> 00:35:43,180
or is another pretty defined memory address or a range of addresses
或者是另一个明确定义的内存地址，或者是一段地址范围。

547
00:35:43,190 --> 00:35:44,900
where you can write.
你可以在哪里写作？

548
00:35:44,910 --> 00:35:47,430
And that data is going to the reader.
这些数据将被发送给读取器。

549
00:35:49,660 --> 00:35:52,600
Or perhaps it causes an exception,
或者它引发了一个异常。

550
00:35:52,910 --> 00:35:55,660
like an example I gave to you earlier on.
就像我之前给你的一个例子一样。

551
00:35:55,670 --> 00:36:01,550
And you are going to write to a data to address which he doesn't belong to you,
而且你要将数据写入一个不属于你的地址。

552
00:36:01,770 --> 00:36:05,390
or say, to the address of an own owned by the operating system.
或者说，发送到操作系统拥有的地址。

553
00:36:07,050 --> 00:36:07,970
It can be ignored.
可以忽略。

554
00:36:07,980 --> 00:36:10,450
But in many cases, you get a segmentation fault.
但在许多情况下，你会遇到段错误。

555
00:36:10,460 --> 00:36:12,050
You cannot cause the exception.
你无法引发异常。

556
00:36:14,520 --> 00:36:20,500
One exception, the offending program is going to basically stop crashed.
有一个异常，有问题的程序基本上会停止崩溃。

557
00:36:26,050 --> 00:36:28,240
Again, you have a bunch of region or segment.
再次，你有一堆区域或段落。

558
00:36:28,890 --> 00:36:30,180
You have the code segment.
你有代码段。

559
00:36:31,140 --> 00:36:35,730
The score segment that already pro mentioned to you contains
我之前提到的分数段已经包含了

560
00:36:35,740 --> 00:36:37,290
the instruction of the program.
程序的指令。

561
00:36:38,170 --> 00:36:40,000
You have the stack segment.
你有栈段。

562
00:36:40,490 --> 00:36:42,720
I told you what,
我告诉你什么了。

563
00:36:42,770 --> 00:36:45,320
again, earlier, what it contains, it contain.
再次，之前，它包含什么，它包含。

564
00:36:45,330 --> 00:36:50,190
It can contains The variable you are going to declare within a function.
它可以包含你在函数内要声明的变量。

565
00:36:50,500 --> 00:36:53,920
And also the return addresses from a function.
还有来自函数的返回地址。

566
00:36:55,260 --> 00:37:00,670
And the stack grows from high to low to grow,
栈从高地址向低地址增长，

567
00:37:00,680 --> 00:37:01,910
so to speak downwards.
所谓向下说。

568
00:37:04,370 --> 00:37:05,640
Because you add,
因为你添加了

569
00:37:05,940 --> 00:37:06,940
when you call a function,
当你调用一个函数时，

570
00:37:06,950 --> 00:37:08,220
you are sinks on the stack.
你是栈上的栈帧。

571
00:37:10,660 --> 00:37:12,170
Then you have the heap,
然后你有堆(heap)，

572
00:37:12,180 --> 00:37:16,810
which is for dynamic data when you allocate data during the program execution,
当您在程序执行期间分配数据时，使用动态数据。

573
00:37:17,180 --> 00:37:21,350
and you're growing from low level of low addresses to high addresses.
你的地址从低地址逐渐增长到高地址。

574
00:37:24,220 --> 00:37:26,310
So let's see,
那么让我们来看一下，

575
00:37:26,320 --> 00:37:27,870
there are some questions here.
这里有一些问题。

576
00:37:31,290 --> 00:37:38,860
Where does os save all the state and registered values when changing as task?
当切换任务时，操作系统将所有状态和注册值保存在哪里？

577
00:37:39,940 --> 00:37:41,580
It's a thread control block,
这是一个线程控制块。

578
00:37:41,590 --> 00:37:46,110
pcb this is where it said it starts.
PCB（进程控制块）是进程开始的地方。

579
00:37:47,260 --> 00:37:53,840
You have a data structure which associated on issue with each thread,
你有一个数据结构，将每个线程与一个问题关联起来。

580
00:37:54,270 --> 00:37:56,500
which is managed by the operating system.
由操作系统管理。

581
00:37:56,730 --> 00:38:01,450
And in that block or region,
在那个块或区域中，

582
00:38:01,810 --> 00:38:04,680
you save all the state associated with a thread.
你保存与线程相关的所有状态。

583
00:38:06,710 --> 00:38:09,460
When we say that the process has a virtual address space,
当我们说进程具有虚拟地址空间时，

584
00:38:09,470 --> 00:38:14,600
zero to ff it doesn't imply that it has free reign to write with our services.
从零到FF，并不意味着它可以自由地使用我们的服务进行写作。

585
00:38:14,610 --> 00:38:14,930
Absolutely.
当然可以。

586
00:38:20,330 --> 00:38:23,160
Let me there are two views of the memory.
让我来介绍一下内存的两种视角。

587
00:38:23,170 --> 00:38:25,260
And again, this is very important to,
而且，这也非常重要，

588
00:38:26,670 --> 00:38:27,900
and this is about arbitralization.
这是关于仲裁化的内容。

589
00:38:28,650 --> 00:38:30,690
It's about creating the illusion.
这是关于创造幻觉的问题。

590
00:38:31,140 --> 00:38:33,240
It's a memory, it's a physical memory,
这是一块内存，是一块物理内存。

591
00:38:33,250 --> 00:38:38,170
and the physical memory is partitioned between different processes.
物理内存被划分给不同的进程。

592
00:38:40,270 --> 00:38:44,230
Now, there is also what the illusion, actually,
现在，还有一个幻觉，实际上，

593
00:38:44,240 --> 00:38:45,270
of the process.
进程的状态。

594
00:38:45,880 --> 00:38:50,610
The illusion of the process is that he has an address from 00 to ff he has
进程的幻觉是它拥有从00到ff的地址。

595
00:38:50,620 --> 00:38:52,050
an entire outer space.
整个外太空。

596
00:38:53,260 --> 00:38:58,560
And the application, in principle,
原则上，应用程序

597
00:38:58,570 --> 00:39:02,550
can can write at any of these addresses.
可以在任何这些地址上写入。

598
00:39:04,390 --> 00:39:04,870
Okay?
好的？

599
00:39:07,440 --> 00:39:08,350
Typically,
通常情况下，

600
00:39:08,360 --> 00:39:14,360
the operating system takes care for cells so that the application does
操作系统负责管理单元，以便应用程序可以正常运行。

601
00:39:14,370 --> 00:39:16,010
a shoot in its foot.
自己给自己脚打了一枪。

602
00:39:16,310 --> 00:39:16,670
Right?
对吗？

603
00:39:17,130 --> 00:39:20,880
For instance, you cannot right on the stack,
例如，你不能在栈上写入数据。

604
00:39:20,890 --> 00:39:23,520
because if you can't write on the stack, the program will crash.
因为如果你不能在栈上写入数据，程序就会崩溃。

605
00:39:24,130 --> 00:39:24,580
Right?
对吗？

606
00:39:25,140 --> 00:39:28,630
The operating system will put the only post some restrictions.
操作系统将会对唯一的帖子施加一些限制。

607
00:39:29,340 --> 00:39:31,990
So you don't have a free ray.
所以你没有空闲的光线。

608
00:39:32,310 --> 00:39:33,980
You do see the entire other space.
你确实可以看到整个其他空间。

609
00:39:33,990 --> 00:39:34,240
Again.
再次。

610
00:39:34,250 --> 00:39:35,540
You don't have free rain,
你没有完全自由的决定权，

611
00:39:35,840 --> 00:39:39,150
but I just come to and to plant the seed.
但我只是来播种和种下种子的。

612
00:39:39,160 --> 00:39:39,870
Now.
现在。

613
00:39:40,340 --> 00:39:43,290
We are going to do this to say this over and over,
我们将一遍又一遍地重复这个过程。

614
00:39:43,300 --> 00:39:45,290
because there are two views of a memory.
因为内存有两个视角。

615
00:39:45,300 --> 00:39:46,930
You have physical memory,
你有物理内存。

616
00:39:47,210 --> 00:39:50,300
which is partitioned between different applications.
这是在不同应用程序之间进行分区的。

617
00:39:50,310 --> 00:39:53,100
They have data code from different applications.
他们有来自不同应用程序的数据代码。

618
00:39:53,480 --> 00:39:55,990
Residing is a physical memory at the same time.
"Residing" 在这里指的是数据或程序在物理内存中的存储位置。

619
00:39:56,250 --> 00:39:58,050
And then you have the virtual memory,
然后你有虚拟内存，

620
00:39:58,280 --> 00:40:03,040
which is basically what is presented to the application.
这基本上是向应用程序呈现的内容。

621
00:40:03,050 --> 00:40:06,800
And there you create the illusion that each application is process,
这样你就创造了每个应用程序都是一个进程的错觉。

622
00:40:07,030 --> 00:40:09,890
has access to the full address space with some constraints,
具有对完整地址空间的访问权限，但受到一些限制。

623
00:40:09,900 --> 00:40:10,790
like I explained.
就像我解释的那样。

624
00:40:20,070 --> 00:40:25,310
So so here is exactly what I mentioned earlier about the physical memory.
所以这就是我之前提到的关于物理内存的具体内容。

625
00:40:25,860 --> 00:40:27,400
You see, on the right hand side,
你看，右边的

626
00:40:27,410 --> 00:40:29,700
you have the physical memory in the physical memory.
你在物理内存中拥有物理内存。

627
00:40:29,710 --> 00:40:30,620
As you can see.
正如你所看到的。

628
00:40:31,360 --> 00:40:33,670
You have, on the left hand side,
您在左侧手边有

629
00:40:33,680 --> 00:40:37,030
you have the operating system with and processes, right?
你有操作系统和进程，对吗？

630
00:40:37,320 --> 00:40:39,480
Green, yellow, orange.
绿色，黄色，橙色。

631
00:40:39,980 --> 00:40:41,240
Now, in the physical memory,
现在，在物理内存中，

632
00:40:41,250 --> 00:40:45,540
you can see that you have instructions,
你可以看到你有一些指示。

633
00:40:45,550 --> 00:40:48,370
a code and data from different processes.
来自不同进程的代码和数据。

634
00:40:48,380 --> 00:40:53,080
And they are all is riding in the same physical memory.
而且它们都在同一块物理内存中运行。

635
00:40:54,990 --> 00:40:58,880
Each of this processing is only going to see only its own data.
每个处理过程只能看到自己的数据。

636
00:40:59,170 --> 00:41:02,760
They shouldn't see the other as a process data.
他们不应该将对方视为进程数据。

637
00:41:06,970 --> 00:41:07,080
Now,
现在，

638
00:41:07,090 --> 00:41:10,600
what is the multi programming about multi programming about is about having
多道程序设计是指同时在计算机中运行多个程序的技术。

639
00:41:10,610 --> 00:41:11,880
different processes?
不同的进程？

640
00:41:12,160 --> 00:41:14,330
Like ii said earlier,
就像我之前说的一样，

641
00:41:14,340 --> 00:41:15,450
I said about jobs,
我说的是关于工作的事情，

642
00:41:15,460 --> 00:41:17,930
but the process with the process is the same thing.
但是"process"和"进程"是同一个意思。

643
00:41:18,190 --> 00:41:22,420
They have different processes running and share running at the same time
它们有不同的进程在运行，并且同时共享运行。

644
00:41:22,430 --> 00:41:24,700
on the same on a single machine.
在同一台机器上。

645
00:41:25,220 --> 00:41:25,670
Right?
对吗？

646
00:41:26,070 --> 00:41:27,740
Now, how do you give the illusion?
现在，你如何制造幻觉？

647
00:41:27,750 --> 00:41:27,940
Right?
对吗？

648
00:41:27,950 --> 00:41:31,380
Because so breaking system provides the illusions that despite you have
因为破坏系统提供了一种错觉，即尽管你有

649
00:41:31,390 --> 00:41:36,060
different processes running at the same time on the same harbor,
在同一个港口上同时运行不同的进程

650
00:41:36,070 --> 00:41:39,340
each process believes that it is allowed.
每个进程都认为自己被允许。

651
00:41:39,970 --> 00:41:40,380
Right?
对吗？

652
00:41:42,870 --> 00:41:45,090
The only way you can give that you have to share,
你能提供的唯一方式就是分享。

653
00:41:45,100 --> 00:41:46,730
you have to multiplex resources.
你需要对资源进行复用。

654
00:41:47,280 --> 00:41:48,730
And there are multiple resources.
还有多个资源。

655
00:41:48,740 --> 00:41:51,700
One is the cpu right?
是的，CPU（中央处理器）是计算机的核心组件之一。它负责执行计算机程序中的指令，并处理数据。

656
00:41:52,140 --> 00:41:55,190
And if you have a single processor,
如果你只有一个处理器，

657
00:41:55,200 --> 00:41:59,390
how do you provide illusion of having multiple processors one for each processor?
如何提供每个处理器都有一个处理器的错觉？

为了提供每个处理器都有一个处理器的错觉，操作系统使用了一种称为多线程的技术。多线程允许在同一时间内执行多个线程，每个线程都可以被视为一个独立的处理器。通过在不同的线程之间快速切换，操作系统可以使多个任务同时运行，从而给用户一种同时执行多个任务的感觉。

此外，操作系统还使用了一种称为时间片轮转的调度算法。该算法将处理器的时间划分为小的时间片段，并按照一定的顺序分配给不同的线程。每个线程在一个时间片段内运行一段时间，然后被暂停，切换到下一个线程。这种快速的切换使得每个线程都能够获得处理器的时间，并给用户一种同时运行的感觉。

通过这些技术，操作系统能够提供给用户一个每个处理器都有一个处理器的错觉，从而提高系统的并发性和响应性。

658
00:41:59,970 --> 00:42:02,210
As we discussed last time,
正如我们上次讨论的那样，

659
00:42:02,450 --> 00:42:05,270
you split the processors in tank quanta.
你将处理器分割成坦克量子。

660
00:42:05,670 --> 00:42:07,460
You give it all time slices,
你给它所有的时间片，

661
00:42:07,790 --> 00:42:11,470
and you give a time count or a time slice to a different process.
你给不同的进程分配时间片或时间片段。

662
00:42:12,010 --> 00:42:12,440
Right?
对吗？

663
00:42:13,070 --> 00:42:14,660
Say it's 10 million seconds.
说是一千万秒。

664
00:42:15,020 --> 00:42:16,740
The time size is 10 million seconds.
时间大小为1000万秒。

665
00:42:17,090 --> 00:42:18,130
For 10 million seconds,
10百万秒的时间内，

666
00:42:18,140 --> 00:42:19,770
you around process one,
你在处理进程一,

667
00:42:19,780 --> 00:42:23,240
then we switch to for the next 10 million seconds to process two,
然后我们切换到处理两个任务的模式，持续10百万秒。

668
00:42:23,250 --> 00:42:25,920
for the next10 million seconds to process three,
为了处理三个任务的下一个1000万秒，

669
00:42:25,930 --> 00:42:27,240
and then come back to process on.
然后继续进行处理。

670
00:42:28,130 --> 00:42:29,080
This is one way to do it.
这是一种方法来做到这一点。

671
00:42:29,750 --> 00:42:30,880
So multiplex it in time.
所以在时间上进行复用。

672
00:42:32,600 --> 00:42:39,540
And each this kind of ritual cp us needs to hold this program counter,
每个这种仪式都需要我们保存程序计数器。

673
00:42:39,980 --> 00:42:42,280
start pointer registers and things like that.
起始指针寄存器和类似的东西。

674
00:42:42,550 --> 00:42:45,020
So this is a state was associated with the thread,
这是与线程关联的状态。

675
00:42:45,640 --> 00:42:48,660
because when you run something on a problem,
因为当你在解决一个问题时运行某个东西时，

676
00:42:48,670 --> 00:42:50,900
this visual cp us is a threat.
这个可视化的控制面板是一个威胁。

677
00:42:51,570 --> 00:42:52,030
Right?
对吗？

678
00:42:53,160 --> 00:42:53,440
Obviously,
显然，

679
00:42:53,450 --> 00:42:57,790
the question now is about how you switch from a virtual security the next time.
现在的问题是关于如何在下一次切换到虚拟安全模式。

680
00:42:58,020 --> 00:42:58,410
Right?
对吗？

681
00:42:58,640 --> 00:42:59,670
This is what you do, right?
是的，这是我要做的，对吗？

682
00:42:59,680 --> 00:43:03,790
You use you you save the state of the virtual cp us.
你使用虚拟CPU时保存其状态。

683
00:43:03,800 --> 00:43:08,490
And here on the state of the virtual cpu is the same as a state
在虚拟 CPU 的状态上，与实际状态相同。

684
00:43:08,500 --> 00:43:11,360
of the thread running on that virtual cpu right?
是的，指的是在该虚拟CPU上运行的线程。

685
00:43:11,370 --> 00:43:12,880
In that time sliced.
在那个时间片中。

686
00:43:13,160 --> 00:43:15,670
And you allowed the state for the next mutual secure,
并且您允许了下一个互相安全的状态。

687
00:43:15,680 --> 00:43:17,830
the next thread you are going to execute.
你即将执行的下一个线程。

688
00:43:19,250 --> 00:43:20,730
And then you execute,
然后你执行，

689
00:43:21,200 --> 00:43:23,500
you run the next thread.
你运行下一个线程。

690
00:43:25,650 --> 00:43:28,960
So it's, again, I just wanted to make sure here it seems i'm not confusing.
所以，再次强调一下，我只是想确保我没有搞混。

691
00:43:28,970 --> 00:43:30,600
You have only once if you,
如果你只有一次机会，

692
00:43:30,980 --> 00:43:32,090
in this particular case,
在这种特殊情况下，

693
00:43:32,100 --> 00:43:33,770
and you want to multiplex it,
并且你想进行多路复用。

694
00:43:33,780 --> 00:43:36,290
so you are going to multiplex it in time.
所以你打算在时间上进行复用。

695
00:43:36,610 --> 00:43:45,780
And that for each process is provided with an illusion that it owns a processor,
并且每个进程都被赋予了拥有处理器的错觉，

696
00:43:45,790 --> 00:43:47,260
albeit a slower processor.
尽管处理器速度较慢。

697
00:43:47,770 --> 00:43:48,120
Right?
对吗？

698
00:43:48,540 --> 00:43:50,590
And by the virtual cpu hearing,
通过虚拟CPU听取，

699
00:43:50,600 --> 00:43:56,790
means that part time partition,
意味着兼职分区。

700
00:43:56,800 --> 00:44:02,560
part of the cpu which is kind of on a by a particular process.
CPU的一部分，它被一个特定的进程所占用。

701
00:44:04,100 --> 00:44:04,380
Right?
对吗？

702
00:44:04,880 --> 00:44:07,820
And when you from the process,
当你从进程中退出时，

703
00:44:07,830 --> 00:44:09,890
when you have each process,
当你有每个进程时，

704
00:44:09,900 --> 00:44:10,940
if you remember,
如果你记得的话，

705
00:44:10,950 --> 00:44:11,990
has a thread,
有一个线程

706
00:44:12,280 --> 00:44:14,040
and again,
再次，

707
00:44:14,050 --> 00:44:15,940
we repeat that soon,
我们重申很快会完成。

708
00:44:15,950 --> 00:44:23,230
and that thread is a part which is running on the process processor
这个线程是运行在进程处理器上的一部分。

709
00:44:23,240 --> 00:44:24,390
or the visual studio.
或者使用Visual Studio。

710
00:44:27,430 --> 00:44:34,020
Let me you said a program can write on the stack,
你说一个程序可以在栈上写入数据。

711
00:44:34,030 --> 00:44:35,780
but when you write assembly,
但是当你编写汇编语言时，

712
00:44:35,790 --> 00:44:38,340
we often move the stack pointer and write.
我们经常移动栈指针并进行写操作。

713
00:44:44,030 --> 00:44:44,510
Yes.
是的。

714
00:44:45,160 --> 00:44:45,980
That's true.
没错。

715
00:44:47,680 --> 00:44:49,510
When basically,
基本上，

716
00:44:49,520 --> 00:44:51,270
you said the program can write on the stack,
你说这个程序可以在栈上写入数据。

717
00:44:51,280 --> 00:44:52,510
but when you write assembly,
但是当你编写汇编语言时，

718
00:44:52,520 --> 00:44:55,470
you often move the stack pointer and write to the stack.
你经常移动栈指针并向栈中写入数据。

719
00:44:56,460 --> 00:44:58,450
You are a bit confused.
你有点困惑了。

720
00:44:58,460 --> 00:45:02,250
So when you write an assembly,
当你编写汇编语言时，

721
00:45:02,620 --> 00:45:06,890
you don't go through the compiler so that you don't have anyone to put
你不需要经过编译器，因此没有人可以帮你放置。

722
00:45:07,460 --> 00:45:10,040
any kind of constraints of what you are going to do.
你所要做的事情是否有任何限制？

723
00:45:10,050 --> 00:45:15,520
So you can indeed do almost everything you also need to.
所以你确实可以做几乎所有你需要做的事情。

724
00:45:17,080 --> 00:45:18,270
So you need to do that.
所以你需要这样做。

725
00:45:18,280 --> 00:45:23,150
But when you write a typical program like in high level languages,
但是当你编写一个典型的高级语言程序时，

726
00:45:23,500 --> 00:45:24,330
you compile it.
你编译它。

727
00:45:24,340 --> 00:45:27,530
And the compiler is going to put additional constraints about what you
而编译器将对你的代码施加额外的约束条件，限制你可以做什么。

728
00:45:27,540 --> 00:45:32,540
can do with the program now that the cpu is time partition.
现在CPU进行了时间分片，你可以使用程序做什么。

729
00:45:32,900 --> 00:45:34,280
Now, in general,
现在，总的来说，

730
00:45:37,000 --> 00:45:37,670
no,
不需要。

731
00:45:38,290 --> 00:45:41,210
what is exactly slower when in reality, it is multiplex.
在现实中，当存在多路复用时，什么会变得更慢？

732
00:45:42,200 --> 00:45:45,490
What I mean slower is by when I slower,
我指的是当我减慢速度时，

733
00:45:45,880 --> 00:45:50,940
I imagine that you have acpu and it's,
我想象你有一个CPU，并且它是...

734
00:45:52,320 --> 00:45:59,010
and if the cpu is partitioned between two processes,
如果CPU被分配给两个进程，

735
00:45:59,270 --> 00:46:00,340
then each process,
然后每个进程，

736
00:46:00,350 --> 00:46:01,740
and if each process will,
如果每个进程都会，

737
00:46:01,750 --> 00:46:05,340
alternatively use a 10 millisecond run for 10 millisecond.
或者使用10毫秒的运行时间进行10毫秒的操作。

738
00:46:05,960 --> 00:46:09,280
This means that each process will see a processor,
这意味着每个进程都会看到一个处理器。

739
00:46:09,610 --> 00:46:14,480
which is half the speed of the original processor.
这是原处理器速度的一半。

740
00:46:15,470 --> 00:46:15,710
Right?
对吗？

741
00:46:16,810 --> 00:46:18,790
Because, for instance, out of one,
因为，例如，从一个中，

742
00:46:19,690 --> 00:46:24,770
second, each process will use acpu only for 500 meters ago.
其次，每个进程只能使用CPU 500个时钟周期。

743
00:46:27,710 --> 00:46:35,090
So it's half cost so half slow as slow as the real cpu
所以它的成本只有一半，所以速度只有真实CPU的一半那么慢。

744
00:46:39,400 --> 00:46:42,430
what is done differently for context switching between threads
在线程之间进行上下文切换时有哪些不同之处？

745
00:46:42,440 --> 00:46:45,230
of the same process versus different processes?
相同进程与不同进程之间的区别是什么？

746
00:46:47,760 --> 00:46:49,710
Again, this is probably too early.
再次强调，现在可能还为时过早。

747
00:46:51,940 --> 00:46:52,690
We learn a lot.
我们学到了很多。

748
00:46:52,700 --> 00:46:58,670
But so in short,
总之，

749
00:46:58,680 --> 00:47:03,040
the answer here is that when you change,
这里的答案是，当你改变时，

750
00:47:03,050 --> 00:47:06,340
when you switch content to contact switching between the thread,
当你切换内容以在线程之间进行上下文切换时，

751
00:47:06,350 --> 00:47:09,230
you only need to switch.
你只需要切换。

752
00:47:09,580 --> 00:47:11,820
A context switch is a state of the thread,
上下文切换是线程的一种状态，

753
00:47:12,260 --> 00:47:13,830
which is a bunch of registers.
这是一组寄存器。

754
00:47:15,040 --> 00:47:16,790
And pointers is very light.
而指针非常轻量级。

755
00:47:18,050 --> 00:47:23,230
When you are going to switch between different processes,
当你要在不同的进程之间切换时，

756
00:47:23,760 --> 00:47:29,310
you need also to switch the state about all the resources, for instance,
你还需要切换所有资源的状态，例如，

757
00:47:29,680 --> 00:47:30,390
memories.
回忆。

758
00:47:30,400 --> 00:47:34,080
There is aa memory table to ensure the translation
有一个内存表来确保翻译

759
00:47:34,090 --> 00:47:37,410
between this virtual address space and physical address space.
虚拟地址空间和物理地址空间之间的区别。

760
00:47:39,460 --> 00:47:41,480
There is a file descriptors.
这是一个文件描述符。

761
00:47:42,730 --> 00:47:48,280
So it's a lot of more state you need to to switch on your switch between processors,
因此，在处理器之间切换时，您需要更多的状态来切换开关。

762
00:47:49,350 --> 00:47:50,380
between processes.
进程之间的通信。

763
00:47:52,800 --> 00:47:55,100
Where are these state blocks start?
这些状态块从哪里开始？

764
00:47:55,110 --> 00:47:56,390
So strapped block,
所谓的"strapped block"，

765
00:47:59,620 --> 00:48:01,380
slight strap control blocks,
轻微的带控制块

766
00:48:01,390 --> 00:48:07,020
or all this state is stored in the operating system by the operating system
或者所有这些状态都由操作系统存储在操作系统中

767
00:48:07,840 --> 00:48:09,280
and managed by the operating system.
由操作系统管理。

768
00:48:10,100 --> 00:48:14,210
Isn't there overhead with switching from on virtual cpu to another?
从一个虚拟CPU切换到另一个虚拟CPU会有开销吗？

769
00:48:15,030 --> 00:48:15,640
Yes.
是的。

770
00:48:17,400 --> 00:48:18,060
Absolutely.
当然可以。

771
00:48:18,330 --> 00:48:23,520
There is an overhead one switching from one village choice abuse to another,
从一个村庄选择滥用转向另一个村庄会有一定的开销。

772
00:48:23,970 --> 00:48:31,760
because we need to save on low states like the person who asked the
因为我们需要节省资源，就像提问的人一样。

773
00:48:31,770 --> 00:48:35,220
question correctly identified.
问题正确识别。

774
00:48:35,700 --> 00:48:39,900
And is it just a necessary inefficiency we accept in order to multiplex?
这只是我们为了多路复用而接受的必要的低效吗？

775
00:48:39,910 --> 00:48:40,380
Yes.
是的。

776
00:48:41,390 --> 00:48:41,790
It is.
是的。

777
00:48:42,560 --> 00:48:44,840
How about those programs that are time sensitive?
那些对时间敏感的程序怎么样？

778
00:48:51,050 --> 00:48:53,610
When the programs are time sensitive?
当程序对时间敏感时？

779
00:48:54,340 --> 00:48:55,370
Typically,
通常情况下，

780
00:48:56,360 --> 00:48:59,650
you may have an operating system which has real time support
你可能拥有一个具有实时支持的操作系统。

781
00:48:59,980 --> 00:49:02,110
in these operating systems.
在这些操作系统中。

782
00:49:02,520 --> 00:49:08,290
You can specify by when a particular task should be executed,
您可以指定特定任务应该在何时执行，

783
00:49:08,300 --> 00:49:12,650
and they are going to ensure that task will be executed by that time.
他们将确保任务在那个时间之前被执行。

784
00:49:13,050 --> 00:49:16,660
Or you can other ways you can specify.
或者你可以指定其他的方式。

785
00:49:18,420 --> 00:49:22,050
And the operating similar guarantee that you are going to get
并且操作类似的保证是您将获得的。

786
00:49:22,400 --> 00:49:26,270
a minimum share of the cpu if you get a minimum share of the
如果你获得了CPU的最小份额，那么你将获得CPU的最小份额。

787
00:49:26,280 --> 00:49:29,780
cpu then presumably,
CPU则可以推测是指中央处理器。

788
00:49:33,210 --> 00:49:38,220
you are guaranteed that you can finish some of the operations
你可以确保完成其中一些操作。

789
00:49:38,230 --> 00:49:41,220
or your operations in time.
或者你的操作在时间上。

790
00:49:45,740 --> 00:49:48,390
For instance, this is a continuation,
例如，这是一个延续的例子，

791
00:49:48,400 --> 00:49:50,670
this is question from your friend.
这是你朋友的问题。

792
00:49:52,740 --> 00:49:56,010
For example, some programs receive data from network,
例如，一些程序从网络接收数据，

793
00:49:56,390 --> 00:50:00,320
wouldn't contact switching the program during the transmission caused trouble.
在传输过程中切换程序不会引起麻烦。

794
00:50:03,340 --> 00:50:08,850
Now, you will is the other way around.
现在，你将是相反的方式。

795
00:50:08,860 --> 00:50:11,510
Actually, when you get something from the another,
实际上，当你从另一个地方得到某物时，

796
00:50:11,520 --> 00:50:12,830
there is an interrupt.
发生了一个中断。

797
00:50:13,480 --> 00:50:17,960
You are going to interrupt the processes which are
你将要中断正在运行的进程

798
00:50:17,970 --> 00:50:20,680
actually application processes which are actually running.
实际上正在运行的应用程序进程。

799
00:50:21,340 --> 00:50:23,280
And then after you do the work,
然后在你完成工作之后，

800
00:50:23,290 --> 00:50:24,400
you get the data,
你已经获取到数据。

801
00:50:24,410 --> 00:50:25,800
you return from the internet.
你从互联网返回。

802
00:50:26,140 --> 00:50:28,210
And you are going to continue the processes.
你将继续进行这些进程。

803
00:50:29,280 --> 00:50:30,110
Typically,
通常情况下，

804
00:50:31,940 --> 00:50:34,250
it's a little bit the other way around.
有点相反。

805
00:50:34,260 --> 00:50:38,530
It's not like a process interrupted transmission or receiving data.
并不是进程中断了传输或接收数据。

806
00:50:39,900 --> 00:50:42,250
Where is the current start block information being stored
当前的起始块信息存储在哪里？

807
00:50:42,260 --> 00:50:44,530
for individual cpu like I mentioned,
对于我之前提到的单个CPU来说，

808
00:50:44,540 --> 00:50:48,610
this is in the operating system following up on the assembly,
这是在操作系统中对汇编语言的后续工作。

809
00:50:48,620 --> 00:50:50,130
giving you free ring questions.
给你免费的戒指问题。

810
00:50:50,140 --> 00:50:51,690
Are the segmentation faults?
出现了分段错误吗？

811
00:50:52,000 --> 00:50:56,350
Receipt things, or will you also be prohibitive on the assemble?
收据事项，或者你也会对组装有限制吗？

812
00:50:56,980 --> 00:50:58,130
Assembly level?
汇编级别？

813
00:50:58,540 --> 00:51:01,410
The segmentation falls are the seas?
分段错误是什么意思？

814
00:51:02,350 --> 00:51:06,220
See things as see thing, right?
看事情就是看事情，对吗？

815
00:51:06,230 --> 00:51:07,740
It's like an assembly level,
这就像是汇编级别的。

816
00:51:08,130 --> 00:51:12,800
because it gives you a lot of more flexibility, right?
因为它给你更多的灵活性，对吗？

817
00:51:13,510 --> 00:51:16,440
We see you can write all over the place.
我们注意到你可以随意写字。

818
00:51:16,450 --> 00:51:18,980
But again, when you have like, for instance,
但是再说一遍，当你有像，例如，

819
00:51:18,990 --> 00:51:21,020
if you run java or things like that,
如果你运行Java或类似的东西，

820
00:51:21,670 --> 00:51:22,740
you cannot do it.
你不能做这件事。

821
00:51:23,630 --> 00:51:25,740
And this is enforced by your compilers.
这是由你的编译器强制执行的。

822
00:51:26,190 --> 00:51:31,880
It can be type is can if you probably heard about being their type safety,
如果你可能听说过类型安全性，那么它可以是类型安全的。

823
00:51:33,170 --> 00:51:33,750
type safe,
类型安全的

824
00:51:34,270 --> 00:51:37,980
then they verify that actually, when you write the program, you cannot,
然后他们验证了实际情况，即当你编写程序时，你无法...

825
00:51:37,990 --> 00:51:38,860
for instance,
例如，

826
00:51:39,270 --> 00:51:41,460
overwrite on the stack, right on the stack.
在栈上覆盖，直接在栈上覆盖。

827
00:51:41,970 --> 00:51:43,710
In short answer, assembly language,
简而言之，汇编语言是一种低级编程语言，与计算机硬件直接交互。它使用特定的指令集来编写程序，这些指令集对应于计算机的机器指令。汇编语言程序员需要了解计算机的内部结构和指令集，以便编写有效的程序。与高级编程语言相比，汇编语言更接近计算机硬件，因此可以更精确地控制计算机的操作。

828
00:51:43,990 --> 00:51:45,300
c language, you can do it.
C语言，你可以做到。

829
00:51:45,610 --> 00:51:47,680
Higher level languages, you cannot do it.
在高级语言中，你无法做到这一点。

830
00:51:48,260 --> 00:51:50,300
The compilers will take care of that.
编译器会处理这个。

831
00:51:51,570 --> 00:51:53,220
What is the state block?
状态块是操作系统中用于跟踪文件或设备状态的数据结构。它包含了与文件或设备相关的信息，如文件大小、权限、创建时间、修改时间等。状态块还可以包含指向文件数据或设备驱动程序的指针，以便操作系统可以访问和管理文件或设备。通过状态块，操作系统可以有效地管理和控制文件和设备的访问和操作。

832
00:51:53,230 --> 00:51:54,540
I it is,
是的，它是。

833
00:51:54,780 --> 00:51:56,210
maybe if I say state block it,
也许如果我说状态块的话，

834
00:51:56,900 --> 00:51:59,890
it's this is not the correct term,
这不是正确的术语。

835
00:51:59,900 --> 00:52:03,290
is a thread control block and this process control block.
线程控制块和进程控制块。

836
00:52:04,670 --> 00:52:06,530
And this is, again,
这是，再次，

837
00:52:06,540 --> 00:52:09,410
the state control block contains all the state,
状态控制块包含了所有的状态信息，

838
00:52:10,380 --> 00:52:12,930
which is associated with a particular threat,
与特定威胁相关的是

839
00:52:13,150 --> 00:52:14,960
program counters, stack, pointer,
程序计数器、栈、指针

840
00:52:14,970 --> 00:52:17,180
and addresses and the registers.
以及地址和寄存器。

841
00:52:19,770 --> 00:52:25,930
What was the difference between a thread control block and process control block?
线程控制块（Thread Control Block）和进程控制块（Process Control Block）之间的区别是什么？

842
00:52:27,070 --> 00:52:27,870
Like I mentioned,
正如我之前提到的，

843
00:52:27,880 --> 00:52:32,530
the process control block has all the state associated with the resources
进程控制块包含与资源相关的所有状态信息。

844
00:52:33,570 --> 00:52:35,460
associated with that process,
与该进程相关的

845
00:52:36,310 --> 00:52:36,710
right?
对的？

846
00:52:37,450 --> 00:52:43,230
Like filed a script daughters and based translation information
像提交一个脚本，根据翻译信息进行翻译。

847
00:52:43,240 --> 00:52:43,870
and things like that.
等等，诸如此类的东西。

848
00:52:46,030 --> 00:52:46,920
Let's move on.
让我们继续吧。

849
00:52:46,930 --> 00:52:49,320
We are the, but thanks for that question.
我们是的，但是谢谢你的问题。

850
00:52:49,330 --> 00:52:50,220
This is great.
太棒了。

851
00:52:51,600 --> 00:52:54,250
And if I don't answer a particular question,
如果我不回答某个特定问题，

852
00:52:54,260 --> 00:52:55,650
you can repeat it,
你可以重复一遍吗？

853
00:52:58,130 --> 00:52:58,510
feel free.
随意。

854
00:53:00,720 --> 00:53:01,390
Let me see.
让我看看。

855
00:53:02,560 --> 00:53:03,020
Now,
现在，

856
00:53:04,220 --> 00:53:06,790
when you have obviously multi,
当你明显有多个时，

857
00:53:07,120 --> 00:53:11,060
when you have multiple processes running on the same hardware,
当多个进程在同一台硬件上运行时，

858
00:53:11,530 --> 00:53:13,440
you need to multiply the hardware.
你需要将硬件进行乘法运算。

859
00:53:13,650 --> 00:53:15,160
And the basic problem,
基本问题是，

860
00:53:15,730 --> 00:53:17,160
what is called this concurrency?
这个并发被称为什么？

861
00:53:18,630 --> 00:53:20,510
And concurrency meaning,
并发的含义是指在计算机系统中同时执行多个独立的任务或操作。这些任务可以是同时运行的多个进程或线程，它们可以并行执行或交替执行。并发性是提高系统性能和资源利用率的重要手段，但也带来了一些挑战，如竞态条件和死锁等问题。

862
00:53:20,860 --> 00:53:25,360
again, multiple processes wanting to access the same hardware.
再次，多个进程想要访问同一硬件。

863
00:53:25,940 --> 00:53:26,380
Okay?
好的？

864
00:53:30,260 --> 00:53:36,190
Because you want to multiplex single cpu memory,
因为你想要将单个CPU内存进行多路复用，

865
00:53:36,840 --> 00:53:39,000
io devices, and things like that.
输入/输出设备，以及诸如此类的东西。

866
00:53:41,590 --> 00:53:43,150
And remember, again,
记住，再次强调，

867
00:53:43,500 --> 00:53:47,550
the role of the operating system at the same time is to provide
操作系统的角色之一是同时提供

868
00:53:47,560 --> 00:53:51,480
the illusion that each of these processes
每个进程都有的错觉

869
00:53:52,810 --> 00:53:58,710
own a on a single machine is the only one executing on the machine.
在一台机器上拥有独占权意味着只有一个进程在该机器上执行。

870
00:53:59,620 --> 00:54:02,760
The operating system is in charge to arbitrate,
操作系统负责调度和协调各个任务，

871
00:54:02,770 --> 00:54:03,840
to coordinate,
协调

872
00:54:04,090 --> 00:54:07,270
to manage all these concurrent activities while providing
在提供这些并发活动的同时进行管理

873
00:54:07,280 --> 00:54:11,250
this a single machine abstraction to the processors,
这是对处理器的单机抽象。

874
00:54:12,330 --> 00:54:13,210
the processes.
进程。

875
00:54:15,910 --> 00:54:17,850
So that's kind of hard.
这有点困难。

876
00:54:20,680 --> 00:54:23,370
So one of the main abstraction,
所以其中一个主要的抽象是，

877
00:54:24,390 --> 00:54:27,170
one of the main resources needs to be multiplex.
其中一个主要资源需要进行多路复用。

878
00:54:28,020 --> 00:54:29,650
A is a physical memory.
A 是一个物理内存。

879
00:54:31,500 --> 00:54:33,440
The way this is done,
这是通过以下方式完成的，

880
00:54:33,450 --> 00:54:40,360
it's using the concepts of virtual memory.
它使用虚拟内存的概念。

881
00:54:40,830 --> 00:54:44,700
And we can extend that concept to the virtual to the machine,
我们可以将这个概念扩展到虚拟机上，

882
00:54:44,710 --> 00:54:45,900
right to the entire machine.
对整个机器的访问权限。

883
00:54:46,800 --> 00:54:47,630
What we call,
我们所说的，

884
00:54:47,640 --> 00:54:53,940
when I said that we provide the illusion to a process that it owns
当我说我们给一个进程提供了它拥有的幻觉时

885
00:54:54,410 --> 00:54:55,760
is dedicated machine,
是专用机器，

886
00:54:56,000 --> 00:54:58,710
that machine is called virtual machine.
那台机器被称为虚拟机。

887
00:54:59,340 --> 00:55:01,580
Or we also referred to it as a virtual machine.
我们也称之为虚拟机。

888
00:55:02,660 --> 00:55:03,000
Okay?
好的？

889
00:55:06,660 --> 00:55:08,330
Then the question, then,
那么问题就是，

890
00:55:08,340 --> 00:55:10,970
it's about how to multiply these virtual machines.
这是关于如何扩展这些虚拟机的问题。

891
00:55:11,430 --> 00:55:13,980
The virtual machines has its virtual skip years,
虚拟机具有其虚拟的跳过年份功能。

892
00:55:14,580 --> 00:55:16,490
virtual memory, and so forth.
虚拟内存等等。

893
00:55:18,720 --> 00:55:27,530
The first system doing this was the system short and interesting name.
第一个实现这一功能的系统被命名为简短而有趣的名称。

894
00:55:28,010 --> 00:55:30,310
It really was a few thousand lines of code,
这确实是几千行代码。

895
00:55:32,850 --> 00:55:34,170
the os 360,
OS/360是IBM公司于1964年推出的一款操作系统。它是IBM System/360计算机系列的一部分，为多种应用提供了统一的操作环境。OS/360是第一个支持多道程序设计的操作系统，它引入了分时系统和批处理系统的概念，为大型机提供了更高效的资源管理和作业调度。OS/360的设计思想和架构对后来的操作系统发展产生了重要影响。

896
00:55:34,180 --> 00:55:41,070
which arguably was one of the first and probably the first commercial,
可以说这是第一款商业化的产品，很可能是第一个。

897
00:55:41,080 --> 00:55:48,080
successful commercial operating system created by ibm was having at that time,
IBM当时成功创建的商业操作系统是

898
00:55:48,090 --> 00:55:49,600
1 million slides of code.
100万行代码。

899
00:55:49,610 --> 00:55:50,400
It was huge.
它很大。

900
00:55:50,960 --> 00:55:56,530
Today probably you have windows has tens of million slides of code or even more.
今天，Windows可能有数千万行甚至更多的代码。

901
00:55:58,870 --> 00:55:59,340
It's again,
又是这样，

902
00:55:59,350 --> 00:56:01,300
they just show you another data point
他们只是向你展示了另一个数据点。

903
00:56:01,310 --> 00:56:04,420
about how complex a separating system came
关于一个分离系统的复杂程度如何产生

904
00:56:09,610 --> 00:56:10,450
grew over time.
随着时间的推移逐渐增长。

905
00:56:11,060 --> 00:56:12,840
And this is a funny thing, right?
这是一件有趣的事情，对吗？

906
00:56:12,850 --> 00:56:13,840
It's like probably.
大概就是这样。

907
00:56:13,850 --> 00:56:19,310
And the number of bugs in os 60 were probably the same or larger
OS 60中的错误数量可能是相同或更多的。

908
00:56:19,320 --> 00:56:22,740
than the number of lines of code in the system.
比系统中的代码行数还要多。

909
00:56:34,630 --> 00:56:38,080
So now,
现在，

910
00:56:38,090 --> 00:56:41,040
what are some of the consequences of sharing?
分享的一些后果有哪些？

911
00:56:41,750 --> 00:56:42,120
Right?
对吗？

912
00:56:43,160 --> 00:56:45,080
If you have only threats,
如果你只有威胁的话，

913
00:56:46,170 --> 00:56:49,390
the threads are going to share the same address face,
线程将共享相同的地址空间。

914
00:56:51,750 --> 00:56:57,890
which means that the threads can have access to the other threads.
这意味着线程可以访问其他线程。

915
00:56:58,170 --> 00:56:58,940
Data, for instance.
数据，例如。

916
00:56:59,970 --> 00:57:00,810
So they can share,
这样他们就可以共享，

917
00:57:00,820 --> 00:57:05,290
but these means that they also can change the data of a different threat.
但这也意味着它们可以更改不同线程的数据。

918
00:57:06,100 --> 00:57:06,540
Right?
对吗？

919
00:57:10,320 --> 00:57:13,860
So that's very important to keep in mind.
所以这一点非常重要要牢记在心。

920
00:57:13,870 --> 00:57:15,300
And here is a question.
这是一个问题。

921
00:57:15,670 --> 00:57:19,030
Can threads overwrite operating system functions?
线程可以覆盖操作系统的函数吗？

922
00:57:21,280 --> 00:57:24,840
We are not in the class to ask the class and people to answer.
我们不是来上课并让班级和同学们回答问题的。

923
00:57:25,370 --> 00:57:32,480
But the answer here is no because the operating system doesn't run
但是这里的答案是否定的，因为操作系统不运行

924
00:57:32,490 --> 00:57:34,280
in the same address space.
在相同的地址空间中。

925
00:57:36,000 --> 00:57:38,590
But it's, again, all the threads in the same operator,
但是，再次强调，所有的线程都在同一个操作符中。

926
00:57:38,600 --> 00:57:39,910
in the same address space,
在相同的地址空间中，

927
00:57:39,920 --> 00:57:41,750
they can see each other beta.
它们可以相互看到beta版本。

928
00:57:41,760 --> 00:57:45,360
They can drive read each other a bit as I can write each other a bit.
他们可以互相读取一点，就像我可以互相写入一点一样。

929
00:57:47,140 --> 00:57:48,910
And this is, and actually,
这是，实际上，

930
00:57:48,920 --> 00:57:50,750
there are systems in the past,
过去存在着一些系统，

931
00:57:51,100 --> 00:57:55,790
which have this mode like windows 3.1,
类似于Windows 3.1的操作系统有哪些？

932
00:57:56,470 --> 00:58:02,140
which was most the first really successful windows operating system from microsoft,
微软最早真正成功的Windows操作系统是哪一个？

933
00:58:02,670 --> 00:58:05,990
and the early mic miking posh operating systems.
以及早期的麦克风操作系统。

934
00:58:06,860 --> 00:58:14,610
This is before oil stand in which you have this kind of threads are the
这是一个放置油的架子，在这种架子上有这样的螺纹。

935
00:58:17,050 --> 00:58:19,520
are in the same other space even more.
甚至更多地在同一个其他空间中。

936
00:58:20,940 --> 00:58:21,570
They are.
他们是。

937
00:58:23,060 --> 00:58:30,770
The operating system didn't actively share the cpu among the applications.
操作系统没有主动在应用程序之间共享CPU。

938
00:58:31,670 --> 00:58:32,210
Okay?
好的？

939
00:58:33,130 --> 00:58:33,960
Instead,
相反，

940
00:58:34,170 --> 00:58:40,160
the application have to use this kind of common yield to relinquish the cpu
应用程序需要使用这种常见的yield方法来释放CPU

941
00:58:40,170 --> 00:58:42,160
so other application can wrap,
这样其他应用程序就可以包装了

942
00:58:42,680 --> 00:58:43,120
right?
对的？

943
00:58:43,760 --> 00:58:50,750
A misbehaving application who never use yield can monopolize the entire
一个不使用yield的行为不端的应用程序可以垄断整个系统。

944
00:58:51,490 --> 00:58:55,060
system and hang every other application.
系统崩溃并使其他应用程序停止运行。

945
00:58:59,220 --> 00:59:00,200
This kind of,
这种类型的，

946
00:59:01,200 --> 00:59:02,840
therefore, what do you want?
因此，你想要什么？

947
00:59:03,150 --> 00:59:07,890
Though we want to have this product to have protection, right?
我们希望这个产品有保护措施，对吗？

948
00:59:08,210 --> 00:59:11,390
We want that we have two processes.
我们希望有两个进程。

949
00:59:11,400 --> 00:59:13,350
And this is the concept of process,
这是进程的概念。

950
00:59:13,670 --> 00:59:15,840
is kind of encapsulate the protection,
是一种封装保护的方式。

951
00:59:16,240 --> 00:59:19,870
because the thread in each process can see each other data can modify
因为每个进程中的线程可以看到彼此的数据并进行修改。

952
00:59:19,880 --> 00:59:20,870
each other beta,
彼此之间的贝塔

953
00:59:20,880 --> 00:59:24,990
but stress from different processes cannot have access to the data
但是来自不同进程的压力不能访问数据

954
00:59:25,910 --> 00:59:27,020
from the other process.
来自另一个进程。

955
00:59:28,810 --> 00:59:32,210
Because the process contains the address space,
因为进程包含地址空间，

956
00:59:32,790 --> 00:59:34,280
the address space.
地址空间。

957
00:59:34,790 --> 00:59:40,700
It's a unit of protection of the address space in the memory.
它是内存中地址空间的保护单位。

958
00:59:42,030 --> 00:59:44,460
And here it's here again,
这里又来了，

959
00:59:44,470 --> 00:59:49,780
you have two programs of two processes as a brown one and the green one,
你有两个程序，一个是褐色的，一个是绿色的，分别对应两个进程。

960
00:59:49,790 --> 00:59:51,300
process one and process two.
进程一和进程二。

961
00:59:51,310 --> 00:59:55,940
And here a process to shouldn't have access to the memory of frost,
这里有一个进程不应该访问frost内存的过程。

962
00:59:55,950 --> 00:59:59,580
swan shouldn't have access to the operating system memory,
天鹅不应该访问操作系统内存。

963
00:59:59,840 --> 01:00:03,850
or shouldn't have access to the file descriptor of other processes.
或者不应该访问其他进程的文件描述符。

964
01:00:05,120 --> 01:00:05,510
Okay?
好的？

965
01:00:10,150 --> 01:00:12,660
Typically, when they try to access resources,
通常情况下，当他们尝试访问资源时，

966
01:00:12,670 --> 01:00:17,180
they don't own a process to operating system will cause
如果他们没有拥有一个进程给操作系统，将会导致什么问题。

967
01:00:17,190 --> 01:00:21,780
a segmentation fault and will crash the offending process.
出现段错误将导致进程崩溃。

968
01:00:23,570 --> 01:00:25,040
Let me just,
让我来，

969
01:00:26,160 --> 01:00:27,950
if there are a few more questions,
如果还有几个问题的话，

970
01:00:34,310 --> 01:00:38,930
how are operating system tested in development when the complexity is very high?
当操作系统的复杂性非常高时，如何进行开发中的操作系统测试？

在操作系统开发过程中，当复杂性非常高时，通常会采用以下几种测试方法：

1. 单元测试（Unit Testing）：针对操作系统中的各个模块或组件进行独立测试，以验证其功能是否正确。这种测试方法可以帮助开发人员快速发现和修复单个模块的问题。

2. 集成测试（Integration Testing）：将各个模块或组件结合起来进行测试，以验证它们之间的交互是否正确。这种测试方法可以帮助开发人员发现模块之间的集成问题。

3. 系统测试（System Testing）：对整个操作系统进行全面的测试，以验证其功能和性能是否符合预期。这种测试方法可以模拟实际使用环境，发现系统级别的问题。

4. 性能测试（Performance Testing）：通过模拟大量用户和负载，测试操作系统在高负载情况下的性能表现。这种测试方法可以帮助开发人员优化操作系统的性能。

5. 冒烟测试（Smoke Testing）：在每次代码更改后，运行一组基本的测试用例，以确保操作系统的基本功能没有受到破坏。这种测试方法可以帮助开发人员快速发现潜在的问题。

此外，还可以使用自动化测试工具和技术来加快测试过程，例如使用测试框架、模拟器、虚拟化技术等。

总之，当操作系统的复杂性非常高时，需要采用多种测试方法和工具来确保其正确性和稳定性。

971
01:00:40,420 --> 01:00:43,420
That's why there are so few operating system being developed
这就是为什么开发操作系统的数量如此之少的原因

972
01:00:43,430 --> 01:00:44,420
a new operating system,
一个新的操作系统

973
01:00:44,430 --> 01:00:46,780
because it's fundamentally extremely hard.
因为它在根本上非常困难。

974
01:00:50,900 --> 01:00:54,670
It's just good software engineering practices.
这只是良好的软件工程实践。

975
01:00:56,560 --> 01:01:01,750
You are very aggressive during the unit testing and then testing and so forth.
你在单元测试和其他测试过程中非常积极。

976
01:01:02,400 --> 01:01:04,610
Even so with all of these,
即使有所有这些，

977
01:01:04,620 --> 01:01:06,460
because they are so complex.
因为它们非常复杂。

978
01:01:07,640 --> 01:01:08,990
Many operating systems,
许多操作系统，

979
01:01:09,000 --> 01:01:10,310
they still have bugs.
它们仍然有一些错误。

980
01:01:11,150 --> 01:01:13,310
I'm not sure I have that plot,
我不确定我有那个情节。

981
01:01:13,320 --> 01:01:21,520
but it is a plot in which you can see like when people debug the operating system,
但这是一个情节，你可以看到人们调试操作系统的过程。

982
01:01:23,070 --> 01:01:25,450
your initially you are going to have a lot of bugs.
初始阶段你可能会遇到很多错误。

983
01:01:25,460 --> 01:01:26,930
And then after a while,
然后过了一段时间，

984
01:01:27,160 --> 01:01:30,590
the box, the rate at which new bucks are occur,
这个句子有一些语法错误，我假设你想表达的是：

"the box, the rate at which new bugs occur"

翻译成中文为：

"这个盒子，新错误发生的速率"

985
01:01:30,600 --> 01:01:31,750
it's reducing.
它正在减少。

986
01:01:32,310 --> 01:01:33,980
This kind of ones are very flat,
这种类型的物品非常平坦。

987
01:01:33,990 --> 01:01:35,940
and then you should the operating system.
然后你应该安装操作系统。

988
01:01:36,270 --> 01:01:38,230
This doesn't mean that you have zero box.
这并不意味着你没有任何盒子。

989
01:01:38,240 --> 01:01:41,750
It just seems that the number of boxes rarely enough,
似乎盒子的数量很少。

990
01:01:42,000 --> 01:01:43,870
the operating system is usable.
操作系统可用。

991
01:01:50,690 --> 01:01:53,560
All cp us share the same resources.
所有的CPU共享同样的资源。

992
01:01:53,570 --> 01:01:56,670
It is ii was saying problem,
这是一个问题。

993
01:01:56,680 --> 01:02:01,920
he spoke there by saying the question is by saying they all cpu share
他通过说出问题来表达，即他们所有的CPU共享。

994
01:02:01,930 --> 01:02:03,400
the same resources.
相同的资源。

995
01:02:03,740 --> 01:02:06,190
It is referring to stress within a single process
它指的是单个进程内的压力。

996
01:02:06,200 --> 01:02:08,290
or process sharing resources and so forth.
或者进程共享资源等等。

997
01:02:10,790 --> 01:02:15,380
I was referring at basically all threads in the same process,
我指的是同一进程中的所有线程。

998
01:02:15,390 --> 01:02:16,740
share the same resources.
共享相同的资源。

999
01:02:17,320 --> 01:02:22,050
Then all processes also share the same physical resources in terms
那么所有进程也共享相同的物理资源。

1000
01:02:22,060 --> 01:02:26,980
of the cpu and in terms of physical memory.
在CPU和物理内存方面。

1001
01:02:27,720 --> 01:02:28,170
Okay?
好的？

1002
01:02:30,270 --> 01:02:31,940
Power address space is allowed.
允许使用特权地址空间。

1003
01:02:31,950 --> 01:02:35,820
It seems inefficient to lock a large blocks or have many small blocks.
锁定大块或拥有许多小块似乎是低效的。

1004
01:02:36,730 --> 01:02:42,780
There is a big trade off here between having small blocks and large blocks.
在这里存在着小块和大块之间的一个很大的权衡。

1005
01:02:43,920 --> 01:02:48,230
You have what is called internal fragmentation or external fragmentation.
你遇到了所谓的内部碎片或外部碎片问题。

1006
01:02:48,730 --> 01:02:50,320
For instance, with large blocks,
例如，使用大块大小时，

1007
01:02:50,330 --> 01:02:52,560
if you don't use the entire block,
如果你没有使用整个块，

1008
01:02:52,810 --> 01:02:54,790
you are located, then you wear this memory,
你所在的位置，然后你穿戴这块内存，

1009
01:02:58,590 --> 01:03:00,820
something like and so,
类似于这样，那么，

1010
01:03:01,540 --> 01:03:04,130
but so you need to be smart about it.
但是你需要对此进行聪明的处理。

1011
01:03:04,570 --> 01:03:07,890
Today's operating systems allocate the memory in what?
现代操作系统将内存分配给什么？

1012
01:03:07,900 --> 01:03:10,300
In small blocks or pages,
以小块或页面为单位，

1013
01:03:10,310 --> 01:03:12,060
which are a few kilobytes,
这些是几千字节的文件。

1014
01:03:12,470 --> 01:03:15,390
four kilobytes, 16 kilobytes of 72 kilobytes.
四千字节，十六千字节，七十二千字节中的一部分。

1015
01:03:15,800 --> 01:03:19,840
And then you have many of these small blocks,
然后你有许多这些小块，

1016
01:03:20,170 --> 01:03:22,740
then you need to manage them efficiently.
那么你需要高效地管理它们。

1017
01:03:23,190 --> 01:03:26,060
And we are going to learn how this is done.
我们将学习如何完成这个任务。

1018
01:03:27,690 --> 01:03:32,480
Ideally, would application use yield when they are performing?
理想情况下，应用程序在执行过程中使用 yield 吗？

1019
01:03:32,490 --> 01:03:34,080
Absolutely, that's a great..
当然，那是一个很好的..

1020
01:03:34,580 --> 01:03:35,250
Sorry,
抱歉，

1021
01:03:36,060 --> 01:03:38,730
that to read the full question, ideally,
最好的情况是阅读完整的问题。

1022
01:03:38,740 --> 01:03:42,870
what application is yield when they are performing our operations.
在执行我们的操作时，应用程序会使用什么应用程序？

1023
01:03:44,160 --> 01:03:45,350
That's exactly the case.
确实如此。

1024
01:03:45,360 --> 01:03:47,830
When you are going to send some data,
当你要发送一些数据时，

1025
01:03:48,300 --> 01:03:53,370
then you can do yelled because you can wait for, excuse me,
那你可以大声喊叫，因为你可以等一下，对不起，

1026
01:03:55,890 --> 01:03:58,720
or when you are going to execute the yield,
或者当你要执行yield语句时，

1027
01:03:59,390 --> 01:04:03,670
or you can when the interaction on the application is interactive,
或者当应用程序的交互是互动的时候，你可以这样做。

1028
01:04:03,680 --> 01:04:07,510
like an editor on a click on the keyboard,
就像键盘上的编辑器一样，

1029
01:04:08,350 --> 01:04:11,070
then you see the characters appearing on the screen.
然后你会看到字符出现在屏幕上。

1030
01:04:11,080 --> 01:04:12,880
In that case,
在这种情况下，

1031
01:04:12,890 --> 01:04:19,660
the editor will do yield after each time after he displays a character.
编辑器在显示每个字符后会执行yield操作。

1032
01:04:20,730 --> 01:04:24,790
And it's going to wait for the next character to be typed into what I
它将等待下一个字符被输入到什么地方。

1033
01:04:24,800 --> 01:04:26,290
have to get from the keyboard.
需要从键盘获取。

1034
01:04:29,480 --> 01:04:33,650
What does threads can share instruction mean on the previous slide?
在前一张幻灯片中，"threads can share instruction" 是什么意思？

1035
01:04:42,190 --> 01:04:47,540
This means that again,
这意味着再次，

1036
01:04:47,550 --> 01:04:50,180
the threads are in the same address space.
这些线程处于相同的地址空间中。

1037
01:04:50,970 --> 01:04:51,970
And,
而且，

1038
01:04:53,470 --> 01:04:54,380
for instance,
例如，

1039
01:04:56,340 --> 01:04:58,410
even between processes, you can share that.
即使在进程之间，你也可以共享它。

1040
01:04:58,420 --> 01:05:00,810
But if you have the same user, same libraries,
但是如果你有相同的用户，相同的库文件，

1041
01:05:01,580 --> 01:05:02,690
and multiple study,
并且进行多次学习，

1042
01:05:02,700 --> 01:05:03,930
the same libraries,
相同的库文件

1043
01:05:04,920 --> 01:05:07,330
you are going to have only one copy of the library,
你将只拥有一份图书馆的副本。

1044
01:05:08,090 --> 01:05:12,470
which is going to be shared by the threads.
将要被线程共享的内容。

1045
01:05:12,480 --> 01:05:13,990
You are not going to have multiple copies.
你不会有多个副本。

1046
01:05:18,380 --> 01:05:22,250
Here is another picture showing the boundary protection boundary,
这是另一张展示边界保护边界的图片。

1047
01:05:22,260 --> 01:05:27,310
and how the row resources access to the row resources is protected
如何保护行资源的访问权限？

1048
01:05:27,320 --> 01:05:28,570
from the processes.
从进程中。

1049
01:05:29,960 --> 01:05:32,390
And like I we discussed last time,
就像我们上次讨论的那样，

1050
01:05:32,950 --> 01:05:36,140
I we already said a few times this lecture and this lecture,
我们已经在这节课上说了几次这个问题了。

1051
01:05:36,560 --> 01:05:40,030
the os operating system isolate processes from each other,
操作系统（OS）将进程彼此隔离开来。

1052
01:05:40,410 --> 01:05:44,070
make sure they don't read and write data from each other.
确保它们彼此不读写数据。

1053
01:05:44,390 --> 01:05:47,870
The operating system also isolate itself from other processes.
操作系统还会与其他进程隔离开来。

1054
01:05:49,890 --> 01:05:53,920
Again, the challenge here because all of those run on the same harbor,
在这里的挑战是因为所有这些都在同一个港口上运行，

1055
01:05:59,570 --> 01:06:01,510
this is, again,
这是，再次，

1056
01:06:02,730 --> 01:06:03,240
some,
一些

1057
01:06:04,560 --> 01:06:07,950
again, summary and repeating what was in the previous slide,
再次总结并重复上一张幻灯片中的内容。

1058
01:06:07,960 --> 01:06:09,670
maybe with a little bit more details.
也许需要更多细节。

1059
01:06:12,010 --> 01:06:15,000
The operating system must protect itself from the user programs,
操作系统必须保护自身免受用户程序的影响。

1060
01:06:15,010 --> 01:06:16,320
from the user processes.
来自用户进程。

1061
01:06:18,100 --> 01:06:21,810
And what does it mean?
这句话的意思是什么？

1062
01:06:21,820 --> 01:06:25,780
I need to and why is that needed?
我需要这样做，因为这是必要的。

1063
01:06:26,250 --> 01:06:28,150
Is obviously for security,
显然是为了安全考虑，

1064
01:06:29,120 --> 01:06:31,270
if the operating system is not protecting,
如果操作系统没有提供保护机制，

1065
01:06:31,280 --> 01:06:35,230
and then it's easier for an application to break into another application.
然后，一个应用程序更容易侵入另一个应用程序。

1066
01:06:35,730 --> 01:06:38,760
This is the confidential data or private data.
这是机密数据或私人数据。

1067
01:06:40,380 --> 01:06:44,630
I just mentioned about the privacy in the same example.
我刚刚提到了同一个例子中的隐私问题。

1068
01:06:44,960 --> 01:06:48,990
And one of the amazing is reliability, right?
是的，可靠性是其中之一的亮点。

1069
01:06:49,000 --> 01:06:50,630
If the operating system fails,
如果操作系统失败，

1070
01:06:51,160 --> 01:06:57,780
then the computer it's any unusable,
那么计算机就无法使用了。

1071
01:07:00,870 --> 01:07:01,840
the operating system.
操作系统。

1072
01:07:01,850 --> 01:07:04,060
It better runs at all times.
最好始终保持运行。

1073
01:07:04,890 --> 01:07:07,610
And fairness,
公平性，

1074
01:07:07,990 --> 01:07:08,720
it's, again,
又是这个问题，

1075
01:07:08,730 --> 01:07:13,690
the operating system is the one which ensures that the processes,
操作系统是确保进程、程序和硬件之间协调运行的软件。

1076
01:07:13,960 --> 01:07:19,800
different processes get a fair access to the harbor program.
不同的进程公平地访问港口程序。

1077
01:07:20,570 --> 01:07:21,700
Like I mentioned,
正如我之前提到的，

1078
01:07:22,090 --> 01:07:26,710
the operating system is to protect user programs from one another.
操作系统的作用是保护用户程序之间的隔离。

1079
01:07:29,120 --> 01:07:33,240
One of the primary mechanisms of protections.
保护的主要机制之一。

1080
01:07:33,570 --> 01:07:35,230
It's a translation.
这是一段翻译。

1081
01:07:36,720 --> 01:07:38,110
And we'll see that next.
接下来我们会看到。

1082
01:07:38,810 --> 01:07:42,990
And the translation ensure that the process can only touch
并且翻译确保进程只能触及

1083
01:07:43,370 --> 01:07:46,220
its own address space and cannot touch
它拥有自己的地址空间，无法访问其他地址空间。

1084
01:07:47,390 --> 01:07:50,460
the address physical addresses of another process.
该地址是另一个进程的物理地址。

1085
01:07:51,950 --> 01:07:53,460
There are a few of other mechanics,
还有一些其他的机制，

1086
01:07:53,470 --> 01:07:55,900
like political edge instruction that can be only executed
像政治边缘指令一样，只能执行的指令

1087
01:07:55,910 --> 01:07:57,580
on by the operating system.
由操作系统启动。

1088
01:07:59,660 --> 01:08:01,450
There are some special registers.
有一些特殊寄存器。

1089
01:08:01,460 --> 01:08:06,830
Only operating system has access to the circumstances.
只有操作系统才能访问这些情况。

1090
01:08:06,840 --> 01:08:07,190
So far.
到目前为止。

1091
01:08:07,200 --> 01:08:08,550
We talk about threads,
我们来讨论线程。

1092
01:08:08,560 --> 01:08:10,230
we talked about addresses,
我们讨论了地址。

1093
01:08:10,240 --> 01:08:12,350
we also talk quite a bit about processes.
我们也会谈论很多关于进程的内容。

1094
01:08:12,770 --> 01:08:14,590
This is, again, to make it explicit.
这是为了明确起见，再次强调一下。

1095
01:08:15,110 --> 01:08:23,970
Once more, the process is basically another space+1 or more threats.
再次强调，该进程基本上是另一个空间加上一个或多个威胁。

1096
01:08:25,560 --> 01:08:28,330
So processes allocate resources.
所以进程分配资源。

1097
01:08:29,400 --> 01:08:31,910
Then it has a thread,
然后它有一个线程。

1098
01:08:32,260 --> 01:08:34,490
which basically is a unit of execution.
基本上，它是一个执行单元。

1099
01:08:38,280 --> 01:08:39,590
Why do you have processes?
为什么需要进程？

1100
01:08:39,600 --> 01:08:41,670
Because the processes protect from each other?
因为进程之间相互保护吗？

1101
01:08:42,190 --> 01:08:44,030
Stress do not protect from each other.
压力并不能相互保护。

1102
01:08:44,840 --> 01:08:46,360
They share our same other space.
他们与我们共享同一个其他空间。

1103
01:08:46,370 --> 01:08:50,470
They share all the resources within a process.
它们在一个进程内共享所有资源。

1104
01:08:53,600 --> 01:08:56,040
However, threads are more efficient like we discussed.
然而，正如我们讨论过的那样，线程更高效。

1105
01:08:56,400 --> 01:08:58,930
The context switching between the threading the same process is
在同一进程的线程之间进行上下文切换

1106
01:08:58,940 --> 01:09:02,030
much quicker than between threads and different processes.
比线程之间和不同进程之间要快得多。

1107
01:09:03,210 --> 01:09:08,760
Also, so communication between studies in the same process much faster,
此外，同一进程中的通信速度更快。

1108
01:09:09,170 --> 01:09:10,510
because you can use share memory.
因为你可以使用共享内存。

1109
01:09:10,520 --> 01:09:14,500
You can use the other space which is already shared between the stress,
你可以使用已经在压力之间共享的其他空间。

1110
01:09:14,510 --> 01:09:15,900
to communicate, between the stress,
在压力之间进行沟通

1111
01:09:18,170 --> 01:09:19,520
between processes.
进程之间的通信。

1112
01:09:20,010 --> 01:09:22,820
You need to communicate through other means,
你需要通过其他方式进行沟通。

1113
01:09:23,300 --> 01:09:25,620
and you need to contact you between the processes,
你需要在进程之间进行联系，

1114
01:09:25,890 --> 01:09:26,990
which is far more expensive.
这要贵得多。

1115
01:09:29,280 --> 01:09:32,850
And typical in application consist of one or more processes.
典型的应用程序由一个或多个进程组成。

1116
01:09:32,860 --> 01:09:34,170
A process consists of one,
一个进程由一个或多个线程组成。

1117
01:09:34,180 --> 01:09:35,450
more one or more threats.
更多的威胁或多个威胁。

1118
01:09:40,800 --> 01:09:42,910
Here, you can see in this figure,
在这个图中，你可以看到

1119
01:09:46,010 --> 01:09:49,440
on the left hand side, you see one process with a single stretch.
在左侧，你可以看到一个具有单个进程的进程条。

1120
01:09:51,110 --> 01:09:51,550
Right?
对吗？

1121
01:09:52,170 --> 01:09:54,680
You can see what belongs you have.
你可以查看你拥有的物品。

1122
01:09:54,950 --> 01:09:58,780
The process owns is that you have the memory,
进程所拥有的是内存。

1123
01:09:59,910 --> 01:10:01,430
others, other space.
其他人，其他空间。

1124
01:10:01,440 --> 01:10:03,550
You have the code data, file,
你有代码数据、文件。

1125
01:10:03,560 --> 01:10:04,670
card file,
卡片文件

1126
01:10:04,680 --> 01:10:07,290
descriptors that I used to stack.
我使用的描述符堆栈。

1127
01:10:10,280 --> 01:10:11,950
This belongs to a process.
这属于一个进程。

1128
01:10:12,910 --> 01:10:14,300
And now on the right hand side,
现在在右侧，

1129
01:10:14,310 --> 01:10:16,140
you have different threading the same process.
你可以在同一个进程中使用不同的线程。

1130
01:10:17,380 --> 01:10:19,850
Here you can see notice at the top,
这里你可以看到顶部的通知。

1131
01:10:19,860 --> 01:10:22,850
the code and the data and the file descriptors,
代码、数据和文件描述符，

1132
01:10:22,860 --> 01:10:27,770
all these resources are shared across all the threads in the different
所有这些资源在不同的线程之间共享。

1133
01:10:28,260 --> 01:10:29,170
in the same process.
在同一个进程中。

1134
01:10:29,990 --> 01:10:34,260
What is not shared is the execution state of his thread.
不共享的是他的线程的执行状态。

1135
01:10:34,490 --> 01:10:37,310
So his thread come its own registers from its own stack.
所以他的线程从自己的堆栈中获取自己的寄存器。

1136
01:10:38,850 --> 01:10:39,260
Right?
对吗？

1137
01:10:39,510 --> 01:10:42,860
Registers includes a program counter as a stack pointer and things like that.
寄存器包括程序计数器、堆栈指针等等。

1138
01:10:43,820 --> 01:10:44,190
Okay?
好的？

1139
01:10:46,240 --> 01:10:50,050
And the address encapsulate protection.
并且地址封装保护。

1140
01:10:50,330 --> 01:10:50,540
Right?
对吗？

1141
01:10:50,550 --> 01:10:53,440
It's a passive part of the process.
这是一个过程的被动部分。

1142
01:10:53,950 --> 01:10:54,350
Right?
对吗？

1143
01:10:55,860 --> 01:10:57,560
The thread is an active part,
线程是一个活动的部分，

1144
01:10:58,020 --> 01:10:59,250
concurrent concurrence,
concurrent 并发的
concurrence 同时发生的

1145
01:10:59,260 --> 01:11:00,490
encapsulate concurrence.
封装并发性。

1146
01:11:09,000 --> 01:11:09,600
Why?
为了方便理解和交流，我会将英文翻译成中文。这样可以确保信息的准确传达，并帮助您更好地理解所提供的内容。如果您有任何问题或需要进一步的帮助，请随时告诉我。

1147
01:11:09,610 --> 01:11:13,010
Multiple stress for other space?
其他空间的多重压力？

1148
01:11:20,550 --> 01:11:20,860
Too bad?
很遗憾？

1149
01:11:20,870 --> 01:11:21,540
You cannot.
你不能。

1150
01:11:21,790 --> 01:11:23,540
It's hard to have this question answering.
回答这个问题很困难。

1151
01:11:23,550 --> 01:11:26,730
You have in the class on this web another.
你在这个网页上有另一个班级。

1152
01:11:29,600 --> 01:11:34,480
But you want to have more because you want to
但是你想要更多，因为你想要

1153
01:11:37,910 --> 01:11:41,650
build higher performance applications.
构建更高性能的应用程序。

1154
01:11:42,980 --> 01:11:46,670
Like, for instance, if you have an application which is doing,
例如，如果你有一个正在运行的应用程序，它正在执行...

1155
01:11:46,680 --> 01:11:51,860
you have waiting from the keyboard and they're doing some processing
你正在等待键盘输入，并且正在进行一些处理。

1156
01:11:51,870 --> 01:11:53,940
like rendering graphics and things like that.
比如渲染图形和类似的东西。

1157
01:11:54,390 --> 01:12:00,240
You are and a as a result of what are the users?
你是什么样的用户，是由什么结果导致的？

1158
01:12:00,250 --> 01:12:02,730
It's users input.
这是用户的输入。

1159
01:12:03,490 --> 01:12:06,310
Then you are going to have two threads.
那么你将会有两个线程。

1160
01:12:07,190 --> 01:12:10,980
You want this stress to communicate between others to send the user input
你希望这种压力能够在其他人之间传递，以发送用户输入。

1161
01:12:12,520 --> 01:12:13,630
To the thread,
回复该帖子，

1162
01:12:13,640 --> 01:12:14,950
which is being rendering.
正在进行渲染的是哪个？

1163
01:12:15,400 --> 01:12:18,030
You want these two threads to be in the same process.
你希望这两个线程在同一个进程中。

1164
01:12:18,040 --> 01:12:19,790
If they are not in the same processes,
如果它们不在同一个进程中，

1165
01:12:20,230 --> 01:12:22,200
then you're going to be in a different process.
那么你将会处于一个不同的进程中。

1166
01:12:22,210 --> 01:12:24,700
You need to incur contact switching and see like that,
你需要进行上下文切换并进行类似的操作。

1167
01:12:25,070 --> 01:12:26,890
which is going to be much less efficient.
这将会效率低下得多。

1168
01:12:28,890 --> 01:12:29,890
That's one example.
这是一个例子。

1169
01:12:32,250 --> 01:12:34,040
Some example, some questions.
一些例子，一些问题。

1170
01:12:34,050 --> 01:12:34,480
Now,
现在，

1171
01:12:36,020 --> 01:12:39,250
how can application have multiple processes?
应用程序如何拥有多个进程？

1172
01:12:39,880 --> 01:12:44,070
Is it if it needs multiple instances of a CPU or something?
这是指如果需要多个CPU实例吗？

1173
01:12:44,740 --> 01:12:46,810
What the practical reasoning for this,
这的实际理由是什么？

1174
01:12:46,820 --> 01:12:48,290
I thought it was 1~1.
我以为是1~1。

1175
01:12:52,150 --> 01:12:53,860
There are many reasons,
有很多原因，

1176
01:12:53,870 --> 01:12:57,780
a multiple and application can have multiple processes.
一个多线程应用程序可以有多个进程。

1177
01:12:57,790 --> 01:13:00,440
And let me give you an extreme example.
让我给你举个极端的例子。

1178
01:13:00,450 --> 01:13:03,820
And then you can imagine that will happen also on a single machine.
然后你可以想象这也会发生在一台单独的机器上。

1179
01:13:03,830 --> 01:13:09,200
An application like Facebook has obviously multiple processes because runs
像Facebook这样的应用显然有多个进程，因为它需要同时运行多个任务。

1180
01:13:09,210 --> 01:13:10,400
on different machines.
在不同的机器上。

1181
01:13:10,990 --> 01:13:13,390
You have one part which is running on your machine.
你的机器上有一个正在运行的部分。

1182
01:13:13,400 --> 01:13:14,430
It's the front end,
这是前端。

1183
01:13:14,670 --> 01:13:17,580
and then a path which is running on the back end.
然后是在后端运行的路径。

1184
01:13:18,160 --> 01:13:18,530
Right?
对吗？

1185
01:13:19,710 --> 01:13:24,860
You can imagine many of these applications like that could be client and server.
你可以想象很多这样的应用程序可以是客户端和服务器之间的关系。

1186
01:13:24,870 --> 01:13:27,750
Some are part of the application is handling, say,
一些部分是应用程序处理的，比如说，

1187
01:13:27,760 --> 01:13:29,300
an access to the database.
对数据库的访问权限。

1188
01:13:29,310 --> 01:13:38,130
And some part of the application is handling the front end.
应用程序的一部分负责处理前端。

1189
01:13:38,670 --> 01:13:40,780
Then you can have a multi user application,
那么你可以拥有一个多用户应用程序。

1190
01:13:40,790 --> 01:13:43,580
and then you want to isolate the user from each other
然后你想要将用户彼此隔离开来

1191
01:13:43,590 --> 01:13:46,940
in the same application for each year that you are going to provide
在您提供的每年的同一应用程序中

1192
01:13:46,950 --> 01:13:48,980
the different process,
不同的进程

1193
01:13:48,990 --> 01:13:49,200
right?
对的吗？

1194
01:13:49,720 --> 01:13:54,010
Or you want to process to have stronger isolation, like, for instance,
或者你希望进程具有更强的隔离性，例如，

1195
01:13:54,020 --> 01:13:54,850
in your browser,
在你的浏览器中，

1196
01:13:55,470 --> 01:13:57,360
in your browser, you have different taps.
在你的浏览器中，你有不同的标签页。

1197
01:13:58,130 --> 01:13:59,840
And if every tap is,
如果每个水龙头都是的话，

1198
01:14:01,050 --> 01:14:04,580
you run it in the same process,
你在同一个进程中运行它。

1199
01:14:04,970 --> 01:14:08,590
then you have no protection.
那么你就没有保护措施了。

1200
01:14:09,220 --> 01:14:13,540
Therefore, a misbehaving web page can crash your browser.
因此，一个行为不端的网页可能会导致你的浏览器崩溃。

1201
01:14:16,320 --> 01:14:19,780
If you have each other process and you have strong isolation between processes.
如果你有多个进程，并且进程之间有强大的隔离性。

1202
01:14:19,790 --> 01:14:21,740
So these are quite a few examples.
这是相当多的例子。

1203
01:14:22,020 --> 01:14:22,520
Now,
现在，

1204
01:14:23,420 --> 01:14:24,860
we are not going in details,
我们不会深入细节。

1205
01:14:24,870 --> 01:14:29,880
but there are more things between processes and threads.
但是进程和线程之间还有更多的东西。

1206
01:14:30,290 --> 01:14:34,680
There are actually other ways people try to maintain the efficiency
实际上，人们还尝试了其他方法来保持效率。

1207
01:14:34,690 --> 01:14:36,520
to preserve the efficiency of the thread,
为了保持线程的效率，

1208
01:14:36,870 --> 01:14:41,420
but are some protection which you have for across from processes.
但是有一些保护措施可以防止进程之间的干扰。

1209
01:14:41,940 --> 01:14:44,230
We are not going to discuss about this, though,
我们不打算讨论这个问题，不过，

1210
01:14:45,340 --> 01:14:47,000
but hopefully answer that question,
但希望能回答那个问题，

1211
01:14:49,150 --> 01:14:51,420
that attack doesn't depend on waiting,
这种攻击不依赖于等待。

1212
01:14:51,430 --> 01:14:54,140
can take over while the other is waiting,
当一个正在等待时，另一个可以接管。

1213
01:14:54,150 --> 01:14:56,140
even if the superior is multiplex.
即使上级是多路复用的。

1214
01:15:00,940 --> 01:15:02,490
I'm afraid I don't.
很抱歉，我不知道。

1215
01:15:03,740 --> 01:15:05,430
This is a statement I
这是一个声明。

1216
01:15:16,940 --> 01:15:17,330
that.
那个。

1217
01:15:17,640 --> 01:15:19,710
But what the statement said is correct.
但是这个陈述是正确的。

1218
01:15:19,720 --> 01:15:21,550
The task which doesn't depend on waiting,
不依赖于等待的任务

1219
01:15:21,560 --> 01:15:24,230
can take over the task which depends on waiting.
可以接管依赖等待的任务。

1220
01:15:24,430 --> 01:15:29,200
Is it going to be suspended to wait for some part and so on and on a task
这个任务会被暂停等待某个部分的完成，以及其他相关的任务。

1221
01:15:29,210 --> 01:15:32,730
which a process which waits for an event to happen?
一个等待事件发生的进程是什么？

1222
01:15:33,320 --> 01:15:38,690
Like getting an input event from getting some data from the network
从网络获取数据时，可以通过获取输入事件来实现。

1223
01:15:39,220 --> 01:15:43,260
is suspended and waiting for that event to happen.
被暂停，并等待事件发生。

1224
01:15:43,270 --> 01:15:45,980
And during that time another process can run.
在此期间，另一个进程可以运行。

1225
01:15:46,230 --> 01:15:48,790
The operating system can takes care of that.
操作系统可以处理这个。

1226
01:15:53,940 --> 01:15:54,430
Okay?
好的？

1227
01:15:56,090 --> 01:16:00,850
First, finally, the force operating system concept is dual mode operation.
首先，最终，操作系统的核心概念是双模式运行。

1228
01:16:01,140 --> 01:16:08,880
The old mode operation is fundamentally concern about how you are going to share
旧模式操作主要关注的是如何共享资源。

1229
01:16:09,270 --> 01:16:11,240
the hardware,
硬件

1230
01:16:11,600 --> 01:16:16,780
the machine between processes,
进程之间的机器

1231
01:16:16,790 --> 01:16:18,860
the user processes and the operating system.
用户进程和操作系统。

1232
01:16:21,750 --> 01:16:22,580
Typically, this happens.
通常情况下，会发生这种情况。

1233
01:16:22,590 --> 01:16:24,260
You have 2 months for that.
你有两个月的时间来完成。

1234
01:16:24,270 --> 01:16:25,660
You have a user mode,
你有一个用户模式，

1235
01:16:26,570 --> 01:16:29,320
which is used when you run a user process.
当运行用户进程时使用的是什么？

1236
01:16:29,650 --> 01:16:30,960
And the kernel amount,
和内核数量,

1237
01:16:31,170 --> 01:16:33,330
which is used on the operating system runs.
这是在操作系统上运行的。

1238
01:16:33,870 --> 01:16:39,480
The reason for that is the operating system actually has access to a lot
这是因为操作系统实际上可以访问很多资源。

1239
01:16:39,490 --> 01:16:41,640
of more resources and
更多资源和

1240
01:16:41,650 --> 01:16:47,990
even to processes resources during when it is running.
即使在运行过程中，进程也需要使用资源。

1241
01:16:48,620 --> 01:16:48,930
Right?
对吗？

1242
01:16:50,190 --> 01:16:53,460
The way to differentiate between these two mouths is you have a bit.
区分这两个嘴的方法是你需要一点儿。

1243
01:16:55,350 --> 01:16:57,680
It's a user system mode beat.
这是一个用户系统模式的节拍。

1244
01:16:58,560 --> 01:17:00,310
When you set to zero, for instance,
当你将其设置为零时，例如，

1245
01:17:00,320 --> 01:17:01,550
it's a user mode.
这是用户模式。

1246
01:17:01,890 --> 01:17:03,490
He said to one is kernel mode,
他说的是内核模式。

1247
01:17:08,020 --> 01:17:15,420
how the transition happened from a user process to a kernel to the happens
用户进程向内核的转换是通过系统调用实现的。系统调用是用户进程通过特定的指令向操作系统请求服务的一种机制。当用户进程需要执行一些只有内核才能完成的操作时，例如文件操作、网络通信或者内存管理，它会通过系统调用将控制权转交给内核。

在系统调用发生时，用户进程的执行被暂停，操作系统会保存用户进程的上下文信息，包括寄存器的状态和程序计数器的值。然后，操作系统会根据系统调用的类型，执行相应的内核代码来完成用户进程请求的操作。完成后，操作系统会将结果返回给用户进程，并恢复用户进程的上下文，使其继续执行。

这种从用户进程到内核的转换是通过特权级的切换实现的。用户进程运行在用户态，拥有较低的特权级，而内核运行在内核态，拥有较高的特权级。当用户进程发起系统调用时，会触发特权级的切换，使得用户进程的特权级提升到内核态，从而可以执行内核代码。完成系统调用后，特权级会再次切换回用户态，用户进程继续在用户态执行。

总结起来，用户进程向内核的转换是通过系统调用和特权级的切换实现的。系统调用是用户进程与内核之间的接口，特权级的切换则是确保只有内核才能执行特定的操作。

1248
01:17:15,880 --> 01:17:17,620
from the user to kernel.
从用户到内核。

1249
01:17:17,860 --> 01:17:20,460
You set the system out now,
你现在设置系统。

1250
01:17:22,840 --> 01:17:25,080
save the user program counters.
保存用户程序计数器。

1251
01:17:26,720 --> 01:17:35,270
And all the state of that particular thread execution state.
以及该特定线程的执行状态的所有状态。

1252
01:17:35,280 --> 01:17:36,550
And then from the care number,
然后从关心号码开始，

1253
01:17:36,560 --> 01:17:37,710
they use their transition.
他们使用他们的过渡。

1254
01:17:37,720 --> 01:17:42,780
You clear, the system and restored as an appropriate user program counter.
你清除了系统，并将其恢复为适当的用户程序计数器。

1255
01:17:43,480 --> 01:17:43,780
Right?
对吗？

1256
01:17:44,740 --> 01:17:51,070
And you return from the interrupt.
然后你从中断返回。

1257
01:17:51,410 --> 01:17:54,310
And here how you,
这是你的操作方式，

1258
01:17:54,320 --> 01:17:57,270
as a user mode and the kennel mode interact with each other.
用户模式和内核模式相互交互。

1259
01:17:57,280 --> 01:17:58,390
So on one hand,
一方面，

1260
01:17:58,980 --> 01:18:00,920
from the canon mode, you have exact.
从标准模式下，你是准确的。

1261
01:18:00,930 --> 01:18:05,760
And this is how you run a process that throw you the kernel.
这是如何运行一个会导致内核错误的进程。

1262
01:18:05,770 --> 01:18:09,110
And the operating system is launching a new process.
操作系统正在启动一个新的进程。

1263
01:18:11,770 --> 01:18:14,080
Then when the process exits,
然后当进程退出时，

1264
01:18:14,090 --> 01:18:15,400
you return to the kernel.
你返回到内核。

1265
01:18:15,410 --> 01:18:17,960
The kernel is taking care of freeing all the resources,
内核负责释放所有资源。

1266
01:18:17,970 --> 01:18:19,200
allocated that process.
分配给该进程的资源。

1267
01:18:19,210 --> 01:18:21,000
So these processes, these are resources,
所以这些进程，这些是资源，

1268
01:18:21,500 --> 01:18:23,140
can be used by other processes.
可以被其他进程使用。

1269
01:18:23,800 --> 01:18:25,450
Then it's a system call.
那么这就是一个系统调用。

1270
01:18:26,540 --> 01:18:28,650
This is one operating system.
这是一个操作系统。

1271
01:18:28,660 --> 01:18:32,170
I'm sorry, when the user process requires some functionality,
很抱歉，当用户进程需要某些功能时，

1272
01:18:32,180 --> 01:18:36,380
some services invoke some services from the operating system.
一些服务从操作系统中调用其他服务。

1273
01:18:37,010 --> 01:18:39,960
Example of some services like accessing a file,
例如，访问文件的一些服务，

1274
01:18:40,480 --> 01:18:41,710
sending some data,
正在发送一些数据，

1275
01:18:44,160 --> 01:18:46,790
reading input data from the keyboard.
从键盘读取输入数据。

1276
01:18:48,430 --> 01:18:49,500
This is return,
这是返回值。

1277
01:18:49,510 --> 01:18:53,300
this is after the operating system satisfies this request,
这是在操作系统满足此请求之后。

1278
01:18:53,840 --> 01:18:56,810
then is returning control back to the user.
然后将控制权返回给用户。

1279
01:18:59,280 --> 01:19:02,160
And then there are user interrupts.
然后还有用户中断。

1280
01:19:03,150 --> 01:19:04,500
The user interacts.
用户进行交互。

1281
01:19:05,700 --> 01:19:09,650
One example is basically you can have a secure,
一个例子就是你可以拥有一个安全的，

1282
01:19:09,660 --> 01:19:12,720
you can actually kill a process.
你实际上可以终止一个进程。

1283
01:19:15,620 --> 01:19:18,530
That's one example, a of a user interrupt.
这是一个例子，一个用户中断的例子。

1284
01:19:20,680 --> 01:19:21,950
There are also interrupted,
还有中断，

1285
01:19:21,960 --> 01:19:23,230
come from the hardware,
来自硬件

1286
01:19:23,650 --> 01:19:26,690
like when packet arrives,
当数据包到达时，

1287
01:19:27,470 --> 01:19:30,910
when you click on a keyboard,
当你点击键盘时，

1288
01:19:31,530 --> 01:19:33,270
then you have an interrupt.
那么你遇到了一个中断。

1289
01:19:33,630 --> 01:19:36,070
The operator gives a mystery, the symbols.
操作员给出了一个谜题，即符号。

1290
01:19:37,290 --> 01:19:37,740
Okay?
好的？

1291
01:19:39,050 --> 01:19:40,840
Then you can return from the interrupt.
然后你可以从中断中返回。

1292
01:19:40,850 --> 01:19:41,880
It's a user level interrupt.
这是一个用户级中断。

1293
01:19:41,890 --> 01:19:43,920
You return to the internet from the interrupt,
你从中断中返回到互联网。

1294
01:19:43,930 --> 01:19:45,520
the returns, a control,
返回值，控制

1295
01:19:45,530 --> 01:19:48,660
eventually to the user.
最终传递给用户。

1296
01:19:49,450 --> 01:19:52,340
And finally,
最后，

1297
01:19:52,350 --> 01:19:53,740
there are exceptions.
有一些例外情况。

1298
01:19:53,970 --> 01:20:01,950
And exceptions are when the user of somehow
异常是指用户以某种方式

1299
01:20:01,960 --> 01:20:05,410
the program is doing something which is not allowed,
程序正在执行一些不允许的操作。

1300
01:20:05,750 --> 01:20:08,900
like or for instance,
例如，比如说，

1301
01:20:08,910 --> 01:20:10,540
you can have division by zero.
你可以进行除以零的操作。

