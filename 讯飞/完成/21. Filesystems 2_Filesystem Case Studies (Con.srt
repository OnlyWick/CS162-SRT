1
00:00:23,790 --> 00:00:24,550
Hello, everyone.
大家好。

2
00:00:25,490 --> 00:00:29,520
So today we are going to continue our discussion about file systems.
今天我们将继续讨论文件系统的话题。

3
00:00:31,740 --> 00:00:32,410
In particular,
特别是，

4
00:00:32,420 --> 00:00:39,650
we are going to go through a few examples to see how some of the most popular
我们将通过一些例子来看看一些最受欢迎的方法。

5
00:00:40,670 --> 00:00:44,790
file systems in the past have been implemented.
过去已经实现了各种文件系统。

6
00:00:46,330 --> 00:00:49,910
First, to to recall,
首先，回顾一下，

7
00:00:51,130 --> 00:00:58,580
these are the main data structures which are maintained in the by file system.
这些是文件系统中维护的主要数据结构。

8
00:00:59,290 --> 00:00:59,940
First of all,
首先，

9
00:01:01,500 --> 00:01:03,970
we are going to have a directory structures,
我们将要有一个目录结构。

10
00:01:05,590 --> 00:01:07,660
which is it's an article.
这是一篇文章。

11
00:01:08,240 --> 00:01:13,250
And here you are going to use a file pass to locate a particular file
在这里，您将使用文件路径来定位特定的文件。

12
00:01:13,260 --> 00:01:15,210
in this directory structure.
在这个目录结构中。

13
00:01:16,860 --> 00:01:19,010
And entering the indirectory structures,
进入索引目录结构，

14
00:01:19,020 --> 00:01:22,180
associate the file with an eye number,
将文件与一个唯一的编号关联起来，

15
00:01:22,190 --> 00:01:23,900
an eye number.
一个眼睛数字。

16
00:01:23,910 --> 00:01:30,450
It's an index in index structure called file header structure.
这是索引结构中的一个索引，称为文件头结构。

17
00:01:31,140 --> 00:01:36,560
And this index points to what is called an inode.
这个索引指向的是所谓的inode。

18
00:01:37,420 --> 00:01:43,580
The I node contains all the information which is relevant to the file,
I节点包含与文件相关的所有信息。

19
00:01:43,590 --> 00:01:50,270
and which help the operating system to locate the data for that file
并且帮助操作系统定位该文件的数据

20
00:01:50,280 --> 00:01:51,440
on the disk.
在磁盘上。

21
00:01:55,160 --> 00:01:58,490
The first case we are going to go over.
我们要讨论的第一个案例。

22
00:01:58,500 --> 00:02:03,460
It's a fat stands for the final location table.
这是 FAT 的缩写，代表最终位置表。

23
00:02:03,940 --> 00:02:09,310
And this was the first file system
这是第一个文件系统。

24
00:02:14,430 --> 00:02:16,150
employed by microsoft.
受雇于微软。

25
00:02:16,400 --> 00:02:17,910
This operating system,
这个操作系统，

26
00:02:17,920 --> 00:02:23,390
which is the first operating system released by microsoft all the way in 1977.
微软在1977年发布的第一个操作系统是哪个？

27
00:02:24,900 --> 00:02:27,050
It's still quite used today.
它在今天仍然被广泛使用。

28
00:02:27,060 --> 00:02:30,950
I despise after what after 50,
我讨厌在50岁之后。

29
00:02:32,510 --> 00:02:35,680
50, 40 years of 44 years, right?
对的，50减去40等于10年，再加上44年，总共是54年。

30
00:02:37,800 --> 00:02:40,150
And the fact,
事实上，

31
00:02:40,800 --> 00:02:41,110
look,
看着吧，

32
00:02:41,830 --> 00:02:45,020
is aa file system is quite simple.
aa文件系统非常简单。

33
00:02:45,030 --> 00:02:47,280
Let me just so first of all,
首先让我这样做，

34
00:02:47,290 --> 00:02:52,010
what you have here on the right,
你在右边看到的是什么？

35
00:02:52,020 --> 00:02:54,250
it's a blocks on the disk,
它是磁盘上的数据块。

36
00:02:54,970 --> 00:02:59,000
and that these blocks and you have a file.
并且这些块和你有一个文件。

37
00:02:59,440 --> 00:03:01,920
For each file, you have whether the block is.
对于每个文件，你需要知道每个块是否存在。

38
00:03:02,410 --> 00:03:04,280
Each file has a bunch of blocks.
每个文件都有一堆数据块。

39
00:03:08,490 --> 00:03:10,660
Like they say the 456,
就像他们说的那样，456。

40
00:03:10,880 --> 00:03:15,230
31, this is where the disk are located.
31，这是磁盘所在的位置。

41
00:03:17,090 --> 00:03:20,580
And then you need to maintaining the fat table,
然后你需要维护文件分配表。

42
00:03:20,830 --> 00:03:22,710
a pointer or the item,
指针或者项目

43
00:03:22,720 --> 00:03:26,400
the offer to where the disk is locked,
磁盘被锁定的位置的提供

44
00:03:27,230 --> 00:03:28,500
the blocks are located.
块的位置。

45
00:03:30,510 --> 00:03:34,330
Therefore, to the I number of,
因此，对于我来说，数量是很重要的。

46
00:03:35,980 --> 00:03:37,980
sorry, to the index of that block,
抱歉，对于该块的索引，

47
00:03:39,000 --> 00:03:39,870
that this block,
这个块，

48
00:03:40,600 --> 00:03:43,140
you can think about of an array of blocks,
你可以考虑一个块数组，

49
00:03:43,840 --> 00:03:46,630
each blocks has a identifier,
每个块都有一个标识符。

50
00:03:46,640 --> 00:03:48,830
is typically it's a logical identifier,
通常它是一个逻辑标识符。

51
00:03:49,110 --> 00:03:50,420
which is mapped, then,
然后，被映射的是哪个部分？

52
00:03:50,430 --> 00:03:52,260
on a physical identifier as it is.
按照物理标识符的原样。

53
00:03:53,210 --> 00:04:01,790
And the fat maintains a mapping between the files and the list of blocks
FAT（文件分配表）维护了文件与块列表之间的映射关系。

54
00:04:01,800 --> 00:04:03,030
identify as logical,
自我认定为逻辑的。

55
00:04:03,040 --> 00:04:03,830
identify as.
身份认同为。

56
00:04:05,910 --> 00:04:08,150
So how does fat maintain that?
那么，FAT是如何维护这一点的呢？

57
00:04:10,210 --> 00:04:10,780
It's,
这是

58
00:04:11,630 --> 00:04:18,660
again, this is maintained in I the I note it's indexed by the I number.
再次强调，这是由我维护的笔记，它按照编号进行索引。

59
00:04:19,680 --> 00:04:22,520
Let's assume that the file number here is 31.
假设这里的文件号是31。

60
00:04:23,660 --> 00:04:26,580
And the fact is just basically a linguist.
事实上，基本上只是一个语言学家。

61
00:04:27,650 --> 00:04:32,080
Each link, each entry in the linked list corresponds to a block of a file.
每个链接，每个链表中的条目对应于文件的一个块。

62
00:04:32,840 --> 00:04:36,660
And each entry will maintain the index of a block,
每个条目将维护一个块的索引。

63
00:04:37,380 --> 00:04:41,850
and then a pointer to the next entry,
然后是指向下一个条目的指针。

64
00:04:42,340 --> 00:04:43,880
which points to the next block.
指向下一个块的指针。

65
00:04:44,890 --> 00:04:45,310
Okay?
好的？

66
00:04:46,570 --> 00:04:50,980
He has assumed that you are going to have in three,
他假设你将在三天内到达。

67
00:04:51,260 --> 00:04:53,730
a three blocks in this 501, and 2.
这个501中有三个块，其中有2个。

68
00:04:53,740 --> 00:04:57,840
You have three corresponding entries in the fat table.
你在FAT表中有三个对应的条目。

69
00:04:58,240 --> 00:05:03,350
And each entry will have an index to a corresponding block,
每个条目将具有指向相应块的索引。

70
00:05:03,360 --> 00:05:05,750
and then a pointer to the next entry.
然后是指向下一个条目的指针。

71
00:05:06,660 --> 00:05:13,020
It's the next entry in the in this
这是在这个里面的下一个条目。

72
00:05:17,300 --> 00:05:18,650
to the next entry,
到下一个条目，

73
00:05:18,660 --> 00:05:21,290
corresponding to the next block in the file.
对应于文件中的下一个块。

74
00:05:23,930 --> 00:05:24,560
Also,
另外，

75
00:05:25,490 --> 00:05:29,760
when i'm opening a file and other important data,
当我打开一个文件和其他重要数据时，

76
00:05:29,770 --> 00:05:33,080
I need is basically the offset.
我需要的基本上是偏移量。

77
00:05:33,600 --> 00:05:36,900
So I what is the current position in the file?
那么，我当前在文件中的位置是什么？

78
00:05:37,270 --> 00:05:43,350
The current position in the file here is given by a the first couple is
文件中的当前位置由第一个元组给出。

79
00:05:43,360 --> 00:05:46,180
a block in the file.
文件中的一个块。

80
00:05:46,190 --> 00:05:51,460
And the second and part of the double,
和第二个部分以及双倍的一部分，

81
00:05:52,490 --> 00:05:54,810
it's basically the offset within that block.
它基本上是该块内的偏移量。

82
00:06:01,630 --> 00:06:02,340
The question is,
问题是，

83
00:06:02,350 --> 00:06:06,540
what does x the second element of the two x double comes into the place?
x的第二个元素进入了两个x double的位置。

84
00:06:06,550 --> 00:06:09,950
Again, x it's offset within the block two.
再次，x是在块二中的偏移量。

85
00:06:09,960 --> 00:06:11,120
In this case.
在这种情况下。

86
00:06:16,520 --> 00:06:22,860
That's why in order to access the data here for from block two,
这就是为什么要从块二中访问这里的数据。

87
00:06:23,090 --> 00:06:24,720
you start from block zero,
你从块零开始，

88
00:06:24,730 --> 00:06:28,680
then you have to follow the link list to block one, then to block two.
然后你需要按照链表的顺序访问块一，然后访问块二。

89
00:06:28,850 --> 00:06:29,680
Now it block two.
现在它阻塞了两个。

90
00:06:29,690 --> 00:06:31,320
This is a block I care about.
这是我关心的一个块。

91
00:06:31,570 --> 00:06:33,280
Now I can read three block two.
现在我可以读取三个块中的两个。

92
00:06:34,240 --> 00:06:37,190
Then i'm going to the offset x within the block two.
然后我要去块二中的偏移量x处。

93
00:06:42,500 --> 00:06:44,850
It's a very simple technique.
这是一个非常简单的技术。

94
00:06:45,540 --> 00:06:47,980
Now you read the block two in the memory,
现在你要读取内存中的第二个块。

95
00:06:47,990 --> 00:06:51,140
and then you access offset x within that.
然后你在其中访问偏移量 x。

96
00:06:56,140 --> 00:06:59,150
Again, it's the file,
再次，这是文件。

97
00:06:59,160 --> 00:07:01,910
like it's a collection of blocks.
就像是一个块的集合。

98
00:07:02,300 --> 00:07:09,570
And each entry in this link listing the fat link list corresponds to a block.
这个链接列表中的每个条目对应一个块。

99
00:07:11,470 --> 00:07:19,250
And the file number is
文件编号是

100
00:07:19,260 --> 00:07:22,050
basically the file number for simplicity.
基本上是为了简单起见的文件编号。

101
00:07:22,450 --> 00:07:23,460
In the case,
在这种情况下，

102
00:07:23,470 --> 00:07:24,750
of fact,
事实上，

103
00:07:25,180 --> 00:07:29,480
it's exactly the index of the roadblock.
这正是路障的索引位置。

104
00:07:31,190 --> 00:07:33,300
In the file, in this case, 31.
在这个文件中，这种情况下是31。

105
00:07:33,310 --> 00:07:38,380
It's also the index of the roadblock on the disk.
它也是磁盘上障碍物的索引。

106
00:07:41,110 --> 00:07:41,780
Okay.
好的。

107
00:07:42,190 --> 00:07:44,740
So what about, obviously,
那么，显然，

108
00:07:45,360 --> 00:07:49,750
what about three blocks?
三个块怎么样？

109
00:07:51,690 --> 00:07:54,620
You need three blocks in order, obviously,
显然，你需要按顺序使用三个块。

110
00:07:54,630 --> 00:07:56,310
to extend the file.
扩展文件。

111
00:07:56,320 --> 00:08:00,840
Remember that the file extends expands as you write more in the file.
请记住，随着在文件中写入更多内容，文件的大小会扩展增大。

112
00:08:02,150 --> 00:08:04,940
So there are four or four new files you need to follow.
所以有四个或四个新文件你需要跟进。

113
00:08:04,950 --> 00:08:06,620
If you want to write the new files,
如果你想要写入新文件，

114
00:08:06,630 --> 00:08:13,320
you need to to look to find the three blocks.
你需要去找到这三个块。

115
00:08:13,330 --> 00:08:17,680
Typically, there are two ways to to manage these three blocks.
通常有两种方法来管理这三个块。

116
00:08:18,000 --> 00:08:20,240
One is to have a list of three blocks.
一种方法是拥有一个由三个块组成的列表。

117
00:08:21,330 --> 00:08:23,740
The other one, you can have a big map of it,
另一个，你可以有一个大的地图。

118
00:08:23,990 --> 00:08:26,130
333 blocks.
333个块。

119
00:08:26,450 --> 00:08:28,620
So basically, in this opinion case,
基本上，在这个观点案例中，

120
00:08:28,630 --> 00:08:29,980
you have for each block,
对于每个块，你有

121
00:08:29,990 --> 00:08:32,750
you have a bit1 or 01.
你有一个位1或01。

122
00:08:32,760 --> 00:08:36,260
If it's that block is not free,
如果该块不是空闲的，

123
00:08:36,270 --> 00:08:38,120
it's used by a file zero.
它被一个文件用作零。

124
00:08:38,130 --> 00:08:39,050
If it's free.
如果是免费的。

125
00:08:40,140 --> 00:08:41,210
This is how you find it.
这是你找到它的方法。

126
00:08:42,240 --> 00:08:44,190
In this particular case, for instance,
在这个特定的情况下，例如，

127
00:08:44,400 --> 00:08:47,990
you are going to write if the file for now has only three blocks,
你现在要写的是，如果文件只有三个块的情况下，

128
00:08:48,380 --> 00:08:53,360
you want to write to more data.
你想要写入更多的数据。

129
00:08:53,690 --> 00:08:54,600
Like in this case,
就像在这种情况下，

130
00:08:54,610 --> 00:08:58,880
I want to write in 571 in block c this means the first block.
我想在块c的第571个位置写入数据，这意味着第一个块。

131
00:08:59,330 --> 00:09:00,600
Then what happens?
然后会发生什么？

132
00:09:00,610 --> 00:09:03,280
Again, the file of the operating system,
再次提到操作系统的文件，

133
00:09:03,290 --> 00:09:05,240
the file system expands the file,
文件系统扩展了文件。

134
00:09:05,570 --> 00:09:08,200
and finds on bikes,
并在自行车上发现的东西，

135
00:09:08,210 --> 00:09:10,920
finding a new block in the empty list,
在空列表中找到一个新的块。

136
00:09:11,320 --> 00:09:12,390
and then allocating that block.
然后分配该块。

137
00:09:12,400 --> 00:09:14,820
And now that block is part of the file.
现在该块已经成为文件的一部分。

138
00:09:15,170 --> 00:09:19,790
And it's also part of the linked list of all the blocks which belong
它也是属于所有块的链表的一部分

139
00:09:19,800 --> 00:09:24,620
to that file.
将其保存到该文件中。

140
00:09:28,240 --> 00:09:28,730
Now,
现在，

141
00:09:29,430 --> 00:09:30,620
what is passed out?
"passed out" 可以有两种不同的含义：

1. 在口语中，"passed out" 意味着昏倒或失去意识。例如，如果一个人因为疲劳或酒精过量而失去意识，我们可以说他们 "passed out"。

2. 在某些上下文中，"passed out" 可以指分发或分发物品。例如，如果一个人在一次会议上分发文件或材料，我们可以说他们 "passed out" 这些文件。

请根据上下文判断具体含义。

142
00:09:31,100 --> 00:09:33,350
So again, this is persistent storage.
所以，这是持久性存储。

143
00:09:33,360 --> 00:09:39,440
All these modifications needs to persist after I am going.
所有这些修改都需要在我离开后保持不变。

144
00:09:39,450 --> 00:09:40,720
I write a file.
我写了一个文件。

145
00:09:40,960 --> 00:09:42,750
For instance, I modify the file,
例如，我修改了文件。

146
00:09:42,760 --> 00:09:45,190
and then I close the application, because next time,
然后我关闭了应用程序，因为下次

147
00:09:45,200 --> 00:09:47,550
when I open the application and I want to read the files,
当我打开应用程序并想要读取文件时，

148
00:09:47,560 --> 00:09:49,700
I want my changes to be reflected.
我希望我的更改能够反映出来。

149
00:09:49,950 --> 00:09:51,540
Therefore, by default,
因此，默认情况下，

150
00:09:52,430 --> 00:09:55,460
all this information is a fact, not only the data,
所有这些信息都是事实，不仅仅是数据。

151
00:09:55,470 --> 00:09:56,860
but also the meta data.
还有元数据。

152
00:09:57,060 --> 00:10:00,530
This has to be on persistently started in this,
这必须在持续启动中进行。

153
00:10:00,900 --> 00:10:02,490
and the obvious place to be started.
显然，开始的明显地方。

154
00:10:02,500 --> 00:10:03,690
It's on the risk.
有风险。

155
00:10:07,840 --> 00:10:09,750
How do you format a disk?
如何格式化磁盘？

156
00:10:10,400 --> 00:10:14,790
Do you know what formatting a disk mean for people?
你知道对于人们来说，格式化磁盘是什么意思吗？

157
00:10:26,710 --> 00:10:28,150
So formatting meaning,
格式化的意思是，将存储设备（如硬盘、闪存等）上的数据进行清除，并重新设置文件系统以便存储新的数据。格式化可以完全擦除存储设备上的所有数据，并为其创建一个新的文件系统，使其能够被操作系统识别和使用。

158
00:10:29,360 --> 00:10:31,070
I want to make the discus new,
我想让这个讨论变得新鲜。

159
00:10:32,110 --> 00:10:32,460
right?
对的？

160
00:10:33,170 --> 00:10:35,160
I want to basically erase everything.
我想基本上抹掉所有东西。

161
00:10:36,330 --> 00:10:40,880
The way you do it is basically your zeros of locks.
你所做的方式基本上是锁的零点。

162
00:10:41,550 --> 00:10:42,870
And in the fact,
实际上，

163
00:10:42,880 --> 00:10:46,140
I will you you mark everything being free.
我会给你标记所有免费的东西。

164
00:10:48,150 --> 00:10:51,740
There is a question here from gilbert.
这里有一个来自Gilbert的问题。

165
00:10:52,160 --> 00:10:55,970
Do the blocks not have to be in order in the linguist?
在语言学中，块状物是否需要按顺序排列？

166
00:11:01,400 --> 00:11:04,420
I i'm afraid I don't know understand that question.
很抱歉，我不明白你的问题。

167
00:11:04,430 --> 00:11:05,990
Can you be more precise?
你能更具体一点吗？

168
00:11:06,000 --> 00:11:08,910
Gilbert about gilbert about this question?
关于这个问题，Gilbert有什么看法？

169
00:11:09,370 --> 00:11:13,320
Are you asking that because the link list is fundamentally ordered?
你是在问这个问题是因为链表本质上是有序的吗？

170
00:11:15,690 --> 00:11:19,360
Like block three is before the block dough.
像 block three 在 block dough 之前。

171
00:11:19,370 --> 00:11:21,920
That's exactly why we have a linguist.
这正是为什么我们有语言学家的原因。

172
00:11:22,200 --> 00:11:24,700
Because when you are going to read from a blog,
因为当你要阅读一篇博客时，

173
00:11:24,710 --> 00:11:26,860
we are going to go along the linguist.
我们打算跟着语言学家一起走。

174
00:11:28,020 --> 00:11:29,850
So that's the main point.
所以这就是主要的观点。

175
00:11:30,900 --> 00:11:32,290
In this particular case,
在这种特殊情况下，

176
00:11:33,570 --> 00:11:34,710
we are going, again,
我们再次出发了

177
00:11:34,720 --> 00:11:36,150
if you follow the linguist,
如果你遵循语言学家的话，

178
00:11:36,510 --> 00:11:40,370
the link list will link the blocks in the order is your reader.
链表将按照您的读取顺序链接块。

179
00:11:41,590 --> 00:11:45,120
They are appended to the fact that's exactly where I need a linguist
它们被附加到事实上，这正是我需要一个语言学家的地方。

180
00:11:47,520 --> 00:11:50,400
to preserve that to start that order.
为了保留那个启动顺序。

181
00:11:54,230 --> 00:12:00,750
What happens if we try to insert us something in the middle of a file for fat?
如果我们尝试在FAT文件系统的中间插入数据，会发生什么情况？

182
00:12:01,210 --> 00:12:03,720
Do we insert a new block into the linked list?
我们需要将一个新的块插入到链表中吗？

183
00:12:03,730 --> 00:12:05,320
Or is there something more clever?
还是有更聪明的方法吗？

184
00:12:05,840 --> 00:12:12,480
If you said you see in any file system and most file systems, actually,
如果你说的是在任何文件系统和大多数文件系统中都能看到的话，实际上，

185
00:12:12,930 --> 00:12:15,730
you cannot insert a block in the middle, right?
你不能在中间插入一个块，对吗？

186
00:12:15,740 --> 00:12:18,020
Because from the file system,
因为从文件系统来看，

187
00:12:18,030 --> 00:12:20,060
think about what is the interface.
思考一下什么是接口。

188
00:12:20,850 --> 00:12:23,920
You can just write to the blog,
你可以直接写博客。

189
00:12:23,930 --> 00:12:25,690
so or read from the, sorry,
所以或者从中读取，抱歉，

190
00:12:25,930 --> 00:12:28,220
you write through the file and read from the file.
你可以通过文件进行写操作和读操作。

191
00:12:28,570 --> 00:12:29,730
If you write from the file,
如果你从文件中写入数据，

192
00:12:29,740 --> 00:12:35,700
if you write a in a in a place where already contains data,
如果你在一个已经包含数据的位置写入一个a，

193
00:12:35,710 --> 00:12:37,260
you override the data,
你覆盖了数据。

194
00:12:38,250 --> 00:12:40,760
you're writing an already existing block.
你正在写一个已经存在的块。

195
00:12:41,300 --> 00:12:41,660
Right?
对吗？

196
00:12:42,020 --> 00:12:44,660
And if you're right at the end of the file,
如果你正好在文件的末尾，

197
00:12:47,300 --> 00:12:49,510
then when if you don't have,
那么如果你没有的话，那么什么时候会有呢？

198
00:12:49,990 --> 00:12:54,030
if you run out of existing at the block at the end of the file,
如果你在文件末尾运行到了不存在的块，

199
00:12:54,040 --> 00:12:55,350
you are going to add a new block.
你要添加一个新的块。

200
00:12:56,110 --> 00:12:57,420
You are going to expand the fact.
你要扩展这个事实。

201
00:13:03,340 --> 00:13:03,980
The question,
问题是什么？

202
00:13:07,450 --> 00:13:10,250
how to quick format a disk,
如何快速格式化磁盘？

203
00:13:11,560 --> 00:13:15,280
you can mark all the fat entries to free.
你可以将所有的FAT表项标记为可用。

204
00:13:17,070 --> 00:13:18,900
And this can be easily implemented.
这可以很容易地实现。

205
00:13:19,150 --> 00:13:20,860
The main.here is, again,
这里是main.h，再次提供。

206
00:13:20,870 --> 00:13:22,460
is like you can actually,
就像你实际上可以这样做一样，

207
00:13:23,040 --> 00:13:26,540
there are two ways to format it and again,
有两种方法可以进行格式化，再次进行操作。

208
00:13:26,550 --> 00:13:28,970
formal meanings in it.
在计算机操作系统中，"formal meanings" 的正式含义是指特定术语、概念或符号的确切定义或解释。这些定义通常是由操作系统的设计者或标准化组织提供的，以确保在不同的上下文中使用相同的术语时能够保持一致性和准确性。在操作系统文档、规范或标准中，"formal meanings" 通常以明确定义的方式出现，以便用户或开发人员能够理解和正确使用这些术语。

209
00:13:28,980 --> 00:13:31,960
Just you want to have the disk that's new.
你只是想要一个全新的硬盘。

210
00:13:32,740 --> 00:13:32,970
Now,
现在，

211
00:13:33,930 --> 00:13:36,900
if you just remove all the information in the fact,
如果你只是删除事实中的所有信息，

212
00:13:37,400 --> 00:13:39,100
without doing anything without these blocks,
没有做任何事情，没有这些块。

213
00:13:39,110 --> 00:13:40,750
that this block still remains,
这个块仍然存在，

214
00:13:43,370 --> 00:13:44,360
you don't zero there.
你不需要在那里清零。

215
00:13:44,950 --> 00:13:49,200
Then from the point of view of the operating of the file system,
从文件系统的角度来看，

216
00:13:49,620 --> 00:13:50,860
the disk is free.
磁盘空闲。

217
00:13:50,870 --> 00:13:55,080
You can allocate everything because you removed your reform.
你可以分配所有资源，因为你取消了你的改革。

218
00:13:55,510 --> 00:14:01,670
You just as mark all is a fat and is being free.
你只需要将所有的东西都标记为肥胖并且是免费的。

219
00:14:02,090 --> 00:14:02,250
Right?
对吗？

220
00:14:02,420 --> 00:14:05,680
You are going to allocate from the previous blocks which are written
你将从先前写入的块中分配空间。

221
00:14:05,690 --> 00:14:07,480
for a different file suggest of rights.
为不同的文件提供权限建议。

222
00:14:07,880 --> 00:14:08,460
No problem.
没问题。

223
00:14:09,030 --> 00:14:12,340
Now, obviously, this is not a hard format,
显然，这不是一个困难的格式。

224
00:14:12,350 --> 00:14:16,670
because it maintains the information from the previous files.
因为它保留了之前文件的信息。

225
00:14:17,060 --> 00:14:18,370
And typically,
通常情况下，

226
00:14:18,380 --> 00:14:19,530
when people format,
当人们进行格式化操作时，

227
00:14:19,540 --> 00:14:22,650
they also want to relate this information for security reasons.
出于安全考虑，他们还希望将这些信息相关联。

228
00:14:22,880 --> 00:14:26,900
So you need to be careful about what kind of format is going to happen
所以你需要小心发生的格式是什么样的

229
00:14:26,910 --> 00:14:27,980
on your format disc.
在您的格式化磁盘上。

230
00:14:28,570 --> 00:14:31,490
If you care about the information from your previous files,
如果你关心之前文件中的信息，

231
00:14:31,780 --> 00:14:33,210
do not be visible.
不要可见。

232
00:14:33,750 --> 00:14:35,940
Again, for instance, your hand down,
再举一个例子，比如说，你把手放下来，

233
00:14:36,380 --> 00:14:40,910
you hand back your computer to your employee or something like that.
你将你的电脑交还给你的员工或者类似的情况。

234
00:14:42,920 --> 00:14:45,950
The fact that fat directory is a fat directory.
"fat directory" 这个术语指的是一个"fat directory"。

235
00:14:45,960 --> 00:14:49,360
It's again it's like in a director,
这句话的意思是：就像在导演的位置上一样。

236
00:14:49,370 --> 00:14:53,900
you have to remember you have these and doubles.
你必须记住你有这些和双倍数。

237
00:14:54,150 --> 00:14:55,700
One is a file name,
一个是文件名

238
00:14:55,710 --> 00:14:57,260
the first part is a file name,
第一部分是一个文件名，

239
00:14:57,270 --> 00:14:59,260
the second one is a file number.
第二个是文件编号。

240
00:15:01,350 --> 00:15:04,280
Here is a factory also of have.
这里也有一个工厂。

241
00:15:05,520 --> 00:15:06,750
It's a linguist, right?
是的，这是一个语言学家，对吗？

242
00:15:06,760 --> 00:15:09,490
This like we know all is the directory,
这就像我们所知道的，是一个目录。

243
00:15:10,100 --> 00:15:11,890
what you see in a directory,
在一个目录中，你可以看到以下内容：

244
00:15:11,900 --> 00:15:14,890
which is basically a list of names.
这基本上是一个名字列表。

245
00:15:15,800 --> 00:15:16,870
What happens here?
这里发生了什么事情？

246
00:15:16,880 --> 00:15:19,290
You are going to have each of these,
你将会拥有其中的每一个。

247
00:15:19,300 --> 00:15:24,660
what you've seen entering this directory is going to be linked all of them,
你所看到的进入这个目录的内容将会与它们全部链接起来。

248
00:15:25,430 --> 00:15:26,740
a a in a linguist.
我是一个语言学家中的一个。

249
00:15:27,860 --> 00:15:29,890
If you remove a file,
如果你删除一个文件，

250
00:15:29,900 --> 00:15:36,440
then you are going to update the pointers so that you are going to step
然后你需要更新指针，这样你就可以进行下一步操作了

251
00:15:36,450 --> 00:15:38,880
over that file,
在那个文件上，

252
00:15:38,890 --> 00:15:41,880
which was over that entry, which was deleted.
这是一个被删除的条目的上方。

253
00:15:42,300 --> 00:15:42,710
Okay?
好的？

254
00:15:43,260 --> 00:15:45,170
That's how you have here.
这是你在这里的情况。

255
00:15:45,180 --> 00:15:46,450
So it's very simple.
所以这很简单。

256
00:15:49,810 --> 00:15:50,280
One.
一。

257
00:15:52,170 --> 00:15:54,800
So one, there are a few things about the fad directory,
首先，关于fad目录有几件事情需要注意。

258
00:15:54,810 --> 00:15:56,000
which is worth mention.
值得一提的是。

259
00:15:56,820 --> 00:16:00,930
It's where do you have a the attributes for a file is
文件的属性存储在哪里？

260
00:16:00,940 --> 00:16:06,200
like protection and permission attributes who has access to the file,
像保护和权限属性这样的东西决定了谁可以访问文件。

261
00:16:06,210 --> 00:16:07,800
to read it, to write it,
读取它，写入它，

262
00:16:07,810 --> 00:16:10,360
to execute that file is if it's a binary file.
如果要执行该文件，那么它必须是一个二进制文件。

263
00:16:11,440 --> 00:16:12,840
In the fact,
事实上，

264
00:16:12,850 --> 00:16:16,310
these attributes are maintained here in the director,
这些属性在这里由主任维护。

265
00:16:16,830 --> 00:16:19,630
like we'll see in other file systems,
就像我们在其他文件系统中看到的那样，

266
00:16:19,930 --> 00:16:23,540
these attributes are associated with the fire itself.
这些属性与火本身相关联。

267
00:16:28,370 --> 00:16:30,320
The other question, which, in general is,
另一个问题，一般来说是这样的，

268
00:16:30,610 --> 00:16:33,120
it's an important collision for all the file systems.
这对于所有文件系统来说都是一个重要的碰撞。

269
00:16:33,430 --> 00:16:34,410
Where do you find that?
你在哪里找到的？

270
00:16:34,420 --> 00:16:35,560
Where do you start from?
你从哪里开始？

271
00:16:38,170 --> 00:16:39,200
To get the route?
获取路由？

272
00:16:39,210 --> 00:16:40,640
If I give you a file name,
如果我给你一个文件名，

273
00:16:40,650 --> 00:16:45,160
you need to go and get the route directory and then goes to the past names
你需要去获取路由目录，然后进入过去的名称。

274
00:16:45,170 --> 00:16:49,590
in that end the directory to find the particular a file name,
在那个目录中找到特定的文件名。

275
00:16:49,600 --> 00:16:51,230
and then I number for the file.
然后我为文件编号。

276
00:16:53,070 --> 00:17:00,840
And typically this route or what it's a well defined place on the disk.
通常情况下，这个路径或者说它是磁盘上一个明确定义的位置。

277
00:17:01,180 --> 00:17:01,530
Right?
对吗？

278
00:17:02,340 --> 00:17:04,410
For instance, a case of fat is blocked.
例如，一个脂肪堵塞的情况。

279
00:17:05,990 --> 00:17:06,860
What else here?
这里还有什么其他的？

280
00:17:07,270 --> 00:17:07,940
Obviously,
显然，

281
00:17:07,950 --> 00:17:12,060
because this is maintaining a linguist and in order to read a directory
因为这是维护一个语言学家并且为了读取一个目录。

282
00:17:12,070 --> 00:17:14,670
and display the content of directory,
并显示目录的内容。

283
00:17:14,680 --> 00:17:16,790
you need to go over this linguist.
你需要请一位语言学家审查一下这个。

284
00:17:17,040 --> 00:17:19,670
You need also to go what which is commonly defined,
你还需要去了解通常被定义的内容。

285
00:17:19,680 --> 00:17:24,130
because when you do a display like all the entries in our directories,
因为当你显示目录中的所有条目时，

286
00:17:24,140 --> 00:17:27,490
you are want to display all the files in the directory.
你想要显示目录中的所有文件。

287
00:17:27,930 --> 00:17:31,060
But when you want to find a fire in a directory,
但是当你想在一个目录中找到一个文件时，

288
00:17:31,370 --> 00:17:34,190
you still need to have to go over this linked list,
你还需要检查这个链表，

289
00:17:34,200 --> 00:17:35,270
which can be expensive.
这可能会很昂贵。

290
00:17:37,420 --> 00:17:38,180
Any questions?
有任何问题吗？

291
00:17:44,160 --> 00:17:45,470
He had a few questions.
他有几个问题。

292
00:17:49,300 --> 00:17:52,090
Suppose you start with a file number.
假设你从一个文件编号开始。

293
00:17:52,100 --> 00:17:54,610
The file number is everyone like in our previous.
文件编号与我们之前的一样，每个人都喜欢。

294
00:17:55,800 --> 00:17:59,100
Here you see also is yellow is you have a file too.
这里你也看到了黄色，这是你也有一个文件。

295
00:18:02,540 --> 00:18:04,600
Let's tell me,
让我告诉你，

296
00:18:05,530 --> 00:18:06,000
let's see.
让我们看看。

297
00:18:06,010 --> 00:18:07,440
What is the time to find a blog?
找到一个博客需要多长时间？

298
00:18:08,890 --> 00:18:09,960
What do you need to find a block?
你需要找到一个块，你需要什么？

299
00:18:24,080 --> 00:18:25,670
You take this is you already,
你已经拿走了这个。

300
00:18:26,930 --> 00:18:29,680
it's our friend or any the number of blocks.
它是我们的朋友还是任意数量的块。

301
00:18:33,160 --> 00:18:35,120
I say, in this case, you say route,
我说，在这种情况下，你说路由。

302
00:18:35,130 --> 00:18:37,160
then reverse the desired number.
然后将所需的数字反转。

303
00:18:37,170 --> 00:18:40,270
Here you already have the file number, the third one.
这里已经有文件编号了，是第三个。

304
00:18:40,790 --> 00:18:45,830
You don't need to do the directory traversal,
你不需要进行目录遍历操作。

305
00:18:47,680 --> 00:18:49,210
but this is correct.
但这是正确的。

306
00:18:49,640 --> 00:18:52,380
And gilbert, so basically,
而且，基本上，

307
00:18:52,390 --> 00:18:53,620
in this particular case,
在这种特定情况下，

308
00:18:53,630 --> 00:18:55,380
you need it's a linear search, right?
你需要的是线性搜索，对吗？

309
00:18:55,700 --> 00:18:58,500
You need to find a particular block.
你需要找到一个特定的块。

310
00:18:58,830 --> 00:19:02,820
You need to follow the pointers in the linguist,
你需要按照语言学家的指示来进行操作。

311
00:19:02,830 --> 00:19:07,810
and everyone knows at english to find something in a linguist is linear.
而且大家都知道，在语言学家那里找到某样东西是线性的。

312
00:19:07,820 --> 00:19:09,010
So near that,
就快了，

313
00:19:14,520 --> 00:19:16,950
what is a block layout for files?
文件的块布局是指将文件存储在磁盘上时，将文件划分为连续的块并按顺序存储的方式。每个块通常具有固定的大小，例如4KB或8KB。块布局的优点是可以提高文件的读取和写入性能，因为连续的块可以更有效地利用磁盘的读写操作。此外，块布局还可以简化文件的管理和索引，因为文件的逻辑顺序与物理存储顺序一致。然而，块布局也可能导致外部碎片问题，即文件的块可能不连续存储在磁盘上，从而浪费了存储空间。

314
00:19:20,460 --> 00:19:21,610
It was a previous question,
这是之前的一个问题。

315
00:19:21,620 --> 00:19:23,210
but they need to be contiguous.
但它们需要是连续的。

316
00:19:23,810 --> 00:19:24,420
Not.
不。

317
00:19:36,100 --> 00:19:36,540
Yes.
是的。

318
00:19:37,770 --> 00:19:38,430
It's correct.
没问题。

319
00:19:39,330 --> 00:19:41,240
Actually, they don't need to be going to go.
实际上，他们不需要去。

320
00:19:41,250 --> 00:19:42,400
They can be random,
它们可以是随机的。

321
00:19:42,840 --> 00:19:49,160
because then we are going to have our linguist in the fat table to maintain
因为这样我们就需要在文件分配表中维护我们的语言学家

322
00:19:49,730 --> 00:19:51,200
the logical order of the loss,
损失的逻辑顺序

323
00:19:51,570 --> 00:19:54,930
which provides you a lot of flexibility about where to allocate the blocks.
这样可以为您提供很大的灵活性，可以自由选择在哪里分配块。

324
00:19:55,340 --> 00:20:01,110
And which is what sequential access.
顺序访问是什么意思？

325
00:20:04,300 --> 00:20:04,960
What do you think about?
你对这个有什么看法？

326
00:20:04,970 --> 00:20:07,520
Sequential access is a fast,
Sequential access是一种快速的访问方式，

327
00:20:07,530 --> 00:20:08,760
slow.
慢。

328
00:20:22,770 --> 00:20:23,230
Yes,
是的，

329
00:20:23,480 --> 00:20:31,360
the director is out of link lists also are presented in the fat in the and
主管已经超出了链接列表，FAT中也有表示。

330
00:20:33,980 --> 00:20:35,130
there are also linguists,
还有语言学家，

331
00:20:35,140 --> 00:20:40,170
but with directories is a linguist between the entries in the directories.
但是在目录中，目录项之间存在一种联系。

332
00:20:41,710 --> 00:20:43,170
Here for the files themselves,
这里是文件本身，

333
00:20:43,180 --> 00:20:44,770
you have the linked list,
你有一个链表。

334
00:20:47,530 --> 00:20:50,640
basically between the blocks of that file.
基本上是在该文件的块之间。

335
00:20:53,530 --> 00:20:55,410
Now, the answer to the question,
现在，问题的答案是，

336
00:20:55,420 --> 00:21:00,860
sequential access can be somewhat slow,
顺序访问可能会有些慢，

337
00:21:00,870 --> 00:21:04,100
because need to linear is gone for every access.
因为需要线性访问，每次访问都会消失。

338
00:21:06,120 --> 00:21:11,060
Because we do not have a guaranteed order is correct.
因为我们没有保证的顺序是正确的。

339
00:21:11,070 --> 00:21:14,140
So the sequential access can be slow,
所以顺序访问可能会很慢，

340
00:21:14,150 --> 00:21:20,000
because if you look about at how block01,
因为如果你仔细观察block01，

341
00:21:20,010 --> 00:21:22,000
and3 are located here,
and3位于这里，

342
00:21:22,290 --> 00:21:25,700
block zero, and one are consecutive right?
块零和一是连续的，对吗？

343
00:21:26,940 --> 00:21:28,490
Because they are consecutive.
因为它们是连续的。

344
00:21:28,690 --> 00:21:34,000
You do not need to incur a sick latency or a patient latency.
你不需要承受病态延迟或者耐心延迟。

345
00:21:34,420 --> 00:21:36,740
What if to go from block zero to block one?
如果要从块零移动到块一怎么办？

346
00:21:39,200 --> 00:21:41,800
But now to go from block one to block two,
但是现在要从块一跳转到块二，

347
00:21:42,040 --> 00:21:45,190
you have to incur a sick latency, rotational agency.
你将会遭受病态延迟和旋转代理的影响。

348
00:21:46,000 --> 00:21:47,110
This is huge overhead.
这是巨大的开销。

349
00:21:49,800 --> 00:21:51,150
You have a lot of flexibility.
你有很大的灵活性。

350
00:21:51,160 --> 00:21:52,750
You have to put the blocks on the disk.
你需要将数据块存储到磁盘上。

351
00:21:53,940 --> 00:21:56,760
But if you are not careful and you put them around on me,
但是如果你不小心把它们放在我身上，

352
00:21:57,440 --> 00:22:00,450
then is going to hurt your access to
那么这将会影响你对...的访问

353
00:22:14,400 --> 00:22:15,310
how is random access.
随机访问是指在计算机系统中可以直接访问存储设备中的任意位置的能力。这意味着可以通过指定存储位置的地址来读取或写入数据，而不需要按照顺序逐个访问。随机访问的速度通常比顺序访问快，因为它不需要按照顺序遍历整个存储设备。常见的随机访问存储设备包括硬盘驱动器和固态硬盘。

354
00:22:19,940 --> 00:22:21,020
Yes, it's even slower.
是的，它甚至更慢。

355
00:22:21,030 --> 00:22:24,470
Since you have to encourage us,
既然你需要鼓励我们，

356
00:22:24,480 --> 00:22:27,730
you need to sequentially search for the block,
你需要按顺序搜索块。

357
00:22:28,710 --> 00:22:30,710
which contains the data you want to read.
其中包含了您想要读取的数据。

358
00:22:34,960 --> 00:22:35,910
It's quite slow.
它运行得相当慢。

359
00:22:40,370 --> 00:22:41,370
Fragmentation.
碎片化。

360
00:22:42,390 --> 00:22:43,230
How is fragmentation?
碎片化是什么情况？

361
00:22:57,300 --> 00:22:59,280
Fragmentation is pretty good,
碎片化情况相当好，

362
00:22:59,290 --> 00:23:01,360
is not much fragmentation because remember,
由于记忆力强，所以碎片化不多。

363
00:23:01,370 --> 00:23:02,680
you can put the blocks anywhere.
你可以把这些块放在任何地方。

364
00:23:03,850 --> 00:23:05,610
See, if you have just some three blocks,
看，如果你只有三个块的话，

365
00:23:06,130 --> 00:23:07,070
you are going to get it.
你会得到它的。

366
00:23:08,190 --> 00:23:08,760
No problem.
没问题。

367
00:23:10,700 --> 00:23:13,010
It's okay, it's going to help your performance.
没关系，这会帮助提升你的表现。

368
00:23:13,430 --> 00:23:16,910
But you can have your fragmentation will be very low.
但是你可以使你的碎片化非常低。

369
00:23:18,260 --> 00:23:19,020
Small files.
小文件。

370
00:23:19,030 --> 00:23:20,700
Is this sufficient for small files?
对于小文件来说，这是否足够？

371
00:23:27,100 --> 00:23:28,380
Remember what if
记住如果发生什么

372
00:23:41,180 --> 00:23:41,650
so?
那么呢？

373
00:23:41,660 --> 00:23:42,090
It's,
这是，

374
00:23:44,070 --> 00:23:45,950
yes, if the file fits in on,
是的，如果文件适合在一个上面。

375
00:23:45,960 --> 00:23:47,230
block is very efficient.
块是非常高效的。

376
00:23:48,070 --> 00:23:48,430
Right?
对吗？

377
00:23:49,170 --> 00:23:49,890
It's very good.
非常好。

378
00:23:50,450 --> 00:23:53,400
If a file fits only in one block, like why?
如果一个文件只能放在一个块中，为什么会这样？

这种情况可能是因为文件的大小小于或等于一个块的大小。在计算机系统中，文件通常被分割成多个块来存储，每个块的大小由文件系统决定。如果文件的大小不超过一个块的大小，那么它就可以完全存储在一个块中。这种情况通常发生在文件比较小或者文件系统的块大小相对较大的情况下。

379
00:23:53,780 --> 00:23:56,460
Because you all in the file number,
因为你们都在文件编号中，

380
00:23:56,470 --> 00:23:59,340
it's indexed into the block.
它被索引到了块中。

381
00:24:00,490 --> 00:24:01,230
The first block,
第一个块，

382
00:24:03,490 --> 00:24:04,480
you find it immediately.
你立即找到了它。

383
00:24:06,540 --> 00:24:06,930
Right?
对吗？

384
00:24:07,980 --> 00:24:13,130
As you have more blocks in the file,
由于文件中有更多的块，

385
00:24:13,380 --> 00:24:15,510
then it becomes more inefficient.
那么它变得更加低效。

386
00:24:15,770 --> 00:24:18,410
For the reason I mentioned, rightly mentioned.
出于我所提到的原因，确实是正确的。

387
00:24:18,420 --> 00:24:19,530
And for the big files,
对于大文件，

388
00:24:19,780 --> 00:24:21,320
it's even more inefficient.
这更加低效。

389
00:24:21,330 --> 00:24:25,280
It's again, because the blocks can be loud.
这是因为块可以发出噪音。

390
00:24:25,290 --> 00:24:26,880
They are loud on the disk,
它们在磁盘上发出很大的声音。

391
00:24:27,190 --> 00:24:28,640
can not end up being random.
不能最终变成随机的。

392
00:24:29,470 --> 00:24:34,650
And then you pay a lot of sick time rotation latency to read and write
然后你需要支付很多病假时间的轮换延迟来进行读写操作。

393
00:24:34,660 --> 00:24:35,290
from the file.
从文件中。

394
00:24:36,630 --> 00:24:42,960
This is fact like very simple and very influential.
这是一个事实，非常简单且具有很大的影响力。

395
00:24:44,280 --> 00:24:46,640
Like this was for many years.
就像这样已经很多年了。

396
00:24:47,240 --> 00:24:51,800
For decades, this was a file system or personal computers.
几十年来，这一直是个人计算机的文件系统。

397
00:24:53,490 --> 00:24:58,180
Because obviously90%of the personal computers were running microsoft
因为显然90%的个人电脑都在运行微软操作系统。

398
00:24:58,190 --> 00:24:58,900
operating system.
操作系统。

399
00:25:02,080 --> 00:25:05,870
Now, let's switch the gears and talk about unique file systems.
现在，让我们转换话题，谈谈独特的文件系统。

400
00:25:07,810 --> 00:25:10,660
And the next file system,
接下来是文件系统，

401
00:25:12,410 --> 00:25:15,040
this is berkeley standard distribution.
这是伯克利标准发行版。

402
00:25:15,050 --> 00:25:17,160
4.1is what we are looking.
我们正在寻找的是4.1。

403
00:25:17,170 --> 00:25:17,680
Now.
现在。

404
00:25:18,750 --> 00:25:21,260
This is a part of your heritage.
这是你的遗产的一部分。

405
00:25:21,940 --> 00:25:28,010
And the similar in the linux today has very similar file structure.
而且现在的Linux系统也有非常相似的文件结构。

406
00:25:28,280 --> 00:25:29,910
It's again, a hugely influential,
这是又一个极具影响力的

407
00:25:29,920 --> 00:25:31,210
a file system,
文件系统

408
00:25:33,920 --> 00:25:35,800
the file number or I numbered.
文件编号或我编号的数字。

409
00:25:36,100 --> 00:25:39,940
As again, it's an index into an array of eye notes.
再次提醒，它是一个指向眼睛音符数组的索引。

410
00:25:41,810 --> 00:25:46,110
I notes corresponds to a file, right?
笔记对应一个文件，对吗？

411
00:25:46,120 --> 00:25:51,860
I notes contains the indexes to the blocks on the disk.
我的笔记包含了磁盘上块的索引。

412
00:25:52,420 --> 00:25:57,480
And in this case, it also contains other meta data associated with a file.
在这种情况下，它还包含与文件相关的其他元数据。

413
00:26:03,160 --> 00:26:06,240
It's pretty good for both little and large files.
它对于小文件和大文件都非常好。

414
00:26:10,920 --> 00:26:15,630
All the assume that still all the blocks are the same size.
假设所有的块仍然是相同大小的。

415
00:26:16,580 --> 00:26:19,500
The trees, what you are going to see is estimate because you are,
树木，你将要看到的是估计值，因为你是，

416
00:26:19,740 --> 00:26:21,340
he's here is how it looks like.
他在这里，看起来是这样的。

417
00:26:22,390 --> 00:26:24,020
You have an, I not array.
你有一个，我没有数组。

418
00:26:25,250 --> 00:26:28,370
The file number is the index in this area,
文件号是在这个区域中的索引。

419
00:26:30,570 --> 00:26:32,330
the iron ore in this area,
这个地区的铁矿石，

420
00:26:34,320 --> 00:26:38,060
it's is basically, this is,
基本上，这是

421
00:26:38,150 --> 00:26:39,540
I know, data structure.
我知道，数据结构。

422
00:26:41,040 --> 00:26:43,640
The first part, there are a bunch of attributes,
第一部分，有一堆属性。

423
00:26:45,070 --> 00:26:48,060
for instance, 99basic control bits.
例如，99个基本控制位。

424
00:26:50,490 --> 00:26:56,110
You have typically owner or users,
通常情况下，你有所有者或用户。

425
00:26:58,410 --> 00:27:00,070
group, and others.
组，和其他人。

426
00:27:01,240 --> 00:27:02,760
So it's basically,
所以基本上，

427
00:27:02,770 --> 00:27:05,160
it was at the owner of the file.
这是文件的所有者。

428
00:27:05,820 --> 00:27:07,010
And for each of them,
对于每一个它们，

429
00:27:07,020 --> 00:27:08,290
you have three beats,
你有三个节拍。

430
00:27:08,970 --> 00:27:10,490
read, write, execute.
读取，写入，执行。

431
00:27:11,950 --> 00:27:14,180
So for owner of the file,
对于文件的所有者，

432
00:27:14,940 --> 00:27:18,570
for the group and for others, right?
是的，适用于小组和其他人，对吗？

433
00:27:19,150 --> 00:27:21,040
Basically, for everyone else.
基本上，对于其他人来说。

434
00:27:21,930 --> 00:27:23,330
And typically, obviously,
通常情况下，显然地，

435
00:27:23,340 --> 00:27:25,250
the owner has the most rights,
所有者拥有最多的权利。

436
00:27:25,810 --> 00:27:26,850
then the group,
那么这个组，

437
00:27:28,150 --> 00:27:35,770
and then every others you have,
然后你还有其他的东西，

438
00:27:35,780 --> 00:27:37,730
and also you have a few other beats,
而且你还有其他一些任务，

439
00:27:38,300 --> 00:27:44,610
which basically you can executed only at the owner permission
这基本上只能在拥有者权限下执行。

440
00:27:44,620 --> 00:27:48,090
rather than users and to execute at groups permission.
而不是用户，并以组权限执行。

441
00:27:53,490 --> 00:27:53,800
Again,
再次，

442
00:27:55,630 --> 00:27:56,830
it's pretty classic.
这是非常经典的。

443
00:27:58,010 --> 00:28:00,160
The more interesting part is after this,
更有趣的部分在此之后，

444
00:28:00,570 --> 00:28:02,280
but remember this permission,
但请记住这个权限，

445
00:28:02,960 --> 00:28:03,530
bits,
位 (b)

446
00:28:04,160 --> 00:28:05,270
and information.
和信息。

447
00:28:05,550 --> 00:28:08,800
It's associated with the iron ore, with a file.
它与铁矿石相关，与一个文件有关。

448
00:28:08,810 --> 00:28:11,440
In this case, in the case of fat or fat,
在这种情况下，指的是脂肪或肥胖的情况。

449
00:28:11,710 --> 00:28:14,230
it does this information on maintaining the director.
这是关于维护主任的信息。

450
00:28:17,200 --> 00:28:27,110
And then you have13 other entries in this idle structure.
然后在这个空闲结构中，你还有13个其他条目。

451
00:28:28,320 --> 00:28:31,210
Each entry points to a block.
每个条目指向一个块。

452
00:28:31,220 --> 00:28:35,320
The first ten entries are called on each of them.
对每个条目调用前十个条目。

453
00:28:35,650 --> 00:28:38,220
They are pointing to one block.
它们指向一个数据块。

454
00:28:42,110 --> 00:28:48,230
The 11th entry point is called indirect pointer,
第11个入口点被称为间接指针。

455
00:28:49,130 --> 00:28:51,970
and points to a block,
并指向一个块，

456
00:28:53,440 --> 00:28:55,150
which each element is a block.
每个元素都是一个块。

457
00:28:56,700 --> 00:28:58,400
It's a pointer to a real block.
这是一个指向真实块的指针。

458
00:29:00,770 --> 00:29:06,520
Then you have double indirection pointers where this points to a block,
然后你有双重间接指针，其中这个指针指向一个块，

459
00:29:06,530 --> 00:29:09,080
which is full of pointers, or each pointer,
是指针的集合，还是每个指针？

460
00:29:09,530 --> 00:29:10,550
points to another block,
指向另一个块

461
00:29:10,560 --> 00:29:14,030
which is full of pointers to, finally, two blocks.
其中充满了指向最终两个块的指针。

462
00:29:14,810 --> 00:29:16,610
And then you have triple in direction,
然后你需要在方向上进行三倍的增加，

463
00:29:17,070 --> 00:29:18,910
pointers, which is, again,
指针，再次强调，

464
00:29:19,570 --> 00:29:20,810
going three levels.
进行三级。

465
00:29:23,650 --> 00:29:24,420
In this case,
在这种情况下，

466
00:29:24,950 --> 00:29:26,500
if you have four kilobytes blocks,
如果你有四千字节的块，

467
00:29:26,510 --> 00:29:27,800
is a feature you have,
是你拥有的一个特性。

468
00:29:33,590 --> 00:29:34,260
you have.
你有。

469
00:29:34,790 --> 00:29:35,860
Here you have.
这是给你的。

470
00:29:43,210 --> 00:29:45,530
Yeah, sorry, I said the first they did.
是的，抱歉，我说的是他们所做的第一件事。

471
00:29:45,540 --> 00:29:50,720
Direct number of direct pointers was then it's actually, sorry, it is12.
直接指针的直接数量实际上是12个。抱歉，之前说错了。

472
00:29:51,210 --> 00:29:52,360
Life is12.
生活是12。

473
00:29:52,370 --> 00:29:54,240
And then you have three other ones,
然后你还有另外三个。

474
00:29:54,250 --> 00:29:56,580
one for india, indirect.
一个给印度的，间接的。

475
00:29:57,910 --> 00:30:00,680
Doubly direct and triple indirect.
双重直接和三重间接。

476
00:30:01,270 --> 00:30:02,420
So you have to12.
所以你必须12。

477
00:30:02,890 --> 00:30:04,950
And if you have 12point, that is,
如果你有12分，也就是说，

478
00:30:05,220 --> 00:30:07,740
this means that if you have four k blocks,
这意味着如果你有四个k块，

479
00:30:09,200 --> 00:30:11,790
you can start using only direct pointers.
你可以开始只使用直接指针。

480
00:30:12,150 --> 00:30:14,520
You can start 48 kilobytes files.
你可以开始处理48千字节的文件。

481
00:30:16,670 --> 00:30:18,620
And if you remember, from last time,
如果你还记得的话，上次我们讨论了

482
00:30:18,630 --> 00:30:21,340
when you are looking at these results from this paper,
当你查看这篇论文的结果时，

483
00:30:22,170 --> 00:30:28,000
which are looking at the statistics of the length of the file system of size,
正在查看文件系统大小的统计数据。

484
00:30:28,010 --> 00:30:29,120
of the file systems,
文件系统中的一种，

485
00:30:30,260 --> 00:30:33,750
there in that paper, in the plots,
在那篇论文中，在图表中，

486
00:30:34,190 --> 00:30:35,620
we presented lifetime,
我们提出了生命周期。

487
00:30:35,890 --> 00:30:39,800
we are seeing that most of the files are small files.
我们注意到大部分文件都是小文件。

488
00:30:40,730 --> 00:30:41,640
Therefore,
因此，

489
00:30:42,410 --> 00:30:43,720
for most of the files,
对于大多数文件来说，

490
00:30:43,960 --> 00:30:46,270
you are using only the direct pointers.
你只使用了直接指针。

491
00:30:53,770 --> 00:30:55,400
Then for the bigger files,
对于较大的文件，

492
00:30:55,410 --> 00:30:57,560
you are going to use the indirect pointer,
你将使用间接指针。

493
00:30:57,570 --> 00:30:59,640
establishing direct pointers, entry, playing direct mode.
建立直接指针，入口，播放直接模式。

494
00:31:01,820 --> 00:31:03,090
Just to give you a sense,
只是为了让你有个概念，

495
00:31:03,960 --> 00:31:06,770
you can get for doubling direct pointers,
你可以通过双倍直接指针来实现。

496
00:31:07,170 --> 00:31:09,800
you can get to 4megabytes.
你可以达到4兆字节。

497
00:31:09,810 --> 00:31:10,280
Why?
为了方便理解和交流，将英文翻译成中文可以帮助更多的人理解和使用相关信息。作为计算机操作系统的助教，我会尽力提供帮助和支持，包括翻译英文内容为中文。如果您有任何问题或需要帮助，请随时告诉我。

498
00:31:10,630 --> 00:31:13,390
Because in this particular case,
因为在这种特殊情况下，

499
00:31:13,770 --> 00:31:17,790
it's again of this pointer.
这又是关于指针的问题。

500
00:31:18,130 --> 00:31:20,220
Here, the 13pointer.
这里是13指针。

501
00:31:20,470 --> 00:31:23,110
It points you to one block.
它指向一个数据块。

502
00:31:23,120 --> 00:31:25,010
A block has four kilobytes.
一个块有四千字节。

503
00:31:25,430 --> 00:31:27,400
Each pointer, in this case,
在这种情况下，每个指针

504
00:31:27,410 --> 00:31:28,560
is4bytes.
是4字节。

505
00:31:28,990 --> 00:31:30,180
Therefore, in a block,
因此，在一个块中，

506
00:31:30,190 --> 00:31:34,430
you have 1,024pointers.
你有1,024个指针。

507
00:31:35,210 --> 00:31:39,820
Each of these pointers points to a physic, to a block.
这些指针中的每一个指向一个物理块。

508
00:31:40,410 --> 00:31:42,090
A block four has four kilobytes.
一个块大小为四千字节。

509
00:31:42,260 --> 00:31:42,890
Now I have,
现在我有了。

510
00:31:43,620 --> 00:31:45,940
then1,024×4.
那么1,024乘以4等于4,096。

511
00:31:46,260 --> 00:31:47,540
You have four kilobytes,
你有四千字节。

512
00:31:47,550 --> 00:31:48,940
you have 4megabytes.
你有4兆字节。

513
00:31:49,150 --> 00:31:50,530
This is level two.
这是第二级。

514
00:31:50,920 --> 00:31:53,940
It's a 111 in direction.
这是一个指向111的方向。

515
00:31:53,950 --> 00:31:58,710
The doubling direction is going to add another layer.
加倍的方向将会增加另一层。

516
00:31:58,720 --> 00:32:03,150
And it's basically you have four gigabytes.
基本上，你有四千兆字节。

517
00:32:03,460 --> 00:32:05,340
And then for that hour,
然后在那个小时里，

518
00:32:05,350 --> 00:32:09,670
and then for if you have the triple indirect.,
如果你有三级间接索引的话，那么就会有这样的情况。

519
00:32:09,680 --> 00:32:11,610
that is you have four terabytes.
你有四个TB的存储空间。

520
00:32:14,120 --> 00:32:17,320
So it's a lot of storage.
所以这是很多存储空间。

521
00:32:17,680 --> 00:32:20,490
Now, there is advantage for these ones.
现在，这些有优势。

522
00:32:20,500 --> 00:32:24,800
What is the disadvantage with the going with the that with indirect,
使用间接方式的缺点是什么？

523
00:32:24,810 --> 00:32:27,500
doubly indirect and triple indirect loss?
双重间接损失和三重间接损失

524
00:32:28,000 --> 00:32:29,240
What is the disadvantage here?
这里有什么缺点？

525
00:32:42,710 --> 00:32:43,390
Yes.
是的。

526
00:32:43,760 --> 00:32:45,160
Longer access times.
较长的访问时间。

527
00:32:45,590 --> 00:32:46,470
Because right now,
由于现在，

528
00:32:46,640 --> 00:32:53,540
I if I am going to to go to this the first level pointers,
如果我要进入第一级指针的话，

529
00:32:55,110 --> 00:32:56,780
i'm going to get the I node.
我要获取 I 节点。

530
00:32:57,310 --> 00:32:59,170
Then from I node, I get the pointers,
然后从I节点获取指针。

531
00:32:59,180 --> 00:33:00,610
all the pointers to the block.
所有指向该块的指针。

532
00:33:00,860 --> 00:33:03,010
I have another access to get to the data.
我有另一种方法可以访问数据。

533
00:33:03,760 --> 00:33:05,090
11x axis.
11x轴。

534
00:33:05,880 --> 00:33:09,600
If I am going to have triple indirect in order to get to these data blocks,
如果我要使用三级间接来访问这些数据块，

535
00:33:09,610 --> 00:33:15,860
I have to get one other access to get the first level block,
我需要获取另一个访问权限来获取第一级块。

536
00:33:15,870 --> 00:33:18,020
which contains pointers at the first level,
其中包含指向第一级的指针

537
00:33:18,030 --> 00:33:19,620
then another pointer,
然后另一个指针，

538
00:33:20,190 --> 00:33:21,900
another I need to access another.
我需要访问另一个。

539
00:33:21,910 --> 00:33:25,460
They get another block at the second level to contains against pointers,
他们在第二级获得另一个块，用于存放指针。

540
00:33:25,890 --> 00:33:29,180
another block at the third level of container game pointers.
容器游戏指针的第三层又有一个块。

541
00:33:29,490 --> 00:33:30,600
And finally,
最后，

542
00:33:30,610 --> 00:33:33,790
I am going to get the data to the real block.
我将把数据写入真实的块中。

543
00:33:35,550 --> 00:33:38,570
But also here I have for each of these levels,
但是在这里，我对每个级别都有。

544
00:33:38,580 --> 00:33:40,250
I have an extra axis.
我有一个额外的轴。

545
00:33:42,770 --> 00:33:43,070
Okay?
好的？

546
00:33:43,840 --> 00:33:45,960
On the other hand, it's pretty cool designed, right?
另一方面，它设计得相当酷，对吧？

547
00:33:45,970 --> 00:33:47,440
Because for the small blocks,
因为对于小块来说，

548
00:33:48,610 --> 00:33:49,560
it's pretty efficient.
这很高效。

549
00:33:50,870 --> 00:33:52,750
Small block less than 48kilobytes.
小块大小小于48千字节。

550
00:33:53,840 --> 00:33:58,270
All these pointers here are to data blocks.
这里的所有指针都指向数据块。

551
00:34:01,140 --> 00:34:03,130
At the same time,
同时，

552
00:34:03,140 --> 00:34:09,160
you can store huge files like up to four terabytes in this design.
在这个设计中，您可以存储高达四个TB的大文件。

553
00:34:15,080 --> 00:34:16,230
It's a question here.
这是一个问题。

554
00:34:20,130 --> 00:34:23,060
This seems really similar to page tables.
这似乎与页表非常相似。

555
00:34:23,450 --> 00:34:27,890
Do file systems have the equivalent of super pages or huge pages?
文件系统是否有超级页或巨大页的等效物？

文件系统本身并不直接涉及到页的概念。页是操作系统内存管理的一部分，用于将物理内存划分为固定大小的块，以便更高效地管理和访问内存。超级页和巨大页是操作系统中的概念，用于将常规大小的页合并为更大的页，以提高内存管理的效率。

因此，文件系统本身并不具备超级页或巨大页的等效物。这些概念主要适用于操作系统的内存管理层面，而不是文件系统。

556
00:34:30,360 --> 00:34:36,080
Is very similar to the files is similar to the base table in some respects,
在某些方面，文件非常类似于基本表。

557
00:34:36,090 --> 00:34:36,380
right?
对的？

558
00:34:37,600 --> 00:34:46,830
Is one is that the unit of allocation a it's a it's a blog, it's a page.
一个单位分配的是一个块，它可以是一个块，也可以是一个页面。

559
00:34:47,970 --> 00:34:49,910
It's also they are connected, right?
它们也是相互连接的，对吗？

560
00:34:50,210 --> 00:34:58,290
Because the reason for which you have pages in when we do demand beijing
因为当我们进行页面调度时，有时会出现需求不足的情况。

561
00:34:58,680 --> 00:34:59,170
is why?
为什么？

562
00:34:59,180 --> 00:35:01,830
Because these pages needs to be stored.
因为这些页面需要被存储。

563
00:35:02,040 --> 00:35:05,560
Eventually when on the disk when they are evicted, right?
最终当它们被驱逐到磁盘上时，对吗？

564
00:35:06,020 --> 00:35:07,700
They need to be read from the disk.
它们需要从磁盘上读取。

565
00:35:08,050 --> 00:35:09,500
And the unit, again,
再次提醒，单位是

566
00:35:09,510 --> 00:35:10,660
it has to be the same unit.
它必须是相同的单位。

567
00:35:10,670 --> 00:35:12,070
It's a block, right?
是的，它是一个块吗？

568
00:35:12,460 --> 00:35:12,730
Block.
阻塞。

569
00:35:12,740 --> 00:35:14,970
And the pages are basically the same unit.
而页面基本上是相同的单元。

570
00:35:15,420 --> 00:35:17,860
Otherwise, to make things much more complicated,
否则，为了让事情变得更加复杂，

571
00:35:19,550 --> 00:35:21,380
you'll see towards the end of the lecture,
你会在讲座的最后部分看到，

572
00:35:21,390 --> 00:35:24,530
hopefully can get there where you see the similarity,
希望你能理解并看到相似之处。

573
00:35:24,540 --> 00:35:27,610
but more because they are going to talk about memory maps.
但更重要的是因为他们要讨论内存映射。

574
00:35:27,960 --> 00:35:30,690
So then you are going to map the files into memory.
那么你要将文件映射到内存中。

575
00:35:30,990 --> 00:35:35,510
And then you'll see one more of the similarity in terms of file system,
然后你会看到文件系统方面的另一个相似之处，

576
00:35:35,520 --> 00:35:38,430
having the equivalent of super pages of huge pages,
拥有超级页或大页的等效功能，

577
00:35:43,860 --> 00:35:46,900
you do have that not in unique,
你确实没有那个独特的东西。

578
00:35:47,410 --> 00:35:50,820
but you don't have that in the windows,
但是在Windows中你没有那个选项。

579
00:35:53,770 --> 00:35:57,790
the more and more than windows file system,
越来越多的文件系统比Windows更强大。

580
00:35:57,800 --> 00:35:59,070
microsoft file system.
微软文件系统。

581
00:35:59,550 --> 00:36:02,320
And in that case, you have what is called extent.
在这种情况下，你所拥有的就是所谓的extent（范围）。

582
00:36:02,680 --> 00:36:06,750
What we are going to learn later in this lecture in visa blocks can have
在这节课中，我们将学习关于VISA块的内容。

583
00:36:06,760 --> 00:36:07,330
variable sites.
变量 sites.

584
00:36:10,940 --> 00:36:11,940
Great questions?
很好的问题！

585
00:36:16,360 --> 00:36:17,710
Let's take an example here,
让我们来举个例子，

586
00:36:18,120 --> 00:36:19,790
I right now.
我现在。

587
00:36:19,800 --> 00:36:28,250
And that's why I was a little in this particular a it's a different example.
这就是为什么我在这个特定的例子中有点困惑，因为它是一个不同的例子。

588
00:36:28,260 --> 00:36:33,110
And he here assume that each block is one kilobyte.
他在这里假设每个块的大小为一千字节。

589
00:36:35,930 --> 00:36:42,220
We assume that there are ten direct pointers.
我们假设有十个直接指针。

590
00:36:42,980 --> 00:36:46,440
And in indirect blog,
在间接博客中，

591
00:36:48,030 --> 00:36:49,140
the standard pointer.
标准指针。

592
00:36:49,150 --> 00:36:53,980
So directly you can access only 1 kilo one,
所以你只能直接访问1千兆位。

593
00:36:54,550 --> 00:36:56,620
1kilowatt, one kilobyte,
1千瓦，一千字节

594
00:36:56,630 --> 00:36:59,380
ten ten×10kilobytes files.
十个10千字节的文件。

595
00:37:00,330 --> 00:37:02,700
Then because you have only one kilobyte.
因此，由于你只有1千字节。

596
00:37:02,710 --> 00:37:03,990
If each entry,
如果每个条目，

597
00:37:04,000 --> 00:37:05,910
each point there is 4bytes,
每个点占用4个字节。

598
00:37:06,170 --> 00:37:11,120
then you have only20 56indirect blocks at the first level.
那么你只有20个一级间接块。

599
00:37:11,760 --> 00:37:14,230
Then you have twenty five two hundred,
那么你有两百五十个。

600
00:37:14,240 --> 00:37:18,950
56power to doubling the right box and 256 for three people in the right box.
将右边的盒子的功率增加到56倍，并将右边的盒子容纳三个人的功率增加到256。

601
00:37:20,770 --> 00:37:22,520
That's kind of the layout in this case.
在这种情况下，就是这样的布局。

602
00:37:23,150 --> 00:37:27,550
And now the question is that how many access is you need?
现在的问题是你需要多少次访问？

603
00:37:27,560 --> 00:37:31,210
How many access is to get to the block23?
到达block23需要多少次访问？

604
00:37:32,850 --> 00:37:35,160
Assume the file is everything it's open.
假设文件已经打开。

605
00:37:35,170 --> 00:37:38,870
Now, i'm just to add one process, block the industry.
现在，我只需要添加一个进程，阻塞该行业。

606
00:37:39,590 --> 00:37:40,610
How many answers
有多少个答案？

607
00:37:49,280 --> 00:37:51,870
Is this 23 in a direct pointers?
这个23是直接指针吗？

608
00:37:51,880 --> 00:37:56,910
But it's not right,
但这是不正确的，

609
00:37:56,920 --> 00:37:59,250
because I have only done in this stuff.
因为我只在这方面做过。

610
00:38:02,890 --> 00:38:04,290
It's A
这是A。

611
00:38:11,200 --> 00:38:13,800
23 will be in the single indirect block.
23将位于单间接块中。

612
00:38:14,790 --> 00:38:16,210
So you need to ask this,
所以你需要问这个问题，

613
00:38:17,230 --> 00:38:17,510
right?
是的，正确的。

614
00:38:17,930 --> 00:38:26,480
We need the first access to get to the root of the first level indirect locks.
我们需要第一次访问才能到达第一级间接锁的根节点。

615
00:38:27,000 --> 00:38:28,240
And then from here,
然后从这里开始，

616
00:38:28,780 --> 00:38:29,910
once you get there,
一旦你到达那里，

617
00:38:30,270 --> 00:38:32,750
you are going to read the data block.
你将要读取数据块。

618
00:38:37,970 --> 00:38:39,050
What about block five?
第五个块怎么样了？

619
00:38:44,000 --> 00:38:46,100
Block five is in the first stand.
第五个块在第一个架子上。

620
00:38:47,050 --> 00:38:49,490
So you are going to have only one access.
所以你只会有一个访问权限。

621
00:38:50,280 --> 00:38:51,080
It is a data block.
这是一个数据块。

622
00:38:51,690 --> 00:38:52,320
Number five,
第五个，

623
00:38:53,840 --> 00:38:55,350
block service, three hundred fourth.
块服务，第304个。

624
00:38:57,250 --> 00:39:04,210
That's 340 hits in the first level,
第一层有340个命中。

625
00:39:04,220 --> 00:39:05,610
the indirect loss.
间接损失。

626
00:39:05,890 --> 00:39:06,580
Does it feel?
它有感觉吗？

627
00:39:07,780 --> 00:39:08,620
How many you have that?
你有多少个？

628
00:39:08,630 --> 00:39:11,390
You have twenty five fifty six last time,
上次你有二十五五十六。

629
00:39:11,400 --> 00:39:17,600
which are direct is only indirect blocks or direct.
这句话的意思是：哪些是直接块，哪些是间接块或直接块。

630
00:39:21,810 --> 00:39:22,720
Therefore,
因此，

631
00:39:24,040 --> 00:39:26,030
you need it has to be in doubling direct.
你需要它必须是双向的。

632
00:39:28,500 --> 00:39:30,810
So then you are going to have how many axis?
那么你打算有多少个轴？

633
00:39:31,440 --> 00:39:31,880
Again,
请再说一遍。

634
00:39:32,570 --> 00:39:35,300
one axis per level, each level.
每个层级有一个轴。

635
00:39:35,310 --> 00:39:39,470
So you have double for each level,
所以对于每个级别，你都有两倍的数量。

636
00:39:39,480 --> 00:39:41,110
you need one access or two,
你需要一个访问权限还是两个访问权限？

637
00:39:41,480 --> 00:39:43,350
and the third one for access to the right.
第三个用于访问权限。

638
00:39:49,980 --> 00:39:50,810
Some announcement.
一些公告。

639
00:39:50,820 --> 00:39:55,850
So again, many congress for finishing the second meet them.
所以，再次，为了完成第二次会议，需要召开许多次会议。

640
00:39:56,500 --> 00:39:57,930
We are making progress here.
我们在这里取得了进展。

641
00:39:58,720 --> 00:40:00,640
Omar five has been released.
Omar五已经发布。

642
00:40:00,650 --> 00:40:02,760
It will be due on monday,
它将在星期一到期。

643
00:40:03,160 --> 00:40:05,180
november, 22nd.
11月22日。

644
00:40:06,960 --> 00:40:08,590
The project too.
这个项目也是。

645
00:40:08,890 --> 00:40:11,360
Obviously, now is due on sunday.
显然，现在是星期天截止。

646
00:40:12,730 --> 00:40:16,240
Hopefully everyone here,
希望这里的每个人，

647
00:40:16,250 --> 00:40:19,040
it's in a good state with that project.
这个项目的进展良好。

648
00:40:19,500 --> 00:40:23,450
If not, please feel free to ask any questions we are here to help you.
如果有任何问题，请随时提问，我们在这里帮助您。

649
00:40:29,330 --> 00:40:32,520
That was the initial file system in unix,
那是Unix中最初的文件系统。

650
00:40:34,140 --> 00:40:34,900
4.1.
4.1.

651
00:40:36,010 --> 00:40:36,510
Now,
现在，

652
00:40:37,170 --> 00:40:38,490
people, obviously,
人们，显然，

653
00:40:38,500 --> 00:40:41,520
after they used it for a while,
使用一段时间后，

654
00:40:41,910 --> 00:40:46,530
they figure out there are some limitations and they try to address these limitations.
他们发现了一些限制，并试图解决这些限制。

655
00:40:47,370 --> 00:40:52,750
And the address is limitation in what is called berkeley fast file system,
地址限制是指在所谓的伯克利快速文件系统中的限制。

656
00:40:52,760 --> 00:40:56,910
ffs which is bsd.4.2.
ffs是指BSD 4.2中的文件系统。

657
00:40:59,590 --> 00:41:00,830
This was at least 84.
这至少是84。

658
00:41:00,840 --> 00:41:02,190
So still a long time ago,
所以还是很久以前，

659
00:41:04,000 --> 00:41:06,020
it's very similar with 4.1.
这与4.1非常相似。

660
00:41:06,570 --> 00:41:09,260
The differences are that while in 4.1,
区别在于，在4.1版本中，

661
00:41:09,270 --> 00:41:15,610
typical is a block size with one kilobyte in 4.21~4 kilobytes.
典型的块大小为1千字节到4.21~4千字节。

662
00:41:16,090 --> 00:41:16,730
Why?
为了帮助更多的学生理解和学习计算机操作系统课程。

663
00:41:17,020 --> 00:41:20,250
Because obviously, the discovery are increasing size.
因为显然，发现的规模正在增加。

664
00:41:22,220 --> 00:41:23,530
It's a very good paper.
这是一篇非常好的论文。

665
00:41:23,540 --> 00:41:24,970
I recommend you to read.
我建议你阅读。

666
00:41:24,980 --> 00:41:26,610
It's in the reading material.
这在阅读材料中。

667
00:41:26,920 --> 00:41:30,380
If not, you can search on the web and you can get it,
如果没有的话，你可以在网上搜索，就能找到。

668
00:41:30,390 --> 00:41:31,500
but it's very interesting.
但这非常有趣。

669
00:41:32,450 --> 00:41:34,800
And there are a bunch of optimization.
还有很多优化措施。

670
00:41:35,750 --> 00:41:42,670
We are going to go briefly through these optimization and comparison with 4.1.
我们将简要地介绍这些优化和与4.1版本的比较。

671
00:41:48,750 --> 00:41:50,490
So let me go.
那就让我走吧。

672
00:41:50,500 --> 00:41:52,690
So I am not going to go now through this list.
所以我现在不会逐个查看这个列表。

673
00:41:52,700 --> 00:41:57,450
I'm going while I am going to explain this optimization.
我会在我解释这个优化的时候进行操作。

674
00:41:57,910 --> 00:41:59,870
But the media thinks about, first of all,
但是媒体首先考虑的是

675
00:41:59,880 --> 00:42:03,510
let's talk about what are the motivation?
让我们来谈谈动机是什么？

676
00:42:03,770 --> 00:42:10,070
What are the problems with the file systems in unix,
Unix文件系统存在哪些问题？

677
00:42:10,080 --> 00:42:14,270
bsd 4.10 k
BSD 4.10 是一个操作系统版本。BSD 是指 Berkeley Software Distribution，它是一个基于 Unix 的操作系统系列。BSD 4.10 是其中的一个版本，它是在 2000 年发布的。

678
00:42:19,800 --> 00:42:25,690
the one thing is that the fire system is a fat table,
其中一个问题是防火系统是一个庞大的表格。

679
00:42:25,700 --> 00:42:28,440
and all of these,
还有所有这些，

680
00:42:28,690 --> 00:42:32,320
I note data structures, right?
我需要记录数据结构，对吗？

681
00:42:33,290 --> 00:42:36,150
They were in a fixed disk,
它们存储在固定磁盘中。

682
00:42:36,650 --> 00:42:38,240
in the fixed place on the disk.
在磁盘上的固定位置。

683
00:42:40,480 --> 00:42:41,060
Okay?
好的？

684
00:42:43,140 --> 00:42:46,300
And the problem,
问题是，

685
00:42:46,350 --> 00:42:51,380
or is that if you have all these I notes on the disk in on place,
或者是说，如果你将所有这些笔记都存储在一个地方的磁盘上，

686
00:42:52,800 --> 00:43:00,010
then it's very likely that
那么很有可能

687
00:43:00,610 --> 00:43:04,530
they are going to be far from most of the data blocks.
它们将远离大部分数据块。

688
00:43:06,040 --> 00:43:09,830
The data blocks are all over, obviously.
数据块分散在各处，显而易见。

689
00:43:10,670 --> 00:43:13,530
And the eye notes are only at the age.
眼睛的注意力只集中在年轻时期。

690
00:43:13,540 --> 00:43:15,370
In order to access the data blocks,
为了访问数据块，

691
00:43:15,380 --> 00:43:18,610
you need the information from the inode of that particular file.
你需要从该特定文件的inode中获取信息。

692
00:43:19,640 --> 00:43:19,830
Right?
对吗？

693
00:43:19,840 --> 00:43:21,310
So you need to read on I note,
所以你需要阅读我记录的内容。

694
00:43:21,320 --> 00:43:24,950
and you are almost guaranteed that I know the place where I know the store
而且几乎可以肯定我知道那个商店的地方。

695
00:43:24,960 --> 00:43:28,530
on that is is far away from where the data is located on this.
那是离数据所在位置很远的地方。

696
00:43:30,500 --> 00:43:31,330
It's sick time.
现在是病假时间。

697
00:43:31,690 --> 00:43:33,150
You are going to pay for the 6th time.
您将进行第六次付款。

698
00:43:34,730 --> 00:43:36,250
The other thing is reliability.
另一个重要的因素是可靠性。

699
00:43:37,020 --> 00:43:43,010
If somehow the outer edges tracks of the disk are destroyed,
如果磁盘的外缘轨道被破坏了，

700
00:43:43,020 --> 00:43:48,120
because sometimes when some of the failures happen,
因为有时候当一些故障发生时，

701
00:43:48,130 --> 00:43:53,480
is that when you have a power outage and the discourse are rotating,
这是指当你遭遇停电时，磁盘正在旋转的情况吗？

702
00:43:53,490 --> 00:43:59,120
and sometimes the heads were kind of scratching the disk
有时候磁头会有点刮到磁盘的情况

703
00:43:59,130 --> 00:44:01,000
in that particular case.
在那种特定情况下。

704
00:44:02,230 --> 00:44:09,450
Then if you lose this kind of the inode information, you lost everything.
如果你丢失了这种inode信息，就意味着你失去了一切。

705
00:44:14,740 --> 00:44:17,090
So that's a problem.
那是个问题。

706
00:44:20,010 --> 00:44:24,140
The other think it was,
另一件事是，

707
00:44:26,100 --> 00:44:28,460
it's hard to allocate for performance,
性能分配很困难。

708
00:44:29,960 --> 00:44:31,260
because in unix,
因为在Unix中，

709
00:44:31,480 --> 00:44:33,790
most rights in many rights are by append.
许多权限中的大多数权限是通过追加实现的。

710
00:44:33,800 --> 00:44:37,070
It's again when you write either your right to existing block,
当你写入现有块时，再次发生这种情况。

711
00:44:37,520 --> 00:44:39,190
because what is the existing data?
因为现有的数据是什么？

712
00:44:39,200 --> 00:44:40,750
Is that you override the data.
你是否覆盖了数据。

713
00:44:40,760 --> 00:44:42,350
But if you append,
但是如果你追加的话，

714
00:44:42,630 --> 00:44:44,870
in many cases, you just append to file,
在许多情况下，你只需要将内容追加到文件中。

715
00:44:44,880 --> 00:44:47,570
then you are going to add new blocks.
那么你将要添加新的块。

716
00:44:49,500 --> 00:44:58,630
And the problem here is that you want to allocate, in some sense,
这里的问题是你想要在某种意义上进行分配。

717
00:45:00,680 --> 00:45:03,960
obviously, on to allocate blocks which are contiguous, right?
显然，我们要分配连续的块，对吗？

718
00:45:04,570 --> 00:45:06,900
But that's kind of was difficult.
但那有点困难。

719
00:45:07,300 --> 00:45:11,190
In the case of4.1,
在4.1的情况下，

720
00:45:11,470 --> 00:45:12,990
you need to be 84.1.
你需要是84.1。

721
00:45:13,000 --> 00:45:15,450
You have a linguist for the three blocks,
你有一个语言学家负责这三个区块。

722
00:45:15,460 --> 00:45:17,240
like in the fact table.
就像在事实表中一样。

723
00:45:17,660 --> 00:45:19,120
And then the way you allocate,
然后是你分配资源的方式，

724
00:45:19,130 --> 00:45:20,570
you go through this list,
你浏览这个列表，

725
00:45:20,870 --> 00:45:24,790
and you allocate always the first block, which is available.
你总是分配第一个可用的块。

726
00:45:25,360 --> 00:45:27,380
But the going through the list of the three blocks,
但是要遍历这三个块的列表，

727
00:45:27,390 --> 00:45:29,450
all these blocks can be all over the place.
所有这些块可以随意摆放。

728
00:45:32,430 --> 00:45:33,350
So are they done?
他们完成了吗？

729
00:45:34,000 --> 00:45:35,190
So here is what they done.
所以这是他们所做的事情。

730
00:45:36,050 --> 00:45:40,030
Basically, they define this kind of block groups.
基本上，他们定义了这种块组。

731
00:45:40,740 --> 00:45:47,490
So the tracks which are nearby are in the same block.
附近的轨道位于同一个块中。

732
00:45:47,780 --> 00:45:49,090
And correspondingly, also,
相应地，还有，

733
00:45:49,100 --> 00:45:51,770
they define the cylinder group,
它们定义了柱组。

734
00:45:52,890 --> 00:45:58,980
like all the blocks which are fall under block groups,
像所有属于块组的块一样，

735
00:45:58,990 --> 00:46:04,850
which are falling under the
属于的

736
00:46:07,550 --> 00:46:13,550
the drive head heads on all the bladders,
驱动头在所有气囊上移动。

737
00:46:13,970 --> 00:46:14,970
are in the same cylinder.
在同一个柱面上。

738
00:46:14,980 --> 00:46:19,130
You imagine a cylinder which are going to contain all these data blocks,
你可以想象一个圆柱体，它将包含所有这些数据块。

739
00:46:19,940 --> 00:46:22,570
which are overlay one over another.
它们是相互叠加的。

740
00:46:27,340 --> 00:46:28,540
So right now,
所以现在，

741
00:46:29,130 --> 00:46:33,010
then instead of having these I nodes,
那么，不再使用这些I节点，

742
00:46:33,910 --> 00:46:38,410
and only at the edge,
仅限于边缘位置，

743
00:46:39,610 --> 00:46:43,800
start at the age of that is you are associating these eye notes,
从那个年龄开始，你就开始与这些眼睛笔记相关联了。

744
00:46:44,670 --> 00:46:45,190
right?
对的？

745
00:46:45,720 --> 00:46:46,790
To the files,
关于文件，

746
00:46:46,800 --> 00:46:50,790
the eye notes with which for the files,
用于文件的眼睛注释

747
00:46:50,800 --> 00:46:54,230
which are who was that I stored in the same block,
这些是我存储在同一个块中的人或物。

748
00:46:54,700 --> 00:46:56,040
are also in the same block.
也在同一个块中。

749
00:46:59,310 --> 00:47:00,960
Seriously, this is, I know,
真的，我知道的。

750
00:47:00,970 --> 00:47:06,300
the information for the files which are stored in blog group one.
存储在博客群组一中的文件的信息。

751
00:47:06,800 --> 00:47:09,190
And these are the eye notes.
这些是眼睛的笔记。

752
00:47:09,630 --> 00:47:15,160
The information now for the files with data is in block group two.
现在带有数据的文件的信息在块组二中。

753
00:47:19,930 --> 00:47:20,970
Furthermore,
此外，

754
00:47:20,980 --> 00:47:28,100
instead of maintaining the are available three blocks in,
而不是维护三个可用的块，

755
00:47:28,110 --> 00:47:30,140
at least you have a bit back.
至少你有一点回报。

756
00:47:30,790 --> 00:47:31,460
And i'll tell you,
我会告诉你，

757
00:47:31,470 --> 00:47:33,820
i'll show you next time you can do if you have a bit back.
下次我会给你看看，如果你稍微退后一点的话。

758
00:47:34,520 --> 00:47:34,880
Right?
对吗？

759
00:47:35,190 --> 00:47:36,360
But this is what it is now.
但这就是现在的情况。

760
00:47:37,710 --> 00:47:39,180
In terms of performance,
就性能而言，

761
00:47:39,540 --> 00:47:41,230
if you have this kind of layout,
如果你有这种布局，

762
00:47:41,780 --> 00:47:48,630
now, because I nodes are in the same blog groups
现在，因为我节点在同一个博客组中

763
00:47:52,910 --> 00:47:54,370
with the corresponding files,
带有相应的文件，

764
00:47:54,790 --> 00:47:56,000
what do I gain here?
我在这里能得到什么好处？

765
00:47:57,180 --> 00:47:58,220
What do I save here?
我在这里保存什么？

766
00:47:59,640 --> 00:48:00,880
In terms of performance?
从性能方面来说？

767
00:48:04,080 --> 00:48:05,580
What is a big deal about this?
这有什么大不了的？

768
00:48:14,850 --> 00:48:16,730
Again, for a file to access a file,
再次强调，要访问一个文件，

769
00:48:16,740 --> 00:48:18,050
I need to get its eye node.
我需要获取它的眼睛节点。

770
00:48:19,270 --> 00:48:20,850
And then I need to access these data.
然后我需要访问这些数据。

771
00:48:23,050 --> 00:48:24,210
Because once I get there,
因为一旦我到达那里，

772
00:48:24,220 --> 00:48:28,310
I know I have the information or the blocks of the file are located.
我知道文件的信息或者文件块的位置。

773
00:48:28,320 --> 00:48:29,550
I'm going to read or write.
我要进行读取或写入操作。

774
00:48:30,950 --> 00:48:34,380
That is a big deal about this layout.
这个布局确实很重要。

775
00:48:53,730 --> 00:48:55,810
If the iron ore is near the file blocks,
如果铁矿石靠近文件块，

776
00:48:55,820 --> 00:48:57,250
then it will be much faster,
那么它将会快得多。

777
00:48:57,260 --> 00:48:59,090
but it especially for small files.
但它尤其适用于小文件。

778
00:48:59,100 --> 00:49:00,350
This is good.
这很好。

779
00:49:01,060 --> 00:49:08,750
The sick time it's exactly listeners and it's
病假时间是准确的听众，并且它是

780
00:49:08,760 --> 00:49:11,350
basically the sick time would be smaller,
基本上，病假时间会更短。

781
00:49:11,360 --> 00:49:13,970
which will be much lower.
这将会低得多。

782
00:49:14,740 --> 00:49:14,970
Right?
对吗？

783
00:49:14,980 --> 00:49:16,170
Because the sick time,
由于生病的原因，

784
00:49:16,480 --> 00:49:19,850
it's about how far there are two tracks on from each other.
这是关于两个轨道之间有多远的问题。

785
00:49:19,860 --> 00:49:21,730
This is a sick time it is given by.
这是一个病假时间，由...提供。

786
00:49:22,630 --> 00:49:28,740
And now the blocks are on tracks which are closer together.
现在，这些块已经放在距离更近的轨道上了。

787
00:49:29,340 --> 00:49:29,740
Right?
对吗？

788
00:49:30,760 --> 00:49:31,930
So this is what it is.
所以就是这样。

789
00:49:32,360 --> 00:49:34,420
It's not only that I read the I note,
不仅仅是我阅读了笔记，

790
00:49:34,430 --> 00:49:36,760
and i'm going to this file, separate these files,
我要去这个文件，将这些文件分开。

791
00:49:36,770 --> 00:49:38,380
but also all the fire,
还有所有的火焰，

792
00:49:38,390 --> 00:49:44,680
all the blocks are in each all the blocks of the file are in a blog group.
文件的所有块都在一个块组中的每个块中。

793
00:49:44,690 --> 00:49:48,460
If they are in a blog groups and going from one block to another.
如果他们在一个博客群组中，并且从一个区块转移到另一个区块。

794
00:49:48,690 --> 00:49:50,600
Even if they are not contiguous,
即使它们不是连续的，

795
00:49:50,920 --> 00:49:52,510
the sick time is going to be loved.
病假将会被喜爱。

796
00:50:02,590 --> 00:50:02,940
Also, here,
此外，在这里，

797
00:50:02,950 --> 00:50:10,200
one thing which I didn't mention is that the I note for for files,
我没有提到的一件事是，I节点也适用于文件。

798
00:50:10,860 --> 00:50:16,560
and the pattern is the entire directories with the files.
模式是包括文件在内的整个目录。

799
00:50:17,660 --> 00:50:22,300
They the file system tries to put them on the same cylinder.
文件系统尝试将它们放在同一个柱面上。

800
00:50:23,510 --> 00:50:23,930
Right?
对吗？

801
00:50:24,250 --> 00:50:29,670
So on different corresponding blocks on different bladders of that is right.
所以在不同的膀胱上的不同对应区块上是正确的。

802
00:50:30,150 --> 00:50:33,040
It's, again, to minimize a sick time, in this case,
这是为了尽量减少病假时间，这种情况下，

803
00:50:33,640 --> 00:50:37,560
going to do analysis from directory.
将要从目录中进行分析。

804
00:50:37,760 --> 00:50:40,750
You all the information is within the same cylinder.
所有的信息都在同一个柱面内。

805
00:50:48,270 --> 00:50:52,060
I will discuss about this data block metadata and free space are
我将讨论关于数据块元数据和空闲空间的问题。

806
00:50:52,070 --> 00:50:53,260
within each block.
在每个块内部。

807
00:50:53,730 --> 00:50:57,190
A voice huge, 6 time between user data and system structures.
一个巨大的声音，在用户数据和系统结构之间有6倍的差距。

808
00:51:00,240 --> 00:51:03,880
You also put the directory, like I mentioned,
你也可以像我提到的那样，将目录放在这里。

809
00:51:03,890 --> 00:51:06,210
and these files in the common logo.
这些文件在公共标志中。

810
00:51:06,700 --> 00:51:07,060
Basically,
基本上，

811
00:51:07,070 --> 00:51:11,330
you try to preserve some locality between the meta data of the files
你尝试在文件的元数据之间保持一定的局部性

812
00:51:11,340 --> 00:51:13,610
and the data blocks of the files
文件的数据块

813
00:51:14,910 --> 00:51:19,470
on by being careful how you store them on the disk.
通过谨慎地将它们存储在磁盘上来实现。

814
00:51:19,730 --> 00:51:21,480
But I try to be close to each other.
但是我试图让彼此靠近。

815
00:51:24,340 --> 00:51:25,420
Like I mentioned,
正如我之前提到的，

816
00:51:25,430 --> 00:51:31,490
the least the free block allocation.
最小的空闲块分配。

817
00:51:33,120 --> 00:51:41,430
Here we use bit map that before we used least by using bit map,
在这里，我们使用位图来实现之前使用位图的最小值。

818
00:51:41,440 --> 00:51:44,070
you can actually avoid some fragmentation.
你实际上可以避免一些碎片化。

819
00:51:45,090 --> 00:51:46,480
One important things,
一个重要的事情，

820
00:51:48,070 --> 00:51:49,530
which is true,
哪个是正确的，

821
00:51:49,770 --> 00:51:56,650
both for the file systems in unix,
对于Unix中的文件系统，

822
00:51:57,650 --> 00:51:59,860
bsd 4.1 and 4.2,
BSD 4.1和4.2，

823
00:52:00,050 --> 00:52:03,090
is that you need to keep some 10%,
这意味着你需要保留10%的金额。

824
00:52:03,100 --> 00:52:05,190
20% of free space, always,
始终保持20%的可用空间。

825
00:52:05,490 --> 00:52:07,060
because this, too.
因为这个原因，也是如此。

826
00:52:07,340 --> 00:52:10,770
But because if you don't have any kind of free space,
但是如果你没有任何空闲空间，

827
00:52:11,420 --> 00:52:17,320
really, you have no freedom about where to allocate the new blocks.
实际上，你没有自由决定在哪里分配新的块。

828
00:52:17,760 --> 00:52:20,230
They are going to become pretty, very random.
它们将变得相当随机。

829
00:52:20,550 --> 00:52:25,580
The performance of the disk will will slow down to a crowd.
磁盘的性能将会变得非常慢。

830
00:52:26,490 --> 00:52:26,770
Right?
对吗？

831
00:52:27,470 --> 00:52:30,250
But i'll say a few more words about that.
但我还想多说几句关于这个的。

832
00:52:30,540 --> 00:52:32,950
But now let's see what is a big difference?
但现在让我们看看有什么大的区别？

833
00:52:32,960 --> 00:52:40,990
And what is the advantage of maintaining a big map for the three blocks?
保持一个大地图的优势是什么？

834
00:52:41,350 --> 00:52:43,190
Instead of linguists?
而不是语言学家？

835
00:52:44,290 --> 00:52:45,280
Here is a difference.
这是一个区别。

836
00:52:50,730 --> 00:52:52,040
We'll go over the summary here.
我们将在这里概述一下。

837
00:52:52,050 --> 00:52:53,120
So here is the difference.
所以这里有一个区别。

838
00:52:54,380 --> 00:52:55,650
So here is a bit much.
这里有一点太多了。

839
00:52:56,230 --> 00:52:56,780
Okay?
好的？

840
00:52:57,470 --> 00:53:00,460
The dark shades,
深色的阴影，

841
00:53:00,770 --> 00:53:01,800
each rectangle,
每个矩形，

842
00:53:01,810 --> 00:53:03,120
it's a correspondence to block,
这是一封关于阻塞的通信。

843
00:53:03,130 --> 00:53:04,680
a square correspondence to block,
一个正方形对应一个块。

844
00:53:07,930 --> 00:53:10,040
the shy shaded, one represent blocks,
腼腆的阴影，一个代表着块。

845
00:53:10,050 --> 00:53:11,160
which are in yours,
在你的里面有哪些？

846
00:53:11,390 --> 00:53:13,390
and the white one cities and three blocks.
还有一个白色的城市和三个街区。

847
00:53:16,870 --> 00:53:18,110
So a here,
所以在这里，

848
00:53:18,240 --> 00:53:19,990
a it's a very nice characteristic.
这是一个非常好的特点。

849
00:53:20,680 --> 00:53:29,620
Let's say that I I I am starting to add to expand the a file,
假设我正在开始扩展一个文件。

850
00:53:29,820 --> 00:53:32,870
and i'm going to allocate new blocks, right?
我需要分配新的块吗？

851
00:53:32,880 --> 00:53:34,800
I have to allocate new blocks.
我需要分配新的数据块。

852
00:53:34,810 --> 00:53:35,030
Okay?
好的？

853
00:53:35,440 --> 00:53:37,350
What i'm going to do here,
我在这里要做什么，

854
00:53:37,570 --> 00:53:40,210
i'm going to go through this speed map.
我要浏览一下这个速度图。

855
00:53:40,220 --> 00:53:42,890
I'm going to start reading from the beginning.
我打算从头开始阅读。

856
00:53:43,550 --> 00:53:48,350
Whenever i'm going to see a free blog,
每当我要查看一个免费博客时，

857
00:53:48,710 --> 00:53:49,980
i'm going to allocate it.
我将要分配它。

858
00:53:49,990 --> 00:53:51,060
So this one,
所以这个问题，

859
00:53:51,070 --> 00:53:53,300
the blue ones are the one which have been allocated.
蓝色的是已经被分配的。

860
00:53:54,580 --> 00:53:55,130
So far.
到目前为止。

861
00:53:55,140 --> 00:53:55,690
So good.
太好了。

862
00:53:55,700 --> 00:53:59,330
Again, it's like i'm going to allocate what I seek encounter.
再次，就好像我要分配我所寻找的遭遇一样。

863
00:53:59,340 --> 00:53:59,850
First.
首先。

864
00:54:00,370 --> 00:54:01,620
These blocks, actually,
这些块，实际上，

865
00:54:01,630 --> 00:54:03,720
in terms of the location,
就地理位置而言，

866
00:54:03,970 --> 00:54:08,510
can be quite random if they are not one near each other.
如果它们不彼此靠近，那么它们可能会相当随机。

867
00:54:09,580 --> 00:54:10,330
However,
然而，

868
00:54:10,920 --> 00:54:20,190
when I am going to start allocating the more I allocate or file,
当我开始分配更多的内存或文件时，

869
00:54:20,530 --> 00:54:22,130
the more i'm going to start,
我越是要开始了

870
00:54:22,410 --> 00:54:25,040
looking for bigger gaps,
寻找更大的间隙

871
00:54:25,890 --> 00:54:26,270
right?
对的？

872
00:54:26,960 --> 00:54:30,630
For more contiguous regions.
对于更多的连续区域。

873
00:54:31,510 --> 00:54:32,020
Okay?
好的？

874
00:54:33,950 --> 00:54:36,460
I think that's basically the key.
我认为这基本上就是关键。

875
00:54:36,930 --> 00:54:39,100
So initially, I am allocating,
所以最初，我正在分配内存，

876
00:54:40,930 --> 00:54:41,930
as I find,
据我所知，

877
00:54:42,640 --> 00:54:45,770
these blocks available, empty.
这些块可用，为空。

878
00:54:46,980 --> 00:54:48,640
But then after a while,
但是过了一会儿，

879
00:54:49,090 --> 00:54:52,630
when I start to allocate more and more new blocks to file,
当我开始为文件分配越来越多的新块时，

880
00:54:52,850 --> 00:54:56,650
I am starting to look more and more for contiguous blocks.
我越来越开始寻找连续的块。

881
00:54:57,550 --> 00:54:57,900
Right?
对吗？

882
00:54:58,290 --> 00:54:59,840
Because I have a bit map.
因为我有一个位图。

883
00:55:00,090 --> 00:55:02,680
It's much easier to look for continuous blocks,
寻找连续的块要容易得多，

884
00:55:02,690 --> 00:55:05,580
because I know I just look at the bit map.
因为我知道我只需要查看位图。

885
00:55:05,960 --> 00:55:09,040
In the case of the linguist is much harder because I need to pop
在语言学家的情况下，这要困难得多，因为我需要弹出

886
00:55:09,050 --> 00:55:13,290
up from to go from one to another entry with a linguist.
与一位语言学家一起从一个词条跳转到另一个词条。

887
00:55:14,380 --> 00:55:15,720
With a linguist, really,
真的是一个语言学家，

888
00:55:15,730 --> 00:55:21,350
I am going to in the order in which I am going to see to find
我将按照我要查找的顺序进行处理。

889
00:55:21,360 --> 00:55:23,500
in the linguist the three blocks.
在语言学中有三个块。

890
00:55:26,130 --> 00:55:27,120
Does it make sense?
这有意义吗？

891
00:55:28,850 --> 00:55:34,810
Then the pldr here is that a a with a if I have a big map,
那么这里的pldr是，如果我有一个大地图，那么a a与a if。

892
00:55:36,140 --> 00:55:46,090
then it's much easier for me to identify contiguous regions of three blocks.
那么对我来说，要识别连续的三个块的区域就容易多了。

893
00:55:49,240 --> 00:55:51,880
It's a simple that more efficient.
这是一个更高效的简单方法。

894
00:55:53,370 --> 00:55:55,880
Then as I have of larger and larger files,
随着我处理越来越大的文件，

895
00:55:55,890 --> 00:55:57,480
which advocate more and more blocks,
越来越多的支持者提倡增加区块数量。

896
00:55:57,490 --> 00:56:03,770
I am going to start using and allocate more of these contiguous blocks.
我将开始使用并分配更多这些连续的块。

897
00:56:18,690 --> 00:56:19,480
It's a bit map.
这是一个位图。

898
00:56:19,930 --> 00:56:20,920
The question here.
这里的问题是什么？

899
00:56:20,930 --> 00:56:24,120
The blocks here are in an area rather than a linguist.
这里的块是指一个区域，而不是一个语言学家。

900
00:56:24,680 --> 00:56:27,700
Yes, again, it's a a bit map is by definition and others,
是的，再次强调，位图的定义和其他方面是这样的，

901
00:56:28,560 --> 00:56:32,130
but it's very efficient, right?
但是它非常高效，对吗？

902
00:56:32,600 --> 00:56:32,820
A pointer.
一个指针。

903
00:56:32,830 --> 00:56:34,070
How many beats you have?
你有多少节拍？

904
00:56:34,080 --> 00:56:34,320
Right?
对吗？

905
00:56:34,330 --> 00:56:37,530
For a point that you have beats 4 bytes, right?
对于一个点，你有4个字节的节拍，对吗？

906
00:56:37,540 --> 00:56:38,730
32 beats, at least.
至少32拍。

907
00:56:39,650 --> 00:56:42,250
Here you have for one block, you have 1 bit.
在这里，对于一个块，你有1个比特。

908
00:56:46,040 --> 00:56:46,370
Right?
对吗？

909
00:56:53,900 --> 00:56:54,810
Now let's go back.
现在让我们回到之前的地方。

910
00:56:57,670 --> 00:57:02,540
A summary for these fast file systems are now layout.
现在对这些快速文件系统进行了布局的摘要。

911
00:57:04,300 --> 00:57:06,260
If you have a small directory,
如果你有一个小目录，

912
00:57:06,270 --> 00:57:10,080
you can fit all the data of the files in the directory,
你可以将目录中所有文件的数据都放得下。

913
00:57:10,090 --> 00:57:11,240
in the same cylinder.
在同一个柱面中。

914
00:57:11,510 --> 00:57:13,580
There is no very little six.
没有非常少的六。

915
00:57:14,230 --> 00:57:14,510
Right?
对吗？

916
00:57:19,700 --> 00:57:28,600
So If the file had that is are smaller than the whole blocks,
如果文件的大小小于整个块的大小，那么

917
00:57:28,610 --> 00:57:32,920
you can obviously fetch many of those at the same time.
你显然可以同时获取许多这样的东西。

918
00:57:33,500 --> 00:57:38,700
The last one, remember that one of the disadvantage of 4.1,
最后一个，记住4.1的一个缺点是

919
00:57:38,710 --> 00:57:41,420
it was big reliability,
它非常可靠。

920
00:57:42,060 --> 00:57:44,770
because all the eye notes are in one place.
因为所有的眼睛笔记都在一个地方。

921
00:57:45,130 --> 00:57:46,980
If that place is corrupted,
如果那个地方已经被损坏了，

922
00:57:47,190 --> 00:57:50,110
you lost all the information from the entire risk.
你丢失了整个风险的所有信息。

923
00:57:51,880 --> 00:57:54,590
Right here, it's basically,
就在这里，基本上，

924
00:57:54,600 --> 00:57:56,270
if some part is corrupted,
如果某个部分损坏了，

925
00:57:56,950 --> 00:57:58,460
maybe you lose some eye nodes,
也许你失去了一些眼睛节点。

926
00:57:58,470 --> 00:58:00,380
the information about some files.
一些文件的信息。

927
00:58:00,830 --> 00:58:02,780
You can never access those files,
你永远无法访问那些文件。

928
00:58:03,150 --> 00:58:04,710
but many other files,
但还有许多其他文件，

929
00:58:04,930 --> 00:58:06,880
they are still going to be accessible,
它们仍然将是可访问的。

930
00:58:07,110 --> 00:58:10,220
because that I knows are going to be intact because they are stored
因为我知道它们将保持完好无损，因为它们被存储了起来。

931
00:58:10,230 --> 00:58:11,720
on different places on the disk.
在磁盘的不同位置上。

932
00:58:13,450 --> 00:58:13,900
Okay.
好的。

933
00:58:15,490 --> 00:58:18,760
Here is another very interesting aspect is a rotation like this.
这里还有一个非常有趣的方面，就是像这样的旋转。

934
00:58:18,770 --> 00:58:20,000
We talk about the sick.
我们谈论病人。

935
00:58:20,910 --> 00:58:27,270
The group block groups are intended to reduce the overhead for the sick time.
组块组旨在减少病假的开销。

936
00:58:27,630 --> 00:58:29,040
What about rotation letters?
旋转字母是什么意思？

937
00:58:31,140 --> 00:58:32,450
Here is a one interesting thing.
这是一个有趣的事情。

938
00:58:34,510 --> 00:58:36,700
Initially, with the unix,
最初，使用Unix系统，

939
00:58:38,290 --> 00:58:39,780
a lot of these blocks,
很多这些块，

940
00:58:40,840 --> 00:58:45,910
the block is a lot of functionality of the file system was implemented
这个块是文件系统的许多功能被实现的地方。

941
00:58:45,920 --> 00:58:48,570
in the operating system.
在操作系统中。

942
00:58:49,310 --> 00:58:51,240
The controllers of the drive,
驱动器的控制器

943
00:58:51,250 --> 00:58:52,680
this drive was very simple.
这个驱动程序非常简单。

944
00:58:53,950 --> 00:58:57,100
Now, the operating system was getting a block,
现在，操作系统正在获取一个块。

945
00:59:00,200 --> 00:59:00,530
right?
对的吗？

946
00:59:01,910 --> 00:59:05,350
Say, and then needs to transfer the data from the block.
然后需要将数据从块中传输。

947
00:59:06,740 --> 00:59:09,230
But while transferring the data from the block,
在从块中传输数据时，

948
00:59:10,390 --> 00:59:13,990
the head was on top of the next sector.
头部位于下一个扇区的顶部。

949
00:59:17,600 --> 00:59:22,820
And then you don't know, right?
然后你不知道，对吗？

950
00:59:22,830 --> 00:59:26,810
And then you are going to miss reading the data from the next sector.
然后你将无法读取下一个扇区的数据。

951
00:59:27,580 --> 00:59:28,000
Right?
对吗？

952
00:59:28,320 --> 00:59:29,950
Basically, think about this.
基本上，思考一下这个问题。

953
00:59:29,960 --> 00:59:31,190
I am want to do.
我想要做什么。

954
00:59:31,480 --> 00:59:36,050
Ii want to transfer the data from sectors one by one.
我想逐个扇区地传输数据。

955
00:59:36,590 --> 00:59:38,960
Assume that the data is on contiguous sectors.
假设数据在连续的扇区上。

956
00:59:39,350 --> 00:59:39,900
It's great.
太棒了。

957
00:59:40,250 --> 00:59:40,700
Right?
对吗？

958
00:59:40,880 --> 00:59:44,030
But now the problem is that I read the data from a sector.
但现在的问题是我从一个扇区读取数据。

959
00:59:44,490 --> 00:59:47,740
And while i'm transferring the data from the sector to read it,
在我将数据从扇区传输并读取时，

960
00:59:48,000 --> 00:59:49,520
the head is on the next sector.
头部在下一个扇区上。

961
00:59:50,370 --> 00:59:50,760
Right?
对吗？

962
00:59:52,420 --> 00:59:57,490
And then I missed that I miss the beginning of the next sector,
然后我错过了下一个扇区的开头。

963
00:59:58,150 --> 00:59:58,580
right?
对的？

964
00:59:59,120 --> 01:00:04,040
Then I need to wait for the entire rotation of the disk to get the next sector.
那么我需要等待整个磁盘的旋转才能获取下一个扇区。

965
01:00:05,840 --> 01:00:11,040
So one original techniques to address this problem,
因此，解决这个问题的一个原始技术是，

966
01:00:11,380 --> 01:00:15,370
it was is when I I am writing data on sectors,
当我在扇区上写入数据时，它是如此的。

967
01:00:15,710 --> 01:00:16,770
is to intervene,
是为了干预，

968
01:00:16,780 --> 01:00:21,500
do not write data downs on subsequent sectors,
不要将数据写入后续扇区

969
01:00:22,000 --> 01:00:24,000
but skip one sector.
但跳过一个扇区。

970
01:00:24,930 --> 01:00:26,880
So that when I read the data,
这样当我读取数据时，

971
01:00:27,160 --> 01:00:29,570
then i'm reading the data on a sector.
然后我正在读取一个扇区上的数据。

972
01:00:29,580 --> 01:00:34,690
And while i'm transferring the data from that sector to the operating system,
当我将数据从该扇区传输到操作系统时，

973
01:00:35,410 --> 01:00:42,630
I I am not going to the next sector is fine if i'm skipping it,
如果我跳过下一个扇区，那是可以的。

974
01:00:42,640 --> 01:00:45,190
because it doesn't contain the data from the file.
因为它不包含文件中的数据。

975
01:00:45,600 --> 01:00:47,040
By the time the head,
到头的时候，

976
01:00:47,050 --> 01:00:48,490
it's over the next sector,
它在下一个扇区上。

977
01:00:48,500 --> 01:00:50,520
which contains the data from the file,
其中包含了文件的数据。

978
01:00:50,530 --> 01:00:52,450
I am ready to read it to read.
我已经准备好阅读了。

979
01:00:58,530 --> 01:00:59,090
Make sense?
有意义吗？

980
01:01:01,650 --> 01:01:06,190
So basically, here you overlap the transfer time,
基本上，在这里你重叠了传输时间。

981
01:01:06,840 --> 01:01:07,170
right?
对的？

982
01:01:10,230 --> 01:01:11,030
With a rotation,
通过旋转，

983
01:01:16,410 --> 01:01:17,290
it is pretty cool.
这很酷。

984
01:01:18,770 --> 01:01:22,930
It turns out that actually,
事实证明，实际上，

985
01:01:22,940 --> 01:01:26,090
the other solution was you just read ahead.
另一种解决方案是提前阅读。

986
01:01:26,100 --> 01:01:28,100
I read a sector.
我读取了一个扇区。

987
01:01:29,320 --> 01:01:31,310
While i'm transferring it after that,
在那之后，我正在进行传输。

988
01:01:31,320 --> 01:01:34,310
i'm not sure whether I need the data from the next sector or not.
我不确定我是否需要下一个扇区的数据。

989
01:01:37,040 --> 01:01:37,750
But it's okay.
但没关系。

990
01:01:38,540 --> 01:01:40,660
I'm just assuming that i'm needing it.
我只是假设我需要它。

991
01:01:41,470 --> 01:01:42,570
So i'm going to read ahead.
所以我打算提前阅读。

992
01:01:45,460 --> 01:01:46,490
And if I don't need it,
如果我不需要它，

993
01:01:46,500 --> 01:01:47,730
i'm going to discuss it.
我会讨论这个问题。

994
01:01:50,660 --> 01:01:51,810
I'm just going to buffer it.
我只是要将其缓冲。

995
01:01:51,820 --> 01:01:53,810
I just need a buffer to push more data.
我只需要一个缓冲区来存储更多的数据。

996
01:01:56,000 --> 01:01:59,340
So that's that's another solution.
那就是另一个解决方案。

997
01:01:59,350 --> 01:02:00,780
It's more flexible solution.
这是一个更灵活的解决方案。

998
01:02:01,500 --> 01:02:06,780
And this is actually what they it's used.
这实际上就是它们的用途。

999
01:02:07,290 --> 01:02:12,440
And this is implemented mostly in the controllers of the disk.
这主要是在磁盘的控制器中实现的。

1000
01:02:13,440 --> 01:02:16,040
The disk has a ram has a buffer, if you remember.
磁盘上有一个缓冲区，如果你还记得的话。

1001
01:02:16,050 --> 01:02:17,440
So you read in that buffer,
所以你从缓冲区中读取数据，

1002
01:02:17,780 --> 01:02:19,500
and then you transfer to the operating system.
然后你转移到操作系统。

1003
01:02:23,610 --> 01:02:24,730
Any questions about this?
对此有任何问题吗？

1004
01:02:35,520 --> 01:02:37,870
The first solution is implementing your rewriting,
第一个解决方案是实现你的重写。

1005
01:02:37,880 --> 01:02:41,230
while the second one is implementing your reading is a question.
第二个实现是在你阅读时提出一个问题。

1006
01:02:42,310 --> 01:02:43,500
No, not really.
不，不是真的。

1007
01:02:43,830 --> 01:02:47,080
In both cases, you can think about this optimization for reading.
在这两种情况下，你可以考虑这种读取的优化。

1008
01:02:47,660 --> 01:02:52,490
It's, again, the problem here is that you read a sector,
问题在于你读取了一个扇区，

1009
01:02:52,500 --> 01:02:56,290
and then I I am going to send the request for reading the next sector
然后我将发送读取下一个扇区的请求

1010
01:02:56,300 --> 01:02:57,850
and the next sector and the next.
以及下一个扇区和接下来的扇区。

1011
01:02:58,790 --> 01:03:00,140
I'm reading this sector.
我正在读取这个扇区。

1012
01:03:00,530 --> 01:03:03,000
And then I need to transfer the data from the sectors.
然后我需要将数据从扇区传输出来。

1013
01:03:03,010 --> 01:03:04,360
And by the time,
到那个时候，

1014
01:03:04,620 --> 01:03:08,070
I am going to issue the request for it in the next sector.
我将在下一个扇区发出请求。

1015
01:03:09,290 --> 01:03:13,020
The head, it's already over the next sector,
磁头已经移到了下一个扇区。

1016
01:03:13,030 --> 01:03:14,250
on the list.
已列入名单。

1017
01:03:15,620 --> 01:03:15,950
Right?
对吗？

1018
01:03:17,310 --> 01:03:18,500
I'm reading this sector,
我正在读取这个扇区。

1019
01:03:18,510 --> 01:03:19,860
and then I am,
然后我是，

1020
01:03:20,120 --> 01:03:24,160
by the time I am going to issue the request for reading the next sector
到我发出读取下一个扇区的请求时

1021
01:03:25,950 --> 01:03:26,980
from the file.
从文件中。

1022
01:03:28,040 --> 01:03:30,720
The next i'm already over the next sector, i'm going.
下一个我已经超过了下一个扇区，我继续前进。

1023
01:03:30,730 --> 01:03:32,120
So if it happened,
如果发生了这种情况，

1024
01:03:32,740 --> 01:03:35,400
that is actually the sector.
那实际上是扇区。

1025
01:03:35,660 --> 01:03:39,590
I want to read it just after the sector I am reading,
我想在读取的扇区之后立即读取它。

1026
01:03:42,150 --> 01:03:43,800
then I am going to miss it,
那我会错过它了，

1027
01:03:45,320 --> 01:03:48,430
because I don't get in time the comment to read the next sector.
因为我没有及时获取到注释以阅读下一个扇区。

1028
01:03:50,410 --> 01:03:50,960
Therefore,
因此，

1029
01:03:50,970 --> 01:03:57,550
I I have to wait all the way for the destroyed once to read the next sector.
我必须一直等待被破坏的扇区读取下一个扇区。

1030
01:03:58,760 --> 01:04:03,140
What this first optimization says that I am reading a sector,
这个第一个优化意味着我正在读取一个扇区。

1031
01:04:04,500 --> 01:04:09,360
all I am transferring and give you some time before I get the next comment.
我正在传输所有的数据，请给我一些时间，在我收到下一条评论之前。

1032
01:04:10,810 --> 01:04:12,480
And if I get the next comment,
如果我得到下一个评论，

1033
01:04:12,490 --> 01:04:18,010
then I am going to know i'm going to be close to this next sector after I
然后我会知道我接下来要接近的这个扇区之后的情况。

1034
01:04:18,020 --> 01:04:18,610
skipped one.
跳过一个。

1035
01:04:21,100 --> 01:04:21,580
Okay?
好的？

1036
01:04:22,020 --> 01:04:27,580
If I want to continuously in this mode to have maximized performance,
如果我想在这种模式下持续地获得最大化的性能，

1037
01:04:28,010 --> 01:04:30,800
I need to interleave the sectors.
我需要交错扇区。

1038
01:04:31,460 --> 01:04:32,730
I when I write them,
当我写它们时，

1039
01:04:32,740 --> 01:04:33,810
so when I read them,
所以当我阅读它们时，

1040
01:04:33,820 --> 01:04:40,970
I am going to read ones and while i'm transferring and be getting command
我将会读取数据，并在传输过程中接收指令。

1041
01:04:40,980 --> 01:04:41,530
for it,
对于它，

1042
01:04:41,540 --> 01:04:42,970
reading the next sector,
读取下一个扇区

1043
01:04:46,070 --> 01:04:47,430
I have enough time.
我有足够的时间。

1044
01:04:47,950 --> 01:04:50,000
So I am ready to read the next section.
我已经准备好阅读下一节了。

1045
01:04:51,730 --> 01:04:52,480
This makes sense.
这是有道理的。

1046
01:04:58,090 --> 01:05:02,760
How big does a track buffer usually needs to be to store the entire track?
通常，一个磁道缓冲区需要多大才能存储整个磁道？

1047
01:05:02,770 --> 01:05:04,280
That's a very good question.
这是一个非常好的问题。

1048
01:05:05,410 --> 01:05:07,360
So candida had the entire track.
所以 candida 有整个赛道。

1049
01:05:09,870 --> 01:05:13,070
Ii don't know on top of my mind of my head,
我脑海中一时想不起来。

1050
01:05:13,370 --> 01:05:14,520
what is how much?
"how much" 是一个疑问词组，用于询问数量或价格。

1051
01:05:16,920 --> 01:05:17,160
Yeah,
是的，

1052
01:05:18,130 --> 01:05:19,440
i'll try to get back to you,
我会尽快回复您的。

1053
01:05:19,450 --> 01:05:22,980
but I assume a few tens of megabytes,
但我估计大约几十兆字节。

1054
01:05:23,380 --> 01:05:24,520
depending on the disk.
根据磁盘的情况而定。

1055
01:05:27,270 --> 01:05:32,620
But so gilbert did answer your question.
但是 Gilbert 确实回答了你的问题。

1056
01:05:43,770 --> 01:05:44,820
So it's again,
所以又是这样，

1057
01:05:44,830 --> 01:05:50,410
remember that the disks and this controller do a lot of things under the foot,
请记住，磁盘和控制器在底层执行许多操作。

1058
01:05:50,420 --> 01:05:50,810
right?
对的？

1059
01:05:50,820 --> 01:05:51,130
Like,
就像，

1060
01:05:51,630 --> 01:05:52,190
remember,
记住，

1061
01:05:52,200 --> 01:05:56,830
we did last time we learned about c scan and other scheduling algorithms,
上次我们学习了C扫描和其他调度算法。

1062
01:05:56,840 --> 01:05:58,350
three orders, a request.
三个订单，一个请求。

1063
01:05:58,360 --> 01:06:01,580
So therefore, you reduce a 6 time and rotation letters,
因此，你需要将一个字符串中的6个字母进行减少和旋转。

1064
01:06:07,700 --> 01:06:09,410
the price of 4.2,
4.2的价格是多少？

1065
01:06:10,790 --> 01:06:13,870
you have official storage for both small and large files.
你们有专门用于存储小文件和大文件的官方存储空间。

1066
01:06:14,310 --> 01:06:17,330
And this is because you have this direct blocks,
这是因为你有这些直接块。

1067
01:06:17,340 --> 01:06:18,850
indirect block pointers,
间接块指针

1068
01:06:18,860 --> 01:06:21,090
and doubling direct and triple indirect.
并且进行双重直接和三重间接。

1069
01:06:22,410 --> 01:06:25,730
You can accommodate both small files and large files.
您可以同时处理小文件和大文件。

1070
01:06:28,620 --> 01:06:30,370
You have locality for boston,
您的本地位置是波士顿。

1071
01:06:30,380 --> 01:06:32,410
small and large files to try to do that,
尝试处理小文件和大文件来实现这一目标。

1072
01:06:32,420 --> 01:06:40,030
because they try to store them within the same block group or cylinder group.
因为它们试图将它们存储在相同的块组或柱组中。

1073
01:06:40,910 --> 01:06:43,970
And you also try to,
你也试试看，

1074
01:06:44,300 --> 01:06:47,690
you have the locality between the meta data and data,
元数据和数据之间存在局部性。

1075
01:06:47,700 --> 01:06:50,130
because the meta data that is I nodes.
因为元数据是指i节点。

1076
01:06:50,640 --> 01:06:55,510
We try to store them on the same block group,
我们尝试将它们存储在同一个块组中，

1077
01:06:55,830 --> 01:06:58,440
whether the files themselves are stored.
文件本身是如何存储的。

1078
01:07:02,190 --> 01:07:04,180
We didn't talk about this when they say, no,
当他们说不的时候，我们没有讨论过这个。

1079
01:07:04,190 --> 01:07:06,180
the fragmentation is necessary.
碎片化是必要的。

1080
01:07:06,560 --> 01:07:12,250
Not a fragmentation in the study here because you have the big map in what
这里的研究没有碎片化，因为你已经有了整体的大局图。

1081
01:07:12,260 --> 01:07:14,300
happens to is that with and
发生的情况是与之相关的。

1082
01:07:14,310 --> 01:07:17,200
I remember that when I use it long time ago,
我记得很久以前我使用过它。

1083
01:07:18,330 --> 01:07:19,640
when use fat,
使用FAT文件系统时，

1084
01:07:20,530 --> 01:07:26,340
when you or this30 microsoft operating systems,
当你或这30个微软操作系统时，

1085
01:07:27,430 --> 01:07:28,620
the file systems,
文件系统

1086
01:07:28,910 --> 01:07:31,310
what you have from time to time, you need to dance,
有时候，你需要跳舞。

1087
01:07:31,560 --> 01:07:32,750
the fragment, the disk,
碎片，磁盘

1088
01:07:32,760 --> 01:07:34,070
the fragments of this.
这个的碎片。

1089
01:07:34,390 --> 01:07:39,610
What meant is these to rewrite the information from the distribute.
这意味着需要重新编写来自分发的信息。

1090
01:07:39,620 --> 01:07:42,250
So the files are more contiguously stored,
因此文件被更连续地存储，

1091
01:07:43,310 --> 01:07:43,430
right?
对的？

1092
01:07:43,440 --> 01:07:47,460
Because the discourse fragmented as you believe disks,
因为你认为磁盘碎片化了，所以导致了这种讨论的分裂。

1093
01:07:47,930 --> 01:07:51,160
as you delete files and you write more files,
当你删除文件并写入更多文件时，

1094
01:07:51,420 --> 01:07:52,780
is more and more fragmented,
越来越分散

1095
01:07:52,790 --> 01:07:58,180
meaning that the date of the files is stored more and more randomly.
意思是文件的日期存储越来越随机。

1096
01:07:58,480 --> 01:08:03,040
The blocks are more and more randomly from time to time you do the fragmentation.
块的分布越来越随机，有时会导致碎片化。

1097
01:08:03,290 --> 01:08:08,470
So you are going to try again to this to ready to rewrite the files,
所以你打算再试一次，准备重新编写这些文件。

1098
01:08:08,770 --> 01:08:12,160
so to move the blocks around so to speak,
所以可以说，要移动这些块。

1099
01:08:12,550 --> 01:08:16,670
so that the files are stored on contiguous blocks,
这样文件就会存储在连续的块上。

1100
01:08:16,920 --> 01:08:18,510
and the performance will be much better.
而且性能会更好。

1101
01:08:19,110 --> 01:08:19,460
Okay?
好的？

1102
01:08:20,160 --> 01:08:23,200
Here is not really necessary because I told you about these holistics
这里并不是真正必要的，因为我已经告诉你关于这些整体性的事情了。

1103
01:08:23,210 --> 01:08:26,100
in which you try to find large,
在其中你尝试找到大的，

1104
01:08:26,380 --> 01:08:32,300
a a large bunch of three blocks for large files to store the data.
一个用于存储大文件数据的三个块的大捆。

1105
01:08:35,550 --> 01:08:38,390
The course, it's efficient,
这门课程非常高效。

1106
01:08:38,400 --> 01:08:40,230
inefficient for tiny files.
对于小文件来说效率低下。

1107
01:08:42,540 --> 01:08:48,530
It's a little bit unfair because it's still fundamentally the block
这有点不公平，因为它仍然基本上是阻塞的。

1108
01:08:49,040 --> 01:08:50,980
to store the unit of storage.
存储存储单位。

1109
01:08:50,990 --> 01:08:52,090
It's a block.
这是一个块。

1110
01:08:52,590 --> 01:08:54,910
So even if you have1 byte,
即使你只有1个字节，

1111
01:08:55,230 --> 01:08:59,640
you still are going to read or write an entire blog,
你仍然要阅读或撰写一篇完整的博客吗？

1112
01:08:59,650 --> 01:09:00,920
which is four kilobytes.
这是四千字节。

1113
01:09:01,520 --> 01:09:04,550
In additional, you need an eye note for this data block,
此外，您需要为此数据块添加一个注释。

1114
01:09:05,190 --> 01:09:12,040
most of the file systems will have the advantage and inefficient encoding
大多数文件系统都具有高效的编码和低效的编码的优势。

1115
01:09:12,050 --> 01:09:14,280
on file is mostly contiguous on the list.
文件在列表上大多是连续的。

1116
01:09:14,960 --> 01:09:20,510
This basically says that you are going to have this bid map to tell you
这基本上是说你将拥有这个投标地图来告诉你

1117
01:09:20,520 --> 01:09:21,590
where the blocks are.
块的位置在哪里。

1118
01:09:22,080 --> 01:09:26,650
And if you have 1 bit a for each block,
如果每个块都有1位的a，

1119
01:09:27,230 --> 01:09:28,400
but for instance,
例如，

1120
01:09:28,410 --> 01:09:31,860
if the file is continuously a stored on the list,
如果文件持续地存储在列表中，

1121
01:09:32,190 --> 01:09:34,440
then you need only 2 pieces of information.
那么你只需要两个信息。

1122
01:09:34,450 --> 01:09:39,670
What is the beginning the point that to the first block as a point
起始点是以第一个块作为参考点。

1123
01:09:39,680 --> 01:09:40,590
up to the last block?
直到最后一个块吗？

1124
01:09:42,640 --> 01:09:44,710
Because everything in between is continuous,
因为中间的一切都是连续的，

1125
01:09:44,720 --> 01:09:46,750
this what means it's inefficient?
这是什么意思，它是不高效的？

1126
01:09:46,990 --> 01:09:49,890
Encoding one files is mostly contiguous on the disk.
对一个文件进行编码时，它在磁盘上通常是连续存储的。

1127
01:09:52,390 --> 01:09:53,580
And still,
然而，

1128
01:09:53,590 --> 01:09:56,540
in order to avoid the fragmentation,
为了避免碎片化，

1129
01:09:56,550 --> 01:10:00,310
you need to have this kind of space on the disk.
你需要在磁盘上有这种类型的空间。

1130
01:10:00,320 --> 01:10:05,370
So you cannot allocate the entire 100% of the disk space.
所以你不能分配整个100%的磁盘空间。

1131
01:10:06,460 --> 01:10:07,950
You need to leave around 10,
你需要大约在10点离开。

1132
01:10:07,960 --> 01:10:13,430
20% linux.
20% 的用户使用 Linux。

1133
01:10:16,190 --> 01:10:17,440
It's pretty similar.
这非常相似。

1134
01:10:19,520 --> 01:10:22,430
You have12 direct pointers,
你有12个直接指针。

1135
01:10:22,440 --> 01:10:24,030
like in our previous examples.
就像我们之前的例子一样。

1136
01:10:24,040 --> 01:10:24,910
If you remember,
如果你还记得的话，

1137
01:10:26,630 --> 01:10:30,960
when I was a little bit confused between 12 and 10,
当我有点困惑12和10之间的区别时，

1138
01:10:32,400 --> 01:10:34,630
you can have, in this case, you have 12.
在这种情况下，你可以拥有12个。

1139
01:10:36,450 --> 01:10:41,960
The other thing you can configure the says the size of the blocks
另一件你可以配置的事情是块的大小。

1140
01:10:42,850 --> 01:10:45,360
to be different sizes.
大小不同。

1141
01:10:45,610 --> 01:10:46,000
Right?
对吗？

1142
01:10:46,610 --> 01:10:50,160
You can have one kilobyte to kilobytes, four kilobytes, a kilobytes,
你可以有一千字节到一千兆字节，四千字节，一千兆字节。

1143
01:10:50,170 --> 01:10:50,760
and so forth.
等等，诸如此类。

1144
01:10:50,770 --> 01:10:51,320
It's again,
又是这样，

1145
01:10:51,930 --> 01:10:53,840
you don't have in the same system,
你们不在同一个系统中。

1146
01:10:54,090 --> 01:10:55,910
lots of different sizes.
许多不同的尺寸。

1147
01:10:56,300 --> 01:10:57,980
But when you configure the system,
但是当你配置系统时，

1148
01:10:58,430 --> 01:11:01,690
start with, you can choose different block sites.
首先，你可以选择不同的屏蔽网站。

1149
01:11:04,320 --> 01:11:06,510
These x two and x three,
这是两个x和三个x。

1150
01:11:06,520 --> 01:11:09,550
there are different versions of linux.
有不同版本的Linux。

1151
01:11:09,890 --> 01:11:12,360
In terms of particular of this cloud.
就这个云计算而言。

1152
01:11:13,820 --> 01:11:15,100
We also have journaling.
我们还有日志记录。

1153
01:11:15,410 --> 01:11:17,960
We are going to talk about journal ink later,
我们稍后将讨论有关日志墨水的问题。

1154
01:11:18,750 --> 01:11:25,370
but it's a particular way to start the files provide for tolerance.
但这是一种特殊的方式来启动为容错提供的文件。

1155
01:11:25,750 --> 01:11:29,970
And we'll talk more about that.
我们将会更详细地讨论这个问题。

1156
01:11:30,950 --> 01:11:32,150
And other than that,
除此之外，

1157
01:11:32,390 --> 01:11:35,520
is the same kind of organization here.
这里是同一种类型的组织。

1158
01:11:35,940 --> 01:11:36,700
You have,
你有，

1159
01:11:39,530 --> 01:11:43,280
these are the pointers in the group descriptor table.
这些是组描述符表中的指针。

1160
01:11:43,570 --> 01:11:45,740
You have pointer to the blocks in each blocks.
你在每个块中都有指向其他块的指针。

1161
01:11:45,750 --> 01:11:46,860
You are going to have.
你将要拥有。

1162
01:11:47,680 --> 01:11:49,320
You have, I know tables.
你有，我知道表格。

1163
01:11:49,730 --> 01:11:53,340
And then the I know tables are going to go to directory.
然后我知道表格将会被放入目录中。

1164
01:11:53,350 --> 01:11:59,550
This is how the directories are organized in ex two three,
这是 ex two three 中目录的组织方式。

1165
01:12:01,040 --> 01:12:09,360
sending them hard, at least.
至少要给他们点压力。

1166
01:12:10,010 --> 01:12:10,560
Sorry.
抱歉。

1167
01:12:11,300 --> 01:12:13,280
So here,
所以在这里，

1168
01:12:13,550 --> 01:12:17,360
we remember last time we look through this directory structure
我们记得上次我们浏览了这个目录结构。

1169
01:12:17,370 --> 01:12:18,680
and the directory structure.
以及目录结构。

1170
01:12:18,690 --> 01:12:19,670
It's an analogy.
这是一个类比。

1171
01:12:20,730 --> 01:12:21,220
Okay.
好的。

1172
01:12:24,900 --> 01:12:26,540
What you have, typically,
通常情况下，你所拥有的是

1173
01:12:26,550 --> 01:12:30,640
what you can do in unix,
在Unix中，您可以做以下事情：

1. 文件和目录管理：创建、复制、移动、重命名和删除文件和目录。
2. 文件权限管理：设置文件和目录的访问权限，包括读、写和执行权限。
3. 进程管理：启动、停止、监视和管理运行的进程。
4. 用户管理：创建、删除和管理用户账户，设置用户权限和密码。
5. 网络通信：使用网络协议进行网络通信，包括发送和接收数据。
6. 系统配置：配置系统参数、环境变量和系统服务。
7. 软件包管理：安装、更新和卸载软件包。
8. Shell脚本编程：编写和执行Shell脚本以自动化任务和批处理操作。
9. 文件搜索和文本处理：使用命令行工具搜索文件内容、处理文本文件和数据。
10. 系统监控和故障排除：监视系统资源使用情况，诊断和解决系统故障。

这些只是Unix中的一些常见操作，还有许多其他功能和工具可供使用。

1174
01:12:31,040 --> 01:12:34,350
you can have a different,
你可以有不同的选择。

1175
01:12:35,030 --> 01:12:38,190
you can have another hard link is called harding,
你可以创建另一个称为"harding"的硬链接。

1176
01:12:38,200 --> 01:12:40,800
another link to the same file.
同一个文件的另一个链接。

1177
01:12:41,530 --> 01:12:41,930
Right?
对吗？

1178
01:12:41,940 --> 01:12:44,250
You can have the same file,
你可以拥有相同的文件。

1179
01:12:44,610 --> 01:12:49,710
which is basically you can have two names for that files,
这基本上意味着你可以为这些文件设置两个名称。

1180
01:12:49,720 --> 01:12:52,070
and these names can appear in different directors.
这些名称可以出现在不同的目录中。

1181
01:12:54,220 --> 01:12:55,570
When do you want to do that?
你想什么时候做呢？

1182
01:12:55,910 --> 01:13:01,040
Obviously, when I want to share a fart from different directors,
显然，当我想要分享来自不同导演的屁声时，

1183
01:13:02,220 --> 01:13:02,580
right?
对的？

1184
01:13:03,380 --> 01:13:06,900
I want to appear to be locked up to that directory.
我想要看起来被锁定在那个目录里。

1185
01:13:08,040 --> 01:13:08,320
Right?
对吗？

1186
01:13:08,330 --> 01:13:09,680
It's like, for instance,
例如，就像是，

1187
01:13:10,530 --> 01:13:10,810
library fire.
图书馆着火了。

1188
01:13:10,820 --> 01:13:12,110
So it seems like that.
看起来是这样的。

1189
01:13:12,840 --> 01:13:13,030
Right?
对吗？

1190
01:13:13,040 --> 01:13:14,270
And in this case, again,
在这种情况下，再次，

1191
01:13:14,280 --> 01:13:20,980
I i'm going to have point that is the same two different file names
我要指出的是，两个不同的文件名是相同的。

1192
01:13:20,990 --> 01:13:22,900
are going to point to the same file.
将指向同一个文件。

1193
01:13:24,260 --> 01:13:30,270
And in the I node is i'm going to maintain a reference count why I need that?
在 I 节点中，我将维护一个引用计数，为什么我需要这个？

1194
01:13:30,570 --> 01:13:35,890
Because we're all only when all the references I know
因为只有当我知道所有的参考资料时，我们才能一起进行。

1195
01:13:35,900 --> 01:13:38,290
to the same underlying file are removed.
对于相同的底层文件，已删除的链接将被移除。

1196
01:13:38,300 --> 01:13:39,940
I carry on the file.
我继续处理这个文件。

1197
01:13:44,130 --> 01:13:45,160
In addition,
此外，

1198
01:13:45,170 --> 01:13:47,160
I have also soft links.
我也有软链接。

1199
01:13:47,460 --> 01:13:50,930
The soft links provide the same kind of behavior.
软链接提供了相同类型的行为。

1200
01:13:51,210 --> 01:13:51,670
It's again,
又是这样，

1201
01:13:51,680 --> 01:13:58,450
they are used to create another entry in my current directory profile,
它们被用于在我的当前目录配置文件中创建另一个条目。

1202
01:13:58,460 --> 01:14:00,130
which exists in a different directory.
它存在于一个不同的目录中。

1203
01:14:01,980 --> 01:14:04,090
But this is symbolic link,
但这是一个符号链接。

1204
01:14:04,100 --> 01:14:05,530
is our softening.
我们的软化。

1205
01:14:05,880 --> 01:14:06,870
In this case,
在这种情况下，

1206
01:14:06,880 --> 01:14:10,670
it's actually a symbolic link is another entering the directory,
实际上，符号链接是指向另一个目录的入口。

1207
01:14:10,990 --> 01:14:15,480
which basically about it has a file name,
它基本上是关于它有一个文件名的。

1208
01:14:15,490 --> 01:14:18,090
is the new file name,
新文件名是

1209
01:14:18,100 --> 01:14:20,410
and then it's linked to the destination of file name.
然后它会链接到文件名的目标位置。

1210
01:14:21,070 --> 01:14:25,100
You think in bowling and into just something you write in your directory,
你在保龄球中思考，并将其写入你的目录中，

1211
01:14:25,480 --> 01:14:26,980
which basically links the file name,
这基本上是将文件名链接起来，

1212
01:14:26,990 --> 01:14:31,330
the new file name with the destination finding the one which I want to link.
新文件的名称是通过找到我想要链接的目标来确定的。

1213
01:14:32,960 --> 01:14:33,320
Right?
对吗？

1214
01:14:37,710 --> 01:14:39,060
In this particular case,
在这种特定情况下，

1215
01:14:39,070 --> 01:14:42,550
or if the destination file name is removed,
或者如果目标文件名被删除，

1216
01:14:42,800 --> 01:14:50,340
the opening the file using the symbolic link name,
使用符号链接名称打开文件

1217
01:14:51,270 --> 01:14:52,100
it can fail,
它可能会失败。

1218
01:14:53,330 --> 01:14:53,670
right?
对的？

1219
01:14:54,200 --> 01:14:57,400
Because there is no one under the hood to keep the reference counting.
因为没有人在幕后进行引用计数。

1220
01:14:57,720 --> 01:15:05,220
How many as a fine name out of pointing to the same file.
指向同一文件的别名有多少个？

1221
01:15:06,140 --> 01:15:07,570
But this is easier to implement.
但是这个更容易实现。

1222
01:15:12,730 --> 01:15:13,640
This is what it is.
这就是它的样子。

1223
01:15:18,990 --> 01:15:22,450
You can create boss command line,
你可以创建一个强大的命令行界面。

1224
01:15:22,460 --> 01:15:23,610
the symbolic links,
符号链接

1225
01:15:23,620 --> 01:15:24,770
also hard links,
还有硬链接，

1226
01:15:24,780 --> 01:15:29,690
but also you can have a system called to dramatically manipulate
但是你也可以拥有一个被称为系统的工具，可以大幅度地操作。

1227
01:15:29,700 --> 01:15:31,010
this involving links.
这涉及到链接。

1228
01:15:33,590 --> 01:15:35,500
Let's look here as an example,
让我们以这里作为一个例子来看一下，

1229
01:15:35,510 --> 01:15:39,820
and rather than close to the end of the lecture,
而不是在讲座接近结束时，

1230
01:15:40,830 --> 01:15:42,680
about what happens under the hood,
关于底层发生的事情，

1231
01:15:43,440 --> 01:15:48,190
let's say we want to access this file,
假设我们想要访问这个文件，

1232
01:15:48,200 --> 01:15:49,230
a stopped or text,
一个停止或文本。

1233
01:15:49,240 --> 01:15:55,380
and the last name is Holmes last years on c two,
姓氏是霍姆斯，去年在C2班。

1234
01:15:55,800 --> 01:15:58,270
and then is the name of the file, stubborn text.
然后是文件的名称，顽固的文本。

1235
01:15:58,840 --> 01:15:59,240
Right?
对吗？

1236
01:15:59,620 --> 01:16:02,610
First of all, we need to start from the route.
首先，我们需要从路由开始。

1237
01:16:04,260 --> 01:16:09,010
So you need to have the I number of the route and say,
所以你需要知道路由的I号码，并且说出来。

1238
01:16:09,020 --> 01:16:10,650
that's the position to.
这是职位所需的要求。

1239
01:16:13,020 --> 01:16:15,790
And this one is going,
这个正在进行中。

1240
01:16:16,150 --> 01:16:18,660
obviously, it are going to have here.
显然，它将会在这里出现。

1241
01:16:18,670 --> 01:16:19,340
And I know,
我知道，

1242
01:16:20,520 --> 01:16:20,860
right?
对的？

1243
01:16:21,760 --> 01:16:26,180
The inode is going to contain a pointer to the data.
inode将包含指向数据的指针。

1244
01:16:27,060 --> 01:16:28,930
And this data, in this case,
在这种情况下，这些数据

1245
01:16:29,190 --> 01:16:32,720
contains the directory data, right?
包含目录数据，对吗？

1246
01:16:32,730 --> 01:16:33,800
Directory entries.
目录条目。

1247
01:16:36,770 --> 01:16:43,190
Remember, the directory entry maps a to a file number.
记住，目录项将a映射到一个文件编号。

1248
01:16:44,280 --> 01:16:47,390
Let's assume that the file number is 8086.
假设文件编号是8086。

1249
01:16:57,140 --> 01:17:00,000
Now, this is what you have in memory,
现在，这是你在内存中的内容，

1250
01:17:00,010 --> 01:17:01,320
what you have here down.
你在这里写下了什么。

1251
01:17:02,130 --> 01:17:02,720
It's in memory.
它在内存中。

1252
01:17:04,500 --> 01:17:05,000
Now,
现在，

1253
01:17:05,600 --> 01:17:08,280
you read the block 8086,
你读取了块 8086。

1254
01:17:09,250 --> 01:17:09,600
right?
对的？

1255
01:17:10,180 --> 01:17:11,730
What do you get there?
你在那里得到了什么？

1256
01:17:12,070 --> 01:17:18,540
You are going to get the I number of the file.
你将获得文件的I节点编号。

1257
01:17:20,060 --> 01:17:26,140
You have the I number and the I number for this,
你有这个I号和I号。

1258
01:17:27,740 --> 01:17:28,820
the subdirectory,
子目录

1259
01:17:28,830 --> 01:17:30,660
CS 162.
CS 162是计算机操作系统课程。

1260
01:17:31,520 --> 01:17:34,520
And you are going to get from that I number.
然后你会得到一个数字。

1261
01:17:34,530 --> 01:17:37,450
You are going to get data in that directory.
你将在那个目录中获取数据。

1262
01:17:38,320 --> 01:17:43,850
And daytime the directory is going to maintain the entry and mapping
白天，目录将维护条目和映射。

1263
01:17:43,860 --> 01:17:46,250
between csrc two.
在csrc两者之间。

1264
01:17:46,570 --> 01:17:49,180
And it's I number,
这是一个I号码。

1265
01:17:50,490 --> 01:17:52,320
let's say, 7th, 32.
假设是第7个，32。

1266
01:17:53,920 --> 01:17:55,410
You go to 732.
你去732号。

1267
01:17:55,420 --> 01:17:56,660
Now is the eye number.
现在是眼睛编号。

1268
01:17:58,940 --> 01:18:04,420
You are going now finally to get all the Information which is in CS
你现在终于要获取所有在CS中的信息了

1269
01:18:04,430 --> 01:18:05,820
as in the directory,
就像在目录中一样，

1270
01:18:06,100 --> 01:18:10,190
which is also you have file Starbucks next year.
明年你也有一份关于星巴克的文件。

1271
01:18:10,790 --> 01:18:12,700
And one,
还有一个，

1272
01:18:13,110 --> 01:18:15,070
once you read the data in the directory,
一旦你读取了目录中的数据，

1273
01:18:15,080 --> 01:18:18,830
you are going to find the mapping between stuff dot text.
你需要找到 "stuff.dot.text" 之间的映射关系。

1274
01:18:20,290 --> 01:18:24,080
I the number now is ninety nine zero nine.
我现在的数字是九千九百九十九。

1275
01:18:25,140 --> 01:18:27,250
Finally, I have ninety nine zero nine,
最后，我有九千九百九个。

1276
01:18:27,260 --> 01:18:32,050
which is a nine number of stop dot x now I can start reading the data
现在是第九个停止符号x的数字，我可以开始读取数据了。

1277
01:18:32,060 --> 01:18:32,980
from several text.
从几个文本中。

1278
01:18:33,430 --> 01:18:39,510
This may require to read additional blocks before I get to the data blocks.
在访问数据块之前，可能需要读取额外的块。

1279
01:18:39,770 --> 01:18:40,970
If this file is large,
如果这个文件很大，

1280
01:18:40,980 --> 01:18:45,830
and we need to have single indirected or doubling
我们需要使用单间接或双倍间接。

1281
01:18:45,840 --> 01:18:49,910
direct or triple indirect data blocks.
直接或三级间接数据块。

1282
01:18:51,140 --> 01:18:51,500
Okay?
好的？

1283
01:18:52,520 --> 01:18:54,160
This is pretty much what happens.
这基本上就是发生的情况。

1284
01:18:54,760 --> 01:18:58,990
And this is a beside of the files,
这是文件的旁边。

1285
01:18:59,490 --> 01:19:01,130
the data blocks from the file.
文件中的数据块。

1286
01:19:01,710 --> 01:19:03,630
And that's pretty much it.
就是这样了。

1287
01:19:04,640 --> 01:19:10,220
So let's stop here and will continue next time.
那么我们就到这里暂停，下次继续。

1288
01:19:15,450 --> 01:19:16,160
So here,
所以在这里，

1289
01:19:17,100 --> 01:19:23,780
the question is that what is that was also file in slash dot com called CS 062?
问题是，Slashdot.com上也有一个名为CS 062的文件是什么？

1290
01:19:26,030 --> 01:19:27,660
I'm going to answer this question.
我要回答这个问题。

1291
01:19:28,230 --> 01:19:32,980
So basically, if it was in home,
基本上，如果是在家里的话，

1292
01:19:32,990 --> 01:19:35,790
another file CS,
另一个文件 CS

1293
01:19:35,800 --> 01:19:38,310
that will be CS 162 dot text.
那将是CS 162的文本文件。

1294
01:19:39,230 --> 01:19:42,890
But I also have a different extension.
但是我也有一个不同的扩展名。

1295
01:19:43,900 --> 01:19:47,120
So the file system will differentiate.
因此，文件系统将进行区分。

1296
01:19:47,840 --> 01:19:54,390
You have a if as a file system would have exactly the same name
你可以将if作为文件系统的名称，与文件系统完全相同。

1297
01:19:54,400 --> 01:19:56,670
as a directory that cannot happen.
作为一个不可能发生的情况的目录。

1298
01:19:56,680 --> 01:20:05,610
You cannot have a file name and the directory of the same name in the same directory.
在同一个目录中，你不能同时拥有一个文件名和同名的目录。

1299
01:20:07,490 --> 01:20:08,200
You can try it.
你可以试一试。

1300
01:20:09,960 --> 01:20:12,000
You are going, you cannot create it, you don't get another.
你要走了，你不能创造它，你不会再得到另一个。

1301
01:20:14,760 --> 01:20:15,200
Okay?
好的？

1302
01:20:16,010 --> 01:20:16,480
With this.
通过这个。

1303
01:20:16,490 --> 01:20:17,120
Thank you.
谢谢你。

1304
01:20:17,130 --> 01:20:18,800
And i'll see you next time.
下次再见。

