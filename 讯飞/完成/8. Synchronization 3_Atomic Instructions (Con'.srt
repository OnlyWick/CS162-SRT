1
00:00:20,680 --> 00:00:21,520
Hello, everyone.
大家好。

2
00:00:23,970 --> 00:00:25,960
Welcome to the 8th lecture.
欢迎来到第八堂课。

3
00:00:27,030 --> 00:00:29,340
This is really an important lecture.
这是一堂非常重要的讲座。

4
00:00:29,350 --> 00:00:34,810
We are going to learn a lot and continue to learn about synchronization
我们将学习很多关于同步的知识，并持续学习。

5
00:00:34,820 --> 00:00:37,090
and how we are going to solve
我们将如何解决这个问题

6
00:00:37,540 --> 00:00:44,500
the problems and ensure a critical provides a critical section abstraction and
问题和确保关键部分提供了关键部分的抽象化和保证。

7
00:00:45,450 --> 00:00:46,970
and synchronization primitives.
和同步原语。

8
00:00:48,020 --> 00:00:52,420
So let's recall a few things from the last time, in particular,
让我们回顾一下上次的内容，特别是以下几点：

9
00:00:52,430 --> 00:00:53,300
summer force.
夏季力量。

10
00:00:54,040 --> 00:00:55,110
If you remember,
如果你还记得的话，

11
00:00:55,120 --> 00:00:58,760
some of us are like generalized locks,
我们中的一些人就像是通用锁，

12
00:00:59,170 --> 00:01:01,050
and they are defined many times,
它们被多次定义了，

13
00:01:01,060 --> 00:01:02,130
many years ago,
许多年前，

14
00:01:02,140 --> 00:01:04,490
like 60 years ago, almost.
大约60年前左右。

15
00:01:04,990 --> 00:01:08,340
And it's it was a main synchronization,
这是一个主要的同步机制。

16
00:01:08,350 --> 00:01:11,600
primitive used in original units.
原始单位中使用的原语。

17
00:01:11,610 --> 00:01:13,840
And when we are talking here about synchronization,
当我们在这里谈论同步时，

18
00:01:13,850 --> 00:01:19,410
we are talking about in the context of implementing a critical section.
我们正在讨论实现临界区的上下文。

19
00:01:19,420 --> 00:01:21,490
If you remember a critical section,
如果你记得一个关键区域，

20
00:01:22,120 --> 00:01:28,370
a it's a sequence of code as in which only one thread can be
这是一个代码序列，其中只有一个线程可以执行。

21
00:01:28,380 --> 00:01:29,890
active at a given time.
在给定的时间内活跃。

22
00:01:30,450 --> 00:01:34,800
Therefore, if one thread is active in a critical section,
因此，如果一个线程正在执行临界区代码，

23
00:01:35,200 --> 00:01:37,720
the other threads which want to enter the critical section,
其他想要进入临界区的线程，

24
00:01:37,730 --> 00:01:40,320
but they could the code they need to wait.
但是他们可以编写他们需要等待的代码。

25
00:01:40,650 --> 00:01:45,050
But I so need a mechanism to synchronize this kind of entrance
但是我确实需要一种同步机制来同步这种进入方式

26
00:01:45,060 --> 00:01:46,170
to the critical section,
进入临界区

27
00:01:46,180 --> 00:01:48,730
and then on a thread exit the critical section.
然后在线程退出临界区。

28
00:01:48,740 --> 00:01:53,160
And as a thread from the waiting ones is going to enter the critical section.
当一个等待的线程即将进入临界区时。

29
00:01:55,570 --> 00:01:57,280
And there are two primitives,
还有两个原语，

30
00:01:57,290 --> 00:02:01,790
b and b b is,
b和b b是什么意思？

31
00:02:01,800 --> 00:02:03,070
if the sum of four is zero,
如果四个数的和为零，

32
00:02:03,770 --> 00:02:05,370
it be it's waiting.
它正在等待。

33
00:02:05,630 --> 00:02:08,540
If the summer for its greater than zero, it decrement it.
如果夏季的值大于零，则将其减一。

34
00:02:11,290 --> 00:02:13,960
The other one v basically,
另一个基本上是这样的。

35
00:02:13,970 --> 00:02:16,560
it's just increment a similar follow up by one.
这只是将一个类似的后续递增一。

36
00:02:16,840 --> 00:02:21,150
If the similar for a zero and if it's increment to one,
如果相似的话，将其增加到一。

37
00:02:21,160 --> 00:02:25,030
then is going to wake up one of this,
然后将会唤醒其中一个,

38
00:02:25,510 --> 00:02:27,610
one of the threads,
其中一个线程，

39
00:02:27,970 --> 00:02:30,450
which was waiting on a summer for if any.
是否有任何夏天等待着它。

40
00:02:32,430 --> 00:02:32,850
Okay.
好的。

41
00:02:33,800 --> 00:02:35,950
These are 2 years of the summer force.
这是两年的暑期实习经历。

42
00:02:35,960 --> 00:02:37,710
We went over last time.
我们上次已经讲过了。

43
00:02:37,720 --> 00:02:39,190
One is mutual exclusion.
其中之一是互斥。

44
00:02:39,560 --> 00:02:42,190
Again, this is about implementing critical sections.
这次是关于实现临界区的问题。

45
00:02:42,900 --> 00:02:43,500
Here.
在这里。

46
00:02:45,730 --> 00:02:47,040
It's very simple.
这很简单。

47
00:02:47,050 --> 00:02:51,610
You are going to initialize the same effort to one.
你将把相同的努力初始化为一。

48
00:02:52,240 --> 00:02:57,200
And then you put before and after a critical section,
然后你在临界区的前后加上代码。

49
00:02:57,970 --> 00:03:01,670
ap and av the first thread,
对第一个线程进行访问权限 (ap) 和地址空间 (av) 的操作。

50
00:03:01,680 --> 00:03:06,110
which is going to execute the instruction p that's enough for each one
每个执行指令 p 的都足够了。

51
00:03:06,120 --> 00:03:07,230
is going to decrement.
将要递减。

52
00:03:07,240 --> 00:03:09,230
It is going to enter the critical section.
它即将进入临界区。

53
00:03:09,510 --> 00:03:12,820
If another thread comes and right execute the curve,
如果另一个线程进来并正确执行曲线操作，

54
00:03:12,830 --> 00:03:14,060
the summer for now is zero.
现在的夏天是零。

55
00:03:14,590 --> 00:03:18,660
It has to wait when the first summer for x is a critical section,
当第一个夏天对于x来说是一个临界区时，它必须等待。

56
00:03:18,920 --> 00:03:22,310
is calling v and v it's increment in the summer for.
在夏天里，调用v并对其进行递增。

57
00:03:22,320 --> 00:03:24,110
And therefore,
因此，

58
00:03:24,120 --> 00:03:25,150
as a result,
结果是，

59
00:03:25,430 --> 00:03:29,550
we signal the thread who is wiping to enter the critical section.
我们发出信号，让正在清除的线程进入临界区。

60
00:03:30,450 --> 00:03:30,760
Right?
对吗？

61
00:03:32,750 --> 00:03:34,940
And it's also the scheduling constraints.
这也是调度约束的问题。

62
00:03:35,240 --> 00:03:41,520
This is basically we want to signal to wait for a thread or a signal,
这基本上是我们想要发出等待线程或信号的信号。

63
00:03:41,530 --> 00:03:42,880
a thread to do something.
一个线程来做某事。

64
00:03:43,770 --> 00:03:45,720
Here, the initial value is zero.
这里，初始值为零。

65
00:03:45,730 --> 00:03:50,080
And the classic example is a joint implementation for the thread.
经典示例是线程的联合实现。

66
00:03:50,320 --> 00:03:52,910
You remember that with a join,
你记得使用join操作，

67
00:03:52,920 --> 00:03:54,830
the patterns of the thread,
线程的模式

68
00:03:55,110 --> 00:03:58,150
which execute the joint ways for another step to finish.
执行联合方式以完成另一步骤。

69
00:03:58,540 --> 00:03:59,080
Okay?
好的？

70
00:03:59,600 --> 00:04:01,320
And so basically, the threat,
基本上，威胁是这样的，

71
00:04:01,330 --> 00:04:05,670
which way is to finish the join?
如何完成连接操作？

72
00:04:06,070 --> 00:04:07,870
They use to implement this.
他们过去常常使用这种方法来实现。

73
00:04:07,880 --> 00:04:11,220
So use the same semaphore.
所以使用相同的信号量。

74
00:04:11,530 --> 00:04:15,490
So the thread in initialize them for 20,
所以线程初始化它们为20个。

75
00:04:15,770 --> 00:04:20,110
and the thread who waits for another thread to join,
以及等待另一个线程加入的线程，

76
00:04:21,400 --> 00:04:24,800
to finish, then it just calling p right?
完成后，只需要调用 p 对吗？

77
00:04:25,150 --> 00:04:29,120
And if the other thread and the other thread when it finishes,
当另一个线程完成时，如果另一个线程完成时，

78
00:04:29,410 --> 00:04:30,290
is calling me.
正在打电话给我。

79
00:04:30,620 --> 00:04:32,730
So if the thread hasn't finished,
那么如果线程还没有完成，

80
00:04:33,490 --> 00:04:34,810
the semaphore is zero,
信号量为零，

81
00:04:35,610 --> 00:04:37,410
the join operation will just wait.
join操作将会进入等待状态。

82
00:04:39,010 --> 00:04:42,610
And it will wait until one until the thread.
它将等待直到线程完成。

83
00:04:42,930 --> 00:04:46,440
We are way it's waiting for its executing this thread finish,
我们正在等待这个线程执行完毕。

84
00:04:46,680 --> 00:04:49,830
which calls v is increment in the summer for the one,
在夏季期间，对于一个v的调用是增加的。

85
00:04:49,840 --> 00:04:53,550
which means that and seeing signals a waiting thread
这意味着并且观察到信号表示一个等待的线程。

86
00:04:53,560 --> 00:04:57,510
and there's waiting thread now the summer for each one and going to
现在每个人都在等待暑假的到来，并准备着。

87
00:04:58,140 --> 00:05:03,780
start executing and decrementing it to zero and finish a code,
开始执行并将其递减至零，然后完成一段代码。

88
00:05:04,620 --> 00:05:06,290
finish the joint operation.
完成联合行动。

89
00:05:09,970 --> 00:05:10,860
Any questions?
有任何问题吗？

90
00:05:13,700 --> 00:05:15,210
Please ask any questions.
请提出任何问题。

91
00:05:17,750 --> 00:05:25,150
If you have any and then we want to to this bounded buffer.
如果你有任何问题，我们想要实现一个有界缓冲区。

92
00:05:25,160 --> 00:05:26,990
So you remember the bounded buffer.
所以你还记得有界缓冲区。

93
00:05:27,000 --> 00:05:28,720
We have a bunch of producers,
我们有一群生产者，

94
00:05:28,730 --> 00:05:29,880
a bunch of consumers,
一群消费者，

95
00:05:29,890 --> 00:05:31,910
the producer put elements in the buffer.
生产者将元素放入缓冲区。

96
00:05:32,270 --> 00:05:35,240
The consumers get elements around the buffer.
消费者从缓冲区获取元素。

97
00:05:37,570 --> 00:05:40,430
You hear, if you look at the constraints,
你听说了吗？如果你看一下限制条件，

98
00:05:40,440 --> 00:05:43,990
what we are talking about here is that for the consumer must wait
我们在讨论的是消费者必须等待的问题。

99
00:05:44,000 --> 00:05:45,910
for the producer to fill the buffer.
为生产者填充缓冲区。

100
00:05:46,060 --> 00:05:47,470
If the buffer is empty,
如果缓冲区为空，

101
00:05:47,480 --> 00:05:49,270
then the consumer have to wait.
那么消费者就必须等待。

102
00:05:49,540 --> 00:05:50,280
On the other hand,
另一方面，

103
00:05:50,290 --> 00:05:53,710
the producers must wait for the consumer to empty the buffer.
生产者必须等待消费者将缓冲区清空。

104
00:05:53,720 --> 00:05:55,270
If the buffer is full,
如果缓冲区已满，

105
00:05:55,280 --> 00:05:57,070
then the producer has to wait,
那么生产者必须等待。

106
00:05:57,080 --> 00:06:01,520
because there are no place in the buffer doing to put new elements.
因为缓冲区中没有空间来存放新的元素。

107
00:06:03,130 --> 00:06:05,580
And there is, obviously,
显然，还有一个问题，

108
00:06:05,590 --> 00:06:09,990
there is the buffer is self manipulating the buffer or the queue.
缓冲区是自我操作的缓冲区或队列。

109
00:06:10,000 --> 00:06:11,350
It's basically,
基本上，

110
00:06:11,360 --> 00:06:12,470
it's a critical section,
这是一个临界区域，

111
00:06:12,480 --> 00:06:17,180
and only one thread is going to manipulate iq right?
只有一个线程会操作 iq 对象吗？

112
00:06:17,890 --> 00:06:23,300
Is that one consumer or one or one producer?
这是一个消费者还是一个生产者？

113
00:06:23,770 --> 00:06:24,110
Right?
对吗？

114
00:06:26,410 --> 00:06:27,000
Okay.
好的。

115
00:06:27,380 --> 00:06:31,040
So how we are going to implement it, one implement.
那么我们要如何实现它呢？一种实现方式是...

116
00:06:31,050 --> 00:06:32,800
We are going for each of these constraint.
我们将针对每个约束进行处理。

117
00:06:33,610 --> 00:06:36,310
We are going to use a semaphore.
我们将使用一个信号量。

118
00:06:36,980 --> 00:06:39,570
We are going to use a semaphore for full buffers.
我们将使用信号量来管理满的缓冲区。

119
00:06:39,980 --> 00:06:43,650
This is consumer constraint and empty buffers.
这是消费者约束和空缓冲区。

120
00:06:46,120 --> 00:06:47,470
Basically, each of these singapore,
基本上，这些都是新加坡的

121
00:06:47,480 --> 00:06:48,670
at a given time,
在某个特定的时间点，

122
00:06:48,680 --> 00:06:54,530
will show how many elements are in the buffer full buffers,
将显示缓冲区中满的缓冲区元素的数量。

123
00:06:54,840 --> 00:06:57,780
and how many elements you can still put in the buffer.
你还可以将多少个元素放入缓冲区？

124
00:06:58,120 --> 00:07:00,180
Basically, if you add that to this to similar force,
基本上，如果你将这个加到这个类似的力上，

125
00:07:00,190 --> 00:07:04,720
you should get the total number of elements that buffer size.
你应该获取缓冲区大小的元素总数。

126
00:07:05,440 --> 00:07:07,350
Then a mutex are for mutex,
互斥锁（mutex）用于互斥访问。

127
00:07:07,360 --> 00:07:08,630
for the mutual exclusion.
用于互斥访问。

128
00:07:08,910 --> 00:07:15,840
To make sure that you have only one thread manipulating the queue that is
为了确保只有一个线程操作队列

129
00:07:15,850 --> 00:07:16,880
whether inserting a new
是否插入一个新的

130
00:07:16,890 --> 00:07:19,040
element or removing an element from the queue.
队列的元素插入或移除元素。

131
00:07:21,230 --> 00:07:24,750
Let's start full slots is basically zero,
让我们从满槽的数量基本为零开始。

132
00:07:24,970 --> 00:07:27,360
because initially,
因为最初，

133
00:07:27,890 --> 00:07:29,440
there is nothing in the queue.
队列中没有任何内容。

134
00:07:29,720 --> 00:07:31,180
Empty slots is a buffer size.
空槽是缓冲区的大小。

135
00:07:31,460 --> 00:07:34,150
Remember, if you add here full slots with empty slots,
请记住，如果你在这里添加满的插槽和空的插槽，

136
00:07:34,160 --> 00:07:36,250
you get the size of the buffer.
你可以获取缓冲区的大小。

137
00:07:36,730 --> 00:07:38,370
And mutex is one like that.
互斥锁（mutex）就是其中之一。

138
00:07:40,220 --> 00:07:41,770
No one is in the critical section.
没有人在临界区。

139
00:07:42,360 --> 00:07:44,480
And the producers and is very simple, right?
生产者和消费者模型非常简单，对吗？

140
00:07:44,490 --> 00:07:48,860
It's like, basically, you are waiting for slows to be available.
这就像是，基本上你在等待慢速资源可用。

141
00:07:53,600 --> 00:07:58,640
Then you use a mutex to protect the critical section.
然后你使用互斥锁来保护临界区。

142
00:07:58,890 --> 00:08:00,490
And then once you are done,
完成后，

143
00:08:00,500 --> 00:08:04,800
you are implementing the number of slots or full slots, right?
你正在实现槽位数量或已满槽位的功能，对吗？

144
00:08:04,810 --> 00:08:06,250
Because you added on element.
因为你添加了一个元素。

145
00:08:07,230 --> 00:08:09,270
And the consumer is very similar.
而消费者则非常相似。

146
00:08:09,880 --> 00:08:15,770
You are waiting for to full slots to be greater than zero.
你正在等待可用槽位数大于零。

147
00:08:15,780 --> 00:08:18,930
This means as at least one element in the buffer.
这意味着缓冲区中至少有一个元素。

148
00:08:19,300 --> 00:08:21,930
If it's you have more than one element in the buffer,
如果缓冲区中有多个元素，

149
00:08:21,940 --> 00:08:23,250
you can be cue that element.
你可以将那个元素作为提示。

150
00:08:23,680 --> 00:08:26,760
Again, the dq operation is protected by the mutex.
再次强调，dq操作受到互斥锁的保护。

151
00:08:27,460 --> 00:08:30,010
Then once you are done,
完成后，

152
00:08:30,020 --> 00:08:32,010
you are going to increment the empty slots,
你将要增加空槽位的数量。

153
00:08:32,020 --> 00:08:36,830
because now it's one more available slots in the queue and return the item.
因为现在队列中有一个可用的插槽，所以返回该项。

154
00:08:38,860 --> 00:08:46,150
So that's basically here in use a mutex to protect the critical section.
所以基本上在这里使用互斥锁来保护临界区。

155
00:08:46,610 --> 00:08:51,400
Therefore, no two threads at the same time operates on the queue to remove,
因此，没有两个线程同时对队列进行移除操作。

156
00:08:51,410 --> 00:08:53,720
to manipulate the pointers, to remove that,
操作指针，移除它。

157
00:08:55,220 --> 00:08:57,250
the elements or to add the element to the cure.
将元素添加到链表中或将元素添加到队列中。

158
00:08:58,140 --> 00:09:02,290
The other one are scheduling constraints of full slots,
另一个问题是满时间槽的调度限制。

159
00:09:02,520 --> 00:09:04,550
is incremental by the producer,
是由生产者逐步增加的。

160
00:09:04,560 --> 00:09:06,910
and then is diplomatic by the consumer.
然后由消费者进行外交。

161
00:09:06,920 --> 00:09:08,270
And similarly,
同样地，

162
00:09:08,530 --> 00:09:14,050
the empty space is implemented by the consumer and decrement it by the progress.
空闲空间由消费者实现，并通过进度递减它。

163
00:09:21,550 --> 00:09:22,440
Any questions?
有任何问题吗？

164
00:09:28,250 --> 00:09:29,720
A discussion about solution?
关于解决方案的讨论？

165
00:09:30,760 --> 00:09:32,910
You can see there is a symmetry, right?
你能看到这里有对称性，对吧？

166
00:09:33,940 --> 00:09:41,280
The producer is doing is calling p and then v on empty graph buffers
生产者正在对空图缓冲区进行p和v操作。

167
00:09:41,290 --> 00:09:42,360
and full buffers.
满缓冲区。

168
00:09:43,000 --> 00:09:48,240
The consumer does the reserve reverse is calling people on the full buffers
消费者执行反向保留，即在满缓冲区上调用人们。

169
00:09:48,250 --> 00:09:49,720
and be on the empty buffers,
并且在空缓冲区上。

170
00:09:49,730 --> 00:09:50,080
right?
对的？

171
00:09:52,190 --> 00:09:53,620
It is this asymmetry.
就是这种不对称性。

172
00:09:53,910 --> 00:09:54,380
Okay.
好的。

173
00:09:55,010 --> 00:09:56,460
It's exactly what to expect, right?
这正是所期望的，对吗？

174
00:09:56,470 --> 00:09:59,710
Because the producer has to decrease the number of empty slots and increase
由于生产者需要减少空槽的数量并增加

175
00:09:59,720 --> 00:10:00,960
the number of occupy slots.
占用槽位的数量。

176
00:10:02,320 --> 00:10:03,490
And the consumer,
而消费者，

177
00:10:03,970 --> 00:10:11,620
sorry, the producer has to wait for the producer.
抱歉，生产者必须等待消费者。

178
00:10:12,100 --> 00:10:12,380
Yeah.
是的。

179
00:10:13,110 --> 00:10:16,120
It's as to wait for empty starts to be available.
这是等待空闲的起始点可用。

180
00:10:16,130 --> 00:10:17,720
But then once you put the element,
但是一旦你放入元素，

181
00:10:17,730 --> 00:10:20,400
you decrease the number of empty slots and you increase the numbers
你减少了空槽的数量，同时增加了数字的数量。

182
00:10:20,410 --> 00:10:21,360
of occupied slots.
被占用槽位的数量。

183
00:10:21,580 --> 00:10:23,400
As a consumer is the other way around.
作为消费者则正好相反。

184
00:10:23,660 --> 00:10:27,850
When there is at least one element in the buffer,
当缓冲区中至少有一个元素时，

185
00:10:27,860 --> 00:10:31,630
you decrease the number of occupied slots because you take one element,
你减少了占用的插槽数量，因为你取走了一个元素。

186
00:10:32,070 --> 00:10:35,120
then also this increase the number of empty slots.
这也会增加空槽的数量。

187
00:10:35,570 --> 00:10:35,850
Right?
对吗？

188
00:10:37,660 --> 00:10:39,450
Now, this is a question for you.
现在，这是一个问题给你。

189
00:10:41,990 --> 00:10:47,010
If there is that you remember in the original code,
如果你在原始代码中记得有这样的内容，

190
00:10:48,740 --> 00:10:54,350
let me guess what this we called first produce that calls first smfop
让我猜一下这个我们称之为第一个生产的东西叫做第一个smfop。

191
00:10:54,360 --> 00:10:55,630
on the empty slots,
在空槽上，

192
00:10:55,640 --> 00:10:56,910
and then the mutex.
然后是互斥锁。

193
00:10:57,880 --> 00:11:00,250
Now, is that order important?
现在，这个顺序重要吗？

194
00:11:05,060 --> 00:11:06,330
That's a question for the class.
这是一个给全班的问题。

195
00:11:08,570 --> 00:11:11,160
Looking forward to your replies to your answers?
期待您对您的答案的回复。

196
00:11:23,720 --> 00:11:24,320
Yes.
是的。

197
00:11:26,340 --> 00:11:27,010
It is.
是的。

198
00:11:30,550 --> 00:11:33,040
If you do this, it can be, we can deadlock.
如果你这样做，可能会导致死锁。

199
00:11:34,260 --> 00:11:36,680
Can someone explain how you can get the dialogue?
有人可以解释一下如何获取对话框吗？

200
00:11:36,690 --> 00:11:36,980
Here?
在这里吗？

201
00:11:36,990 --> 00:11:37,280
Is?
是吗？

202
00:11:42,930 --> 00:11:43,720
Very simple?
非常简单吗？

203
00:12:00,760 --> 00:12:01,160
Thank you.
谢谢你。

204
00:12:01,170 --> 00:12:01,560
I don't know.
我不知道。

205
00:12:01,570 --> 00:12:02,280
Actually.
实际上。

206
00:12:04,230 --> 00:12:05,630
Basically, it's very simple, right?
基本上，这很简单，对吗？

207
00:12:05,640 --> 00:12:06,470
For instance,
例如，

208
00:12:07,090 --> 00:12:09,340
you imagine that he's a producer,
你可以想象他是一个制片人，

209
00:12:09,950 --> 00:12:12,900
the empty slots that are now empty slots.
现在是空的空槽。

210
00:12:16,130 --> 00:12:17,040
Empty slots is zero.
空槽位为零。

211
00:12:17,690 --> 00:12:18,280
What happens?
发生了什么事情？

212
00:12:18,890 --> 00:12:21,250
You acquire the mutex for the critical section,
你获得了关键区域的互斥锁，

213
00:12:22,940 --> 00:12:26,180
and then you are going to start waiting,
然后你将开始等待，

214
00:12:26,430 --> 00:12:27,780
because empty stocks is zero.
因为空仓意味着零持股。

215
00:12:29,510 --> 00:12:29,920
Right?
对吗？

216
00:12:30,170 --> 00:12:33,930
There is no place in the cure to insert a new element, rather new element.
在这个解决方案中没有地方可以插入一个新元素，而是一个新元素。

217
00:12:34,880 --> 00:12:38,240
But now you are going to wait in the critical section.
但现在你将在临界区等待。

218
00:12:40,780 --> 00:12:44,720
And the only way the empty slots can be increment.
唯一可以增加空槽位的方式。

219
00:12:45,210 --> 00:12:46,390
It is by the consumer.
这是由消费者决定的。

220
00:12:48,430 --> 00:12:49,900
But in order to do that,
但是为了做到这一点，

221
00:12:49,910 --> 00:12:52,100
the consumer has to
消费者必须

222
00:12:58,080 --> 00:13:00,610
the consumer has to be cure and operation.
消费者必须要有疗效和操作性。

223
00:13:00,620 --> 00:13:03,910
But for that, you need to acquire a mutex.
但是为了这样做，你需要获取一个互斥锁。

224
00:13:04,800 --> 00:13:05,810
But you own the mutex.
但是你拥有互斥锁。

225
00:13:05,820 --> 00:13:06,970
The producer owns a mutex.
生产者拥有一个互斥锁。

226
00:13:06,980 --> 00:13:08,810
So you cannot acquire the mutex,
所以你无法获取互斥锁，

227
00:13:09,050 --> 00:13:11,960
because you can have only one thread in the critical section.
因为在临界区中只能有一个线程。

228
00:13:12,260 --> 00:13:14,970
So therefore, consumer cannot be cure any element.
因此，消费者无法治愈任何元素。

229
00:13:15,410 --> 00:13:15,750
Therefore,
因此，

230
00:13:15,760 --> 00:13:21,960
the producer will continue to wait for the empty slots to be implemented,
生产者将继续等待空槽位的实现。

231
00:13:22,350 --> 00:13:23,230
which will never happen.
这将永远不会发生。

232
00:13:25,910 --> 00:13:26,340
Very good.
非常好。

233
00:13:29,500 --> 00:13:31,090
Is the order of the important.
顺序重要吗？

234
00:13:31,340 --> 00:13:33,350
I have the answer here is that yeah,
我这里有答案，是的。

235
00:13:33,360 --> 00:13:35,310
now because they just do the increment.
现在因为它们只是进行递增操作。

236
00:13:37,620 --> 00:13:39,730
What if you have to produce and to consumers?
如果你既要生产又要消费，会怎样呢？

237
00:13:39,740 --> 00:13:43,650
Is this?
这是吗？

238
00:13:43,980 --> 00:13:50,360
Do you need any changes I to the previous code which is working?
之前的代码已经能正常工作了，你需要对它做任何修改吗？

239
00:13:51,050 --> 00:13:51,970
Not to this one?
不对这个？

240
00:13:51,980 --> 00:13:58,360
So assuming that some of the end mutex and empty slots are not,
假设一些终止互斥锁和空槽不是。

241
00:13:59,240 --> 00:13:59,800
are you ordered?
你有被指派任务吗？

242
00:14:07,520 --> 00:14:10,160
So do you need to make any changes to this code?
那么你需要对这段代码做出任何更改吗？

243
00:14:13,440 --> 00:14:15,110
If I have to go to seven to consumers
如果我必须去拜访七个消费者

244
00:14:32,420 --> 00:14:32,970
on ali,
在阿里巴巴上，

245
00:14:33,320 --> 00:14:34,540
you are correct now.
你现在是正确的。

246
00:14:35,570 --> 00:14:41,030
You don't need to do it to do to make any change is going just to work.
你不需要做任何改变，只要继续工作就可以了。

247
00:14:41,370 --> 00:14:42,920
The reason is going to work.
原因是要去工作。

248
00:14:42,930 --> 00:14:47,940
It's again because no matter how many consumer and producers are going to have,
这是因为无论有多少个消费者和生产者，

249
00:14:48,660 --> 00:14:53,810
you can at its only one of those can be in the critical section.
在关键区域中只能有一个进程。

250
00:14:58,240 --> 00:14:59,230
Yes, exactly.
是的，没错。

251
00:15:01,230 --> 00:15:01,870
Thank you.
谢谢你。

252
00:15:05,950 --> 00:15:06,360
Good.
好的。

253
00:15:11,170 --> 00:15:11,600
It's again.
又是你。

254
00:15:11,610 --> 00:15:15,310
So you can see that b and v are the synchronization primitives.
所以你可以看到b和v是同步原语。

255
00:15:15,640 --> 00:15:18,330
And now,
现在，

256
00:15:18,340 --> 00:15:21,170
what we are going to do in the rest of these lectures,
在接下来的讲座中，我们将要做什么

257
00:15:21,180 --> 00:15:25,620
we are going to try to figure out how to implement the synchronization primitives.
我们将尝试弄清楚如何实现同步原语。

258
00:15:26,330 --> 00:15:30,480
Synchronization, primitive pnb are at the higher level.
同步，原语pnb位于较高级别。

259
00:15:30,890 --> 00:15:32,310
But as a low level,
但是作为一个低级别的操作系统，

260
00:15:32,670 --> 00:15:38,340
you have what you have on you up in the when you talk about when you
当你谈论"你拥有的东西"时，指的是你身上携带的东西。

261
00:15:38,350 --> 00:15:39,540
are talking about the processor,
你是在谈论处理器吗？

262
00:15:41,610 --> 00:15:42,520
what you can do,
我可以帮你翻译英文成中文。

263
00:15:43,240 --> 00:15:45,210
you can execute instructions,
你可以执行指令。

264
00:15:45,460 --> 00:15:46,710
like load and stores.
例如加载和存储操作。

265
00:15:47,350 --> 00:15:49,060
You can disable interacts.
你可以禁用交互功能。

266
00:15:49,390 --> 00:15:53,220
And then we'll see there are a few other specialized instructions,
然后我们会看到还有一些其他的专用指令，

267
00:15:53,230 --> 00:15:54,380
like test and set,
像测试和设置一样，

268
00:15:54,820 --> 00:15:56,180
and compare and swap,
比较并交换

269
00:15:56,980 --> 00:16:02,710
which it make it much easier to implement higher level synchronization primitives.
这使得实现更高级的同步原语变得更加容易。

270
00:16:02,950 --> 00:16:04,290
Because like you'll see,
因为就像你会看到的那样，

271
00:16:04,530 --> 00:16:07,400
using just slowed and stored and disabled interrupts,
仅使用了减速、存储和禁用中断，

272
00:16:07,760 --> 00:16:09,490
they are not ideal solutions.
它们不是理想的解决方案。

273
00:16:10,810 --> 00:16:11,180
Right?
对吗？

274
00:16:11,490 --> 00:16:13,600
Then as a higher level, we have blocks.
然后作为更高级别的概念，我们有块（blocks）。

275
00:16:13,610 --> 00:16:14,760
We discussed last time,
我们上次讨论过，

276
00:16:14,770 --> 00:16:17,370
we are going to discuss more this lecture,
我们将会在本次讲座中进一步讨论。

277
00:16:17,840 --> 00:16:23,160
summer force, and then monitors and send receipts operation.
夏季强制执行，然后监控并发送收据操作。

278
00:16:23,170 --> 00:16:27,560
But money we are going to discuss locks somewhere for their implementation.
但是我们要讨论的是锁的实现方式。

279
00:16:30,170 --> 00:16:34,400
And hopefully you are going to also get to monitors during this lecture.
希望在本讲座中你也能学习到关于监视器的知识。

280
00:16:36,240 --> 00:16:38,300
And then programs is a higher.
然后程序是更高级的。

281
00:16:39,090 --> 00:16:39,870
There are higher.
有更高的。

282
00:16:39,880 --> 00:16:41,590
Abstraction is a program level,
抽象是一个程序级别的概念，

283
00:16:42,560 --> 00:16:46,750
and we are not going to talk about them at least this week.
而且我们至少本周不会讨论它们。

284
00:16:49,400 --> 00:16:52,040
And here is a motivating example, okay?
这里有一个激励的例子，好吗？

285
00:16:52,420 --> 00:16:55,020
If you haven't paid too much attention until now,
如果你到现在为止还没有太关注的话，

286
00:16:55,030 --> 00:16:57,580
at least from now on for these examples,
至少从现在开始，针对这些例子，

287
00:16:57,590 --> 00:17:00,890
pay attention because it will earn you a lot.
请注意，因为这将给你带来很多收益。

288
00:17:01,280 --> 00:17:04,300
And remember that next wednesday,
请记住，下周三，

289
00:17:04,660 --> 00:17:05,790
we have the first meet up.
我们有第一次见面。

290
00:17:07,040 --> 00:17:13,440
And the next lecture are going to be part of the topics covered by the meter.
下一堂课将涵盖计量器所涵盖的主题的一部分。

291
00:17:15,220 --> 00:17:16,960
So here is a problem.
所以这里有一个问题。

292
00:17:17,350 --> 00:17:20,010
And basically,
基本上，

293
00:17:20,020 --> 00:17:25,460
the problem is that there are two roommates and both of them like mom,
问题是有两个室友，他们都喜欢妈妈。

294
00:17:25,470 --> 00:17:26,420
they like milk.
他们喜欢牛奶。

295
00:17:26,980 --> 00:17:31,230
And the the question,
而且还有一个问题，

296
00:17:31,240 --> 00:17:35,500
the problem is that if there is no milk in the fridge,
问题是如果冰箱里没有牛奶，

297
00:17:35,730 --> 00:17:40,050
then whoever discovers that they are going to go and get milk,
然后谁发现他们要去买牛奶，就会去买。

298
00:17:40,620 --> 00:17:41,020
right?
对的？

299
00:17:41,500 --> 00:17:46,740
And we want the goal here is to not get too much milk.
我们的目标是不要得到太多的牛奶。

300
00:17:46,750 --> 00:17:48,500
And how can you get too much milk?
你怎么会得到太多的牛奶呢？

301
00:17:48,510 --> 00:17:49,020
Well,
好的，我会尽力将英文翻译成中文。请继续。

302
00:17:49,800 --> 00:17:56,190
think about The same sequence of events at 3 o'clock.
想象一下在3点钟发生的相同事件序列。

303
00:17:57,530 --> 00:17:58,480
First from my parents,
首先是来自我的父母，

304
00:17:59,130 --> 00:18:02,080
let's call her a person a look in the fridge.
让我们称她为一个人来看冰箱。

305
00:18:02,090 --> 00:18:07,640
There is no milk leaves to goes to the store at this star.
这颗星球上没有牛奶可以去商店购买了。

306
00:18:08,090 --> 00:18:11,200
And while arriving at the store is a closed door.
当到达商店时，门是关着的。

307
00:18:12,080 --> 00:18:17,030
The second roommate called her person b look at the fridge and it's out of milk.
第二个室友叫她的朋友B去看冰箱，发现没有牛奶了。

308
00:18:18,210 --> 00:18:24,780
She's going to do the same thing before store and arrival store.
她打算在存储之前和到达存储之前做同样的事情。

309
00:18:25,580 --> 00:18:26,620
During this time,
在这段时间里，

310
00:18:26,630 --> 00:18:28,600
the a person a left,
一个人离开了。

311
00:18:28,610 --> 00:18:31,160
the store arrive at her home,
货物到达了她的家。

312
00:18:31,170 --> 00:18:32,680
put the milk in the fridge,
把牛奶放进冰箱里。

313
00:18:32,890 --> 00:18:35,280
while the person b is at the store buying milk,
当人B在商店买牛奶的时候，

314
00:18:35,720 --> 00:18:38,670
then we are going to get at the end of the day.
那么我们将在一天结束时得到。

315
00:18:38,680 --> 00:18:41,670
We are going to have 2 bottle of milks in the fridge.
我们冰箱里会有两瓶牛奶。

316
00:18:42,490 --> 00:18:42,880
Okay?
好的？

317
00:18:43,800 --> 00:18:48,580
This solution certainly doesn't do what you wanted and what you
这个解决方案显然不能达到你想要的目标和你所期望的

318
00:18:48,590 --> 00:18:50,340
wanted to not buy too much milk.
想要不买太多的牛奶。

319
00:18:55,070 --> 00:18:55,970
How do we do that?
我们该如何做到这一点？

320
00:18:56,570 --> 00:18:58,720
Obviously, we want to,
显然，我们希望，

321
00:18:59,870 --> 00:19:00,420
we can,
我们可以，

322
00:19:01,480 --> 00:19:03,220
the problem here is that,
问题在于，

323
00:19:03,450 --> 00:19:09,690
in some sense, both person a and b execute the same instructions,
从某种意义上说，A和B两个人执行相同的指令。

324
00:19:10,100 --> 00:19:11,570
and so to speak,
所谓的，可以这么说，

325
00:19:11,910 --> 00:19:15,790
take the same actions without kind of any coordination, they do.
他们没有任何协调就采取了相同的行动。

326
00:19:15,800 --> 00:19:20,630
They execute that kind of code each of them at the same time, right?
他们同时执行这种代码，对吗？

327
00:19:21,650 --> 00:19:29,350
What do you you want only one person of the two to go to the to the store
你希望只有两个人中的一个去商店吗？

328
00:19:29,360 --> 00:19:30,150
to buy milk.
购买牛奶。

329
00:19:30,560 --> 00:19:30,880
Right?
对吗？

330
00:19:31,740 --> 00:19:34,990
So basically, you can see now the concept of critical section,
基本上，你现在可以看到临界区的概念了。

331
00:19:35,000 --> 00:19:39,840
if you think about the program is going to the fridge and going
如果你考虑程序要去冰箱并且去

332
00:19:39,850 --> 00:19:41,880
to the store to buy milk,
去商店买牛奶，

333
00:19:42,290 --> 00:19:44,120
we want only one person to do it.
我们只希望有一个人来做这件事。

334
00:19:45,590 --> 00:19:47,080
One way to prevent that,
防止这种情况的一种方法是，

335
00:19:47,090 --> 00:19:48,880
like we learn and we saw.
就像我们学习和看到的那样。

336
00:19:48,890 --> 00:19:50,980
So last time is to have locks.
所以上次是关于锁的问题。

337
00:19:52,610 --> 00:19:57,120
So you look before entering the critical section,
所以在进入临界区之前，你要先进行查看。

338
00:19:57,610 --> 00:19:59,980
you unlock after leaving the critical section.
在离开临界区后解锁。

339
00:20:01,940 --> 00:20:02,420
Now,
现在，

340
00:20:02,960 --> 00:20:05,960
the one important things which will come over and over again,
一件重要的事情会一次又一次地出现

341
00:20:05,970 --> 00:20:13,640
and what makes the implementation of locks challenging
实现锁的挑战在于以下几个方面：

342
00:20:14,360 --> 00:20:21,270
is that any lock implementation or synchronization,
这是关于锁实现或同步的问题吗？

343
00:20:22,010 --> 00:20:28,550
primitive implementation involve waiting.
原始实现涉及等待。

344
00:20:29,380 --> 00:20:30,260
And why is that?
为什么这样做呢？

345
00:20:30,270 --> 00:20:32,020
It should be obvious, right?
这应该是显而易见的，对吧？

346
00:20:32,360 --> 00:20:38,250
Because if many threads wants to enter the same critical section,
因为如果多个线程想要进入同一个临界区域，

347
00:20:39,500 --> 00:20:41,360
and only one at a time can do it,
每次只能有一个人来做。

348
00:20:42,750 --> 00:20:48,910
this means that why not go in a critical section and the other ones?
这意味着为什么不进入一个临界区和其他的临界区呢？

349
00:20:49,400 --> 00:20:51,030
What they can do, they have to wait.
他们能做的就是等待。

350
00:20:51,430 --> 00:20:52,390
There is no around it.
这是无法避免的。

351
00:20:54,770 --> 00:20:55,160
Right?
对吗？

352
00:20:56,840 --> 00:20:57,910
So remember the boat.
记住那艘船。

353
00:21:00,390 --> 00:21:02,010
So you can,
所以你可以，

354
00:21:02,530 --> 00:21:06,270
one way to do it is to lock all the way, also the fridge.
一种方法是将所有的门都锁上，包括冰箱的门。

355
00:21:06,280 --> 00:21:09,500
And basically, you go to,
基本上，你需要前往

356
00:21:10,880 --> 00:21:13,790
before you go to the store, you lock the fridge.
在你去商店之前，你要锁好冰箱。

357
00:21:14,290 --> 00:21:16,450
If the other person sees come to,
如果对方看到了，请过来。

358
00:21:16,460 --> 00:21:17,690
the fridge is locked,
冰箱被锁住了。

359
00:21:17,700 --> 00:21:24,210
but is going to wait for you to unlock the fridge.
但是它会等待你来解锁冰箱。

360
00:21:24,640 --> 00:21:29,040
And then this guarantee that it's only one person you're buying the milk.
然后这个保证是你只购买了一瓶牛奶的人。

361
00:21:29,520 --> 00:21:31,390
But this is not ideal,
但这并不理想，

362
00:21:31,400 --> 00:21:37,180
because what if the other person wants something else and milk from the fridge?
因为如果对方想要冰箱里的其他东西和牛奶呢？

363
00:21:37,690 --> 00:21:41,420
Is so this is kind of very coarse grain solution.
这是一种非常粗粒度的解决方案。

364
00:21:49,800 --> 00:21:53,370
Let's see how we are going to solve this problem.
让我们看看我们将如何解决这个问题。

365
00:21:57,910 --> 00:22:00,080
And before doing that,
在这之前，

366
00:22:00,650 --> 00:22:03,940
again, it's like this is a tricky problem.
再次，这个问题似乎很棘手。

367
00:22:03,950 --> 00:22:10,540
And this general these problems when concurrency problems are tricky,
在并发问题复杂时，通常会遇到这些一般性问题。

368
00:22:12,060 --> 00:22:16,590
and they are tricky fundamentally because there are many entities doing
它们在根本上是棘手的，因为有许多实体在执行任务。

369
00:22:16,600 --> 00:22:18,270
the same things at the same time.
同时做相同的事情。

370
00:22:18,890 --> 00:22:20,190
And it just,
而且，

371
00:22:20,750 --> 00:22:21,670
as a human said,
正如一个人所说，

372
00:22:21,680 --> 00:22:26,720
we are more used to thinking linearly than thinking about many things
我们更习惯于线性思维，而不是同时考虑多个事物。

373
00:22:26,730 --> 00:22:27,720
happening at the same time.
同时发生的。

374
00:22:27,730 --> 00:22:29,120
We are not very good at that.
我们在这方面不太擅长。

375
00:22:30,200 --> 00:22:36,140
So that's one of the reason you can very well miss different edges.
这就是你可能会错过不同边缘的原因之一。

376
00:22:36,460 --> 00:22:42,300
So what you want when you have to deal with this kind of problem,
当你需要处理这类问题时，你想要什么？

377
00:22:43,150 --> 00:22:46,830
actually, you want to do that when you deal with any kind of problem,
实际上，无论你遇到什么问题，你都应该这样做。

378
00:22:46,840 --> 00:22:47,990
programming problem.
编程问题。

379
00:22:48,200 --> 00:22:50,030
But in particular, this kind of problems,
但是特别是这种问题，

380
00:22:50,040 --> 00:22:53,230
you need to be very careful and think quite a bit about what you
你需要非常小心，并且要仔细考虑你所做的事情。

381
00:22:53,240 --> 00:22:57,780
want to achieve and how to make the development solution to meet those,
想要实现什么目标以及如何使开发解决方案满足这些目标，

382
00:22:59,430 --> 00:23:00,990
the requirements you want to achieve.
你想要达到的要求。

383
00:23:01,500 --> 00:23:02,000
Okay?
好的？

384
00:23:02,410 --> 00:23:03,720
Don't start to code.
不要开始编码。

385
00:23:03,930 --> 00:23:05,770
First, I just think,
首先，我只是认为，

386
00:23:06,270 --> 00:23:06,670
first,
首先，

387
00:23:09,010 --> 00:23:13,000
again, the way to think about it is to write down what you want to happen.
再次强调，思考的方法是将你想要发生的事情写下来。

388
00:23:13,430 --> 00:23:13,820
Right?
对吗？

389
00:23:15,070 --> 00:23:17,150
And what do you want to happen here?
在这里你想要发生什么？

390
00:23:17,160 --> 00:23:19,190
Or what are the correctness properties?
或者，正确性属性是什么？

391
00:23:21,220 --> 00:23:25,050
You want no more than one person buy some milk at a time, right?
你希望每次购买牛奶的人数不超过一个，对吗？

392
00:23:25,060 --> 00:23:26,890
If two person buys milk at a time,
如果两个人同时购买牛奶，

393
00:23:27,740 --> 00:23:29,220
you end up with the bottle of peace.
你最终得到了和平之瓶。

394
00:23:29,230 --> 00:23:32,680
I I at the same time.
我我同时。

395
00:23:33,010 --> 00:23:34,410
If there is no milk,
如果没有牛奶，

396
00:23:35,480 --> 00:23:38,270
there must be someone buying the milk,
一定有人在买牛奶。

397
00:23:38,280 --> 00:23:40,670
otherwise you don't get the milk.
否则你就拿不到牛奶。

398
00:23:42,320 --> 00:23:42,750
Okay.
好的。

399
00:23:44,590 --> 00:23:51,460
And let's think about if you restrict yourself to just load and store.
让我们考虑一下，如果你只限制自己只能进行加载和存储操作。

400
00:23:51,470 --> 00:23:56,800
So load and store meaning that you are going to modify some variable
加载和存储意味着你将要修改某个变量。

401
00:23:56,810 --> 00:23:57,640
in the memory,
在内存中，

402
00:23:59,050 --> 00:24:00,280
which can be legal,
可以合法的，

403
00:24:00,290 --> 00:24:02,450
which can be read by any program.
可以被任何程序读取。

404
00:24:06,840 --> 00:24:07,790
Here is an example,
这是一个例子，

405
00:24:08,360 --> 00:24:16,310
the way we are going to emulate this loud in stores in in this problem is
我们在这个问题中要模拟的方式是在商店里大声喊出来。

406
00:24:16,320 --> 00:24:17,030
through notes.
通过笔记。

407
00:24:17,330 --> 00:24:17,720
Right?
对吗？

408
00:24:18,030 --> 00:24:21,100
You put an out on the fridge with a message.
你在冰箱上贴了一张带有信息的便条。

409
00:24:21,110 --> 00:24:24,630
This is basically it's equivalent to studying.
这基本上相当于学习。

410
00:24:24,940 --> 00:24:26,580
And you read the note,
然后你阅读了这个便条，

411
00:24:27,060 --> 00:24:35,470
obviously, and it's a cable entries are allowed.
显然，允许使用电缆接口。

412
00:24:40,300 --> 00:24:42,690
Let's say what we have here.
让我们来看看我们这里有什么。

413
00:24:43,340 --> 00:24:47,520
We have do notes the kind of notes one,
我们有两种类型的笔记。

414
00:24:47,530 --> 00:24:50,080
and it's, sorry, 1note.
抱歉，我犯了个错误，应该是一条笔记。

415
00:24:50,820 --> 00:24:53,410
And then what is what is a code?
代码是计算机程序的一种形式，它由一系列指令组成，用于告诉计算机执行特定的任务或操作。代码可以用各种编程语言编写，如C、Python、Java等。通过编写代码，开发人员可以创建各种应用程序、网站、游戏等。代码是计算机程序的基础，它定义了程序的逻辑和功能。

416
00:24:53,420 --> 00:24:58,350
One possible power code can be one a possible solution is like,
一个可能的电源代码可以是一个可能的解决方案如下，

417
00:24:58,640 --> 00:25:00,450
if there is no milk, right?
如果没有牛奶，对吗？

418
00:25:01,280 --> 00:25:02,520
And there is no note,
并且没有任何备注。

419
00:25:02,530 --> 00:25:09,650
we assume here that a note indicates that someone else is going to buy the milk.
我们在这里假设一张便条表示有人打算买牛奶。

420
00:25:10,730 --> 00:25:14,930
Then you leave note and yourself going to go to buy the milk.
然后你留个便条，自己去买牛奶。

421
00:25:15,510 --> 00:25:17,590
And when you come back, you remove them out.
当你回来时，你把它们移除出去。

422
00:25:18,660 --> 00:25:18,980
Right?
对吗？

423
00:25:20,070 --> 00:25:20,750
Simply enough,
简单来说，

424
00:25:22,920 --> 00:25:23,990
what can happen here?
这里会发生什么？

425
00:25:24,000 --> 00:25:24,270
Right?
对吗？

426
00:25:24,850 --> 00:25:26,200
Do you think is a good solution?
你认为这是一个好的解决方案吗？

427
00:25:36,210 --> 00:25:37,310
Let's see, no answer here.
让我们看看，这里没有答案。

428
00:25:38,120 --> 00:25:39,520
It's not a good solution right?
这不是一个好的解决方案，对吗？

429
00:25:39,810 --> 00:25:40,080
In.
在。

430
00:25:40,650 --> 00:25:41,760
We have an answer,
我们有一个答案，

431
00:25:47,510 --> 00:25:49,420
not atomic that could cause problems.
不是原子操作可能会引起问题。

432
00:25:49,990 --> 00:25:52,270
There are problems here.
这里有问题。

433
00:25:52,670 --> 00:25:54,590
And the way to look at, again,
再次来看，方法是这样的，

434
00:25:54,600 --> 00:25:55,750
these people this can work.
这些人可以做这件事。

435
00:25:55,760 --> 00:25:57,790
But if this is done by machines,
但如果这是由机器完成的，

436
00:25:58,380 --> 00:25:59,340
the machines are myopic.
这些机器是目光短浅的。

437
00:25:59,350 --> 00:26:00,890
They only see this instruction,
他们只看到这个指令。

438
00:26:00,900 --> 00:26:02,130
they only nothing else.
他们只有这些，没有其他的。

439
00:26:03,780 --> 00:26:05,180
So let's see what can happen.
那么让我们看看可能会发生什么。

440
00:26:05,190 --> 00:26:08,480
And always in these concurrency problems,
在这些并发问题中，总是

441
00:26:08,800 --> 00:26:14,120
the bad things can happen if somehow the instruction are interleaved
如果指令被交错执行，可能会发生一些不好的事情。

442
00:26:14,130 --> 00:26:15,960
in an unfortunate way.
以不幸的方式。

443
00:26:17,850 --> 00:26:19,230
So let's see here what can happen?
那么让我们来看看可能会发生什么？

444
00:26:19,580 --> 00:26:22,750
Let's say we have thread a and thread b now,
假设我们现在有线程a和线程b。

445
00:26:22,760 --> 00:26:26,250
thread a is looking and check for the milk.
线程a正在查看并检查牛奶。

446
00:26:27,170 --> 00:26:29,860
And then once thread a checks for the milk,
然后一旦线程a检查牛奶，

447
00:26:30,340 --> 00:26:36,620
it's context switched is suspended by the operating system by the scheduler.
它的上下文被操作系统通过调度器暂停切换。

448
00:26:37,120 --> 00:26:40,120
And thread b can start to execute.
然后线程b可以开始执行。

449
00:26:40,840 --> 00:26:42,110
And thread b is, again,
而线程b则是再次，

450
00:26:42,120 --> 00:26:43,350
check for no milk.
检查是否没有牛奶。

451
00:26:43,620 --> 00:26:45,070
And in both cases,
在这两种情况下，

452
00:26:45,460 --> 00:26:48,440
the answer, it says through there is no milk,
答案是，它说虽然没有牛奶，

453
00:26:48,940 --> 00:26:49,360
right?
对的吗？

454
00:26:49,990 --> 00:26:53,400
But after and then thread b is checked for the note.
但是在此之后，线程b会被检查是否有通知。

455
00:26:54,260 --> 00:26:54,740
Okay?
好的？

456
00:26:55,220 --> 00:26:56,450
There is no note.
没有备注。

457
00:26:56,870 --> 00:26:59,440
But after checks for the note,
但是在检查了笔记之后，

458
00:26:59,830 --> 00:27:04,930
again, that we contact switch to thread a they check again for the notes,
再次联系开关以线程方式，他们再次检查笔记。

459
00:27:04,940 --> 00:27:07,030
and there is no note and leaves a note.
没有留下任何备注，也没有留下备注。

460
00:27:07,850 --> 00:27:08,150
Right?
对吗？

461
00:27:09,330 --> 00:27:09,950
Buy milk,
买牛奶。

462
00:27:10,780 --> 00:27:11,620
removed note.
已删除备注。

463
00:27:12,200 --> 00:27:13,900
Thread b is going to do the same thing.
线程 b 将要做同样的事情。

464
00:27:14,710 --> 00:27:15,020
Right?
对吗？

465
00:27:15,550 --> 00:27:16,720
Because from the point of view,
因为从这个角度来看，

466
00:27:16,730 --> 00:27:19,560
there is thread b is there is no milk, is there is no note.
如果没有牛奶，就没有线程B；如果没有便条，也没有线程B。

467
00:27:20,340 --> 00:27:23,090
From the second point of view of saturday,
从星期六的第二个角度来看，

468
00:27:23,100 --> 00:27:26,130
the same as true when you check or it was no milk.
当你检查时，如果是真的，或者没有牛奶，情况是一样的。

469
00:27:26,140 --> 00:27:28,690
And when he's checked was there is 00.
当他检查时，发现是00。

470
00:27:28,700 --> 00:27:37,350
Now, note you have now both thread a and thread b buying milk.
现在请注意，你现在有两个线程a和b都在购买牛奶。

471
00:27:39,630 --> 00:27:40,460
Any questions yet?
有任何问题吗？

472
00:27:47,520 --> 00:27:48,590
So it's too much milk.
所以这是太多的牛奶。

473
00:27:49,890 --> 00:27:51,430
This happened occasionally,
这种情况偶尔会发生。

474
00:27:52,550 --> 00:27:53,000
right?
对的？

475
00:27:53,330 --> 00:27:57,430
If you don't have this unfortunate order of execution,
如果你没有这个不幸的执行顺序，

476
00:27:57,900 --> 00:27:59,360
actually, this code will work.
实际上，这段代码将会运行。

477
00:28:00,540 --> 00:28:07,640
The problem is this what happened occasionally is that you may say
问题是有时候会发生的情况是你可能会说

478
00:28:07,650 --> 00:28:08,360
it's good news,
这是个好消息，

479
00:28:08,370 --> 00:28:08,720
right?
对的吗？

480
00:28:08,730 --> 00:28:11,100
It's like, it's only happens from time to time.
这种情况只是偶尔发生。

481
00:28:11,510 --> 00:28:14,980
But the problem that when this happens is very hard to remember,
但是当这种情况发生时，很难记住。

482
00:28:14,990 --> 00:28:17,200
because it's not happen all the time.
因为它并不是一直发生。

483
00:28:17,940 --> 00:28:18,330
Right?
对吗？

484
00:28:20,300 --> 00:28:22,330
That's what also makes these problems.
这也是导致这些问题的原因之一。

485
00:28:23,220 --> 00:28:25,080
All this program frustrating,
这个程序真令人沮丧，

486
00:28:25,460 --> 00:28:27,630
because they are very hard to debug.
因为它们很难调试。

487
00:28:28,730 --> 00:28:32,520
Another reason to think very well before starting took out.
在开始借款之前，要仔细考虑的另一个原因。

488
00:28:34,140 --> 00:28:35,780
Okay, so how do you solve this problem?
好的，你如何解决这个问题？

489
00:28:36,570 --> 00:28:36,860
Right?
对吗？

490
00:28:37,850 --> 00:28:41,970
So clearly, this note is not exclusive enough.
显然，这个说明不够具体。

491
00:28:43,940 --> 00:28:44,880
And one, good.
好的，明白了。

492
00:28:44,890 --> 00:28:46,560
So one solution, am I saying,
所以，我是在说有一个解决方案，

493
00:28:46,570 --> 00:28:48,840
is because it's not why don't replace a note?
是因为它不是为什么不替换一个便签呢？

494
00:28:50,400 --> 00:28:50,810
First, right?
首先，对吗？

495
00:28:52,030 --> 00:28:53,270
What if we do this code?
如果我们这样写代码会怎样？

496
00:28:56,040 --> 00:28:56,230
Right?
对吗？

497
00:28:56,240 --> 00:28:59,890
Instead of checking for the note,
不需要检查笔记，

498
00:29:01,350 --> 00:29:02,440
leaving the note,
留下这个便条，

499
00:29:03,560 --> 00:29:04,600
before buying the milk?
在购买牛奶之前？

500
00:29:04,610 --> 00:29:07,740
Let's leave the note even before we check for the milk.
在我们检查牛奶之前，我们先留个便条吧。

501
00:29:09,250 --> 00:29:10,190
What about this crowd?
这群人怎么样？

502
00:29:14,920 --> 00:29:16,350
Any problem with this crowd?
这群人有什么问题吗？

503
00:29:25,360 --> 00:29:25,960
Yes.
是的。

504
00:29:26,730 --> 00:29:30,040
A actually,
实际上，

505
00:29:30,050 --> 00:29:31,440
this is a pretty stupid coach,
这是一个相当愚蠢的教练，

506
00:29:32,410 --> 00:29:34,890
because if you leave that out here,
因为如果你在这里忽略了这一点，

507
00:29:37,340 --> 00:29:41,180
then if now it will be always true.
那么如果现在是永远为真的话。

508
00:29:43,660 --> 00:29:44,170
Right?
对吗？

509
00:29:47,980 --> 00:29:48,720
You don't know.
你不知道。

510
00:29:51,360 --> 00:29:51,860
Sorry.
抱歉。

511
00:29:52,190 --> 00:29:54,900
If now there will be always false and no one will buy me.
如果现在总是假的，没有人会买我的。

512
00:29:56,380 --> 00:29:57,890
Let's see if you leave them out.
让我们看看如果你把它们省略掉会怎样。

513
00:29:58,860 --> 00:29:59,290
Good night.
晚安。

514
00:29:59,550 --> 00:30:01,090
If you leave yourselves a note,
如果你们给自己留个便条，

515
00:30:03,300 --> 00:30:04,880
and then you check for the note.
然后你检查一下便条。

516
00:30:05,300 --> 00:30:06,070
There is a note.
这里有一张便条。

517
00:30:06,850 --> 00:30:07,780
So you don't buy milk.
所以你不买牛奶。

518
00:30:08,320 --> 00:30:10,380
That's I was saying this is stupid.
这就是我说这个很愚蠢的原因。

519
00:30:12,820 --> 00:30:14,950
So you don't do a given for one user.
所以你不为一个用户提供指定的服务。

520
00:30:17,870 --> 00:30:18,160
Okay?
好的？

521
00:30:21,730 --> 00:30:28,090
Let's go to solution to this kind of didn't work.
让我们来解决这种无法工作的问题。

522
00:30:28,510 --> 00:30:29,980
Maybe we need to be more sophisticated.
也许我们需要更加复杂一些。

523
00:30:29,990 --> 00:30:32,230
Maybe we need to have 2 kind two notes,
也许我们需要有两种不同的笔记。

524
00:30:33,110 --> 00:30:33,440
right?
对的？

525
00:30:35,370 --> 00:30:36,480
One for each person.
每人一个。

526
00:30:38,810 --> 00:30:40,760
Let's rewrite the previous code,
让我们重新编写之前的代码，

527
00:30:42,070 --> 00:30:49,210
thread a leave note a thread b leave not b and thread a jokes for checks
线程A留下了一个便条，线程B留下了另一个便条，而线程A则开玩笑地检查了一下。

528
00:30:49,220 --> 00:30:51,250
was a thread b left and out.
一个线程 b 被离开并退出了。

529
00:30:52,100 --> 00:30:55,120
And thread b checks was a thread a left or not.
线程b检查线程a是否已经离开。

530
00:30:59,750 --> 00:31:01,980
Seems more sophisticated, may work, maybe.
看起来更复杂，可能会起作用，也可能不会。

531
00:31:02,630 --> 00:31:04,030
What do you think it is going to work?
你认为这会起作用吗？

532
00:31:17,720 --> 00:31:18,680
Okay, why don't you guess?
好的，你为什么不猜一下呢？

533
00:31:18,970 --> 00:31:19,880
You don't need to tell me?
你不需要告诉我吗？

534
00:31:19,890 --> 00:31:24,070
But whether why is going to work or not?
但是为什么会不会起作用呢？

535
00:31:24,700 --> 00:31:25,860
Just take a guess.
就随便猜一下吧。

536
00:31:36,710 --> 00:31:38,060
Now, good answer.
现在，好的回答。

537
00:31:39,060 --> 00:31:40,980
Ii hope that this answer is not given,
希望这个答案没有被给出。

538
00:31:40,990 --> 00:31:43,100
because you looked at the next slide.
因为你看了下一张幻灯片。

539
00:31:44,590 --> 00:31:45,540
But anyway,
但无论如何，

540
00:31:46,240 --> 00:31:49,080
so now it doesn't work.
现在它不工作了。

541
00:31:49,090 --> 00:31:52,600
And here is a reason and another an example.
这是一个原因和另一个例子。

542
00:31:54,440 --> 00:31:54,820
Again,
请再说一遍。

543
00:31:54,830 --> 00:31:57,940
it's about how this instruction instructions are interleaved
这是关于指令如何交错执行的问题。

544
00:31:58,480 --> 00:31:59,510
from saturday and saturday.
从周六到周六。

545
00:32:00,180 --> 00:32:01,730
B you live now day.
你现在过得怎么样？

546
00:32:03,300 --> 00:32:11,220
You leave now be thread a leaves note a then we contact switch to thread b sarah
你现在离开，留下一张便条，然后我们联系切换到B线程，Sarah。

547
00:32:11,230 --> 00:32:15,160
believes not be is checked for them if there is no day.
如果没有一天，就不会有人相信他们是否被检查过。

548
00:32:15,700 --> 00:32:18,680
And basically a nowadays.
基本上是现在的情况。

549
00:32:18,690 --> 00:32:20,290
So this is false.
所以这是错误的。

550
00:32:21,070 --> 00:32:23,790
And this is not going to execute it.
这不会执行它。

551
00:32:25,580 --> 00:32:26,770
At the same time.
同时。

552
00:32:27,280 --> 00:32:32,550
Said a is looking or there is a node b there is a node be.
假设有一个节点a，正在寻找是否存在一个节点b，是否存在一个节点be。

553
00:32:32,560 --> 00:32:34,150
So this is really false.
所以这是完全错误的。

554
00:32:34,730 --> 00:32:39,030
So it's not going to execute the if what is under the wave condition.
所以它不会执行在波浪条件下的if语句块。

555
00:32:39,040 --> 00:32:41,020
And at the end of them,
最后，

556
00:32:41,750 --> 00:32:44,630
at the end, both of them removed them their own notes,
最后，他们都删除了自己的笔记。

557
00:32:44,640 --> 00:32:46,130
but no one bought the milk.
但是没有人买牛奶。

558
00:32:53,310 --> 00:32:53,820
Make sense?
有意义吗？

559
00:32:53,830 --> 00:32:54,780
Any questions here?
这里有什么问题吗？

560
00:33:04,370 --> 00:33:04,940
Okay?
好的？

561
00:33:05,700 --> 00:33:09,040
It's again possible for neither of the threat to buy milk.
现在又有可能两个人都没买到牛奶。

562
00:33:10,410 --> 00:33:12,280
And again, this is really,
再次强调，这真的很重要，

563
00:33:12,290 --> 00:33:16,430
really hard to debug,
真的很难调试，

564
00:33:17,250 --> 00:33:18,660
because it happens rarely.
因为这种情况很少发生。

565
00:33:23,250 --> 00:33:24,360
Now, let me tell you,
现在，让我告诉你，

566
00:33:24,690 --> 00:33:28,640
I told you something about initially about any synchronization limit.
我之前告诉你关于任何同步限制的事情。

567
00:33:28,650 --> 00:33:30,360
You should involve something.
你应该参与其中。

568
00:33:32,410 --> 00:33:34,640
Actually, even without reading the code,
实际上，即使不阅读代码，

569
00:33:36,470 --> 00:33:42,860
you could have answered the question where there is a code is correct or not.
你可以回答这个问题，代码是否正确。

570
00:33:44,800 --> 00:33:49,510
Can you tell me why and how you could have answered this question immediately?
你能告诉我为什么以及你是如何立即回答这个问题的吗？

571
00:33:50,490 --> 00:33:52,100
Whether the code is correct or not?
这段代码是否正确？

572
00:33:55,690 --> 00:33:57,850
Actually, the question is more clearly.
实际上，问题更加清晰明了。

573
00:33:58,220 --> 00:34:02,370
You could have immediately see that the code is not
你可以立即看到代码是有问题的

574
00:34:15,230 --> 00:34:15,700
correct.
正确。

575
00:34:16,530 --> 00:34:17,280
Nicholas,
尼古拉斯，

576
00:34:18,390 --> 00:34:18,990
that's true.
没错。

577
00:34:19,000 --> 00:34:20,150
There is no wait.
没有等待。

578
00:34:20,770 --> 00:34:22,290
I told you that fundamentally,
我告诉过你，从根本上说，

579
00:34:22,300 --> 00:34:26,170
any of these synchronization primitives has to involve a weight,
这些同步原语中的任何一个都必须涉及一个权重。

580
00:34:27,100 --> 00:34:29,220
because if someone is in the critical section,
因为如果有人在临界区内，

581
00:34:29,230 --> 00:34:33,230
the other one thread has to wait.
另一个线程必须等待。

582
00:34:33,930 --> 00:34:37,220
If it wants to go into the critical section, there is no way around.
如果它想进入临界区，没有其他办法。

583
00:34:37,230 --> 00:34:38,880
It is fundamental.
这是基础的。

584
00:34:39,970 --> 00:34:40,930
But so far,
到目前为止，

585
00:34:40,940 --> 00:34:48,150
none of these codes has a weight instruction or something equivalent.
这些代码中没有权重指令或等效指令。

586
00:34:49,900 --> 00:34:53,370
So that's how you can immediately say these codes.
这就是你能立即说出这些代码的原因。

587
00:34:53,680 --> 00:34:55,150
It's not going to work.
这不会起作用。

588
00:34:57,530 --> 00:34:58,480
Finally,
最后，

589
00:35:00,650 --> 00:35:01,230
okay.
好的。

590
00:35:02,520 --> 00:35:04,490
So let's go.
那么，我们开始吧。

591
00:35:04,870 --> 00:35:05,220
Obviously,
显然，

592
00:35:06,110 --> 00:35:06,620
this,
这个，

593
00:35:07,130 --> 00:35:12,320
if no one gets the milk and this continuous, and obviously,
如果没有人拿到牛奶，而且这种情况持续下去，显然的，

594
00:35:12,330 --> 00:35:13,720
this is called starvation.
这被称为饥饿。

595
00:35:13,730 --> 00:35:17,040
We're going to learn more about starvation in a few lectures.
我们将在接下来的几堂课中学习更多关于饥饿的内容。

596
00:35:18,660 --> 00:35:19,690
Now, finally,
现在，最后，

597
00:35:20,050 --> 00:35:21,710
here is solution three.
这是第三个解决方案。

598
00:35:23,450 --> 00:35:24,530
There are turnouts,
有转弯处，

599
00:35:26,360 --> 00:35:27,450
but not yesterday.
但不包括昨天。

600
00:35:27,770 --> 00:35:30,410
It has ay a while.
已经过了一段时间了。

601
00:35:31,280 --> 00:35:32,610
This is a waiting instruction,
这是一个等待指令。

602
00:35:34,550 --> 00:35:42,090
because you wait for the node b if there is a node be,
因为如果存在节点b，你会等待节点b。

603
00:35:43,240 --> 00:35:49,030
then you wait until the node b is removed.
那么你就等待直到节点 b 被移除。

604
00:35:51,050 --> 00:35:51,580
Okay?
好的？

605
00:35:52,730 --> 00:35:54,090
So in other words,
换句话说，

606
00:35:54,770 --> 00:35:57,890
thread a will not execute or not buy the milk or not,
线程a将不会执行或者不买牛奶。

607
00:35:57,900 --> 00:36:00,570
even look at whether there is a milk in the fridge.
甚至看一下冰箱里是否有牛奶。

608
00:36:01,300 --> 00:36:09,070
If thread b it's checked and already went to buy milk
如果线程b被检查并且已经去买牛奶了

609
00:36:22,220 --> 00:36:24,370
testing set as a synchronization.
将测试集设置为同步。

610
00:36:24,380 --> 00:36:25,890
So the question is for michael,
所以这个问题是给迈克尔的。

611
00:36:25,900 --> 00:36:28,490
instead of waiting countries keep the critical section,
不要让国家等待保持临界区

612
00:36:28,950 --> 00:36:31,820
do we consider test and set as having a critical section?
我们是否认为测试和设置操作具有临界区？

613
00:36:32,740 --> 00:36:33,930
The test is said,
据说考试已经结束了。

614
00:36:33,940 --> 00:36:37,230
they are going to be used to implement things like locks.
它们将被用于实现诸如锁之类的东西。

615
00:36:38,640 --> 00:36:40,330
That's it, right?
就这样了，对吗？

616
00:36:41,290 --> 00:36:44,140
You need to have a while in order to wait on a distance set.
你需要使用一个while循环来等待一个距离集合的设置。

617
00:36:47,830 --> 00:36:48,660
At shake.
摇动。

618
00:36:49,010 --> 00:36:49,970
Answer is correct.
答案是正确的。

619
00:36:54,530 --> 00:36:54,690
Right?
对吗？

620
00:36:55,060 --> 00:36:56,690
You need test and set alone.
你只需要使用测试和设置（test and set）操作。

621
00:36:56,700 --> 00:36:57,970
You need to also have, again,
你需要再次拥有

622
00:36:57,980 --> 00:37:02,650
a while be around you to see that it is going to work.
在你身边待一会儿，看看它是否会起作用。

623
00:37:02,660 --> 00:37:03,250
Yes.
是的。

624
00:37:04,430 --> 00:37:07,770
How you to convince yourself you see these 2 points,
你如何说服自己看到了这两个观点？

625
00:37:07,780 --> 00:37:10,640
x and y in each of these thread programs.
这些线程程序中的 x 和 y。

626
00:37:12,470 --> 00:37:18,490
What you say here is at x if there is no node b
如果没有节点b，你在这里所说的是在x处。

627
00:37:21,620 --> 00:37:23,830
that is safe for a to buy,
这是一个安全的购买选择。

628
00:37:25,860 --> 00:37:26,340
right?
对的？

629
00:37:34,690 --> 00:37:35,990
Say, for a dubai, sorry.
对不起，我不太明白你的意思。你能提供更多的上下文吗？

630
00:37:36,580 --> 00:37:37,130
I what i'm doing,
我正在做什么，

631
00:37:38,130 --> 00:37:38,580
right?
对的吗？

632
00:37:39,250 --> 00:37:43,980
Because if there is no node b the thread b will for sure is
因为如果没有节点 b，线程 b 将肯定会出错。

633
00:37:43,990 --> 00:37:47,240
outside this section of code.
在这段代码之外。

634
00:37:48,030 --> 00:37:49,520
For sure, it doesn't thread.
当然，它不支持线程。

635
00:37:49,530 --> 00:37:50,720
B doesn't buy milk.
B不买牛奶。

636
00:37:51,610 --> 00:37:55,810
So it's safe for a to buy if there is no milk.
如果没有牛奶，那么购买是安全的。

637
00:37:57,330 --> 00:37:57,880
Now,
现在，

638
00:37:58,650 --> 00:38:01,950
if I am at y if there is no node,
如果在位置y处没有节点，

639
00:38:01,960 --> 00:38:03,590
a is safe for bitter,
a对于苦味是安全的。

640
00:38:03,600 --> 00:38:05,920
but why?
因为我是一个计算机程序，我只能将英文翻译成中文，无法回复其他信息。如果你有其他问题，可以继续提问。

641
00:38:06,540 --> 00:38:12,880
Because if there is not a
因为如果没有一个

642
00:38:14,460 --> 00:38:20,190
this means that thread a it's not in exactly in this code.
这意味着线程A并不完全在这段代码中。

643
00:38:20,700 --> 00:38:21,980
So we cannot buy me.
所以我们不能买到我。

644
00:38:24,770 --> 00:38:26,410
Here is another way to look at it.
这是另一种看待它的方式。

645
00:38:27,400 --> 00:38:30,760
There are these two actions leave,
有这两个动作：离开和返回。

646
00:38:30,770 --> 00:38:32,240
not a and no,
不是 a 且不是 no。

647
00:38:32,250 --> 00:38:34,160
not a when is checked.
不是一个被检查的情况。

648
00:38:35,340 --> 00:38:39,300
So if leave node a happens before,
如果离开节点a发生在之前，

649
00:38:39,900 --> 00:38:44,910
no node a is checked by the second thread,
第二个线程没有检查节点 a。

650
00:38:45,920 --> 00:38:46,380
right?
对的？

651
00:38:47,240 --> 00:38:51,340
Then it's obvious that
那么很明显

652
00:38:55,670 --> 00:38:58,590
thread b will not buy milk,
线程 b 不会买牛奶。

653
00:39:00,390 --> 00:39:01,630
because there is a nowadays,
因为现在有一个现象，

654
00:39:02,540 --> 00:39:04,440
and it's over so obvious,
而且这是如此明显，

655
00:39:05,860 --> 00:39:07,170
at least for now,
至少目前来说，

656
00:39:08,000 --> 00:39:13,490
that said a will wait,
那么我会等待的。

657
00:39:13,500 --> 00:39:15,510
because there is a no b right?
因为有一个不是b的元素吗？

658
00:39:19,050 --> 00:39:20,590
Now, at this.,
现在，在这里。

659
00:39:21,480 --> 00:39:23,540
now the thread b is, again,
现在线程 b 再次是，

660
00:39:25,000 --> 00:39:26,110
there is a nowadays,
现如今，

661
00:39:26,120 --> 00:39:30,800
so we skip buying milk and then go all the way and buy and removes.
所以我们跳过买牛奶，然后继续前进，买和移除。

662
00:39:30,810 --> 00:39:33,800
And i'll be without doing the anything without buying milk.
我将什么都不做，也不会买牛奶。

663
00:39:34,640 --> 00:39:37,510
But notice now what happened yesterday once?
但是请注意昨天发生了什么事情？

664
00:39:39,540 --> 00:39:45,620
Said b removes note b thread a exits the y loop.
当线程a退出循环y时，线程b删除了笔记b。

665
00:39:46,680 --> 00:39:50,190
It check whether there is no milk and there is no milk and buy the milks.
它检查是否没有牛奶，如果没有牛奶，则购买牛奶。

666
00:39:51,090 --> 00:39:51,660
Okay?
好的？

667
00:39:53,490 --> 00:39:54,830
In this particular case,
在这种特殊情况下，

668
00:39:55,500 --> 00:39:57,140
thread a bought milk.
线程a买了牛奶。

669
00:39:58,220 --> 00:40:08,300
Now, let's assume that if no node a happens after thread b checks,
现在，让我们假设如果在线程b检查之后没有发生节点a。

670
00:40:08,310 --> 00:40:12,110
whether there is no take what happens in this case.
在这种情况下，如果没有采取任何行动，会发生什么。

671
00:40:13,840 --> 00:40:14,250
Right?
对吗？

672
00:40:17,050 --> 00:40:25,940
So thread b found no note a there is no milk,
所以线程b发现没有便条，说明没有牛奶。

673
00:40:25,950 --> 00:40:27,300
so is going to buy the milk.
所以要去买牛奶。

674
00:40:29,140 --> 00:40:36,900
Then it's removing the node b as in parallel node a
然后它会同时删除节点b和节点a。

675
00:40:38,250 --> 00:40:45,600
is going to execute while node b and is going to wait
将要执行，同时节点 b 将会等待。

676
00:40:46,060 --> 00:40:54,010
for a to remove node b when that happens and b
当节点 b 被移除时，需要执行以下操作：

677
00:40:54,020 --> 00:40:58,770
no thread b removes no b only after it bought the milk.
线程 B 只有在购买了牛奶之后才会移除没有牛奶的 B。

678
00:41:00,020 --> 00:41:03,530
Now, when it be removes not be,
现在，当它被移除时不是存在的。

679
00:41:04,450 --> 00:41:09,340
this means that thread a will exceed the while loop,
这意味着线程A将超过while循环。

680
00:41:11,390 --> 00:41:12,770
and now check for the milk.
现在检查一下牛奶。

681
00:41:13,870 --> 00:41:15,560
But now there is milk in the fridge,
但是现在冰箱里有牛奶。

682
00:41:16,160 --> 00:41:17,880
because we put the milk in the fridge,
因为我们把牛奶放进冰箱里，

683
00:41:17,890 --> 00:41:19,120
you bought the milk.
你买了牛奶。

684
00:41:19,940 --> 00:41:22,240
So therefore, they will not buy milk.
因此，他们不会购买牛奶。

685
00:41:26,500 --> 00:41:28,390
So we are done.
我们完成了。

686
00:41:33,060 --> 00:41:34,230
So you see, in this case,
所以你看，在这种情况下，

687
00:41:34,240 --> 00:41:35,430
in both cases,
在这两种情况下，

688
00:41:35,900 --> 00:41:39,420
only one thread and exactly one thread, but milk.
只有一个线程，确切地说是一个线程，但是牛奶。

689
00:41:43,520 --> 00:41:47,710
The solution is easily protects a single critical section piece of code.
这个解决方案很容易保护单个关键代码段。

690
00:41:48,310 --> 00:41:49,620
This is the critical section.
这是临界区。

691
00:41:49,630 --> 00:41:51,260
If no milk, you buy milk,
如果没有牛奶，你就买牛奶。

692
00:41:53,790 --> 00:41:55,120
solutions three works,
解决方案三有效。

693
00:41:55,130 --> 00:41:59,430
but it's as if is not very satisfactory,
但这似乎并不令人满意，

694
00:42:00,290 --> 00:42:02,300
it's pretty complex, right?
这很复杂，对吧？

695
00:42:02,680 --> 00:42:04,250
Even in this simple example.
即使在这个简单的例子中。

696
00:42:04,920 --> 00:42:06,330
And like you see,
就像你所看到的，

697
00:42:06,340 --> 00:42:09,010
we got like what five six instructions.
我们大约有五六条指令。

698
00:42:09,670 --> 00:42:11,500
It still took us like whatever 10,
我们还是花了大约10分钟。

699
00:42:11,510 --> 00:42:13,540
15 minutes to convince ourselves that is working.
我们有15分钟的时间来确信它是否正常工作。

700
00:42:14,650 --> 00:42:17,150
And also, a code is different from b code.
而且，a code 和 b code 是不同的。

701
00:42:17,160 --> 00:42:21,530
What if you have not to stress by three stress of or ten threads?
如果你不必要处理三个或十个线程的压力，会怎样呢？

702
00:42:23,920 --> 00:42:26,570
Finally, we have a wait here,
最后，我们在这里等待。

703
00:42:26,890 --> 00:42:28,120
but she's busy waiting,
但她忙着等待，

704
00:42:28,650 --> 00:42:29,050
right?
是的，正确的。

705
00:42:29,470 --> 00:42:33,720
This said a consume the superior resources while waiting.
这句话意味着在等待时消耗了更多的资源。

706
00:42:34,460 --> 00:42:36,100
We don't want that in general.
一般情况下，我们不希望这样。

707
00:42:37,340 --> 00:42:39,090
So let's look for a better ways.
那么让我们寻找更好的方法吧。

708
00:42:42,430 --> 00:42:43,700
Think about locking interface.
考虑锁定接口。

709
00:42:43,710 --> 00:42:48,590
You are considering you want to acquire the lock and release a lock.
你正在考虑是否要获取锁并释放锁。

710
00:42:48,600 --> 00:42:49,910
These are the instructions.
这些是指示。

711
00:42:50,150 --> 00:42:51,150
If the lock is taken,
如果锁被占用了，

712
00:42:51,160 --> 00:42:54,750
you are waiting in the choir until someone believes along.
你正在合唱团中等待，直到有人加入。

713
00:42:57,900 --> 00:43:01,710
And then your milk problem is a it's a very simple.
然后你的牛奶问题很简单。

714
00:43:02,000 --> 00:43:03,090
You acquire the lock.
你获得了锁。

715
00:43:03,810 --> 00:43:05,790
If there is no milk, you buy the milk.
如果没有牛奶，你就买牛奶。

716
00:43:06,170 --> 00:43:07,160
I said it really is a lock.
我说的是真的是一个锁。

717
00:43:08,980 --> 00:43:12,590
This is like our very first solution with a lock, right?
这就像我们的第一个带锁的解决方案，对吗？

718
00:43:12,600 --> 00:43:13,910
A physical lock to the fridge.
一个用于冰箱的物理锁。

719
00:43:13,920 --> 00:43:20,720
But now imagine that you can put the lock only on a on something
但现在想象一下，你只能将锁放在某个东西上。

720
00:43:20,730 --> 00:43:23,470
in the fridge were contains only milk,
冰箱里只有牛奶。

721
00:43:25,230 --> 00:43:25,680
right?
对的？

722
00:43:26,340 --> 00:43:28,580
On a container, in the fridge or contains milk.
在冰箱里的容器中装有牛奶。

723
00:43:28,590 --> 00:43:29,420
That's a cuban.
那是一只古巴雪茄。

724
00:43:30,850 --> 00:43:31,170
Right?
对吗？

725
00:43:35,920 --> 00:43:37,950
Now, the question is how to implement lock?
现在的问题是如何实现锁？

726
00:43:38,190 --> 00:43:39,560
This is what we are going to discuss.
这是我们要讨论的内容。

727
00:43:40,220 --> 00:43:44,170
Remember, all synchronization primitive involves wait,
记住，所有的同步原语都涉及到等待操作。

728
00:43:45,180 --> 00:43:47,400
but you don't want to do the waiting, busy, waiting,
但你不想等待，忙碌，等待。

729
00:43:48,210 --> 00:43:52,800
just spending the cpu resources while waiting.
在等待期间仅消耗CPU资源。

730
00:43:53,760 --> 00:43:56,440
Instead, you want to sleep when you wait,
相反，当你等待时，你想要睡觉。

731
00:43:56,950 --> 00:44:03,490
and you want to be open up when you can acquire the lock and enter
当你能够获取锁并进入时，你希望它是开放的。

732
00:44:03,500 --> 00:44:04,300
the critical section.
临界区。

733
00:44:06,960 --> 00:44:12,270
Solution three from the milk or milk three solution was
从牛奶或牛奶三溶液中的第三种溶液是解决方案。

734
00:44:12,280 --> 00:44:15,470
basically equivalent to using atomic load and stores,
基本上等同于使用原子加载和存储操作，

735
00:44:16,130 --> 00:44:17,880
again, pretty complex and the opera.
再次，相当复杂和戏剧性。

736
00:44:20,150 --> 00:44:25,110
So now the question is about how it does this implement the locks,
现在的问题是关于如何实现锁的机制。

737
00:44:25,120 --> 00:44:27,230
because they saw that if we implement the locks,
因为他们看到如果我们实现了锁定机制，

738
00:44:28,670 --> 00:44:29,990
the solution is much easier.
解决方案要简单得多。

739
00:44:31,970 --> 00:44:37,510
One way to think about is to implement its in harbor.
一种思考的方式是在港口中实施它。

740
00:44:38,540 --> 00:44:40,710
However, if you implement it in hardware,
然而，如果你将其实现在硬件中，

741
00:44:41,290 --> 00:44:41,790
a lock,
一个锁

742
00:44:42,960 --> 00:44:44,950
it turns out that it's pretty complicated.
事实证明，这是相当复杂的。

743
00:44:46,320 --> 00:44:48,240
And there are some processors doing it.
而且有一些处理器正在执行这个操作。

744
00:44:49,830 --> 00:44:52,090
But it's, again, the complexity is high,
但是，再次强调，复杂度很高，

745
00:44:52,780 --> 00:44:55,060
and it's also slow,
而且它也很慢，

746
00:44:56,860 --> 00:44:58,450
because the chip is more complex.
因为芯片更复杂。

747
00:44:58,460 --> 00:44:59,770
It's actually slow down,
实际上，它变慢了。

748
00:45:00,050 --> 00:45:01,130
many other instructions.
许多其他指令。

749
00:45:02,930 --> 00:45:07,470
So one simple solution to implement it with what learn so far.
根据目前所学的知识，有一个简单的解决方案可以实现它。

750
00:45:08,760 --> 00:45:11,490
It's about using the internet.
这是关于使用互联网的问题。

751
00:45:13,180 --> 00:45:13,420
Right?
对吗？

752
00:45:13,430 --> 00:45:16,790
Remember that we have these external interrupts,
请记住我们有这些外部中断。

753
00:45:16,800 --> 00:45:17,910
internal interrupts,
内部中断

754
00:45:18,290 --> 00:45:21,010
but fundamentally the interrupts.
但是从根本上讲，中断是关键。

755
00:45:22,230 --> 00:45:23,780
When you execute an interrupt,
当你执行一个中断时，

756
00:45:24,710 --> 00:45:30,470
you are you are going to run some code.
你将要运行一些代码。

757
00:45:31,090 --> 00:45:38,460
And what we are talking about here is that think about like locker choir
我们在这里讨论的是像储物柜合唱团一样的想法。

758
00:45:38,470 --> 00:45:39,900
disable all interrupts.
禁用所有中断。

759
00:45:40,610 --> 00:45:46,560
So this means also there is no contact switching because in order to have
这也意味着没有联系切换，因为为了实现联系切换，需要有

760
00:45:46,570 --> 00:45:48,520
also the context switching,
还有上下文切换，

761
00:45:48,990 --> 00:45:52,220
you're going to have the timer interrupt, right?
你们会有定时器中断，对吗？

762
00:45:52,230 --> 00:45:54,940
Or they interrupt another interrupt external interrupts to do it.
或者他们会中断另一个中断来处理外部中断。

763
00:45:55,770 --> 00:45:57,310
And the local release you enable interrupts.
并且在本地释放中断。

764
00:45:59,250 --> 00:46:02,800
So it is a problem with this approach is not going to work.
这种方法存在问题，无法奏效。

765
00:46:03,390 --> 00:46:03,850
Right?
对吗？

766
00:46:04,400 --> 00:46:06,070
Before we acquire an interrupt.
在我们获取中断之前。

767
00:46:06,650 --> 00:46:06,990
Right?
对吗？

768
00:46:09,030 --> 00:46:09,620
If you're sorry,
如果你很抱歉，

769
00:46:09,630 --> 00:46:13,100
if you do acquire a lock and you disable all the interrupts,
如果你成功获取了锁并禁用了所有中断，

770
00:46:13,630 --> 00:46:18,600
then you do something like a while through your hank computer hanks,
然后你可以像通过你的汉克计算机一样使用一个while循环来做一些事情。

771
00:46:18,810 --> 00:46:20,200
again, it cannot be interrupted.
再次强调，它不能被中断。

772
00:46:20,990 --> 00:46:21,380
Right?
对吗？

773
00:46:23,350 --> 00:46:27,020
You need to do something like ill to voluntarily provide give access
你需要主动提供访问权限，类似于ill的方式来完成某些任务。

774
00:46:27,390 --> 00:46:31,070
to the scheduler in order to the kernel,
给调度器以便于内核使用。

775
00:46:31,080 --> 00:46:32,310
to schedule another thread.
调度另一个线程。

776
00:46:32,990 --> 00:46:35,290
But this code will lock the entire computer.
但是这段代码会锁定整台计算机。

777
00:46:36,280 --> 00:46:37,430
It's very risky.
这非常危险。

778
00:46:42,690 --> 00:46:43,680
You don't want to do that.
你不想这样做。

779
00:46:43,690 --> 00:46:46,640
And there are many other reasons like for real time systems,
还有许多其他原因，比如用于实时系统，

780
00:46:46,650 --> 00:46:48,360
there is no guarantee of timing,
没有时间保证。

781
00:46:48,990 --> 00:46:51,940
because the critical section can be arbitrary long.
因为临界区可能会任意长。

782
00:46:54,050 --> 00:46:57,670
Obviously, what happens when there are very important io events?
显然，当出现非常重要的输入/输出事件时会发生什么？

783
00:47:04,010 --> 00:47:10,320
So let's think about a better implementation of the locks by disabling interrupts.
那么让我们思考一下通过禁用中断来改进锁的实现方式。

784
00:47:10,800 --> 00:47:11,690
So here it is on.
所以这就是它的状态。

785
00:47:13,640 --> 00:47:18,660
Basically, you maintain is a way to think about.
基本上，你维护的是一种思考方式。

786
00:47:18,670 --> 00:47:21,640
You use a lock to implement a lock.
你使用锁来实现一个锁。

787
00:47:22,360 --> 00:47:22,850
Right?
对吗？

788
00:47:23,330 --> 00:47:30,720
What you want is that when the segment that you want to minimize the
你想要的是将你想要最小化的段落

789
00:47:30,730 --> 00:47:37,500
code between disable interrupt and enable interrupts,
在禁用中断和启用中断之间的代码。

790
00:47:37,510 --> 00:47:39,790
that's what you want to do.
那是你想要做的事情。

791
00:47:39,800 --> 00:47:40,230
Okay?
好的？

792
00:47:41,930 --> 00:47:44,730
Because the problem is the previous in the previous case,
因为问题是在之前的情况中出现的。

793
00:47:44,740 --> 00:47:49,020
the problem is that you disable interrupts and you enter the critical section,
问题在于你禁用了中断并进入了临界区。

794
00:47:49,400 --> 00:47:52,110
then the critical section can be arbitrary along.
那么临界区可以是任意长度的。

795
00:47:52,970 --> 00:47:53,320
Right?
对吗？

796
00:47:54,160 --> 00:47:55,300
Depends on the application.
这取决于具体的应用程序。

797
00:47:56,430 --> 00:47:56,810
Right?
对吗？

798
00:47:57,670 --> 00:47:58,470
But in this case,
但在这种情况下，

799
00:47:58,480 --> 00:48:04,790
we are going to implement the lock with a disable interrupt and enable,
我们打算使用禁用中断和启用中断来实现锁。

800
00:48:04,800 --> 00:48:05,270
interrupts,
中断

801
00:48:05,900 --> 00:48:10,980
and then expose acquire lock and release lock to the application,
然后将获取锁和释放锁的操作暴露给应用程序。

802
00:48:12,850 --> 00:48:15,410
implemented under the hood by the disabled interrupt.
在底层通过禁用中断实现。

803
00:48:15,650 --> 00:48:16,500
But notice here,
但是请注意，在这里，

804
00:48:17,350 --> 00:48:19,510
the disabled interrupts and enable interrupts.
禁用中断和启用中断。

805
00:48:20,030 --> 00:48:21,950
You have a very small piece of code here.
这里有一小段代码。

806
00:48:22,470 --> 00:48:24,140
It's going to run very quickly.
它将运行得非常快速。

807
00:48:27,270 --> 00:48:33,130
Ideally, what you do for the choir say the value is a lock value.
理想情况下，你为合唱团做的事情可以说是锁定价值。

808
00:48:35,410 --> 00:48:37,100
It's either free or busy.
它要么是空闲的，要么是忙碌的。

809
00:48:38,570 --> 00:48:39,740
So to acquire it,
所以要获取它，

810
00:48:39,750 --> 00:48:41,500
if you disable the interrupt,
如果你禁用中断，

811
00:48:41,510 --> 00:48:42,900
to manipulate this value,
要操作这个值，

812
00:48:44,140 --> 00:48:45,510
if the value is busy,
如果值是忙碌的，

813
00:48:46,150 --> 00:48:46,900
what did we say?
我们说了什么？

814
00:48:46,910 --> 00:48:47,940
We want to sleep.
我们想要睡觉。

815
00:48:48,680 --> 00:48:51,390
So put thread on the wait list and go to sleep,
将线程放入等待列表并进入休眠状态，

816
00:48:51,860 --> 00:48:54,330
and somehow you want to enable interrupts.
而且你希望启用中断。

817
00:48:56,190 --> 00:49:00,980
So as I said can execute alice,
正如我所说的，可以执行alice。

818
00:49:01,720 --> 00:49:04,080
you acquire the lock value is busy and enable,
你获取到的锁值是忙碌和启用的。

819
00:49:04,090 --> 00:49:08,040
interrupts and for relieves,
中断和中断处理程序

820
00:49:08,940 --> 00:49:10,450
you disable interrupts.
你禁用中断。

821
00:49:11,110 --> 00:49:15,260
You look, if there is only anyone on the whale queue waiting for the lock.
请检查一下鲸队列上是否只有一个人在等待锁。

822
00:49:16,030 --> 00:49:20,880
If it is, you give the lock to one of the thread or from the way queue.
如果是这样的话，你可以将锁交给其中一个线程，或者从等待队列中选择一个线程。

823
00:49:21,690 --> 00:49:23,610
And you play the thread on the ready queue,
然后你将线程放入就绪队列中，

824
00:49:24,870 --> 00:49:28,050
that thread can execute a critical section.
该线程可以执行一个临界区。

825
00:49:28,060 --> 00:49:32,070
If there is no one on the way q the value is free and you enable the interests.
如果路上没有人，q的值是空闲的，并且你可以启用兴趣。

826
00:49:36,370 --> 00:49:37,990
You see here the way it happens,
你看到这里发生的方式，

827
00:49:38,000 --> 00:49:39,230
because you put the thread,
因为你创建了线程，

828
00:49:39,240 --> 00:49:40,710
we're waiting on the waiting queue.
我们正在等待队列上等待。

829
00:49:41,950 --> 00:49:47,600
And then you you'd get that you take that thread from the waiting queue when
然后你会从等待队列中取出该线程

830
00:49:50,480 --> 00:49:52,610
another thread released the lock.
另一个线程释放了锁。

831
00:49:54,240 --> 00:49:55,190
Any questions here?
这里有什么问题吗？

832
00:50:01,690 --> 00:50:03,560
Now, it's against what I was saying.
现在，这与我之前所说的相反。

833
00:50:03,570 --> 00:50:07,120
You inclement input in increment a lock by used by another lock.
您在尝试增加一个已被其他锁使用的锁时出现了不正确的输入。

834
00:50:08,940 --> 00:50:11,810
The reason for that because the second lock you are going to use,
这是因为你要使用的第二个锁。

835
00:50:11,820 --> 00:50:15,280
you can use disable and enable interacts by making
你可以通过禁用和启用交互来实现。

836
00:50:15,290 --> 00:50:19,780
sure that the critical section protected by disabling and enable
确保临界区受到禁用和启用的保护

837
00:50:19,790 --> 00:50:21,490
interrupts is very short.
中断是非常短暂的。

838
00:50:22,140 --> 00:50:24,450
This can be implemented by the operating system.
这可以由操作系统实现。

839
00:50:25,160 --> 00:50:28,590
You have control about on the length of the critical section protecting
你可以控制保护临界区的长度。

840
00:50:28,600 --> 00:50:29,430
by the interrupt,
通过中断，

841
00:50:29,440 --> 00:50:30,910
disabling and enabling.
禁用和启用。

842
00:50:34,170 --> 00:50:37,710
So that's the main difference from using disable,
这就是使用disable的主要区别。

843
00:50:37,720 --> 00:50:39,750
interrupts and enable interrupts directly.
中断和直接启用中断。

844
00:50:44,380 --> 00:50:45,860
With this design,
使用这个设计，

845
00:50:45,870 --> 00:50:50,050
the users can take as long as they want in the critical section,
用户在临界区可以花费任意长的时间。

846
00:50:52,440 --> 00:50:55,360
because their critical section is not protecting by disable interrupt
因为他们的临界区没有通过禁用中断来保护。

847
00:50:55,370 --> 00:50:56,320
or enable interrupt.
或者启用中断。

848
00:51:02,240 --> 00:51:03,800
Now, what is a big problem?
现在，什么是一个大问题？

849
00:51:05,190 --> 00:51:06,310
Here is a big problem.
这是一个大问题。

850
00:51:06,990 --> 00:51:13,080
We need to enable interacts when we put the thread on the wake you,
当我们唤醒线程时，需要启用交互功能。

851
00:51:13,680 --> 00:51:17,400
because we need to allow as a threat to execute in particular,
因为我们需要允许某个威胁特定地执行。

852
00:51:17,410 --> 00:51:19,140
the strategies in the critical section.
临界区的策略。

853
00:51:22,420 --> 00:51:23,550
But the question is,
但问题是，

854
00:51:23,560 --> 00:51:25,870
where do you need to install to enable the interrupts?
需要安装中断处理程序才能启用中断。

855
00:51:28,070 --> 00:51:29,630
There are three possibilities.
有三种可能性。

856
00:51:29,640 --> 00:51:35,820
One is here before putting the thread on the way it is correct.
在将线程放在适当位置之前，需要先了解正确的方法。

857
00:51:49,530 --> 00:51:57,880
That's it's not because the release can check the cure and not waken
这是因为发布版本可以检查疗效而不会唤醒。

858
00:51:57,890 --> 00:51:58,480
up the thread.
提升线程。

859
00:52:00,010 --> 00:52:00,400
Right?
对吗？

860
00:52:00,910 --> 00:52:04,110
So enable upon in inputs of enabling traps here.
在这里启用陷阱的输入。

861
00:52:05,620 --> 00:52:07,620
Before the study sponsor put on the weight queue,
在研究赞助商将其放入权重队列之前，

862
00:52:07,990 --> 00:52:09,260
you do contact switch,
你要进行联系切换。

863
00:52:09,510 --> 00:52:13,740
the current context switch to the thread, another thread,
当前上下文切换到另一个线程。

864
00:52:13,750 --> 00:52:15,380
which is executing the release.
正在执行发布的进程。

865
00:52:17,420 --> 00:52:17,880
Right?
对吗？

866
00:52:19,390 --> 00:52:23,460
The release is going to look at the if there is any set on the wave queue,
该版本将检查波浪队列中是否有任何集合。

867
00:52:24,470 --> 00:52:25,470
and there is none,
并且没有任何的。

868
00:52:26,810 --> 00:52:30,370
because acquire was didn't have a chance to play the set on the way.
因为在路上没有机会玩这个游戏集。

869
00:52:30,380 --> 00:52:33,340
So the threat will not be awkward.
这样就不会让人感到尴尬了。

870
00:52:35,370 --> 00:52:40,350
What if you put the name the enable interrupts before go to?
如果在执行"go to"之前将中断使能的名称放在前面，会发生什么？

871
00:52:45,640 --> 00:52:46,380
These are corner?
这些是角落吗？

872
00:52:57,830 --> 00:53:03,970
Does if so here is a question michael from michael does if have
如果是这样，这里有一个问题：迈克尔来自迈克尔吗？

873
00:53:03,980 --> 00:53:05,290
to be replaced with wild?
要被替换为通配符吗？

874
00:53:06,190 --> 00:53:08,250
Now i'll let you know why,
现在我会告诉你为什么，

875
00:53:08,260 --> 00:53:13,050
because let me go through this slide and i'll tell you why after that.
因为让我浏览一下这张幻灯片，然后我会告诉你为什么。

876
00:53:14,850 --> 00:53:17,130
Now, because this is not correct,
现在，因为这是不正确的，

877
00:53:17,140 --> 00:53:20,830
either because the release put the thread on the ridicule,
要么是因为发布使线程处于嘲笑的境地，

878
00:53:23,730 --> 00:53:25,870
but the threat still think it needs to go to sleep.
但是威胁仍然认为它需要休眠。

879
00:53:27,600 --> 00:53:29,300
So you put the threat on the waiting queue.
所以你将该线程放入等待队列中。

880
00:53:30,840 --> 00:53:32,660
You enable, interrupts,
你启用中断。

881
00:53:34,100 --> 00:53:37,620
now assumes as a release of their from the other side is executed.
现在假设从另一方执行它们的发布。

882
00:53:38,890 --> 00:53:39,250
Right?
对吗？

883
00:53:40,220 --> 00:53:47,330
And here the release is looking on the way q and you have a set on the way
在这里，发布正在进行中，你已经有一套计划在进行中。

884
00:53:47,340 --> 00:53:47,770
to q
给 q

885
00:53:48,320 --> 00:53:50,770
and take that thread to execute it.
并将该线程执行。

886
00:53:53,190 --> 00:53:56,240
But then when the australians executed,
但是当澳大利亚人执行时，

887
00:53:56,250 --> 00:54:00,050
it goes to sleep.
它进入睡眠状态。

888
00:54:01,910 --> 00:54:03,850
So you don't execute.
所以你不执行。

889
00:54:04,620 --> 00:54:05,670
Now it is a question.
现在是一个问题。

890
00:54:06,320 --> 00:54:12,960
I said that it's a busy that we need to have some waiting for any synchronization,
我说过，这是一个繁忙的时候，我们需要等待任何同步操作。

891
00:54:12,970 --> 00:54:13,520
primitive.
原语。

892
00:54:13,780 --> 00:54:14,770
You need to have waiting.
你需要等待。

893
00:54:17,150 --> 00:54:18,790
Why we don't have a while here?
为什么我们这里没有 while 循环？

894
00:54:20,690 --> 00:54:23,310
The reason we don't have a while here is very simple,
我们这里没有while循环的原因非常简单，

895
00:54:25,580 --> 00:54:26,300
like I mentioned,
就像我之前提到的那样，

896
00:54:26,310 --> 00:54:32,500
but probably I was not very clear is because of waiting here happens
但可能我没有表达清楚的原因是因为在这里等待发生了。

897
00:54:33,550 --> 00:54:36,440
implicitly by acquire.
隐式地通过获取。

898
00:54:36,780 --> 00:54:38,770
If the value, if the lock is busy,
如果锁被占用的话，那么值就是忙碌的。

899
00:54:39,860 --> 00:54:42,170
you put the thread on the waiting queue,
你将线程放入等待队列中，

900
00:54:42,870 --> 00:54:44,310
putting the thread of the waiting queue.
将线程放入等待队列。

901
00:54:44,320 --> 00:54:46,590
That act means waiting.
这个行为意味着等待。

902
00:54:48,330 --> 00:54:48,580
Right?
对吗？

903
00:54:48,590 --> 00:54:51,490
It doesn't happen in the program.
这在程序中没有发生。

904
00:54:51,920 --> 00:54:54,870
It happens in the kernel.
这发生在内核中。

905
00:54:55,340 --> 00:54:55,690
Right?
对吗？

906
00:54:58,170 --> 00:54:59,650
You put the thread on the waiting queue,
你将线程放入等待队列中，

907
00:54:59,660 --> 00:55:03,210
and the thread will wait until the release is going to be exactly.
线程将等待，直到释放将要发生。

908
00:55:04,690 --> 00:55:05,900
And here's a lock is at least,
这里至少有一个锁。

909
00:55:09,620 --> 00:55:11,900
anyway, in order to solve the problem,
无论如何，为了解决这个问题，

910
00:55:13,080 --> 00:55:15,940
you need to put to lisa log after going to sleep.
你需要在睡觉之前给丽莎记录日志。

911
00:55:18,270 --> 00:55:19,380
But how you do it?
但是你是如何做到的呢？

912
00:55:20,720 --> 00:55:21,840
Because the thread is sleeping.
因为线程正在休眠。

913
00:55:21,850 --> 00:55:28,550
So how can execute an instruction to enable the interrupts?
要执行一条指令来启用中断，可以如何操作？

914
00:55:32,640 --> 00:55:32,870
Any
任何

915
00:55:42,660 --> 00:55:42,730
suggestions?
建议？

916
00:55:43,660 --> 00:55:45,140
So the problem is very simple.
所以问题非常简单。

917
00:55:46,080 --> 00:55:51,620
It's like I want logically to enable the interrupts after I go to sleep.
就好像我希望在睡觉后逻辑上启用中断一样。

918
00:55:52,690 --> 00:55:54,100
But how can I do that?
但是我该怎么做呢？

919
00:55:54,340 --> 00:55:55,190
Because I am sleeping,
因为我正在睡觉，

920
00:55:59,700 --> 00:56:01,240
modify sleep instruction,
修改睡眠指令，

921
00:56:01,660 --> 00:56:03,060
obviously functional.
显然是功能性的。

922
00:56:03,790 --> 00:56:04,450
That's good.
很好。

923
00:56:06,260 --> 00:56:12,260
But I need to how you modify that's not easy.
但是我需要知道你如何修改，这并不容易。

924
00:56:19,840 --> 00:56:23,730
You can try it, but you'll see that it's not easy,
你可以试试，但你会发现这并不容易。

925
00:56:23,740 --> 00:56:26,050
because you still have a bunch of instruction.
因为你还有一堆指令。

926
00:56:26,060 --> 00:56:30,260
And you'll see the same problem like you have here.
你会遇到和你在这里遇到的相同问题。

927
00:56:32,620 --> 00:56:34,230
Have the kernel do it for now.
暂时让内核来处理。

928
00:56:35,910 --> 00:56:37,860
You can have the kernel do it for now.
你可以让内核现在来做这件事。

929
00:56:38,270 --> 00:56:39,550
But how do you do it?
但是你是如何做到的呢？

930
00:56:40,600 --> 00:56:43,360
You do it on whenever you lose your sleep.
无论何时你失眠，你都可以这样做。

931
00:56:48,740 --> 00:56:49,460
That's not good,
这不好，

932
00:56:50,570 --> 00:56:50,940
right?
对的吗？

933
00:56:52,170 --> 00:56:58,000
Because you can call a sleep for many other cases.
因为你可以在许多其他情况下调用睡眠函数。

934
00:57:02,890 --> 00:57:04,910
So actually the solution is quite brilliant.
实际上，这个解决方案非常出色。

935
00:57:05,660 --> 00:57:06,730
In my opinion,
在我看来，

936
00:57:13,460 --> 00:57:22,690
if the threat which go to sleep cannot enable the interrupts,
如果进入睡眠状态的线程无法启用中断，

937
00:57:26,510 --> 00:57:28,390
the solution is that another thread,
解决方案是创建另一个线程，

938
00:57:30,010 --> 00:57:32,290
which wakes up is going to enable the interests.
哪个唤醒将会启用这些兴趣。

939
00:57:35,360 --> 00:57:37,060
So you do it on contact switching.
所以你是在谈论上下文切换。

940
00:57:38,580 --> 00:57:41,090
In some sense, you can argue this is done by the kernel.
在某种意义上，你可以说这是由内核完成的。

941
00:57:41,480 --> 00:57:42,710
You can do that in the kernel.
你可以在内核中完成这个任务。

942
00:57:44,230 --> 00:57:47,200
But this is a solution here.
但是这里有一个解决方案。

943
00:57:47,900 --> 00:57:48,320
Right?
对吗？

944
00:57:52,100 --> 00:57:54,410
The nice thing about the solution is, again, is like,
解决方案的好处是，再次强调，就像是，

945
00:57:55,690 --> 00:57:59,770
if the thread which goes to sleep cannot enable the interrupt because
如果进入睡眠状态的线程无法启用中断，因为

946
00:57:59,780 --> 00:58:00,810
already went to sleep,
已经去睡觉了。

947
00:58:00,820 --> 00:58:05,800
the solution is for the next thread,
解决方案适用于下一个线程。

948
00:58:06,910 --> 00:58:11,020
which when you return from the sleep to enable the interrupts.
当你从睡眠状态返回时，启用中断。

949
00:58:12,510 --> 00:58:12,850
Right?
对吗？

950
00:58:13,450 --> 00:58:19,390
You have another strategy able to interrupt.
你还有另一种能够中断的策略。

951
00:58:19,400 --> 00:58:22,340
So this is pretty nice.
这真的很不错。

952
00:58:22,350 --> 00:58:23,580
So when you wake up,
当你醒来的时候，

953
00:58:26,720 --> 00:58:35,610
you enable interrupts some announcements,
你启用了中断通知。

954
00:58:36,220 --> 00:58:37,470
design, review schedule,
设计，审查时间表，

955
00:58:37,600 --> 00:58:40,030
as soon as possible you haven't done already.
尽快完成你还没有完成的任务。

956
00:58:41,330 --> 00:58:44,690
The review is your da needs to be done by this thursday,
这个评论需要在本周四之前完成。

957
00:58:44,700 --> 00:58:49,550
so you have 2 days and show up on time listed.
所以你有两天时间，并按时出席。

958
00:58:49,560 --> 00:58:51,270
There is no vertical time we have.
我们没有垂直的时间。

959
00:58:52,870 --> 00:58:56,090
Now 10 minutes after meter,
现在距离计时器开始已经过去了10分钟。

960
00:58:56,100 --> 00:59:00,180
it will be between 7:00 and 9:00 pm 8 days from now.
从现在起8天后，时间将在晚上7点到9点之间。

961
00:59:01,490 --> 00:59:03,990
We is going to cover everything up,
我们打算把一切都掩盖起来，

962
00:59:04,730 --> 00:59:05,090
two.
两个。

963
00:59:05,550 --> 00:59:07,200
And including the next lecture,
包括下一堂课在内，

964
00:59:07,210 --> 00:59:11,860
there will be a midterm review of monday,
周一将进行期中复习。

965
00:59:13,230 --> 00:59:14,290
37and 9.
37和9。

966
00:59:15,190 --> 00:59:21,040
And for logistics on profiting policies and so forth, shit.
关于利润政策和物流等方面的事务，该死的。

967
00:59:22,010 --> 00:59:24,200
Look out for the boss.
小心老板。

968
00:59:40,150 --> 00:59:44,180
Let me see, sorry, it's 29.
让我看看，抱歉，是29。

969
00:59:44,420 --> 00:59:45,300
What i'm saying?
我在说什么？

970
00:59:47,470 --> 00:59:48,870
Wednesday 9:29,
星期三 9:29

971
00:59:48,880 --> 00:59:50,910
thanks for catching.
谢谢你的指正。

972
00:59:52,140 --> 00:59:55,580
So question here was how do you can contact switch?
这里的问题是如何联系交换机？

973
00:59:56,680 --> 00:59:59,690
Because here,
因为在这里，

974
01:00:00,450 --> 01:00:03,050
everything disabled that the interrupts are disabled.
所有被禁用的东西都是中断被禁用的。

975
01:00:03,330 --> 01:00:08,330
So here we are not talking about contact switching based on the timer event.
这里我们不讨论基于定时器事件的上下文切换。

976
01:00:08,340 --> 01:00:09,730
We are talking about here.
我们正在讨论这个问题。

977
01:00:09,740 --> 01:00:10,650
This is here.
这在这里。

978
01:00:10,660 --> 01:00:12,090
Let me just see all the code.
让我看一下所有的代码。

979
01:00:16,380 --> 01:00:17,330
This is a code.
这是一段代码。

980
01:00:19,070 --> 01:00:24,750
You see this part where if anyone on the waiting queue,
你看到这部分，如果等待队列上有任何人，

981
01:00:24,760 --> 01:00:26,390
so when you do this,
这样做的时候，

982
01:00:27,220 --> 01:00:33,330
you go to sleep by the go to sleep means you yield the control to the kernel.
通过"去睡觉"的方式，你将控制权交给了内核。

983
01:00:37,500 --> 01:00:38,690
And the kernel,
而内核，

984
01:00:41,510 --> 01:00:42,150
the interrupts,
中断

985
01:00:43,240 --> 01:00:48,210
you are going to execute this instruction
你将要执行这条指令。

986
01:00:51,830 --> 01:00:53,870
and take the thread of the wake queue.
并获取唤醒队列中的线程。

987
01:00:53,880 --> 01:00:54,990
And when you do this,
当你这样做的时候，

988
01:00:55,000 --> 01:00:57,240
you enable the interrupts again.
你重新启用了中断。

989
01:00:58,550 --> 01:01:00,270
So this enable interrupts from here.
所以从这里开始启用中断。

990
01:01:00,280 --> 01:01:06,120
I hope that you are seeing what i'm highlighting is going to have.
我希望你能看到我所强调的东西的重要性。

991
01:01:06,970 --> 01:01:08,660
It's going to happen here.
这将会在这里发生。

992
01:01:09,400 --> 01:01:13,000
You take the thread of the wake you and you are going to you return
你跟随尾迹，然后你将返回原处。

993
01:01:13,010 --> 01:01:17,170
from the this means you return from the sleep,
从这句话可以理解为你从睡眠中醒来了。

994
01:01:18,190 --> 01:01:21,380
and you are going to enable the interrupts just before place on the ready.
在将进程放入就绪队列之前，你需要启用中断。

995
01:01:30,020 --> 01:01:31,380
Hopefully it answers the question.
希望这能回答你的问题。

996
01:01:34,000 --> 01:01:39,890
So let's see how here and we have another 20 minutes.
那么让我们看看现在的情况，我们还有20分钟。

997
01:01:39,900 --> 01:01:43,540
So here this give you a sense about how this is working,
这里给你一个关于它是如何工作的概念。

998
01:01:44,110 --> 01:01:45,970
doing a kind of assimilation.
进行一种同化。

999
01:01:49,290 --> 01:01:51,100
So here is local choir.
这是一个本地合唱团。

1000
01:01:51,110 --> 01:01:52,260
We have a release.
我们有一个发布版本。

1001
01:01:52,960 --> 01:01:53,870
This is a code.
这是一段代码。

1002
01:01:54,630 --> 01:01:57,940
We have two strides executing the code saturday and said each of them
我们有两个步骤执行代码，一个是星期六，另一个是说出每一个步骤。

1003
01:01:57,950 --> 01:01:58,940
is doing local choir,
正在参加本地合唱团。

1004
01:01:58,950 --> 01:02:00,980
go to the critical section, local release.
进入临界区，局部释放。

1005
01:02:01,680 --> 01:02:05,540
Let's say, said they acquire it is able the instruction,
假设他们获得了能够执行该指令的能力。

1006
01:02:06,310 --> 01:02:07,930
it is able to interrupt, sorry,
它可以中断，抱歉，

1007
01:02:09,130 --> 01:02:10,090
the value.
这个值。

1008
01:02:14,240 --> 01:02:16,940
So in this particular case,
在这种特殊情况下，

1009
01:02:20,540 --> 01:02:26,470
someone doesn't anyone has a critical sector?
有人没有任何关键部门吗？

1010
01:02:27,200 --> 01:02:28,470
This is the first thread,
这是第一个线程。

1011
01:02:28,480 --> 01:02:31,160
a we look executive choir.
我们看起来像一个执行合唱团。

1012
01:02:31,970 --> 01:02:34,570
There is no one using the critical section.
当前没有任何人在使用临界区。

1013
01:02:34,700 --> 01:02:35,530
The value is zero.
这个值是零。

1014
01:02:36,170 --> 01:02:37,410
Increment, the value to one,
将值增加一。

1015
01:02:37,420 --> 01:02:39,440
which means that it acquires a lock,
这意味着它获取了一个锁，

1016
01:02:40,580 --> 01:02:42,050
and it enables the interrupts.
它使中断可用。

1017
01:02:42,060 --> 01:02:47,310
And now you are in critical section.
现在你进入了临界区。

1018
01:02:48,000 --> 01:02:48,390
Right?
对吗？

1019
01:02:49,530 --> 01:02:50,710
This is what happened, right?
这就是发生的事情，对吗？

1020
01:02:52,040 --> 01:02:53,260
At the same time,
同时，

1021
01:02:56,200 --> 01:02:59,630
let's assume that while you are in the critical section, thread,
假设当你在临界区时，线程，

1022
01:02:59,640 --> 01:03:00,990
b is starting to be executed.
b 开始执行。

1023
01:03:01,960 --> 01:03:04,470
Again, while you are in a critical executive section,
再次强调，在你处于关键的执行部分时，

1024
01:03:05,720 --> 01:03:06,950
the interrupts are enabled.
中断已启用。

1025
01:03:13,120 --> 01:03:20,040
Thread b is going to start running saturday in the same in the meantime,
b线程将在周六开始运行，与此同时，

1026
01:03:20,050 --> 01:03:21,000
it seems a ridicule.
这似乎是个荒谬的事情。

1027
01:03:21,010 --> 01:03:22,840
This is just contact switching,
这只是联系切换。

1028
01:03:22,850 --> 01:03:24,040
traditional contact switching.
传统的联系切换。

1029
01:03:25,580 --> 01:03:26,860
You do the local choir,
你参加当地的合唱团，

1030
01:03:27,730 --> 01:03:28,880
execute local choir.
执行本地合唱团。

1031
01:03:30,280 --> 01:03:33,310
But now you look, and what you can see is a value each one,
但是现在你看到的是每个值。

1032
01:03:33,320 --> 01:03:36,830
because the lock is acquired by thread a you cannot acquire the lock.
由于锁已被线程A获取，你无法获取该锁。

1033
01:03:37,930 --> 01:03:39,690
A beard cannot acquire the lock as well.
胡须也无法获得锁。

1034
01:03:39,700 --> 01:03:41,580
So you go to sleep.
那么你去睡觉了。

1035
01:03:43,490 --> 01:03:43,760
Right?
对吗？

1036
01:03:43,930 --> 01:03:45,920
You are going thread is going to be waiting,
你的线程将会进入等待状态。

1037
01:03:45,930 --> 01:03:47,200
it's going to be on the wake you.
这将会在你醒来时发生。

1038
01:03:49,080 --> 01:03:49,520
Okay?
好的？

1039
01:03:52,620 --> 01:03:59,620
And now you are going to start executing thread a because it's ready to execute.
现在你要开始执行线程a，因为它已经准备好执行了。

1040
01:03:59,630 --> 01:04:04,770
And this thread b went to sleep and thread b 111 is going to sleep,
线程 b 正在休眠，线程 b 111 也即将休眠。

1041
01:04:05,050 --> 01:04:11,030
is going to voluntarily release the cpo
将自愿发布CPO

1042
01:04:15,660 --> 01:04:19,870
the kernel is going to start executing saturday,
内核将在星期六开始执行。

1043
01:04:19,880 --> 01:04:25,770
resuming the exhibition of saturday in the critical section ends,
在临界区结束后恢复周六的展览。

1044
01:04:26,820 --> 01:04:29,770
and then is releasing the lock.
然后释放锁定。

1045
01:04:33,260 --> 01:04:36,320
And now, if anyone waste on the waiting queue,
现在，如果有人在等待队列上浪费时间，

1046
01:04:36,330 --> 01:04:38,490
is anyone waiting on the waiting queue?
有人在等待队列上等吗？

1047
01:04:38,810 --> 01:04:41,480
It's thread b right?
是 b 线程吗？

1048
01:04:43,930 --> 01:04:47,520
Thread b is placed on the ridicule from the waiting queue on the ridicule.
线程 b 被从等待队列中取下并放置在运行队列上。

1049
01:04:48,920 --> 01:04:50,650
And now you enable the interrupts.
现在你可以启用中断。

1050
01:04:51,490 --> 01:04:52,260
You are done.
你完成了。

1051
01:04:52,670 --> 01:04:54,570
Thread b is ready to execute.
线程 b 已准备好执行。

1052
01:04:56,380 --> 01:04:57,290
And then,
然后，

1053
01:04:58,930 --> 01:05:02,870
next time you are going to execute thread,
下一次你要执行线程时，

1054
01:05:06,920 --> 01:05:15,400
instead be executes acquire the locks and continue and enter the critical session.
相反，它会执行获取锁并继续进入临界区。

1055
01:05:21,980 --> 01:05:26,650
So please go and try to go carefully through this example.
请仔细阅读并尝试理解这个例子。

1056
01:05:28,050 --> 01:05:28,880
Any questions?
有任何问题吗？

1057
01:05:47,440 --> 01:05:48,520
So what is the problem?
那么问题是什么？

1058
01:05:48,530 --> 01:05:49,800
So it is working.
所以它正在工作。

1059
01:05:50,420 --> 01:05:51,340
Yes, he's working.
是的，他正在工作。

1060
01:05:53,120 --> 01:05:54,670
But there are several issues.
但是有几个问题。

1061
01:05:55,000 --> 01:05:57,310
You cannot give lock implementation to users.
你不能将锁的实现提供给用户。

1062
01:05:57,360 --> 01:05:58,870
They are going to make mistakes.
他们会犯错。

1063
01:06:00,320 --> 01:06:01,040
Now,
现在，

1064
01:06:02,220 --> 01:06:04,530
you can solve that by saying, operate,
你可以通过说"操作"来解决这个问题。

1065
01:06:04,540 --> 01:06:05,610
the kernel can do it.
内核可以做到这一点。

1066
01:06:06,710 --> 01:06:08,730
And that's a very valid answer.
这是一个非常合理的答案。

1067
01:06:09,440 --> 01:06:10,560
But the other problem,
但是另一个问题是，

1068
01:06:10,570 --> 01:06:11,960
especially with the interrupts,
尤其是在处理中断方面，

1069
01:06:12,670 --> 01:06:15,830
is that it doesn't work well on multiprocessors.
这是因为它在多处理器上运行效果不好。

1070
01:06:17,430 --> 01:06:19,910
You have multiple cars which execute in parallel.
你有多辆车同时执行。

1071
01:06:20,850 --> 01:06:24,570
And all cars can access a memory.
所有的汽车都可以访问内存。

1072
01:06:25,030 --> 01:06:26,460
Therefore, the value of the lock.
因此，锁的价值。

1073
01:06:29,150 --> 01:06:32,900
When you need to disable interrupts on all the course,
当你需要在整个过程中禁用中断时，

1074
01:06:32,910 --> 01:06:34,740
you need to send messages between course,
你需要在课程之间发送消息。

1075
01:06:35,390 --> 01:06:35,950
to do it,
要做到这一点，

1076
01:06:37,920 --> 01:06:41,170
to disable interrupts or enable interrupts which is very expensive.
禁用中断或启用中断都是非常昂贵的操作。

1077
01:06:42,940 --> 01:06:45,780
The alternative to this is to have atomic instructions,
这个的替代方案是使用原子指令，

1078
01:06:47,910 --> 01:06:48,190
right?
对的吗？

1079
01:06:49,200 --> 01:06:51,170
And typically what they do,
通常他们会做什么，

1080
01:06:51,510 --> 01:06:54,610
they read a value and write a value atomically.
它们原子地读取一个值并写入一个值。

1081
01:06:55,090 --> 01:06:55,510
So instead,
因此，

1082
01:06:55,520 --> 01:07:00,120
loading stores only is reading a value is atomic and writing a value is atomic.
仅加载存储是原子操作，读取值是原子操作，写入值也是原子操作。

1083
01:07:01,230 --> 01:07:03,030
But this adds another element.
但这增加了另一个因素。

1084
01:07:03,740 --> 01:07:05,620
The read you can have a read and write,
你可以进行读取和写入操作。

1085
01:07:06,340 --> 01:07:10,260
which is our atomic like one operation.
我们的原子操作是哪一个？

1086
01:07:11,180 --> 01:07:12,280
These are great.
这些很棒。

1087
01:07:12,290 --> 01:07:15,990
They are working both only processor and multiprocessors.
他们既在处理器上工作，也在多处理器上工作。

1088
01:07:17,230 --> 01:07:23,840
And they are quite simple.
它们非常简单。

1089
01:07:24,530 --> 01:07:25,710
And here are a few of them.
这里有一些例子。

1090
01:07:26,600 --> 01:07:28,200
The first one is test and set.
第一个是测试并设置。

1091
01:07:29,360 --> 01:07:29,880
Okay?
好的？

1092
01:07:30,470 --> 01:07:32,320
What is doing best and set?
"doing best" 和 "set" 是两个不同的概念。

"doing best" 意味着尽力做到最好，努力达到最佳状态或表现。这个短语通常用于鼓励或提醒某人要尽力做到最好。

"set" 在不同的上下文中有不同的意思。作为动词，它可以表示放置、安排或设置。作为名词，它可以表示一组事物或一套规则或指导原则。

请提供更多上下文，以便我可以更准确地回答你的问题。

1093
01:07:32,850 --> 01:07:35,500
Read a value of a particular memory,
读取特定内存的值

1094
01:07:36,000 --> 01:07:38,040
a a particular,
一个特定的，

1095
01:07:38,690 --> 01:07:43,750
the value at a particular address and returns it,
获取特定地址上的值并返回它，

1096
01:07:45,170 --> 01:07:47,890
and also at the same time set it to one.
同时将其设置为1。

1097
01:07:49,780 --> 01:07:51,210
So reading the value,
所以读取这个值，

1098
01:07:51,870 --> 01:07:53,050
setting it to one,
将其设置为1，

1099
01:07:53,550 --> 01:07:58,170
and returning the previous values of value before us at one original value.
并返回我们之前的值在一个原始值之前的值。

1100
01:07:58,540 --> 01:07:59,100
It's atomic.
这是原子操作。

1101
01:08:00,290 --> 01:08:00,960
That's it.
就是这样。

1102
01:08:01,850 --> 01:08:02,930
That's atomic instruction.
这是原子指令。

1103
01:08:03,060 --> 01:08:05,690
You see, there are multiple operations in this, which are atomic,
你看，这里有多个操作，它们是原子操作。

1104
01:08:05,980 --> 01:08:08,500
which are in this atomic instruction.
这个原子指令中包含哪些操作？

1105
01:08:10,190 --> 01:08:11,110
Then it's a swap.
那么这就是一个交换操作。

1106
01:08:12,800 --> 01:08:15,490
And a swap is basically what is doing.
交换（swap）基本上就是在做什么。

1107
01:08:16,780 --> 01:08:17,200
Right?
对吗？

1108
01:08:18,750 --> 01:08:19,820
You get a value.
你得到了一个值。

1109
01:08:21,840 --> 01:08:22,350
You sorry,
对不起，

1110
01:08:26,030 --> 01:08:27,760
you put a value in a register.
你将一个值放入寄存器中。

1111
01:08:29,720 --> 01:08:36,870
That value put in the register is going to be swapped with the value
寄存器中的值将与该值进行交换。

1112
01:08:38,020 --> 01:08:39,180
at a particular address.
在特定的地址上。

1113
01:08:43,120 --> 01:08:43,840
This is what it is.
这就是它的样子。

1114
01:08:44,560 --> 01:08:48,190
So you shall give a value in a register,
所以你需要在一个寄存器中存储一个值，

1115
01:08:48,200 --> 01:08:52,310
which is going to be swapped with a value at a particular address.
将要与特定地址上的值进行交换的值是什么。

1116
01:08:53,230 --> 01:08:54,920
Finally, it's compare and swap.
最后，这是比较并交换操作。

1117
01:08:55,250 --> 01:08:56,560
It's a little bit more complicated.
这有点复杂。

1118
01:08:56,570 --> 01:08:59,500
You give two registers here.
这里给出了两个寄存器。

1119
01:09:00,160 --> 01:09:03,680
It was a memory address is still equally registered,
这是一个仍然被等注册的内存地址。

1120
01:09:04,530 --> 01:09:06,760
is still equal with register one.
仍然等于寄存器一。

1121
01:09:07,170 --> 01:09:10,340
Then you put the memory value and register to.
然后你将内存值和寄存器放入其中。

1122
01:09:10,350 --> 01:09:12,260
Otherwise, you don't change the memory.
否则，你不会改变内存。

1123
01:09:15,860 --> 01:09:18,310
These are exactly six.
这正好是六个。

1124
01:09:18,320 --> 01:09:19,540
Obviously, it's intel.
显然，这是英特尔。

1125
01:09:19,920 --> 01:09:22,420
6,800 was a very popular chip,
6,800是一款非常受欢迎的芯片。

1126
01:09:22,930 --> 01:09:28,380
motorola chip, which was the cheap for used by apple, early apple,
摩托罗拉芯片是早期苹果公司使用的廉价芯片。

1127
01:09:28,390 --> 01:09:29,420
and macintosh.
和Macintosh。

1128
01:09:29,990 --> 01:09:30,760
Computers.
计算机。

1129
01:09:31,520 --> 01:09:34,310
Testing said it's actually in most architectures today.
测试表明，实际上在大多数现代架构中都存在这个问题。

1130
01:09:37,260 --> 01:09:40,970
Here is an example about how to use,
这是一个关于如何使用的示例。

1131
01:09:41,500 --> 01:09:42,460
compare and swap.
比较并交换。

1132
01:09:46,140 --> 01:09:51,750
And this is about how you are going to use to insert atomically.
这是关于你将如何使用原子插入的内容。

1133
01:09:53,180 --> 01:09:55,920
A new element is ahead of a queue.
一个新元素在队列的前面。

1134
01:09:56,950 --> 01:09:58,300
This is what you want to do it.
这就是你想要做的。

1135
01:09:58,980 --> 01:10:00,050
This is n cube operation.
这是一个 n 立方体操作。

1136
01:10:00,330 --> 01:10:00,590
Insert.
插入。

1137
01:10:00,600 --> 01:10:02,750
A new element is ahead of the queue.
队列中有一个新的元素在前面。

1138
01:10:06,690 --> 01:10:07,640
Here, how do you do it?
这里，你怎么做呢？

1139
01:10:09,000 --> 01:10:10,680
First of all, you have a while.
首先，你有一段时间。

1140
01:10:11,060 --> 01:10:12,350
Do you see do until?
你是否看到了 do until 循环？

1141
01:10:13,740 --> 01:10:13,980
Right?
对吗？

1142
01:10:13,990 --> 01:10:14,660
It's a loop.
这是一个循环。

1143
01:10:17,560 --> 01:10:21,110
And in the low in the condition breaks it from this slope.
而在低处，它会从这个斜坡上断裂。

1144
01:10:21,680 --> 01:10:25,290
You can tell and stop at one and object.
你可以告诉并停在一个对象上。

1145
01:10:26,420 --> 01:10:26,790
Right?
对吗？

1146
01:10:27,240 --> 01:10:29,510
Object is the object identifier,
Object是对象的标识符，

1147
01:10:29,520 --> 01:10:30,530
r one.
抱歉，我不明白您的意思。您能提供更多的上下文或信息吗？

1148
01:10:31,410 --> 01:10:34,560
You can see is a route address.
你可以看到的是一个路由地址。

1149
01:10:36,560 --> 01:10:36,910
Okay?
好的？

1150
01:10:40,120 --> 01:10:41,230
It's your original route.
这是你的原始路径。

1151
01:10:42,050 --> 01:10:42,280
Right?
对吗？

1152
01:10:42,290 --> 01:10:45,440
So what happens here is basically,
这里发生的基本上是，

1153
01:10:46,310 --> 01:10:52,450
you are going to wait until what you do here.
你要等到你在这里做什么。

1154
01:10:52,460 --> 01:10:58,490
You set the route to the new object.
你设置了新对象的路由。

1155
01:11:01,620 --> 01:11:02,110
Okay?
好的？

1156
01:11:07,630 --> 01:11:13,260
And then you are waiting until the route is pointing.
然后你等待直到路由指向正确的位置。

1157
01:11:14,190 --> 01:11:14,680
Sorry.
抱歉。

1158
01:11:15,020 --> 01:11:16,360
What you do is the following thing.
你要做的是以下的事情。

1159
01:11:17,150 --> 01:11:25,000
You set the next the object to point to the first element in the queue.
你将下一个对象设置为指向队列中的第一个元素。

1160
01:11:25,680 --> 01:11:26,170
This one.
这个。

1161
01:11:28,710 --> 01:11:29,530
This is what you do.
这是你要做的事情。

1162
01:11:31,370 --> 01:11:31,790
Right?
对吗？

1163
01:11:32,090 --> 01:11:35,690
This is you get the pointer from the root,
这是你从根节点获取指针的方式，

1164
01:11:35,700 --> 01:11:38,130
which is the point of the first element in the queue.
队列中第一个元素的位置是什么？

1165
01:11:38,910 --> 01:11:42,430
Then you set the next,
然后你设置下一个，

1166
01:11:45,320 --> 01:11:51,170
the new object to point to the old first object in the queue.
将新对象指向队列中的旧第一个对象。

1167
01:11:52,000 --> 01:11:57,800
Then you are going to use a compare and swap to move the pointer
然后你将使用比较和交换（compare and swap）来移动指针。

1168
01:11:57,810 --> 01:11:59,440
of the route to the new object.
到达新对象的路径。

1169
01:12:00,030 --> 01:12:01,260
You wait until that is done.
你等待直到完成。

1170
01:12:05,350 --> 01:12:06,560
So that's what happens here.
所以这就是在这里发生的事情。

1171
01:12:09,900 --> 01:12:12,540
Now, how we implement lock switch test and test.
现在，我们来实现锁开关测试和测试。

1172
01:12:13,400 --> 01:12:17,290
Test and set is very easy acquire.
测试并设置非常容易获取。

1173
01:12:19,080 --> 01:12:21,390
You will set up the value to zero here.
你需要在这里将值设为零。

1174
01:12:23,080 --> 01:12:24,390
Acquire it's,
获取它的

1175
01:12:24,760 --> 01:12:31,130
you just wait for test and set to be one,
你只需要等待测试并设置为1。

1176
01:12:33,850 --> 01:12:37,770
then release you just set value to zero.
释放资源时，只需将值设置为零即可。

1177
01:12:38,990 --> 01:12:39,940
What happens here?
这里发生了什么？

1178
01:12:40,280 --> 01:12:43,100
Remember, what does test and set is doing?
记住，test and set 是做什么的？

1179
01:12:43,970 --> 01:12:51,310
The test and set is going to read to return the
测试并设置操作将读取并返回结果。

1180
01:12:51,320 --> 01:12:56,980
value and set it to one in one instruction.
在一条指令中将值设置为1。

1181
01:12:59,230 --> 01:13:00,360
If the value is zero,
如果值为零，

1182
01:13:01,070 --> 01:13:07,680
you return as a value to while while is going to exit and set value to one.
在 while 循环即将退出时，你将一个值作为返回值返回，并将该值设置为 1。

1183
01:13:08,840 --> 01:13:09,390
It's great.
太棒了。

1184
01:13:09,680 --> 01:13:11,350
Lock is not busy acquired as a lock.
锁未被占用时才能获得锁。

1185
01:13:12,610 --> 01:13:13,990
If the lock is busy,
如果锁被占用，

1186
01:13:14,000 --> 01:13:15,630
so value will be one.
所以值将为1。

1187
01:13:17,170 --> 01:13:19,170
You are going to set the value to one.
你要将值设置为1。

1188
01:13:19,180 --> 01:13:19,970
It's already one.
已经是一个了。

1189
01:13:20,100 --> 01:13:21,970
Nothing will happen, but you return one.
什么都不会发生，但你会返回一个值。

1190
01:13:22,850 --> 01:13:26,480
You are going to be stuck in the while loop until the release
你将会被困在 while 循环中，直到释放。

1191
01:13:26,490 --> 01:13:32,170
is going to be executed and the value set to zero.
将要被执行，并将值设置为零。

1192
01:13:32,820 --> 01:13:33,730
It's quite elegant.
这非常优雅。

1193
01:13:38,060 --> 01:13:38,500
Obviously,
显然，

1194
01:13:38,510 --> 01:13:42,020
the problem here you have the while you do the while in the program.
问题在于你在程序中使用了 while 循环，而你在这里又有一个 while 循环。

1195
01:13:42,640 --> 01:13:42,890
Right?
对吗？

1196
01:13:42,900 --> 01:13:43,890
So very inefficient.
非常低效。

1197
01:13:47,170 --> 01:13:47,540
Right?
对吗？

1198
01:13:49,640 --> 01:13:50,590
You don't want to do that.
你不想这样做。

1199
01:13:51,370 --> 01:13:53,120
But this is a correct implementation,
但这是一个正确的实现。

1200
01:13:53,130 --> 01:13:54,480
very simple implementation.
非常简单的实现。

1201
01:13:54,490 --> 01:14:00,180
So you see our test and set allows us a very simple implementation of a lot.
所以你可以看到我们的测试和设置操作允许我们实现很多东西的简单实现。

1202
01:14:01,390 --> 01:14:01,680
Right?
对吗？

1203
01:14:02,080 --> 01:14:04,750
And again, the testing set very easy to remember.
而且，测试集非常容易记住。

1204
01:14:05,340 --> 01:14:06,380
You do two things,
你要做两件事情，

1205
01:14:06,870 --> 01:14:09,090
return the value and set this one.
返回该值并设置为新值。

1206
01:14:09,710 --> 01:14:10,070
That's all
好的，没问题。

1207
01:14:19,390 --> 01:14:20,870
the problem is busy waiting,
问题是忙等待。

1208
01:14:22,080 --> 01:14:22,670
busy waiting.
忙等待。

1209
01:14:22,680 --> 01:14:24,350
Again, it's a correct implementation.
再次强调，这是一个正确的实现。

1210
01:14:24,360 --> 01:14:26,590
The machine can still receive, interrupts.
这台机器仍然可以接收中断。

1211
01:14:28,260 --> 01:14:31,980
The user code can still use a lock work on multiprocessor,
用户代码仍然可以在多处理器上使用锁。

1212
01:14:32,500 --> 01:14:36,930
all positives, but you don't want this busy week.
都是积极的，但你不想要这个忙碌的一周。

1213
01:14:38,820 --> 01:14:39,760
It's inefficient.
这是低效的。

1214
01:14:40,090 --> 01:14:42,700
Also can result in what we call priority inversion.
还会导致我们所称的优先级反转。

1215
01:14:43,410 --> 01:14:43,800
Right?
对吗？

1216
01:14:44,260 --> 01:14:47,360
If the busy waiting thread has a higher priority than the thread holding
如果忙等待线程的优先级高于持有资源的线程

1217
01:14:47,370 --> 01:14:47,880
the lock,
锁

1218
01:14:49,470 --> 01:14:49,930
right?
对的？

1219
01:14:50,320 --> 01:14:53,210
This is a another way to think about it.
这是另一种思考方式。

1220
01:14:57,780 --> 01:14:58,090
Oops.
哎呀。

1221
01:15:00,400 --> 01:15:03,700
Another way to think about it is like you have two threads,
另一种思考方式是将其视为有两个线程，

1222
01:15:04,260 --> 01:15:05,310
one has higher priorities,
一个具有更高优先级的任务

1223
01:15:05,320 --> 01:15:08,550
and the other one higher priority is going to be always executed
另一个具有更高优先级的任务将始终被执行。

1224
01:15:08,560 --> 01:15:09,360
before the other.
在其他之前。

1225
01:15:09,840 --> 01:15:11,640
The one is a low priority.
这个是低优先级的。

1226
01:15:12,250 --> 01:15:18,920
Now, the thread is a low priority is going to have the lock.
现在，这个线程是一个低优先级的线程，将要获取锁。

1227
01:15:19,800 --> 01:15:21,820
If the third is a lower priority has a lock,
如果第三个任务的优先级较低且有一个锁，

1228
01:15:22,550 --> 01:15:25,500
the third is a higher priority will be stuck because it's going to be stuck
第三个任务优先级较高，将会被阻塞，因为它将会被卡住。

1229
01:15:25,830 --> 01:15:27,570
in the while loop.
在 while 循环中。

1230
01:15:28,120 --> 01:15:30,030
The thread is allowed priority cannot execute,
该线程被允许优先级，但无法执行。

1231
01:15:30,400 --> 01:15:32,090
because the surveys are our higher priority,
因为调查是我们的首要任务，

1232
01:15:32,100 --> 01:15:34,890
but because the thread is a lower priority cannot execute.
但是由于线程的优先级较低，无法执行。

1233
01:15:35,150 --> 01:15:37,840
It cannot exit the critical section.
它无法退出临界区。

1234
01:15:37,850 --> 01:15:38,880
It cannot release a lock.
它无法释放锁定。

1235
01:15:41,350 --> 01:15:42,500
This is priority inversion.
这是优先级反转。

1236
01:15:44,160 --> 01:15:45,980
And this happened in many cases.
而且这种情况发生在许多案例中。

1237
01:15:50,900 --> 01:15:53,890
So that's the problem, right?
那就是问题所在，对吗？

1238
01:15:54,610 --> 01:16:02,130
And so we really want because we don't want us as
所以我们真的想要，因为我们不希望我们作为

1239
01:16:02,410 --> 01:16:06,260
to this busy waiting,
对于这种忙等待的情况，

1240
01:16:07,090 --> 01:16:11,250
we need to find another solution.
我们需要找到另一个解决方案。

1241
01:16:12,260 --> 01:16:13,270
And in general,
总的来说，

1242
01:16:13,780 --> 01:16:17,370
when you have the homework problem or exams solution,
当你有作业问题或考试解答时，

1243
01:16:17,380 --> 01:16:19,530
unless as always specified,
除非另有明确规定，

1244
01:16:21,030 --> 01:16:22,320
you should avoid busy waiting.
你应该避免忙等待。

1245
01:16:24,320 --> 01:16:24,750
Okay?
好的？

1246
01:16:27,410 --> 01:16:29,720
Now let's see for the next couple of minutes,
现在让我们来看接下来的几分钟，

1247
01:16:29,730 --> 01:16:32,960
think about maybe better logs using test and set.
考虑使用测试和设置（test and set）来改进日志记录。

1248
01:16:33,950 --> 01:16:40,670
The question cannot use the sunset to implement locks without busy waiting.
该问题不能使用忙等待来实现锁，而不使用自旋。

1249
01:16:43,790 --> 01:16:45,210
And this answer here,
这里的答案是，

1250
01:16:45,720 --> 01:16:51,390
we cannot, but we can minimize a busy waiting section.
我们无法完全避免，但可以尽量减少繁忙等待的部分。

1251
01:16:53,990 --> 01:16:56,660
And again, the solution here is like with,
这里的解决方案与之前类似，

1252
01:16:58,170 --> 01:17:00,360
if you remember, with interrupts,
如果你还记得，使用中断，

1253
01:17:02,810 --> 01:17:05,110
we use a lock to implement a lock.
我们使用锁来实现锁。

1254
01:17:05,790 --> 01:17:06,530
In some sense,
从某种意义上说，

1255
01:17:07,850 --> 01:17:12,040
the local and implement is is called value.
本地变量和实现被称为值。

1256
01:17:14,140 --> 01:17:15,570
And then what we do,
然后我们要做什么？

1257
01:17:17,000 --> 01:17:23,810
we protect the critical section of the acquire
我们保护获取操作的临界区域。

1258
01:17:25,050 --> 01:17:28,350
and release the critical section being the one,
并释放临界区，其中之一，

1259
01:17:28,360 --> 01:17:29,710
which modifies the lock,
哪个修改了锁定状态，

1260
01:17:30,390 --> 01:17:33,290
which is value by a test and set.
这是通过测试和设置操作来确定的值。

1261
01:17:36,450 --> 01:17:40,540
So use a testing set to implement and protect these critical sections
使用测试集来实现和保护这些关键部分。

1262
01:17:40,550 --> 01:17:41,940
in acquiring release.
在获取释放资源时。

1263
01:17:43,720 --> 01:17:45,070
The solution is very simple.
解决方案非常简单。

1264
01:17:45,080 --> 01:17:48,490
We have define another variable.
我们定义了另一个变量。

1265
01:17:48,500 --> 01:17:49,690
It is called guard.
它被称为"守卫"。

1266
01:17:50,440 --> 01:17:56,570
This ensures a mature mutual exclusion for these critical sections,
这确保了对这些关键部分的成熟互斥。

1267
01:17:57,130 --> 01:17:58,640
which are in the acquire and release.
这些是在获取和释放中使用的。

1268
01:17:59,500 --> 01:17:59,840
Okay?
好的？

1269
01:18:02,150 --> 01:18:03,600
While we initialize to zero,
我们在初始化时将其设为零，

1270
01:18:04,210 --> 01:18:05,190
while god,
当上帝，

1271
01:18:06,810 --> 01:18:08,750
if god is zero,
如果上帝是零，

1272
01:18:09,920 --> 01:18:14,810
then you are going to acquire the lock.
那么你将要获取锁定。

1273
01:18:16,260 --> 01:18:17,400
So I will exit,
那么我将退出。

1274
01:18:19,250 --> 01:18:19,710
right?
对的？

1275
01:18:20,510 --> 01:18:21,190
Because remember,
因为请记住，

1276
01:18:21,200 --> 01:18:27,400
testing set returns the current value of water that is zero and satisfying.
测试集返回当前水的值，该值为零且满足条件。

1277
01:18:29,010 --> 01:18:30,160
You exit the y loop,
你退出了y循环。

1278
01:18:31,140 --> 01:18:33,360
and then you set up the value.
然后你设置数值。

1279
01:18:33,960 --> 01:18:34,640
But what do you know?
但是你知道什么呢？

1280
01:18:36,480 --> 01:18:40,000
And the release is a sense.
发布是一种感觉。

1281
01:18:40,850 --> 01:18:44,170
Again, you protect the critical section by test and set.
再次，你可以通过测试和设置来保护临界区。

1282
01:18:45,830 --> 01:18:51,450
Here you have the same problem like with the release interrupts.
这里你遇到了和释放中断一样的问题。

1283
01:18:51,830 --> 01:18:55,000
When you go to sleep, you also need to put set a guard to zero,
当你去睡觉时，你还需要将警戒值设置为零。

1284
01:18:55,010 --> 01:18:56,870
then when you need to set up it.
那么当你需要设置它时。

1285
01:18:57,680 --> 01:18:58,080
Right?
对吗？

1286
01:18:59,190 --> 01:19:00,480
But this will be much easier
但这将会更容易

1287
01:19:07,800 --> 01:19:12,280
when sleep has to be sure to resell the guard value.
当使用 sleep 时，务必确保重新设置保护值。

1288
01:19:17,020 --> 01:19:19,890
We are going to end up here this lecture.
我们将在本次讲座结束。

1289
01:19:19,900 --> 01:19:21,150
On this note.
在这个问题上。

1290
01:19:21,160 --> 01:19:22,990
We are going to continue next time.
我们下次继续。

1291
01:19:25,380 --> 01:19:27,570
You should think a little bit about this code.
你应该对这段代码思考一下。

1292
01:19:28,050 --> 01:19:29,570
And there is a question here.
这里有一个问题。

1293
01:19:30,960 --> 01:19:31,800
Why?
为了方便理解和交流，我会将英文翻译成中文。这样可以确保信息的准确传达和理解。

1294
01:19:34,360 --> 01:19:35,270
Let me see.
让我看看。

1295
01:19:44,200 --> 01:19:46,950
I'm going to stop here, because for some reason,
我要停在这里了，因为出于某种原因，

1296
01:19:47,360 --> 01:19:50,750
I lost my pointer, so I cannot see my pointer on the screen.
我丢失了我的指针，所以在屏幕上看不到我的指针。

1297
01:19:52,520 --> 01:19:55,190
So there is a question at the end of the previous slide,
所以在前一张幻灯片的末尾有一个问题。

1298
01:19:55,200 --> 01:20:00,620
please think about it until the next time without looking at the next slide.
请在下次之前仔细考虑一下，不要提前查看下一张幻灯片。

1299
01:20:01,390 --> 01:20:05,890
And that is,
这就是，

1300
01:20:08,690 --> 01:20:10,770
yeah, that there is a question here.
是的，这里有一个问题。

1301
01:20:14,590 --> 01:20:19,870
If while test and so we are the lecture is done.
如果测试期间，我们的讲座已经结束。

1302
01:20:19,880 --> 01:20:22,800
I am going to try to ask the last question,
我将尝试提出最后一个问题，

1303
01:20:23,350 --> 01:20:24,670
which was on the chat.
这是在聊天记录中的内容。

1304
01:20:25,280 --> 01:20:26,430
We'll meet next time.
我们下次见面。

1305
01:20:26,440 --> 01:20:30,410
So for people who want to hear the answer can stick around.
所以对于想听答案的人可以继续等待。

1306
01:20:31,480 --> 01:20:36,700
And the question here is that from Michael is well test and set ball,
这里的问题是来自Michael的测试和设置球。

1307
01:20:37,410 --> 01:20:40,510
you yield critical section.
你放弃了临界区。

1308
01:20:42,780 --> 01:20:44,300
Then while is zero,
当while为零时，

1309
01:20:45,390 --> 01:20:46,940
then you set up all to zero.
然后你将所有设置为零。

1310
01:21:01,890 --> 01:21:02,810
Yeah,
是的，

1311
01:21:11,690 --> 01:21:18,700
I think that should work.
我认为那应该可以运行。

1312
01:21:20,700 --> 01:21:21,510
So,
那么，

1313
01:21:25,250 --> 01:21:25,530
yeah,
是的，没问题。

1314
01:21:27,090 --> 01:21:31,280
if you that should work,
如果你这样做应该可以的。

1315
01:21:32,070 --> 01:21:33,790
the problem here is all that.
问题在于这一切。

1316
01:21:34,120 --> 01:21:35,210
If you yield,
如果你让步，

1317
01:21:38,740 --> 01:21:41,550
then you are still going,
那你还在继续前进，

1318
01:21:41,960 --> 01:21:43,700
you yield the processor.
你让出处理器。

1319
01:21:45,640 --> 01:21:50,400
You are still going to be wake woken up before the lock.
在解锁之前，你仍然会被唤醒。

1320
01:21:50,860 --> 01:21:51,890
It's available.
它是可用的。

1321
01:21:53,350 --> 01:21:54,460
For instance, you again,
例如，你再次，

1322
01:21:54,470 --> 01:21:56,040
it's like you go,
就像你走了一样

1323
01:21:56,770 --> 01:21:58,670
you yield the processor to.
你将处理器让给谁。

1324
01:21:58,680 --> 01:22:00,150
And for another thread,
另外一个线程的话，

1325
01:22:00,360 --> 01:22:01,590
the threat can execute.
威胁可以执行。

1326
01:22:01,600 --> 01:22:02,710
It may not be necessary.
可能并不必要。

1327
01:22:02,720 --> 01:22:05,030
The threat who acquire, who has a lock.
威胁者获得，谁拥有锁。

1328
01:22:05,830 --> 01:22:07,550
When that thread finishes on,
当该线程完成时，

1329
01:22:07,560 --> 01:22:09,150
a time quantity finishes,
一个时间量结束了。

1330
01:22:09,410 --> 01:22:12,440
we are going to be open again and so forth.
我们将再次开放，等等。

1331
01:22:13,910 --> 01:22:15,950
So it's still not as efficient.
所以它仍然不够高效。

1332
01:22:15,960 --> 01:22:19,340
It's better than just doing busy wait,
这比简单的忙等待要好。

1333
01:22:19,970 --> 01:22:24,950
but it's not as good as putting the thread on the wake you and being woken
但这不如将线程放在唤醒你并被唤醒的位置好。

1334
01:22:24,960 --> 01:22:28,420
up only when the lock was released.
只有在锁被释放时才能更新。

1335
01:22:29,520 --> 01:22:32,120
In this case, you are going to be open up multiple times.
在这种情况下，你将会被多次打开。

1336
01:22:35,520 --> 01:22:39,010
So is that i'll see you next time.
那么下次我会见到你。

1337
01:22:40,170 --> 01:22:41,110
Thanks, everyone.
谢谢大家。

