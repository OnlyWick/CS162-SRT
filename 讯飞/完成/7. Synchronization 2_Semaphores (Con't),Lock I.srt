1
00:00:08,920 --> 00:00:09,850
Hello, everyone.
大家好。

2
00:00:10,420 --> 00:00:12,890
Welcome to the seven lectures.
欢迎来到这七堂讲座。

3
00:00:12,900 --> 00:00:17,290
So today we are going to continue our discussion about concurrency.
今天我们将继续讨论并发性。

4
00:00:18,250 --> 00:00:24,220
This will happen also over the next couple of lectures,
这也将在接下来的几堂课中发生。

5
00:00:24,880 --> 00:00:29,210
as well as we are going to discuss about lock implementation,
我们还将讨论锁的实现方式，

6
00:00:29,220 --> 00:00:35,840
which is one of the main primitives helping us or is controlling concurrence.
其中之一是帮助我们控制并发的主要原语。

7
00:00:40,280 --> 00:00:41,650
Remember about, again,
再次提醒一下，

8
00:00:41,660 --> 00:00:42,750
this picture.
这张图片。

9
00:00:43,250 --> 00:00:43,660
Excuse me,
请问有什么可以帮到您的吗？

10
00:00:47,870 --> 00:00:50,420
it's basically we are going to have a program.
基本上，我们将要编写一个程序。

11
00:00:50,430 --> 00:00:56,550
And here what we are trying to do is about it's how this program we
我们现在要做的是关于这个程序的内容。

12
00:00:57,590 --> 00:00:58,860
is going to give,
将要给予，

13
00:01:00,650 --> 00:01:02,210
yield the axis,
让出轴

14
00:01:02,220 --> 00:01:04,610
the cpu to another product.
将CPU转移到另一款产品。

15
00:01:04,620 --> 00:01:04,830
Right?
对吗？

16
00:01:04,840 --> 00:01:06,590
If you remember, this was the old examples.
如果你还记得的话，这是旧的例子。

17
00:01:07,040 --> 00:01:08,900
Each one of the first examples,
第一个例子中的每一个

18
00:01:09,110 --> 00:01:10,420
you have two instructions.
你有两个指令。

19
00:01:10,430 --> 00:01:11,540
The first one,
第一个，

20
00:01:12,250 --> 00:01:15,880
trying to print to compute pie and print pie.
尝试计算圆周率并打印圆周率。

21
00:01:16,380 --> 00:01:20,220
Then the second instruction trying to bring the class list,
然后第二条指令尝试获取班级列表，

22
00:01:20,230 --> 00:01:21,620
if I remember correctly.
如果我记得没错的话。

23
00:01:21,970 --> 00:01:27,340
And the point there is that if you try to print by,
这里的重点是，如果你尝试通过...打印输出，

24
00:01:27,390 --> 00:01:31,380
which means also need to compute all the digits,
这也意味着需要计算所有的数字。

25
00:01:31,630 --> 00:01:32,720
you'll never end,
你永远不会结束，

26
00:01:32,950 --> 00:01:38,220
because spy has an infinite number of decimals, right?
因为π是一个无限小数，对吗？

27
00:01:38,830 --> 00:01:42,780
Then the solution was that while you are computing by,
然后解决方案是，在你进行计算的同时，

28
00:01:42,790 --> 00:01:45,900
you are the one to give from a time to time,
你是那个不时提供帮助的人，

29
00:01:46,350 --> 00:01:51,540
access to the cpu to another process to continue other.
将CPU的访问权限转移到另一个进程以继续其他操作。

30
00:01:51,550 --> 00:01:57,770
Otherwise, the cpu will be only hauled by this computer by program.
否则，CPU将只会被该计算机的程序所驱动。

31
00:01:57,780 --> 00:01:58,610
Now yield.
现在让出执行。

32
00:01:58,870 --> 00:02:01,360
It's a system call and the system call.
这是一个系统调用和系统调用。

33
00:02:02,810 --> 00:02:05,640
It's going to result in a trap to the kernel.
这将导致陷入内核陷阱。

34
00:02:05,960 --> 00:02:10,660
And the kernel will then take over.
然后内核将接管。

35
00:02:10,670 --> 00:02:16,780
And it will suspend the current program thread.
它将暂停当前的程序线程。

36
00:02:17,200 --> 00:02:19,660
And that on the new one,
而且这是在新的上面，

37
00:02:21,170 --> 00:02:23,080
this is a pseudo code, very simple.
这是一个伪代码，非常简单。

38
00:02:23,090 --> 00:02:26,160
So this kind of you see that on your thread,
所以你在你的帖子上看到这种情况，

39
00:02:26,310 --> 00:02:29,670
this is what is a function run by the kernel,
这是由内核运行的一个函数。

40
00:02:31,100 --> 00:02:35,520
which basically picks a new thread and switch from the current thread,
这基本上是选择一个新线程并从当前线程切换的操作。

41
00:02:35,730 --> 00:02:37,540
which is in blue here to the new stretch,
这里的蓝色部分延伸到新的区域。

42
00:02:37,980 --> 00:02:42,530
and is doing some housekeeping and some clean up.
正在进行一些清理和整理工作。

43
00:02:42,870 --> 00:02:44,560
When he's going to do this,
他打算什么时候做这件事？

44
00:02:45,130 --> 00:02:47,840
update some counters at the time,
同时更新一些计数器

45
00:02:48,070 --> 00:02:49,080
as a for instance,
例如，

46
00:02:49,090 --> 00:02:51,110
a thread run and things like that.
一个线程运行和类似的事情。

47
00:02:53,610 --> 00:02:55,810
Now the question, obviously, the key is like,
现在问题来了，显然，关键是像这样的，

48
00:02:56,420 --> 00:02:58,490
there are two things we want to understand.
我们想要理解的有两件事情。

49
00:02:58,500 --> 00:03:02,000
It's like how to pick any thread and how you are going to switch
这就像是如何选择任意线程以及如何进行线程切换。

50
00:03:02,010 --> 00:03:03,720
from the current thread to the new thread.
从当前线程到新线程。

51
00:03:08,630 --> 00:03:11,300
And if you remember, obviously,
如果你还记得的话，显然，

52
00:03:11,310 --> 00:03:12,900
in order to do that,
为了做到这一点，

53
00:03:13,120 --> 00:03:16,110
we need to save the state of the current thread.
我们需要保存当前线程的状态。

54
00:03:16,430 --> 00:03:20,980
And then to initialize the registers of the processor,
然后初始化处理器的寄存器。

55
00:03:20,990 --> 00:03:22,300
the bc counter,
BC计数器

56
00:03:22,550 --> 00:03:25,300
with the values, with the state of the new thread,
使用这些值，以及新线程的状态，

57
00:03:25,310 --> 00:03:27,040
and then execute that new thread.
然后执行该新线程。

58
00:03:30,070 --> 00:03:30,480
Okay?
好的？

59
00:03:31,930 --> 00:03:38,600
One of these111 important part of the state of a thread, if you remember,
如果你还记得的话，线程状态的一个重要部分是这些之一。

60
00:03:38,780 --> 00:03:40,060
is a stack, right?
是一个栈，对吗？

61
00:03:40,900 --> 00:03:45,610
And let's look a little bit more into more details about these four simple examples.
让我们更详细地看一下这四个简单示例的细节。

62
00:03:46,140 --> 00:03:48,890
If you are going to have two functions,
如果你打算有两个函数，

63
00:03:49,160 --> 00:03:55,030
a and ba calls b and b is that executive look.
a 和 b 互相调用，b 是执行的对象。

64
00:03:55,410 --> 00:03:58,590
Within that loop, you yield every time you execute the loop.
在这个循环中，每次执行循环时都会进行 yield 操作。

65
00:03:59,100 --> 00:03:59,470
Right?
对吗？

66
00:03:59,890 --> 00:04:02,810
And suppose that we have two threads,
假设我们有两个线程，

67
00:04:02,820 --> 00:04:07,080
s and d and running this program.
运行这个程序需要使用 s 和 d。

68
00:04:08,860 --> 00:04:11,020
Both of them run this program.
他们两个都运行这个程序。

69
00:04:11,440 --> 00:04:12,800
Thread as right,
线程是正确的，

70
00:04:12,810 --> 00:04:14,960
is called function a here.
这里被称为函数a。

71
00:04:15,330 --> 00:04:16,320
This is on the stack.
这是在栈上的。

72
00:04:16,330 --> 00:04:21,240
You remember that the stack grows from the high addresses to the lower addresses.
你记得栈是从高地址向低地址增长的。

73
00:04:21,700 --> 00:04:22,800
On the stack,
在堆栈上，

74
00:04:22,810 --> 00:04:29,850
you are going to have the return values as a return address after executive
在执行后，您将返回值作为返回地址。

75
00:04:30,160 --> 00:04:31,030
to the function,
对于这个函数，

76
00:04:31,470 --> 00:04:32,310
as well.
也是。

77
00:04:32,320 --> 00:04:33,510
As when you call a function,
就像你调用一个函数时，

78
00:04:33,520 --> 00:04:35,230
you are going to put on the stack,
你将要将其放入堆栈中，

79
00:04:35,480 --> 00:04:37,470
the argument for that function.
该函数的参数。

80
00:04:38,260 --> 00:04:39,690
Here there are no arguments,
这里没有争论。

81
00:04:39,980 --> 00:04:42,010
but that happens, in general, right?
但这通常会发生，对吗？

82
00:04:42,100 --> 00:04:44,970
You have a first which you call you put on the stack,
你有一个称为"first"的东西，你将它放在堆栈上。

83
00:04:45,230 --> 00:04:49,180
then b and this is a one which execute a while loop,
然后 b 是一个执行 while 循环的语句。

84
00:04:49,190 --> 00:04:53,380
and then is going to execute and run yield.
然后将执行和运行yield。

85
00:04:54,270 --> 00:04:56,260
And then,
然后，

86
00:04:57,380 --> 00:04:57,810
again,
再次，

87
00:04:57,820 --> 00:05:04,580
yield is going to to call the operating system and the operating system.
yield会调用操作系统和操作系统。

88
00:05:05,990 --> 00:05:12,570
It's going to execute the run new thread and switch to the new thread.
它将执行运行新线程并切换到新线程。

89
00:05:12,990 --> 00:05:16,510
And when you switch is going to run the other thread feel.
当你切换到另一个线程时，它将开始运行。

90
00:05:16,520 --> 00:05:18,670
He said that we have to thread in the system, right?
他说我们在系统中必须使用线程，对吗？

91
00:05:19,030 --> 00:05:19,760
And the threes,
还有那些树，

92
00:05:20,410 --> 00:05:23,600
the new thread will basically they could the same thing.
新线程基本上可以做相同的事情。

93
00:05:24,030 --> 00:05:32,870
And the example is going to execute a and b and b whenever it's going to execute.
每当执行时，示例将执行a和b，并且还会执行b。

94
00:05:32,880 --> 00:05:35,400
So while is going to yield,
在进行yield操作时，

95
00:05:35,700 --> 00:05:38,300
go again, you go to the operating system,
再来一次，你去操作系统。

96
00:05:38,310 --> 00:05:42,100
and then your ping pong between the two threats.
然后你在这两个线程之间来回切换。

97
00:05:42,110 --> 00:05:42,350
Okay?
好的？

98
00:05:42,520 --> 00:05:43,380
This is what we have.
这是我们所拥有的。

99
00:05:44,180 --> 00:05:44,560
Okay?
好的？

100
00:05:45,020 --> 00:05:46,330
Now, it's, again,
现在，又是这样，

101
00:05:46,340 --> 00:05:50,210
like one thing we need to do in when you are going to switch
在进行切换时，我们需要做的一件事情是

102
00:05:50,220 --> 00:05:54,000
from the current strategies and you thread is we need to
根据当前的策略和你的线程，我们需要...

103
00:05:55,120 --> 00:05:57,660
save the state of the current stretch,
保存当前伸展的状态，

104
00:05:57,670 --> 00:05:58,220
right?
对的？

105
00:05:58,810 --> 00:05:59,560
What does it mean?
这句话的意思是什么？

106
00:05:59,570 --> 00:06:01,320
This is that registers.
这是寄存器。

107
00:06:01,330 --> 00:06:04,080
You see, r zero to r seven is that registers.
你看，r zero 到 r seven 是寄存器。

108
00:06:04,880 --> 00:06:07,430
And then sp is a stack pointer.
然后sp是一个栈指针。

109
00:06:07,700 --> 00:06:11,210
And cpu is a return, a pointer.
CPU是一个返回值，一个指针。

110
00:06:11,380 --> 00:06:16,960
This is the pointer of the next instruction we should be executed when I
这是指向下一条应该执行的指令的指针

111
00:06:16,970 --> 00:06:20,600
am going to resume the execution of this thread.
我将继续执行这个线程的操作。

112
00:06:21,070 --> 00:06:21,430
Okay?
好的？

113
00:06:22,790 --> 00:06:26,540
Now the next thing we need to now to take care of the new thread,
现在我们需要了解如何处理新线程。

114
00:06:26,960 --> 00:06:32,410
we are going to update the register of the processor,
我们打算更新处理器的寄存器。

115
00:06:33,300 --> 00:06:34,370
the stack pointers,
栈指针

116
00:06:34,380 --> 00:06:36,650
npc with a new.
一个新的NPC。

117
00:06:37,270 --> 00:06:44,280
We started a with a state corresponding state of the new of the new thread
我们从一个与新线程对应的状态开始。

118
00:06:44,290 --> 00:06:45,080
we want to run.
我们想要跑步。

119
00:06:45,090 --> 00:06:46,160
And by the way,
顺便说一下，

120
00:06:46,170 --> 00:06:49,680
you see where this state it's stored, what is stored.
你想知道这个状态存储在哪里，以及存储了什么内容。

121
00:06:49,690 --> 00:06:52,330
It's in dcb it's thread control block.
这是在 dcb 中，它是线程控制块。

122
00:06:55,030 --> 00:06:56,460
I hope this kind of makes sense,
希望这样说得通，

123
00:06:56,470 --> 00:06:58,020
and this will be pretty simple.
这将会非常简单。

124
00:06:58,370 --> 00:06:58,820
Right?
对吗？

125
00:06:59,010 --> 00:07:01,820
Now, obviously, you need to be careful and implement that.
显然，你需要小心并实施这个。

126
00:07:02,180 --> 00:07:04,350
And by the way, if you have any questions,
顺便说一下，如果你有任何问题，

127
00:07:04,660 --> 00:07:07,740
let me know i'll be happy to answer as always.
请告诉我，我会很乐意像往常一样回答你的问题。

128
00:07:09,320 --> 00:07:12,350
So you need to be very careful, right?
所以你需要非常小心，对吗？

129
00:07:12,360 --> 00:07:13,270
I for instance,
例如，我

130
00:07:13,840 --> 00:07:18,490
if you forget to save or store a particular register, say,
如果你忘记保存或存储一个特定的寄存器，比如说，

131
00:07:19,380 --> 00:07:21,210
and register study too,
并且也要注册学习。

132
00:07:21,220 --> 00:07:23,210
then what will happen?
那么会发生什么呢？

133
00:07:23,220 --> 00:07:23,690
Right?
对吗？

134
00:07:24,140 --> 00:07:25,610
Something that happened,
发生了一些事情，

135
00:07:27,730 --> 00:07:29,040
what happens?
发生了什么事情？

136
00:07:29,250 --> 00:07:33,370
It will very much depend about whether the value is that register
这将非常取决于该寄存器中的值。

137
00:07:33,380 --> 00:07:36,010
is going to be used by the program.
将被程序使用。

138
00:07:36,020 --> 00:07:37,450
If it's not going to be used,
如果不打算使用的话，

139
00:07:38,040 --> 00:07:38,830
nothing will happen.
不会发生任何事情。

140
00:07:38,840 --> 00:07:39,990
But if it's going to be used,
但是如果它要被使用的话，

141
00:07:40,000 --> 00:07:44,630
you are going to see probably a random is a random results or random failures.
你可能会看到随机的结果或随机的失败。

142
00:07:49,530 --> 00:07:54,840
You will say, why wouldn't you then start?
你会问，那你为什么不开始呢？

143
00:07:56,080 --> 00:07:58,350
You test carefully the entire code?
你仔细测试了整个代码吗？

144
00:07:59,370 --> 00:08:01,200
Is that testing the entire code,
这是在测试整个代码吗？

145
00:08:01,210 --> 00:08:04,880
especially passing its exhaustively?
特别是详尽地传递它的排放物？

146
00:08:05,130 --> 00:08:08,080
It's very difficult because there are many combinations.
这很困难，因为有很多组合。

147
00:08:08,090 --> 00:08:09,940
Why is there are many combinations?
为什么有这么多组合？

148
00:08:10,610 --> 00:08:15,720
There are many combinations because you a thread can be interrupted anywhere.
由于线程可以在任何地方被中断，所以有很多种组合。

149
00:08:17,910 --> 00:08:19,100
So if you have a thread,
如果你有一个线程，

150
00:08:19,110 --> 00:08:23,770
which is you have 1,000 instructions,
你有1,000条指令。

151
00:08:23,970 --> 00:08:26,750
it can be interrupted after each of these instructions.
每个指令执行后都可以被中断。

152
00:08:27,260 --> 00:08:27,660
Right?
对吗？

153
00:08:28,600 --> 00:08:31,590
You have another strategy and other ones of the instructions.
你有另一种策略和其他指令。

154
00:08:31,870 --> 00:08:35,060
Now you have combination about where you are going to interrupt the first thread,
现在你已经有了关于在哪里中断第一个线程的组合。

155
00:08:35,070 --> 00:08:37,940
and we are going to resume the second thread like 1 million.
我们将要恢复第二个线程，恢复次数为100万次。

156
00:08:38,500 --> 00:08:38,910
Right?
对吗？

157
00:08:40,280 --> 00:08:44,560
There are many stories about errors.
有许多关于错误的故事。

158
00:08:45,020 --> 00:08:48,000
In some cases, you are found after a long time,
在某些情况下，经过很长时间后才找到你。

159
00:08:48,250 --> 00:08:49,910
like, for instance, in this case,
例如，在这种情况下，

160
00:08:50,730 --> 00:08:53,400
it was aa very early kernel top,
这是一个非常早期的内核顶部。

161
00:08:53,410 --> 00:08:54,480
as you can see,
正如你所看到的，

162
00:08:54,490 --> 00:08:56,440
based on the sale on the size.
根据销售量大小。

163
00:08:56,950 --> 00:09:00,810
It was obviously very well tested.
显然经过了很好的测试。

164
00:09:01,080 --> 00:09:03,280
But it was one thing.
但那只是一件事情。

165
00:09:05,480 --> 00:09:10,030
What happened is that it was one instruction,
发生的是只有一条指令。

166
00:09:10,040 --> 00:09:15,200
one correctly saving the state of a thread,
正确保存线程状态的方法之一是，

167
00:09:15,210 --> 00:09:20,260
depending of whether the kernel size was less than one megabyte,
根据内核大小是否小于1兆字节，

168
00:09:20,620 --> 00:09:22,770
initially was the less than one megabyte, right?
最初的时候是小于1兆字节的，对吗？

169
00:09:22,780 --> 00:09:25,370
But over time, like with any software,
随着时间的推移，就像任何软件一样，

170
00:09:25,380 --> 00:09:26,490
the size increased.
大小增加了。

171
00:09:26,790 --> 00:09:30,820
And people are developers forgot about this limitation.
而且开发人员忘记了这个限制。

172
00:09:31,120 --> 00:09:35,750
And when it did happen and the size increase overall megabyte,
当这种情况发生并且文件的大小总体上增加了几兆字节时，

173
00:09:36,060 --> 00:09:40,730
then they start to get superiors errors.
然后他们开始遇到上级错误。

174
00:09:43,520 --> 00:09:45,390
This kind of like we'll discuss,
这种类似我们将要讨论的东西，

175
00:09:45,400 --> 00:09:50,090
this kind of errors are also very hard to to the back,
这种错误也很难追溯到原因。

176
00:09:50,330 --> 00:09:51,750
because they are not deterministic.
因为它们不是确定性的。

177
00:09:53,460 --> 00:09:56,290
Be honest again, like when you design be very,
再次诚实一点，就像当你设计时一样，要非常

178
00:09:56,300 --> 00:09:59,090
very careful design, for simplicity, simple code,
非常谨慎的设计，以求简单化，简洁的代码。

179
00:09:59,300 --> 00:10:02,690
it's easier to check than more complex code and all.
这样更容易检查，而且代码也不会太复杂。

180
00:10:07,260 --> 00:10:07,840
Now,
现在，

181
00:10:09,410 --> 00:10:14,760
one of the question is about we are switching between when are switching
其中一个问题是关于我们在什么时候进行切换的问题。

182
00:10:14,770 --> 00:10:15,990
between two threads.
在两个线程之间。

183
00:10:16,370 --> 00:10:18,470
We are also switching.
我们也在进行切换。

184
00:10:19,560 --> 00:10:20,910
It's compact switching.
这是紧凑式交换。

185
00:10:22,890 --> 00:10:26,910
We also refer as contact switching when you are switching between two processes.
当你在两个进程之间切换时，我们也称之为上下文切换。

186
00:10:27,550 --> 00:10:28,050
Okay.
好的。

187
00:10:29,470 --> 00:10:29,780
Now,
现在，

188
00:10:30,870 --> 00:10:32,700
and this, again, we discuss this in the past,
而且，再次强调，我们在过去已经讨论过这个问题了。

189
00:10:32,710 --> 00:10:35,620
but let me repeat because it's a very important aspect.
但是让我重复一遍，因为这是一个非常重要的方面。

190
00:10:38,510 --> 00:10:40,300
When you do process switching,
当进行进程切换时，

191
00:10:40,310 --> 00:10:42,140
when you switch between two processes,
当你在两个进程之间切换时，

192
00:10:42,520 --> 00:10:45,240
which means that the boat at the end of the day,
这意味着在一天结束时，船会...

193
00:10:45,250 --> 00:10:47,990
because you are switching between two threads in a different processes
因为你正在在不同的进程之间切换两个线程

194
00:10:49,190 --> 00:10:51,800
that sewage is much more expensive.
那个污水处理更加昂贵。

195
00:10:52,270 --> 00:10:52,790
Okay?
好的？

196
00:10:53,430 --> 00:10:58,360
The reason that switch is much more expensive is simply because the state
交换机价格更高的原因很简单，就是因为它的状态。

197
00:10:58,610 --> 00:11:01,410
associated with the process is much larger.
与该进程相关的内容要大得多。

198
00:11:01,890 --> 00:11:02,290
Right?
对吗？

199
00:11:02,570 --> 00:11:06,540
You need, again, the process is also on another space, right?
你需要的是，再次强调，进程也在另一个空间中，对吗？

200
00:11:07,010 --> 00:11:09,160
It's also on the file descriptors.
这也涉及到文件描述符。

201
00:11:09,410 --> 00:11:09,850
Okay?
好的？

202
00:11:11,440 --> 00:11:12,390
Fundamentally,
从根本上说，

203
00:11:12,400 --> 00:11:16,270
it's a lot of more things you need to do when you switch a context versus
在切换上下文时，你需要做的事情要多得多。

204
00:11:16,280 --> 00:11:17,150
switching a threat.
切换线程。

205
00:11:19,070 --> 00:11:20,100
These are the numbers.
这些是数字。

206
00:11:20,110 --> 00:11:22,220
Actually, the frequency context,
实际上，频率上下文，

207
00:11:22,230 --> 00:11:26,540
the switching between processes can take between,
进程之间的切换可能需要一段时间，

208
00:11:26,550 --> 00:11:29,060
in this case, for these numbers, again,
在这种情况下，针对这些数字，再次，

209
00:11:29,070 --> 00:11:30,420
depends on the implementation,
这取决于具体的实现方式。

210
00:11:30,430 --> 00:11:31,500
depends on the hardware.
这取决于硬件。

211
00:11:31,950 --> 00:11:34,100
Take these numbers, a great grain of salt.
将这些数字视作一大把盐。

212
00:11:34,110 --> 00:11:39,250
They are only supposed to give you the relative a sense about the relative difference.
它们只是为了让你对相对差异有一个相对的感觉。

213
00:11:39,730 --> 00:11:41,240
When you see between processes,
当你在进程之间进行切换时，

214
00:11:41,250 --> 00:11:44,000
it can be like between 3 and 4 micro seconds.
它可能在3到4微秒之间。

215
00:11:44,010 --> 00:11:47,000
When you see between two studies only 100 and a second.
当你在两个研究之间只看到100和第二个时。

216
00:11:47,450 --> 00:11:48,840
In this particular case,
在这种特定情况下，

217
00:11:48,850 --> 00:11:51,990
you can see that the overhead is 30, 40,
你可以看到开销是30，40，

218
00:11:52,000 --> 00:11:54,320
times higher when I see between processes,
当我在进程之间切换时，时间会增加。

219
00:11:55,490 --> 00:12:00,070
as compared when you switch,
与你切换时相比，

220
00:12:00,570 --> 00:12:02,900
just behind be between two threats.
就在两个威胁之间。

221
00:12:03,590 --> 00:12:05,500
And the frequency of context switching.
以及上下文切换的频率。

222
00:12:05,510 --> 00:12:10,430
Here we are talking is about10 or 100 millisecond.
我们现在讨论的是10或100毫秒的时间范围。

223
00:12:11,360 --> 00:12:13,870
You don't want to contact switch all the time.
你不想一直联系开关。

224
00:12:13,880 --> 00:12:15,470
You want to contact switch.
你想联系交换机。

225
00:12:16,340 --> 00:12:17,560
Still fast enough,
仍然足够快速，

226
00:12:18,830 --> 00:12:21,690
but not as fast.
但速度不够快。

227
00:12:21,980 --> 00:12:25,770
So that the amount of computation is the same order.
为了使计算量保持在相同的数量级。

228
00:12:25,780 --> 00:12:29,530
Remind you of squeeze the amount of overhead, it takes the switch.
提醒你要尽量减少开销，这需要使用开关。

229
00:12:30,840 --> 00:12:31,230
Okay.
好的。

230
00:12:32,380 --> 00:12:36,140
We have a question here from a sheet.
我们这里有一个问题来自一张纸上。

231
00:12:36,150 --> 00:12:38,500
Isn't it trivial to change the address space?
更改地址空间不是很简单吗？

232
00:12:38,510 --> 00:12:44,610
Because you just change the pointer and for fallacy that again,
因为你只是改变了指针，再次陷入了错误的推理。

233
00:12:44,620 --> 00:12:46,730
don't you just change this process structure?
你只需要改变这个进程结构吗？

234
00:12:46,740 --> 00:12:51,480
.2is more than that.
0.2比那个更大。

235
00:12:51,890 --> 00:12:53,280
You also need to have.
你还需要拥有。

236
00:12:55,150 --> 00:12:56,220
You have the buffers,
你有缓冲区，

237
00:12:56,230 --> 00:12:58,740
if you remember the, for instance, files tomorrow,
如果你明天还记得，比如说，文件的话，

238
00:12:58,750 --> 00:13:01,970
io the other things you need to do,
除了IO之外，你还需要做的其他事情。

239
00:13:02,420 --> 00:13:05,320
fundamentally, you need to have the entire page table.
基本上，你需要拥有整个页表。

240
00:13:06,640 --> 00:13:08,790
You need to take care of it,
你需要照顾它，

241
00:13:09,210 --> 00:13:13,250
because the page table that is a translation of the address
因为页表是地址的翻译。

242
00:13:13,260 --> 00:13:15,050
virtual addresses to physical addresses.
虚拟地址到物理地址的转换。

243
00:13:15,410 --> 00:13:16,180
It is.
是的。

244
00:13:20,470 --> 00:13:21,300
This is what?
这是什么？

245
00:13:21,310 --> 00:13:22,820
Each process outs.
每个进程输出。

246
00:13:25,400 --> 00:13:25,630
Yeah,
是的，

247
00:13:26,150 --> 00:13:26,650
what?
什么？

248
00:13:26,660 --> 00:13:31,520
And also when you see the address space,
还有，当你看到地址空间时，

249
00:13:31,800 --> 00:13:38,560
then you can because you are going to have probably some of the babies
那么你可以，因为你可能会有一些宝宝。

250
00:13:38,790 --> 00:13:40,430
which of the process,
哪个进程，

251
00:13:40,650 --> 00:13:42,080
which are going to be,
将要成为的是，

252
00:13:43,170 --> 00:13:46,210
we have a big deal from the memory to make room for new processes,
我们需要从内存中腾出空间来容纳新的进程。

253
00:13:46,220 --> 00:13:51,020
and they are going to go to disk or whatever ssd therefore,
然后它们将被存储到磁盘或者固态硬盘(SSD)中。

254
00:13:51,030 --> 00:13:56,330
you may also have to do some work to get some pages in when you switch
当你切换时，你可能还需要做一些工作来获取一些页面。

255
00:13:56,340 --> 00:13:57,290
between the processes,
进程之间的

256
00:14:01,320 --> 00:14:07,100
even cheaper you can actually use without the operating system support.
甚至更便宜的是，你实际上可以不使用操作系统支持。

257
00:14:09,240 --> 00:14:13,840
You can use as you can use yield in the user level.
你可以在用户级别使用yield。

258
00:14:13,850 --> 00:14:18,330
So the application actually is 50 that are thread libraries,
这个应用实际上是一个包含50个线程库的应用程序。

259
00:14:18,340 --> 00:14:21,030
user levels for several thread libraries.
多个线程库的用户级别。

260
00:14:21,290 --> 00:14:24,640
These are the libraries which provide you like a thread interface,
这些是提供类似线程接口的库。

261
00:14:24,870 --> 00:14:27,430
but the operating system doesn't know anything about.
但是操作系统对此一无所知。

262
00:14:29,910 --> 00:14:32,910
And then what happens when you use a thread,
当你使用线程时，会发生什么呢？

263
00:14:32,920 --> 00:14:34,230
use that level thread,
使用该级别的线程

264
00:14:34,240 --> 00:14:35,990
then when you call yield,
那么当你调用yield时，

265
00:14:36,000 --> 00:14:38,630
you call the library which running the same process.
你调用了运行在同一进程中的库。

266
00:14:38,640 --> 00:14:40,190
Again, it's not a system,
再次强调，这不是一个系统，

267
00:14:40,810 --> 00:14:41,330
kernel.
内核。

268
00:14:41,530 --> 00:14:44,120
And then that library is going to invoke,
然后那个库将被调用，

269
00:14:44,490 --> 00:14:46,760
you are going to just make a call a function,
你只需要调用一个函数。

270
00:14:46,770 --> 00:14:50,260
call to another thread in the same process.
在同一进程中调用另一个线程。

271
00:14:50,430 --> 00:14:51,900
This is very, very lightweight,
这非常非常轻量级。

272
00:14:51,910 --> 00:14:53,100
is just a function call.
只是一个函数调用。

273
00:14:54,670 --> 00:14:57,580
This is some of the first stress systems have been implemented.
这是一些最早实施的压力测试系统。

274
00:14:57,800 --> 00:14:58,950
That is the application level.
这是应用层级别。

275
00:15:00,270 --> 00:15:02,790
In this case, all fundamentally,
在这种情况下，从根本上说，

276
00:15:02,800 --> 00:15:12,190
all these user level threads are going to be basically mapped on, say,
所有这些用户级线程基本上会被映射到，比如说，

277
00:15:12,200 --> 00:15:13,430
one cpu now.
现在只有一个CPU。

278
00:15:14,040 --> 00:15:16,190
With a kernel, in general,
一般来说，有了内核，

279
00:15:16,200 --> 00:15:19,070
kernel also uses some threads, right?
内核也使用一些线程，对吗？

280
00:15:19,080 --> 00:15:19,950
And the number.
还有数字。

281
00:15:19,960 --> 00:15:21,430
And these are kernel threads.
这些是内核线程。

282
00:15:21,440 --> 00:15:22,790
And you then, in general,
而你呢，一般来说，

283
00:15:23,000 --> 00:15:25,310
you map the user thread on the kernel threads.
你将用户线程映射到内核线程上。

284
00:15:26,490 --> 00:15:28,040
The kernel said, typically,
内核通常会说，

285
00:15:28,050 --> 00:15:31,040
you uses a number as a number of catalysts.
你使用一个数字作为催化剂的数量。

286
00:15:31,230 --> 00:15:34,970
The number of kennel thread is typically equal,
狗舍线程的数量通常是相等的。

287
00:15:34,980 --> 00:15:37,770
is a number of cp us or a number.
是一个CPU的数量或者一个数字。

288
00:15:38,720 --> 00:15:39,110
Okay?
好的？

289
00:15:39,120 --> 00:15:40,870
And again, you have it difficult.
再次，你遇到了困难。

290
00:15:40,880 --> 00:15:47,200
You have few tens on your cpu but you can have then thousand or tens
你的 CPU 上有几十个，但你可以有成千上万个或几十个。

291
00:15:47,210 --> 00:15:49,130
of thousand of user level threads.
成千上万个用户级线程。

292
00:15:51,760 --> 00:15:55,150
When the kernel has a concept of thread,
当内核具有线程的概念时，

293
00:15:55,160 --> 00:15:56,390
then what you happen,
那么你发生了什么事情？

294
00:15:56,400 --> 00:16:00,280
you are going to map the user thread on top on calendar sets.
你将要在日历集合之上映射用户线程。

295
00:16:02,370 --> 00:16:03,320
Let's look,
让我们来看一下，

296
00:16:10,030 --> 00:16:13,180
is this server overhead on context?
这个服务器在上下文切换方面有开销吗？

297
00:16:14,140 --> 00:16:15,700
Switch between process is purely,
进程切换是纯粹的操作。

298
00:16:15,710 --> 00:16:17,340
do you have to switch of the address space?
你需要切换地址空间吗？

299
00:16:17,350 --> 00:16:18,580
That's a big part of it.
这是其中的一大部分。

300
00:16:22,090 --> 00:16:24,530
Again, there are also file descriptors and things like that,
同样，还有文件描述符和类似的东西。

301
00:16:24,540 --> 00:16:26,770
but the address space is a big partner.
但是地址空间是一个重要的伙伴。

302
00:16:28,980 --> 00:16:29,810
Okay.
好的。

303
00:16:33,590 --> 00:16:34,860
In today, lecture,
在今天的讲座中，

304
00:16:34,870 --> 00:16:37,980
we are going to talk what in the first part of today lecture,
我们今天的讲座的第一部分将讨论什么内容？

305
00:16:37,990 --> 00:16:40,820
we are going to talk about this,
我们要讨论这个。

306
00:16:40,870 --> 00:16:47,740
12the 1~1 thread model in the one grand thread model, actually,
在单一的大线程模型中，12the 1~1线程模型实际上是

307
00:16:48,100 --> 00:16:49,490
in this particular case,
在这种特殊情况下，

308
00:16:49,790 --> 00:16:55,020
we are going to have for one users said we are going to have assumed
我们将为一个用户提供假设的服务。

309
00:16:55,030 --> 00:16:56,220
there is a kernel said.
有一个内核说。

310
00:16:56,230 --> 00:16:58,140
So this means that for one user said,
这意味着对于一个用户所说的，

311
00:16:58,150 --> 00:17:00,700
we are going to have a cpu to run on.
我们将要运行在一个CPU上。

312
00:17:03,370 --> 00:17:04,720
Again, it's another figure,
又是另一个图表，

313
00:17:05,370 --> 00:17:11,480
another representation to for you to better understand how things
另一种表示方式，让你更好地理解事物的方法是：

314
00:17:11,490 --> 00:17:12,800
are working under the hood.
正在幕后运行。

315
00:17:14,100 --> 00:17:15,200
So here is, again,
所以，这里又是

316
00:17:15,210 --> 00:17:17,250
you have two processes,
你有两个进程，

317
00:17:17,260 --> 00:17:20,130
these rounded yellow boxes.
这些圆角黄色的盒子。

318
00:17:20,670 --> 00:17:23,600
Each process you have a few threads.
每个进程都有几个线程。

319
00:17:23,610 --> 00:17:26,070
A thread has its own state.
一个线程有自己的状态。

320
00:17:26,670 --> 00:17:30,980
Then for they have some state they share is a process like memory and our state.
那么，对于它们共享的一些状态，就像是进程之间共享内存和我们的状态一样。

321
00:17:31,920 --> 00:17:34,110
Then this is os with green,
那么这就是带有绿色的操作系统。

322
00:17:34,120 --> 00:17:35,590
and you have acpu scalar,
你有一个CPU标量。

323
00:17:35,600 --> 00:17:39,950
which speaks on which cpu the threat that will run.
这句话的意思是讨论哪个CPU上将运行的线程。

324
00:17:39,960 --> 00:17:43,250
And you initially, let's assume that we have one.
首先，让我们假设我们有一个初始值。

325
00:17:44,260 --> 00:17:44,770
Okay.
好的。

326
00:17:47,170 --> 00:17:47,830
Now,
现在，

327
00:17:49,370 --> 00:17:50,710
let's look at the switch of our heads.
让我们来看一下我们的头部开关。

328
00:17:50,720 --> 00:17:51,870
Now, the switch of our heads.
现在，我们换个话题。

329
00:17:51,880 --> 00:17:53,430
There are multiple cases here.
这里有多种情况。

330
00:17:54,050 --> 00:17:55,390
The switch overhead of two threads.
两个线程的切换开销。

331
00:17:55,400 --> 00:17:55,660
Again.
再次。

332
00:17:55,670 --> 00:17:58,900
Eventually, what you run on the cpu is a strap.
最终，在 CPU 上运行的是一条指令。

333
00:17:59,210 --> 00:17:59,540
Right?
对吗？

334
00:18:00,190 --> 00:18:03,490
So the switch overhead between two threads.
所以线程之间的切换开销。

335
00:18:03,820 --> 00:18:05,930
If they are on the same process is very low,
如果它们在同一个进程中，发生的可能性非常低。

336
00:18:06,530 --> 00:18:06,990
right?
对的吗？

337
00:18:07,240 --> 00:18:14,030
Because all you need to soldiers abuse the you need to save and resume
因为你只需要保存和恢复士兵的滥用所需的信息。

338
00:18:14,190 --> 00:18:15,960
this the stress state,
这是应力状态。

339
00:18:16,500 --> 00:18:16,870
right?
对的？

340
00:18:18,490 --> 00:18:19,120
Which is small.
哪个更小。

341
00:18:20,560 --> 00:18:20,850
Now,
现在，

342
00:18:20,860 --> 00:18:25,570
if you need to go from one thread in one process into a thread
如果你需要从一个进程的一个线程切换到另一个线程

343
00:18:25,580 --> 00:18:26,770
in a different process.
在一个不同的进程中。

344
00:18:26,780 --> 00:18:29,770
Now, you need also to see the context of processes.
现在，你还需要查看进程的上下文。

345
00:18:29,780 --> 00:18:31,910
So then the switch overhead is high.
所以开关开销很高。

346
00:18:32,600 --> 00:18:35,200
Now, why do you have threads and processes?
现在，为什么需要线程和进程呢？

347
00:18:35,570 --> 00:18:38,070
Because the processes,
由于进程，

348
00:18:38,080 --> 00:18:40,950
while it is a context which between processes is slow,
尽管在进程之间的上下文切换是缓慢的，

349
00:18:40,960 --> 00:18:43,310
they provide some things that do not provide.
他们提供了一些其他人没有提供的东西。

350
00:18:43,790 --> 00:18:45,070
That is protection.
这是保护的功能。

351
00:18:46,450 --> 00:18:46,830
Right?
对吗？

352
00:18:47,280 --> 00:18:51,190
The protection between two strides running in the same process is very low.
同一进程中两个步骤之间的保护非常低。

353
00:18:51,200 --> 00:18:53,630
It's because they are sharing the same memory.
这是因为它们共享同一块内存。

354
00:18:54,080 --> 00:18:58,770
One thread can read and write from the memory of the data,
一个线程可以从数据的内存中读取和写入。

355
00:18:58,780 --> 00:19:00,850
from the data of another thread.
从另一个线程的数据中。

356
00:19:01,580 --> 00:19:05,260
While if the strategy could run on different processes,
如果策略可以在不同的进程上运行，

357
00:19:05,270 --> 00:19:06,490
that's not possible.
这是不可能的。

358
00:19:07,560 --> 00:19:07,990
Okay?
好的？

359
00:19:08,650 --> 00:19:10,530
Now sharing overhead, as we know,
现在谈论一下开销，正如我们所知，

360
00:19:10,900 --> 00:19:14,820
and we learned last past lectures,
而且我们在过去的几堂课中学到了，

361
00:19:15,600 --> 00:19:15,940
threads.
线程。

362
00:19:15,950 --> 00:19:21,540
And you may want to share data because the applications are pretty complex.
你可能想要共享数据，因为这些应用程序非常复杂。

363
00:19:21,960 --> 00:19:25,460
And they want to communicate with the multiple step.
他们希望通过多个步骤进行通信。

364
00:19:25,470 --> 00:19:27,020
They want to communicate with each other.
他们想要彼此交流。

365
00:19:28,230 --> 00:19:31,140
Now, if there are two threads are in the same process,
现在，如果有两个线程在同一个进程中，

366
00:19:31,150 --> 00:19:33,100
it's very easy for them to communicate.
他们之间的沟通非常容易。

367
00:19:33,110 --> 00:19:34,460
It's also low overhead.
它的开销也很低。

368
00:19:34,750 --> 00:19:35,020
Why?
为了方便中文用户理解和阅读，我将英文翻译成中文。这样可以帮助更多的人获得所需的信息。

369
00:19:35,030 --> 00:19:37,660
Because they can't communicate through the shared memory,
因为他们无法通过共享内存进行通信，

370
00:19:37,670 --> 00:19:39,780
the memory they share in the same process.
它们在同一进程中共享的内存。

371
00:19:40,180 --> 00:19:43,070
They just read and write to the memory super easy.
他们只需轻松地读写内存。

372
00:19:43,370 --> 00:19:44,450
On the other hand,
另一方面，

373
00:19:44,460 --> 00:19:46,130
if these are two processes,
如果这是两个进程，

374
00:19:46,140 --> 00:19:47,730
the sellers are into processes,
卖家们正在进行流程处理。

375
00:19:47,920 --> 00:19:51,870
then what do you know what the overhead is much higher?
那你知道开销为什么要高得多吗？

376
00:19:51,880 --> 00:19:54,150
Because how you can communicate between the processes?
因为你需要在进程之间进行通信。

377
00:19:54,160 --> 00:19:55,030
Do you remember?
你还记得吗？

378
00:19:55,120 --> 00:19:57,590
You can use pipe, you can use sockets,
你可以使用管道，你可以使用套接字，

379
00:19:57,840 --> 00:20:00,870
but all or you can read and write from a file.
但是你们都可以从文件中读取和写入数据。

380
00:20:01,280 --> 00:20:04,750
All of this operation are far more expensive than reading and writing
所有这些操作都比读写操作要昂贵得多。

381
00:20:04,760 --> 00:20:05,620
from the memory.
从内存中。

382
00:20:10,800 --> 00:20:12,150
What about the parallels?
关于"parallels"是什么意思？

383
00:20:12,770 --> 00:20:15,120
In the case of parallels here, there is no parallels,
在这种情况下，没有任何类似的情况存在。

384
00:20:15,130 --> 00:20:16,840
because you have only one core.
因为你只有一个核心。

385
00:20:16,850 --> 00:20:18,760
You can run only once at a time.
你一次只能运行一个任务。

386
00:20:20,060 --> 00:20:21,370
Here, it's a model.
这是一个模型。

387
00:20:21,380 --> 00:20:24,720
General example is you have four course.
一般的例子是你有四门课程。

388
00:20:25,490 --> 00:20:29,440
You can have four different kernel threads running at the same time.
你可以同时运行四个不同的内核线程。

389
00:20:29,740 --> 00:20:31,310
So now you have parallelism.
现在你有并行性了。

390
00:20:31,890 --> 00:20:39,630
Now you need to the sharing of our head is a little bit even more complex,
现在你需要了解我们头部的共享是更加复杂一些，

391
00:20:40,070 --> 00:20:43,300
because if you have the same process is low,
因为如果你有相同的进程数量很少，

392
00:20:44,990 --> 00:20:46,540
different process is high.
不同的进程数量很高。

393
00:20:46,550 --> 00:20:48,880
But now there are different process.
但是现在有不同的进程。

394
00:20:49,280 --> 00:20:54,520
If actually, it turns out that if you have simultaneous scores,
实际上，如果你有同时的分数，

395
00:20:54,530 --> 00:20:57,070
that's so they are running,
这是他们正在运行的原因。

396
00:20:57,620 --> 00:20:59,570
you can have processes.
你可以拥有进程。

397
00:21:00,140 --> 00:21:01,450
So this is more complicated,
所以这更加复杂，

398
00:21:01,460 --> 00:21:04,530
but you can have kernel stress running on the same car.
但是你可以在同一辆车上运行内核压力测试。

399
00:21:04,740 --> 00:21:07,950
And we see next slide how you can that have that.
接下来我们将看到如何实现这一点的幻灯片。

400
00:21:08,310 --> 00:21:12,010
Then the overhead of communication of sharing is lower.
那么共享通信的开销就会更低。

401
00:21:12,830 --> 00:21:19,250
And this is what I meant is a concept of multithreading or hypothetic,
我所指的是多线程或假设的概念。

402
00:21:19,260 --> 00:21:20,850
actually is hypothetical, right?
实际上是假设的，对吗？

403
00:21:20,860 --> 00:21:23,010
Simultaneous multithreading or hypothetical.
同时多线程或假设性多线程。

404
00:21:23,940 --> 00:21:33,340
This what they are talking about so far in everything I I said,
到目前为止，他们讨论的是我所说的一切。

405
00:21:33,760 --> 00:21:36,320
you can run one thread on one core.
你可以在一个核心上运行一个线程。

406
00:21:42,470 --> 00:21:45,820
But it turns out that in practice,
但实际上，结果证明，

407
00:21:46,040 --> 00:21:48,110
you can run at the same time,
你可以同时运行。

408
00:21:48,120 --> 00:21:50,910
multiple one multiple setting shadow, in general,
多个设置多个阴影，一般来说，

409
00:21:50,920 --> 00:21:53,530
only two threads on the same call.
同一次调用中只有两个线程。

410
00:21:54,920 --> 00:21:55,280
Right?
对吗？

411
00:21:56,120 --> 00:21:58,810
And this is called hypothetical.
这被称为假设性的。

412
00:22:00,860 --> 00:22:04,940
And almost all processors today provided,
几乎所有现代处理器都提供了该功能。

413
00:22:05,890 --> 00:22:06,270
right?
对的？

414
00:22:06,930 --> 00:22:11,480
It's actually, when you look at amazon for those of you, they give,
实际上，当你在亚马逊上搜索时，他们会提供给你一些选项。

415
00:22:11,490 --> 00:22:17,190
they say bcpu virtual cpu a virtual cpu is actually a hyper threat,
他们说 bcpu 虚拟 CPU 实际上是一种超线程技术。

416
00:22:18,110 --> 00:22:19,460
is not one core necessary.
不是必须要有一个核心。

417
00:22:21,060 --> 00:22:22,080
So what is the idea?
那么，这个想法是什么？

418
00:22:22,610 --> 00:22:25,080
Here is as things look at these figures,
以下是这些数据的情况：

419
00:22:25,090 --> 00:22:28,040
do you see my pointer on the screen?
你能看到我在屏幕上的指针吗？

420
00:22:31,890 --> 00:22:33,570
Can someone ask us if you see my point?
有人可以问我们是否理解我的观点吗？

421
00:22:38,770 --> 00:22:39,160
Perfect.
完美。

422
00:22:40,860 --> 00:22:44,530
So here is a time on the vertical.
这里是一个垂直方向上的时间。

423
00:22:45,150 --> 00:22:46,990
Here are, if you remember,
这里是，如果你还记得的话，

424
00:22:47,000 --> 00:22:53,950
from 61 c the processor have in the aromatic logical unit and everything
从61C开始，处理器在芳香逻辑单元中具有一切功能。

425
00:22:54,680 --> 00:23:00,690
there are different components that you need to fetch the instruction,
需要获取指令的不同组件。

426
00:23:00,700 --> 00:23:04,940
then you need to.
那么你需要这样做。

427
00:23:06,390 --> 00:23:10,380
Then you may use different components like ads
那么你可以使用不同的组件，比如广告。

428
00:23:10,390 --> 00:23:13,800
or from the aromatic processor units,
或者来自芳香处理器单元。

429
00:23:14,030 --> 00:23:16,550
a logical unit to perform that operation.
执行该操作的逻辑单元。

430
00:23:18,730 --> 00:23:22,180
Each of this line, it's an instruction.
每一行都是一条指令。

431
00:23:23,550 --> 00:23:24,580
And vertical.
垂直的。

432
00:23:24,590 --> 00:23:29,610
Each of the vertical is one component in the process in that core.
每个垂直线代表核心中的一个组件。

433
00:23:31,170 --> 00:23:33,000
So this color, what is color?
颜色是什么？

434
00:23:33,010 --> 00:23:35,000
This means that this instruction,
这意味着这条指令，

435
00:23:37,210 --> 00:23:38,670
where is a colored?
"colored" is an outdated and offensive term that was historically used to refer to people of non-white racial backgrounds. It is important to use respectful and inclusive language when referring to individuals from diverse racial and ethnic backgrounds. Instead, it is more appropriate to use terms such as "person of color" or specify the specific racial or ethnic group being referred to.

436
00:23:38,970 --> 00:23:43,270
Is that particular instruction uses that component.
那个特定的指令是否使用了那个组件。

437
00:23:44,100 --> 00:23:44,530
Right?
对吗？

438
00:23:46,040 --> 00:23:48,590
For instance, from in this example,
例如，在这个例子中，

439
00:23:48,640 --> 00:23:52,070
in the first instruction using the first and the third component.
在第一条指令中使用第一和第三个组件。

440
00:23:52,540 --> 00:23:54,560
Okay, but not using it doesn't use the second one.
好的，但是不使用它不会使用第二个。

441
00:23:54,970 --> 00:23:56,880
And then for the next,
然后接下来，

442
00:23:57,690 --> 00:23:58,370
actually,
实际上，

443
00:23:58,880 --> 00:24:02,330
ii I was not accurate.
嗨，我不准确。

444
00:24:02,340 --> 00:24:05,810
Sorry, each of this line represents a cycle instruction cycle.
抱歉，每一行代表一个指令周期。

445
00:24:06,160 --> 00:24:07,410
But at many instructions,
但在许多指令中，

446
00:24:07,730 --> 00:24:09,680
they run in a single cycle, some of them,
它们在一个周期内运行，其中一些。

447
00:24:10,150 --> 00:24:11,390
but some of them do not.
但是其中一些不是这样的。

448
00:24:11,690 --> 00:24:12,170
Okay.
好的。

449
00:24:13,220 --> 00:24:15,870
It's instruction cycle in this cycle.
这是指令周期中的一个周期。

450
00:24:17,200 --> 00:24:21,920
These two first and the third component are yours.
这两个第一和第三个组件是你的。

451
00:24:22,400 --> 00:24:23,920
In the next cycle,
在下一个周期中，

452
00:24:23,930 --> 00:24:27,070
there is no component being used.
没有使用任何组件。

453
00:24:27,370 --> 00:24:29,410
And maybe this is because it has stalled.
可能是因为它已经停滞了。

454
00:24:30,080 --> 00:24:31,470
The data is not available,
数据不可用。

455
00:24:31,480 --> 00:24:33,990
and the instruction cannot proceed or something like that,
而且指令无法继续执行，或者类似的情况。

456
00:24:35,560 --> 00:24:36,510
and so forth.
等等。

457
00:24:37,070 --> 00:24:42,160
The main point here is that not all components are used at the same time.
这里的主要观点是并非所有组件都同时使用。

458
00:24:46,210 --> 00:24:49,650
So then what you can do then,
那么你可以做什么呢？

459
00:24:49,660 --> 00:24:56,230
is basically to run two streams of instructions from two different threads.
基本上是同时运行来自两个不同线程的两个指令流。

460
00:24:57,510 --> 00:25:03,710
If a stream doesn't use all the components at the same time,
如果一个流不同时使用所有组件，

461
00:25:04,520 --> 00:25:06,270
then the other string can use them.
然后另一个字符串可以使用它们。

462
00:25:08,360 --> 00:25:09,800
So that's kind of the intuition.
所以这就是直觉的理解。

463
00:25:10,640 --> 00:25:14,790
One stream of instructions doesn't use all the components of the core
一个指令流没有使用核心的所有组件

464
00:25:15,500 --> 00:25:16,430
at all times.
始终如一。

465
00:25:17,910 --> 00:25:20,960
So you can take advantage of that to support the second stream
所以你可以利用这一点来支持第二个流

466
00:25:21,550 --> 00:25:23,850
to better use other components.
为了更好地使用其他组件。

467
00:25:25,190 --> 00:25:32,290
So that's why you can run two streams of instruction on virtually the same harder.
这就是为什么你可以在几乎相同的硬件上运行两个指令流的原因。

468
00:25:32,300 --> 00:25:35,490
So just better utilizing the particular core.
所以只是更好地利用特定的核心。

469
00:25:37,280 --> 00:25:37,640
All right.
好的。

470
00:25:38,260 --> 00:25:38,970
That's what it is.
就是这样。

471
00:25:39,310 --> 00:25:39,750
Okay.
好的。

472
00:25:39,760 --> 00:25:45,570
So it basically provides you the illusion that now you can run multiple.
所以它基本上给你一种错觉，让你觉得现在可以同时运行多个程序。

473
00:25:45,990 --> 00:25:47,380
You like, you have multiple,
你喜欢的话，你可以有多个选择。

474
00:25:50,190 --> 00:25:52,140
the speedup is nonlinear,
加速比是非线性的。

475
00:25:52,150 --> 00:25:55,940
because sometimes you have conflicts,
因为有时候会发生冲突，

476
00:25:56,220 --> 00:25:59,370
like you have the two stream instruction at the given cycle.
在给定的周期内，你有两个流指令。

477
00:25:59,380 --> 00:26:02,780
They want to use the same component.
他们想要使用相同的组件。

478
00:26:05,520 --> 00:26:09,480
But this is super useful and technique.
但这非常有用和实用的技术。

479
00:26:10,540 --> 00:26:13,540
And it's used by almost every processor.
它几乎被每个处理器使用。

480
00:26:20,680 --> 00:26:21,210
Now,
现在，

481
00:26:22,070 --> 00:26:25,890
if I remember a process,
如果我记得一个进程，

482
00:26:26,150 --> 00:26:29,610
can relinquish access to the cpu in multiple ways.
可以通过多种方式放弃对CPU的访问权限。

483
00:26:29,890 --> 00:26:30,130
Right?
对吗？

484
00:26:30,140 --> 00:26:31,810
One is voluntarily yield.
其中一个是自愿让步。

485
00:26:32,200 --> 00:26:39,130
Another one is io when it's making an io one is calling an io operation,
另一个是IO，当执行IO操作时，就会调用IO操作。

486
00:26:39,140 --> 00:26:40,890
like, in this case, it is from a file.
在这种情况下，它是从一个文件中获取的。

487
00:26:41,690 --> 00:26:42,880
Then it's another question.
那么这是另一个问题。

488
00:26:42,890 --> 00:26:44,980
Let me try to answer the question.
让我试着回答这个问题。

489
00:26:44,990 --> 00:26:47,520
Are some components not used,
有一些组件没有被使用吗？

490
00:26:47,530 --> 00:26:49,160
even if we do pipelining?
即使我们进行流水线处理，也是如此吗？

491
00:26:49,450 --> 00:26:52,340
Yes, because pipelining means there are multiple.
是的，因为流水线意味着有多个阶段。

492
00:26:53,650 --> 00:26:54,760
You are also going,
你也要去吗？

493
00:26:55,180 --> 00:26:58,810
you can also have stalls and dependencies in the pipelines
在流水线中也可能出现停顿和依赖关系。

494
00:26:59,380 --> 00:27:00,730
across instruction in the pipeline.
在流水线中的指令之间

495
00:27:02,510 --> 00:27:06,930
The answer is actually all the processors are all already do pipeline,
答案实际上是所有处理器都已经进行了流水线处理。

496
00:27:10,290 --> 00:27:10,700
right?
对的？

497
00:27:11,810 --> 00:27:12,680
Pipelining.
流水线技术。

498
00:27:13,410 --> 00:27:16,980
It helps you to each instruction, new instruction,
它帮助你理解每个指令，新指令。

499
00:27:16,990 --> 00:27:18,620
to every clock cycle.
每个时钟周期。

500
00:27:18,630 --> 00:27:20,810
You start the new instruction,
你开始了新的指令。

501
00:27:21,160 --> 00:27:24,470
but pipelining helps with the use it utilization,
但流水线技术有助于提高利用率。

502
00:27:24,480 --> 00:27:26,070
but it doesn't solve it entirely.
但这并不能完全解决它。

503
00:27:28,530 --> 00:27:29,100
Great question.
很好的问题。

504
00:27:30,260 --> 00:27:31,890
Let's go back here.
让我们回到这里。

505
00:27:31,900 --> 00:27:32,370
Again.
再次。

506
00:27:32,380 --> 00:27:33,730
We are going to show the stack,
我们将展示栈。

507
00:27:34,130 --> 00:27:35,730
and you have copy file,
你需要复制文件。

508
00:27:36,310 --> 00:27:37,180
cold read.
冷读。

509
00:27:37,530 --> 00:27:38,810
And when cold read,
当冷读时，

510
00:27:39,070 --> 00:27:42,250
read it, again, it's a system call.
再读一遍，这是一个系统调用。

511
00:27:42,780 --> 00:27:44,650
You call it a kernel read.
你可以称之为内核读取。

512
00:27:45,150 --> 00:27:46,590
And what is the kernel doing?
内核是做什么的？

513
00:27:48,360 --> 00:27:51,020
Is going to start the read operation.
即将开始读取操作。

514
00:27:51,480 --> 00:27:54,240
But before you get the answer to the read operation,
在你获得读取操作的答案之前，

515
00:27:54,510 --> 00:27:55,780
the cpu is free.
CPU空闲。

516
00:27:56,050 --> 00:27:56,810
So therefore,
因此，

517
00:27:56,820 --> 00:28:02,330
is going to switch to suspend your being the copy file program,
将要切换到暂停你作为复制文件程序的状态，

518
00:28:02,530 --> 00:28:07,100
and give the cpu to another thread.
并将CPU分配给另一个线程。

519
00:28:08,090 --> 00:28:08,450
Right?
对吗？

520
00:28:09,220 --> 00:28:10,260
The same thing happens.
发生了同样的事情。

521
00:28:10,750 --> 00:28:11,020
Right?
对吗？

522
00:28:11,980 --> 00:28:12,780
And the same,
同样，

523
00:28:14,230 --> 00:28:20,360
it is similar when you have signals and joints or operate operations on other.
当你有信号和连接或在其他地方执行操作时，它是相似的。

524
00:28:22,880 --> 00:28:23,280
Okay.
好的。

525
00:28:27,540 --> 00:28:30,290
Finally, one question.
最后，还有一个问题。

526
00:28:30,300 --> 00:28:31,690
So we also ask in the past,
所以我们也在过去提过这个问题，

527
00:28:31,700 --> 00:28:34,770
what happens if there no is a program?
如果没有程序会发生什么？

528
00:28:35,250 --> 00:28:41,270
Doesn't voluntarily yield the cpu there is no io and in general,
不主动让出CPU，没有IO操作，一般情况下。

529
00:28:41,280 --> 00:28:41,690
never waits.
永不等待。

530
00:28:42,490 --> 00:28:42,860
Right?
对吗？

531
00:28:45,440 --> 00:28:46,630
In that case,
在这种情况下，

532
00:28:47,900 --> 00:28:52,510
you still needs to multiply the cpu between different threads.
你仍然需要在不同线程之间进行CPU乘法运算。

533
00:28:52,900 --> 00:28:55,130
The way you do it using external events.
使用外部事件的方式来实现。

534
00:28:55,370 --> 00:28:58,390
External events like in this, like interrupts.
外部事件，例如中断。

535
00:28:58,870 --> 00:28:59,490
In particular,
特别是，

536
00:28:59,500 --> 00:29:05,100
timer interrupts a you program the timer to give an interrupt.
定时器中断是一种机制，它允许你在程序中设置定时器以产生中断。

537
00:29:05,450 --> 00:29:07,060
Every 100 millisecond.
每100毫秒。

538
00:29:07,370 --> 00:29:08,790
When you get this interrupt,
当你收到这个中断时，

539
00:29:08,800 --> 00:29:12,950
the kernel is going to switch from the current threat or infrastructure.
内核将要从当前的线程或基础架构进行切换。

540
00:29:15,440 --> 00:29:15,810
Okay?
好的？

541
00:29:17,880 --> 00:29:18,910
That's what it is.
就是这样。

542
00:29:24,090 --> 00:29:25,760
Let's see another question.
让我们看看另一个问题。

543
00:29:26,370 --> 00:29:29,310
It seemed like the hyperthreading benefits concurrency.
看起来超线程有助于并发性能。

544
00:29:29,320 --> 00:29:31,490
What about parallels?
关于Parallels是什么情况？

545
00:29:31,910 --> 00:29:35,040
It definitely also benefits parallels because you are going to have
这肯定也有利于并行计算，因为你会有更多的

546
00:29:35,050 --> 00:29:38,750
now if you have you are going to double the number of threads you
现在，如果你要将线程数量翻倍，你需要

547
00:29:38,760 --> 00:29:41,270
are going to to run at the same time.
将同时运行。

548
00:29:48,360 --> 00:29:54,900
So this is a picture which basically show you here is acpu and then I show
这是一张图片，基本上展示了一个CPU，然后我展示

549
00:29:54,910 --> 00:29:57,900
you how you are going to interface with different devices.
你将如何与不同设备进行接口？

550
00:29:58,800 --> 00:29:59,230
Right?
对吗？

551
00:29:59,750 --> 00:30:01,740
Again, the way interface, actually,
再说一遍，接口的方式，实际上，

552
00:30:01,750 --> 00:30:06,410
the operating system with a different devices is through these interrupts
不同设备与操作系统之间通过这些中断进行通信。

553
00:30:06,850 --> 00:30:10,860
when an event which requires the attention of the kernel happens,
当需要内核注意的事件发生时，

554
00:30:11,220 --> 00:30:17,020
that device has to going to jane to generate this kind of event which is interact.
该设备必须传递给简来生成这种交互事件。

555
00:30:17,630 --> 00:30:17,960
Right?
对吗？

556
00:30:21,520 --> 00:30:27,980
You can also have software interrupts like seek kill is a software interrupt.
你也可以使用软件中断，比如seek kill就是一个软件中断。

557
00:30:29,960 --> 00:30:31,460
It doesn't come from a device.
它不是来自设备的。

558
00:30:32,070 --> 00:30:35,480
It comes from another process or it comes from the kettle.
它来自另一个进程或来自水壶。

559
00:30:37,320 --> 00:30:40,950
This is a timer, which is a special kind of interrupt like we discussed.
这是一个计时器，就像我们讨论过的一样，它是一种特殊类型的中断。

560
00:30:45,040 --> 00:30:48,590
For interrupt, you can mask interrupts and we'll see.
对于中断，你可以屏蔽中断然后我们再看看。

561
00:30:48,960 --> 00:30:51,120
And the interrupt they have some priority.
中断也有一定的优先级。

562
00:30:55,990 --> 00:30:59,070
The higher priority interrupts,
优先级较高的中断，

563
00:30:59,890 --> 00:31:02,600
for instance can interrupt the lower priority interrupt.
例如，高优先级中断可以打断低优先级中断。

564
00:31:03,810 --> 00:31:04,210
Okay?
好的？

565
00:31:04,640 --> 00:31:06,520
But this is what have you have?
但这是你所拥有的吗？

566
00:31:06,530 --> 00:31:08,140
Basically this is actually this hardware,
基本上，这实际上是指这个硬件。

567
00:31:08,980 --> 00:31:11,510
this kind of different lines,
这种不同的线路，

568
00:31:11,820 --> 00:31:18,150
how to go to lines in the interrupt,
如何进入中断的代码行？

569
00:31:20,320 --> 00:31:20,760
least.
最少的。

570
00:31:21,400 --> 00:31:28,020
And then the key kernel will always look at the highest interrupt
然后关键的内核将始终关注最高的中断。

571
00:31:28,030 --> 00:31:29,940
and will treat the highest interrupt.
并且会处理最高优先级的中断。

572
00:31:30,780 --> 00:31:31,190
Okay?
好的？

573
00:31:32,040 --> 00:31:38,630
If higher interrupts and the one you are currently treating occurs,
如果发生了更高优先级的中断和当前正在处理的中断同时发生，

574
00:31:38,900 --> 00:31:42,310
then you are not going to switch to treat the higher interrupt and then you
那么你不会切换去处理更高优先级的中断，然后再返回吗？

575
00:31:42,320 --> 00:31:42,990
come back,
回来，

576
00:31:43,450 --> 00:31:45,490
finish treating the lower interrupt.
完成处理低优先级中断。

577
00:31:47,370 --> 00:31:47,840
Okay?
好的？

578
00:31:51,190 --> 00:31:57,100
The software interrupts can be cleared by software and cpu can disable
软件中断可以通过软件清除，CPU可以禁用。

579
00:31:57,110 --> 00:31:59,140
all interrupts with some internal flags.
所有带有一些内部标志的中断。

580
00:32:00,160 --> 00:32:00,630
Okay?
好的？

581
00:32:01,240 --> 00:32:04,620
So I don't want to be interrupted because what i'm doing is very important.
所以我不想被打扰，因为我正在做非常重要的事情。

582
00:32:08,310 --> 00:32:16,860
And there is also some non maskable interrupts which you don't have
还有一些非可屏蔽中断，你没有。

583
00:32:16,870 --> 00:32:17,780
anything what to do like,
任何需要做的事情，比如？

584
00:32:17,790 --> 00:32:18,540
for instance,
例如，

585
00:32:18,730 --> 00:32:21,750
reset is a nomas couple interrupt.
reset 是一种非屏蔽中断。

586
00:32:22,440 --> 00:32:22,770
Right?
对吗？

587
00:32:24,710 --> 00:32:31,430
So you have to just kill and reset everything on the computer and restart,
所以你只需要关闭并重启计算机，将所有内容清除并重置。

588
00:32:31,440 --> 00:32:32,150
right?
对的吗？

589
00:32:32,450 --> 00:32:33,230
That's one example.
这是一个例子。

590
00:32:37,490 --> 00:32:41,470
Now, this is an example about how the network interrupt occurs.
现在，这是一个关于网络中断发生的示例。

591
00:32:41,720 --> 00:32:43,030
Let's say you execute this,
假设你执行了这个操作，

592
00:32:43,040 --> 00:32:44,750
call these instructions.
执行这些指令。

593
00:32:45,630 --> 00:32:49,720
Now, you get an external interrupt because a packet arrives.
现在，你收到了一个外部中断，因为有一个数据包到达了。

594
00:32:50,220 --> 00:32:55,600
So the kernel needs to copy the data into the kernel buffer.
所以内核需要将数据复制到内核缓冲区中。

595
00:32:56,620 --> 00:32:57,460
So what do you do?
那你做什么工作？

596
00:32:58,660 --> 00:33:00,010
First of all, your pipeline,
首先，你的流水线，

597
00:33:00,020 --> 00:33:01,840
you flash the pipeline, right?
你是指清空流水线吗？

598
00:33:01,850 --> 00:33:07,590
The pipeline of the processor from the state of the current Instructions.
处理器的流水线从当前指令的状态开始。

599
00:33:10,430 --> 00:33:12,040
You save the program counter,
你保存了程序计数器，

600
00:33:13,200 --> 00:33:13,620
right?
对的？

601
00:33:14,090 --> 00:33:17,520
To know when you are going to resume where you are going to come back,
想知道你什么时候会恢复，以及你会回到哪里。

602
00:33:17,530 --> 00:33:22,190
what is a program counter if you have to come back to and disable all the interrupts?
如果你需要回到程序计数器并禁用所有中断，程序计数器是什么？

程序计数器（Program Counter）是一个特殊的寄存器，用于存储当前正在执行的指令的地址。它指示了下一条将要执行的指令在内存中的位置。当需要回到程序计数器并禁用所有中断时，意味着要暂停当前的执行流程，并将程序计数器的值保存下来，以便在中断处理完成后能够恢复到原来的执行位置。同时，禁用所有中断可以防止在中断处理期间发生其他中断，确保中断处理的完整性和正确性。

603
00:33:24,000 --> 00:33:28,970
Because now you need to do some work,
因为现在你需要做一些工作，

604
00:33:29,190 --> 00:33:30,660
and you don't want to be interrupted.
而且你不想被打扰。

605
00:33:33,190 --> 00:33:35,130
And basically what you do here,
基本上你在这里做的是什么，

606
00:33:35,480 --> 00:33:38,740
you raise a priority and you mask all the lower level interrupt,
你提高了一个优先级，并屏蔽了所有较低级别的中断。

607
00:33:38,750 --> 00:33:44,960
because I don't want to be interrupted by lower level interrupts when you
因为我不希望在执行时被更低级别的中断打断。

608
00:33:44,970 --> 00:33:45,480
do that.
好的，我会翻译的。

609
00:33:47,010 --> 00:33:52,990
And you save the registers for this current thread,
并且你保存了当前线程的寄存器，

610
00:33:55,900 --> 00:33:57,970
you dispatched to the handler of the interrupt,
你被派遣到中断处理程序。

611
00:33:58,740 --> 00:33:59,840
because you need to treat the interact.
因为你需要处理交互。

612
00:33:59,850 --> 00:34:00,960
In this particular case,
在这种特殊情况下，

613
00:34:00,970 --> 00:34:02,770
read the data from the network,
从网络中读取数据

614
00:34:05,140 --> 00:34:06,540
transfer the network packets,
传输网络数据包，

615
00:34:06,550 --> 00:34:08,060
from harvard to the canal buffers.
从哈佛到运河缓冲区。

616
00:34:09,440 --> 00:34:10,460
Once you're done with that,
一旦你完成了那个任务，

617
00:34:10,470 --> 00:34:12,020
you restore the registers,
你恢复寄存器的值，

618
00:34:13,470 --> 00:34:13,930
right?
对的？

619
00:34:16,550 --> 00:34:20,500
You clear current interrupt because you are done with it.
你清除当前中断是因为你已经处理完它了。

620
00:34:23,480 --> 00:34:26,830
You desirable, all interrupts are going to do your work.
你很理想，所有的中断都会为你工作。

621
00:34:27,520 --> 00:34:29,750
Do you don't want to be interrupted as a journal?
作为一名助教，您是否希望在工作期间不被打扰？

622
00:34:30,950 --> 00:34:32,960
And you restore the priority?
你要恢复优先级吗？

623
00:34:36,720 --> 00:34:38,190
You then clear the masks.
然后你清除掩码。

624
00:34:38,500 --> 00:34:38,730
Right?
对吗？

625
00:34:38,740 --> 00:34:41,450
The set, the mask which are clear here,
这里清除的是集合和掩码。

626
00:34:43,620 --> 00:34:46,970
the mask, which you said here to not be interrupted.
你在这里提到的“屏蔽”，是指不被中断的情况。

627
00:34:46,980 --> 00:34:48,050
Now you clear it,
现在你明白了。

628
00:34:48,330 --> 00:34:51,490
basically saying, now I can be interrupted by anything by any.
基本上是说，现在我可以被任何事情随时打断。

629
00:34:52,000 --> 00:34:52,180
Right?
对吗？

630
00:34:52,190 --> 00:34:55,000
And now I return from the interact.
现在我从交互中返回。

631
00:34:57,720 --> 00:34:58,230
That's it.
就是这样。

632
00:35:00,250 --> 00:35:01,030
It's very simple.
这很简单。

633
00:35:09,690 --> 00:35:11,520
And it's, again, an interim, though,
这又是一个临时的情况，不过，

634
00:35:11,530 --> 00:35:14,600
it was to think about it's a hardware involved context switch.
这是在考虑到涉及硬件的上下文切换。

635
00:35:18,340 --> 00:35:19,810
There is no separate state.
没有独立的状态。

636
00:35:19,820 --> 00:35:22,850
There is no decision of what to run next.
目前没有决定下一步要运行什么。

637
00:35:23,380 --> 00:35:24,100
It's very clear.
非常清楚。

638
00:35:24,110 --> 00:35:28,880
I am going to run the handle to treat the interrupt.
我将运行处理程序来处理中断。

639
00:35:30,980 --> 00:35:34,890
And i'm going to go back to this program.
我要回到这个程序。

640
00:35:34,900 --> 00:35:36,290
I just interrupted.
我刚刚打断了。

641
00:35:41,890 --> 00:35:43,070
So like we mentioned,
就像我们之前提到的一样，

642
00:35:43,730 --> 00:35:51,680
one way to interrupt a program now and give and give
现在中断程序并返回的一种方法是使用中断。

643
00:35:51,690 --> 00:35:57,480
control to another program is simple simply by using the time of interact.
通过使用交互时间，将控制权简单地转移到另一个程序。

644
00:35:58,050 --> 00:35:58,480
Right?
对吗？

645
00:35:58,880 --> 00:36:01,240
As the time I interrupt on the interrupt, happens,
当我在中断发生时中断时刻发生。

646
00:36:01,250 --> 00:36:02,520
time I interrupt happens,
当我中断发生时，

647
00:36:04,390 --> 00:36:10,640
you are going to kennel is going to execute this time or interrupt handle.
你将要执行的是内核中的这个时间或中断处理程序。

648
00:36:11,280 --> 00:36:13,700
And the time of interrupt handle or a pin,
中断处理的时间或引脚的时间

649
00:36:14,910 --> 00:36:16,980
it's doing some housekeeping.
正在进行一些清理工作。

650
00:36:17,460 --> 00:36:18,140
It's again,
又是这样，

651
00:36:19,290 --> 00:36:21,380
update some counters and things like that,
更新一些计数器和类似的东西。

652
00:36:21,780 --> 00:36:23,350
and then run new thread,
然后运行新的线程。

653
00:36:24,350 --> 00:36:24,670
right?
对的吗？

654
00:36:25,910 --> 00:36:28,580
And that you run new threads, what he's doing,
并且你运行新的线程，他在做什么。

655
00:36:28,830 --> 00:36:30,850
save the state of the current thread.
保存当前线程的状态。

656
00:36:34,580 --> 00:36:35,170
Initially,
最初，

657
00:36:35,180 --> 00:36:42,930
the state is a state into registers of the new thread and start the new threat.
状态是将新线程的状态保存到寄存器中，并启动新线程。

658
00:36:42,940 --> 00:36:44,090
And in between,
而在其中，

659
00:36:44,540 --> 00:36:46,860
you need to decide which instead you are going to run.
你需要决定你要运行哪一个。

660
00:36:50,340 --> 00:36:52,250
This is what we are talking about.
这就是我们正在讨论的内容。

661
00:36:55,750 --> 00:37:00,750
You initialize the registered field of that dcb or stack pointer
你需要初始化该dcb或堆栈指针的registered字段。

662
00:37:01,130 --> 00:37:03,040
with pc return address.
带有PC返回地址。

663
00:37:04,400 --> 00:37:06,110
Also, in this case,
此外，在这种情况下，

664
00:37:06,450 --> 00:37:09,220
is the functions and the function arguments.
是指函数和函数参数。

665
00:37:09,540 --> 00:37:13,290
You.out to this function and the point of the function to the list of
你可以将该函数的输出和函数的指针添加到列表中。

666
00:37:13,300 --> 00:37:14,250
function arguments,
函数参数

667
00:37:14,480 --> 00:37:17,270
which you put into registers, in this case, a zero and a one.
在这种情况下，你将这些值放入寄存器中，一个是零，一个是一。

668
00:37:19,890 --> 00:37:21,160
Then all about the stacks.
关于栈的一切。

669
00:37:21,170 --> 00:37:24,200
Again, the stack is in the memory, served by the processor.
栈位于内存中，并由处理器提供服务。

670
00:37:24,210 --> 00:37:29,030
You don't need to do anything other than pointing to the rockaric location
除了指向rockaric位置外，你不需要做任何其他事情。

671
00:37:29,040 --> 00:37:29,910
of the stack,
栈的

672
00:37:29,920 --> 00:37:31,270
which is a stack pointer.
栈指针是什么。

673
00:37:35,840 --> 00:37:37,710
Again, let's see what happens here.
再次，让我们看看这里会发生什么。

674
00:37:39,120 --> 00:37:40,390
In this particular case,
在这种特殊情况下，

675
00:37:40,400 --> 00:37:41,950
this is the old one.
这是旧的版本。

676
00:37:42,510 --> 00:37:46,100
It's basically we went through this one here, use yield,
基本上我们已经讲过这个了，使用yield。

677
00:37:46,510 --> 00:37:51,890
which is voluntarily relinquish the cpu to be used by another thread.
主动放弃CPU，以便让其他线程使用。

678
00:37:52,580 --> 00:37:54,220
And when this happened,
而当这发生时，

679
00:37:54,530 --> 00:37:56,330
you and you set up the new thread,
你和你的团队创建了新的线程。

680
00:37:56,590 --> 00:38:03,580
you are going to initialize the greatest,
你将要初始化最大值。

681
00:38:04,190 --> 00:38:10,000
the pointers and registers of the processors with the values from the pcb
将处理器的指针和寄存器的值与 PCB 中的值进行关联。

682
00:38:11,270 --> 00:38:12,940
from the thread control block.
来自线程控制块。

683
00:38:13,390 --> 00:38:13,670
Right?
对吗？

684
00:38:17,240 --> 00:38:20,870
And then you are going to run the newsletter.
然后你将负责运行通讯稿。

685
00:38:25,460 --> 00:38:27,100
So this thread road,
所以这个线程的路径，

686
00:38:28,330 --> 00:38:31,640
this is a route for all the thread routines.
这是所有线程例程的路由。

687
00:38:31,650 --> 00:38:33,770
So when you have to switch,
所以当你需要切换时，

688
00:38:34,070 --> 00:38:35,550
which from one thread to another thread,
从一个线程到另一个线程

689
00:38:35,560 --> 00:38:37,470
this is what you are going to execute.
这是你要执行的内容。

690
00:38:39,540 --> 00:38:40,070
Okay?
好的？

691
00:38:41,060 --> 00:38:47,030
The thread wrote what it takes to take this address to the function
线程将该地址传递给函数所需的内容写入了。

692
00:38:47,040 --> 00:38:49,450
of the thread you want to execute,
您想执行的线程的标识符，

693
00:38:49,460 --> 00:38:49,730
right?
对的？

694
00:38:49,740 --> 00:38:50,850
Remember a strategy,
记住一个策略，

695
00:38:50,860 --> 00:38:54,170
just a function you have to execute at the end of the day, right?
是的，这只是你在一天结束时需要执行的一个函数，对吗？

696
00:38:54,540 --> 00:38:56,530
You need to provide to this thread route,
你需要提供给这个线程一个路由。

697
00:38:57,060 --> 00:39:03,420
the function of the new thread to execute and the front and the arguments,
新线程的功能是执行前端和参数。

698
00:39:03,430 --> 00:39:03,650
right?
对的吗？

699
00:39:05,380 --> 00:39:07,120
Again, you lose some households,
再次，你失去了一些家庭。

700
00:39:07,790 --> 00:39:08,600
housekeeping.
清洁工作。

701
00:39:10,900 --> 00:39:13,090
You do the user mode switch.
你执行用户模式切换。

702
00:39:13,410 --> 00:39:15,100
So now you are in the kernel,
现在你进入了内核。

703
00:39:15,110 --> 00:39:17,460
so you need to go to the user mode,
所以你需要进入用户模式，

704
00:39:18,240 --> 00:39:20,560
because the application runs in the user mode,
因为应用程序运行在用户模式下，

705
00:39:20,850 --> 00:39:25,880
and then simply invoke the the thread function with the arguments.
然后只需使用参数调用线程函数即可。

706
00:39:26,440 --> 00:39:26,960
And you are done.
你已经完成了。

707
00:39:26,970 --> 00:39:33,280
And like I mentioned,
正如我之前提到的，

708
00:39:33,290 --> 00:39:37,080
the housekeeping includes things like recording the start time of the strategy,
清理工作包括记录策略的开始时间，

709
00:39:37,350 --> 00:39:45,270
how long the thread is spare run of the cpu while other statistics,
在其他统计数据的情况下，线程在CPU上空闲运行多长时间？

710
00:39:45,280 --> 00:39:47,510
number of context switching and things like that.
上下文切换的次数和类似的事情。

711
00:39:49,720 --> 00:39:50,160
Obviously,
显然，

712
00:39:50,170 --> 00:39:53,880
the struck stack will grow and shrink with the execution of a strategy.
随着策略的执行，堆栈会不断增长和缩小。

713
00:39:56,870 --> 00:40:01,430
And when you return from this function,
当你从这个函数返回时，

714
00:40:01,830 --> 00:40:05,040
you this is you call the thread finish, right?
你是在问这个是你调用的线程结束的意思吗？

715
00:40:05,050 --> 00:40:06,240
What is the thread finish?
线程结束是指线程执行完其任务或被显式地终止的状态。当线程完成其工作或达到终止条件时，它将进入线程结束状态。在此状态下，线程将不再执行任何指令，并且其资源将被释放。线程结束后，其相关的内存空间和系统资源将被回收，以便其他线程可以使用。

716
00:40:07,810 --> 00:40:10,130
Is you need to execute another thread,
你需要执行另一个线程吗？

717
00:40:10,830 --> 00:40:11,310
right?
对的？

718
00:40:11,830 --> 00:40:14,720
You need to find and wake up a sleeping threat.
你需要找到并唤醒一个休眠的线程。

719
00:40:18,660 --> 00:40:20,930
So now we really go into concurrence.
所以现在我们真的进入了并发状态。

720
00:40:24,330 --> 00:40:28,040
It's again, once you have multiple threads running at the same time,
当你有多个线程同时运行时，

721
00:40:30,790 --> 00:40:32,170
and have the kernel,
并且拥有内核，

722
00:40:33,370 --> 00:40:40,270
non deterministic decide at what point to interrupt a threat to suspend it
非确定性地决定在何时中断一个线程以暂停它

723
00:40:40,280 --> 00:40:41,550
and regime on other side.
和另一方的政权。

724
00:40:43,740 --> 00:40:44,930
Now you need to be very careful.
现在你需要非常小心。

725
00:40:46,360 --> 00:40:50,400
And you need to be careful because these threads can share the same data.
你需要小心，因为这些线程可以共享相同的数据。

726
00:40:52,590 --> 00:40:54,160
If there is no share, state,
如果没有共享状态，

727
00:40:54,660 --> 00:40:56,090
is fine, no problems.
没问题，一切都好。

728
00:40:57,090 --> 00:40:58,620
But if the state is shared,
但是如果状态是共享的，

729
00:40:59,010 --> 00:41:00,040
then you can run in,
那么你可以进来了。

730
00:41:00,050 --> 00:41:01,360
we can run into problems.
我们可能会遇到问题。

731
00:41:02,970 --> 00:41:03,320
Here.
在这里。

732
00:41:03,330 --> 00:41:05,720
Are you want to be very careful on the design?
你想在设计上非常小心吗？

733
00:41:06,180 --> 00:41:11,810
And you should try to what we call correctness by design,
你应该尝试我们所称之为设计正确性。

734
00:41:12,050 --> 00:41:14,280
meaning that we need to convince yourself.
意思是我们需要说服自己。

735
00:41:14,650 --> 00:41:15,650
Maybe in some case,
也许在某些情况下，

736
00:41:15,660 --> 00:41:19,540
you can even prove that the design of,
你甚至可以证明设计的

737
00:41:19,550 --> 00:41:27,990
despite the fact that multiple concurrent threads can access the same data,
尽管多个并发线程可以访问相同的数据，

738
00:41:30,420 --> 00:41:32,380
the design is correct, nothing bad.
设计是正确的，没有任何问题。

739
00:41:33,780 --> 00:41:33,990
Happened.
发生了。

740
00:41:34,850 --> 00:41:36,250
Recall again, different executions.
再次回顾，不同的执行过程。

741
00:41:36,260 --> 00:41:41,630
And the execution we really care about is b and c where threads
我们真正关心的是 b 和 c 的执行，其中涉及到线程。

742
00:41:41,640 --> 00:41:44,330
are interleaved or they are running at the same time.
它们是交错执行的，或者说它们同时运行。

743
00:41:44,340 --> 00:41:47,360
So they can touch the data at the same time.
这样他们可以同时访问数据。

744
00:41:50,250 --> 00:41:52,490
This is extremely important.
这非常重要。

745
00:41:53,100 --> 00:41:53,320
Right?
对吗？

746
00:41:53,690 --> 00:41:57,530
Here is an example to drive home.
这是一个例子，以便更好地理解。

747
00:41:57,540 --> 00:42:00,930
The point is that handling the concurrency is important.
重点是处理并发是很重要的。

748
00:42:01,700 --> 00:42:02,690
So think about idea.
所以思考一下这个想法。

749
00:42:02,700 --> 00:42:04,490
You have an idea.
你有一个想法。

750
00:42:06,320 --> 00:42:07,710
You have, obviously,
显然，你有

751
00:42:07,720 --> 00:42:12,450
with atm you want to either deposit or withdraw money.
使用自动取款机，您可以选择存款或取款。

752
00:42:14,160 --> 00:42:16,220
And the state assumes that it's in a database.
而且系统假设它在一个数据库中。

753
00:42:19,240 --> 00:42:20,680
So we need to be very careful here.
所以我们在这里需要非常小心。

754
00:42:23,070 --> 00:42:25,610
So you're supposed that you want to implement this functionality.
所以你打算实现这个功能。

755
00:42:29,110 --> 00:42:35,320
Then you need to process fundamentally,
那么你需要进行基本处理。

756
00:42:35,330 --> 00:42:41,180
you have to have an infinite loop where you wait for request from the users.
你需要一个无限循环，等待用户的请求。

757
00:42:42,040 --> 00:42:43,480
And then you process the requests.
然后你处理这些请求。

758
00:42:44,230 --> 00:42:44,430
Right?
对吗？

759
00:42:44,440 --> 00:42:47,270
And the request is basically specifying operation,
请求基本上是指定操作，

760
00:42:48,090 --> 00:42:49,050
withdraw,
取款

761
00:42:49,630 --> 00:42:50,400
or deposit,
或存款，

762
00:42:51,590 --> 00:42:53,830
account id as the amount.
将账户ID作为金额。

763
00:42:55,800 --> 00:42:56,150
Right?
对吗？

764
00:42:57,410 --> 00:42:59,930
This is you receive the request and then you process the request.
这是你收到请求后进行处理的过程。

765
00:43:02,450 --> 00:43:04,820
The process request is simple, right?
进程请求很简单，对吗？

766
00:43:04,830 --> 00:43:06,880
If it's a deposit,
如果是存款的话，

767
00:43:07,390 --> 00:43:14,580
you deposit the amount in account id if it's if it's withdrawal,
如果是存款，您将金额存入账户ID中。如果是取款，

768
00:43:16,910 --> 00:43:19,260
you subtract the amount from the deposit,
你从存款中扣除了这笔金额。

769
00:43:22,130 --> 00:43:23,560
the deposit functions.
存款功能。

770
00:43:23,850 --> 00:43:24,960
What is a deposit function?
存款功能是指允许用户将资金存入账户的一种功能。通过存款功能，用户可以将现金、支票或其他形式的支付方式存入银行账户或电子钱包中。存款功能通常由银行、金融机构或电子支付平台提供，并且可以通过柜台、ATM、手机应用程序或网上银行等渠道进行操作。存款功能的目的是方便用户存储资金，并使其能够随时进行取款或进行其他交易。

771
00:43:24,970 --> 00:43:25,920
How does it look like?
它看起来是什么样子？

772
00:43:26,500 --> 00:43:30,720
You get account id you get the account data structure from the account id
当你获得账户ID时，你可以通过该账户ID获取账户数据结构。

773
00:43:31,670 --> 00:43:34,260
and you add the amount to the balance.
然后你将这个金额加到余额上。

774
00:43:35,020 --> 00:43:38,620
And then you store the account reader account,
然后你将账户读取器的账户存储起来，

775
00:43:38,630 --> 00:43:40,660
modifies the account, store, the account.
修改账户、存储、账户。

776
00:43:45,150 --> 00:43:46,730
So if you do this thing,
如果你做这件事，

777
00:43:47,860 --> 00:43:48,180
right?
对的吗？

778
00:43:49,290 --> 00:43:50,660
At one given time,
在任何给定的时间，

779
00:43:51,550 --> 00:43:53,980
you are only to set up a single request.
你只需要设置一个单独的请求。

780
00:43:57,970 --> 00:43:59,430
So what is the problem with that?
那有什么问题吗？

781
00:44:00,210 --> 00:44:02,100
The problem is can be very slow.
问题可能会非常慢。

782
00:44:02,740 --> 00:44:03,770
And why is slow?
为什么会慢呢？

783
00:44:05,150 --> 00:44:06,660
Not because of computation.
不是因为计算。

784
00:44:06,950 --> 00:44:08,640
Adding numbers is super fast.
加法运算非常快速。

785
00:44:09,610 --> 00:44:09,990
Right?
对吗？

786
00:44:11,010 --> 00:44:15,820
What is slow is to access a database to get the account information
访问数据库获取账户信息的过程较慢。

787
00:44:15,830 --> 00:44:19,780
from the database and to store the account information to the database.
从数据库中获取账户信息，并将账户信息存储到数据库中。

788
00:44:21,470 --> 00:44:23,720
That is what is slow.
那就是慢的原因。

789
00:44:25,180 --> 00:44:26,410
And during this time,
在这段时间里，

790
00:44:27,350 --> 00:44:28,550
the program is blocked,
程序被阻塞了。

791
00:44:28,810 --> 00:44:33,650
just waiting for the database operation to complete.
只需等待数据库操作完成。

792
00:44:35,390 --> 00:44:42,860
The opportunity here is to overlap communication is a database io who is a computation.
这里的机会是将通信与数据库输入/输出重叠起来，这是一种计算。

793
00:44:43,680 --> 00:44:50,620
While you wait for an account to be read from the database or written
当您等待从数据库中读取或写入帐户时

794
00:44:50,630 --> 00:44:51,660
to the database,
到数据库中，

795
00:44:52,350 --> 00:44:56,290
you can very well serve as a users.
你可以很好地为用户提供服务。

796
00:44:56,710 --> 00:44:59,500
And by the way, the users actually, in this case,
顺便说一下，在这种情况下，实际上用户们...

797
00:45:00,320 --> 00:45:03,810
they can operate on different accounts on their own accounts.
他们可以在自己的账户上操作不同的账户。

798
00:45:06,220 --> 00:45:06,430
Right?
对吗？

799
00:45:06,910 --> 00:45:08,000
So how do you do that?
那么你是如何做到的呢？

800
00:45:09,670 --> 00:45:10,860
One way to do it,
有一种方法可以这样做，

801
00:45:10,870 --> 00:45:12,900
and this is typical is called event driven.
这种典型的方式被称为事件驱动。

802
00:45:14,580 --> 00:45:17,390
And with the event driven approach,
使用事件驱动的方法，

803
00:45:18,430 --> 00:45:20,150
you basically split the requests,
你基本上将请求分割开来，

804
00:45:21,880 --> 00:45:22,190
right?
对的？

805
00:45:24,150 --> 00:45:25,430
In multiple pieces.
分成多个部分。

806
00:45:26,020 --> 00:45:27,610
1 piece, for instance,
例如，一件商品。

807
00:45:27,950 --> 00:45:30,270
you start on the request is basically, for instance,
你的请求基本上是这样的，例如，

808
00:45:30,280 --> 00:45:34,500
this piece can only start the aisle.
这件物品只能在过道开始。

809
00:45:35,670 --> 00:45:37,910
It can only makes any questions, a database.
它只能生成任何问题的数据库。

810
00:45:37,920 --> 00:45:40,820
And then you switch, you end up,
然后你切换，你最终完成，

811
00:45:42,250 --> 00:45:47,550
and you wait for an event to come from the database,
然后你等待来自数据库的事件发生，

812
00:45:47,560 --> 00:45:54,550
basically saying from then the operating system saying this request set
基本上，操作系统从那时开始就在处理这个请求集合。

813
00:45:55,760 --> 00:45:59,070
has been completed.
已完成。

814
00:45:59,730 --> 00:46:00,640
Now there is a data.
现在有一些数据。

815
00:46:00,650 --> 00:46:03,680
Now you can go to continuous requests to read the data.
现在你可以进行连续的请求来读取数据。

816
00:46:05,680 --> 00:46:06,110
Okay?
好的？

817
00:46:07,480 --> 00:46:10,570
This is kind of the things you do it, right?
是的，这是你要做的事情，对吗？

818
00:46:11,240 --> 00:46:16,230
By hand, you are going to basically say that in the programming by hand,
手动编程，你基本上是要说通过手动编写代码。

819
00:46:16,240 --> 00:46:18,670
I think that explicitly in the program,
我认为在程序中明确地表示，

820
00:46:19,060 --> 00:46:23,530
you make sure that there is no part of the program that's wait
你要确保程序中没有任何等待的部分

821
00:46:24,120 --> 00:46:28,090
for is blocked further than I already quest to complete.
我已经尽力完成了进一步的任务。

822
00:46:33,830 --> 00:46:37,520
But now this way to write programs,
但是现在编写程序的方式，

823
00:46:40,660 --> 00:46:41,490
it's pretty hard.
这很困难。

824
00:46:42,420 --> 00:46:43,860
What if you miss the blocking aisle?
如果你错过了阻塞通道怎么办？

825
00:46:46,300 --> 00:46:47,480
Then you are going to block.
那么你将会被阻塞。

826
00:46:48,920 --> 00:46:50,440
The performance is going to suffer.
性能将会受到影响。

827
00:46:53,260 --> 00:46:54,010
What do you have?
你有什么？

828
00:46:54,820 --> 00:46:56,410
Your function?
你的函数是什么？

829
00:46:57,550 --> 00:46:59,150
Has hundreds of aisles.
有数百个过道。

830
00:47:00,400 --> 00:47:02,950
You need to split into hundreds of pieces,
你需要将其分成数百个部分。

831
00:47:03,220 --> 00:47:07,170
very hard to reason and be back.
很难理解和回溯。

832
00:47:08,720 --> 00:47:10,580
However, this is super fast.
然而，这非常快速。

833
00:47:11,190 --> 00:47:12,960
It's even faster than threads.
它甚至比线程更快。

834
00:47:13,940 --> 00:47:14,350
Right?
对吗？

835
00:47:14,980 --> 00:47:18,990
There is not even context switching between threats super fast.
线程之间的上下文切换非常快速。

836
00:47:19,510 --> 00:47:21,720
This is used when you really,
当你真的需要的时候使用它，

837
00:47:21,730 --> 00:47:25,160
really need performance like graphical program.
确实需要像图形程序一样的性能。

838
00:47:28,740 --> 00:47:29,250
Now,
现在，

839
00:47:29,260 --> 00:47:32,890
the obvious question is that and this is what we brought in this example.
显而易见的问题是什么，这就是我们在这个例子中所带来的。

840
00:47:33,640 --> 00:47:34,600
Then you may say,
那么你可以说，

841
00:47:35,650 --> 00:47:36,650
but what about threads?
但是线程呢？

842
00:47:36,660 --> 00:47:38,970
We just said that threads can handle concurrency.
我们刚刚说过线程可以处理并发。

843
00:47:38,980 --> 00:47:40,170
It's a unit of concurrence.
这是一个并发的单位。

844
00:47:41,850 --> 00:47:42,390
Indeed.
确实。

845
00:47:42,750 --> 00:47:44,010
And using threads,
并且使用线程，

846
00:47:44,540 --> 00:47:46,140
you can do this much easier.
你可以更轻松地完成这个任务。

847
00:47:47,670 --> 00:47:48,020
Right?
对吗？

848
00:47:50,080 --> 00:47:51,720
So let's see how this is done.
那么让我们看看这是如何完成的。

849
00:47:52,220 --> 00:47:52,630
Right?
对吗？

850
00:47:53,350 --> 00:47:56,500
Basically, you run each of this operation in different threads.
基本上，你可以将每个操作在不同的线程中运行。

851
00:47:58,340 --> 00:47:58,560
Right?
对吗？

852
00:47:58,570 --> 00:47:59,760
You can do another thread.
你可以创建另一个线程。

853
00:47:59,770 --> 00:48:01,560
Each operation can be another thread.
每个操作可以是另一个线程。

854
00:48:02,200 --> 00:48:03,230
You have a thread,
你有一个线程。

855
00:48:03,240 --> 00:48:08,270
you can have a thread pool to make sure that you don't have a huge number
你可以使用线程池来确保不会有大量的线程

856
00:48:08,280 --> 00:48:08,750
of threads.
线程的数量。

857
00:48:08,760 --> 00:48:10,270
So the system is going to crash,
所以系统要崩溃了，

858
00:48:10,420 --> 00:48:11,960
like we learned the last lecture.
就像我们在上一堂课学到的一样。

859
00:48:12,500 --> 00:48:13,270
But otherwise,
但是除此之外，

860
00:48:13,280 --> 00:48:18,680
the only thing you need to do each operation is a differential,
每个操作所需的唯一事物就是一个差分。

861
00:48:20,480 --> 00:48:22,470
because if you remember from what you learn,
因为如果你记得你所学的东西，

862
00:48:22,480 --> 00:48:26,830
what a thread is going to wait for an eye operation,
一个线程即将等待进行眼部手术。

863
00:48:26,990 --> 00:48:28,330
it's going to be suspended.
它将被暂停。

864
00:48:29,870 --> 00:48:33,940
And the kennel will let another thread to run.
并且狗舍将允许另一个线程运行。

865
00:48:35,370 --> 00:48:35,840
Okay?
好的？

866
00:48:37,230 --> 00:48:39,960
The problems are here is that,
问题在于，

867
00:48:40,710 --> 00:48:41,250
okay.
好的。

868
00:48:41,770 --> 00:48:48,060
Now, it's the two threads can access the same data.
现在，这两个线程可以访问相同的数据。

869
00:48:49,900 --> 00:48:51,330
Here is a very simple example.
这是一个非常简单的例子。

870
00:48:56,150 --> 00:49:02,230
We have maybe here two threads which are depositing in the same account.
我们可能有两个线程在向同一个账户存款。

871
00:49:03,010 --> 00:49:03,450
Right?
对吗？

872
00:49:05,020 --> 00:49:05,970
What happened here?
这里发生了什么事情？

873
00:49:05,980 --> 00:49:06,170
Right?
对吗？

874
00:49:06,180 --> 00:49:08,750
The straight one is reading the balance.
直接的那个正在读取余额。

875
00:49:11,390 --> 00:49:13,640
After that the threat to read the balance,
之后，威胁要读取余额，

876
00:49:15,960 --> 00:49:21,290
and then add the amount to the balance,
然后将该金额加到余额中，

877
00:49:21,300 --> 00:49:22,490
which is in other one,
这是在另一个中的哪一个？

878
00:49:24,540 --> 00:49:25,960
and then save the balance.
然后保存余额。

879
00:49:29,110 --> 00:49:31,860
But now I am going to resume to set one.
但是现在我要恢复设置一个。

880
00:49:31,870 --> 00:49:33,580
I said one, the first thing is doing,
我说的第一件事是开始行动。

881
00:49:33,590 --> 00:49:36,140
it's at its own amount to the balance,
它将自己的金额加到余额中。

882
00:49:38,150 --> 00:49:39,310
and then start the balance.
然后开始结算。

883
00:49:41,040 --> 00:49:41,830
What did they do?
他们做了什么？

884
00:49:41,840 --> 00:49:43,310
What is this code accomplish?
这段代码实现了什么功能？

885
00:49:44,330 --> 00:49:45,340
What is not accomplishing?
什么是未完成的任务？

886
00:49:46,270 --> 00:49:47,060
What happens here?
这里发生了什么？

887
00:49:48,270 --> 00:49:49,380
What is your own behavior?
你自己的行为是什么？

888
00:49:52,010 --> 00:49:54,440
I have an ebola thread one, say.
我有一个关于埃博拉的话题。

889
00:49:55,330 --> 00:49:58,820
I want to add the balance $100 thread to,
我想要添加一个余额为100美元的线程。

890
00:49:58,830 --> 00:50:03,920
I want to add to the balance $200.
我想要将账户余额增加200美元。

891
00:50:05,710 --> 00:50:08,780
I should have added to the balance behind the dollars.
我应该将金额加到美元后面。

892
00:50:09,640 --> 00:50:11,400
But if I execute the code, what happens?
但是如果我执行这段代码，会发生什么？

893
00:50:15,010 --> 00:50:16,190
A mountain is lost.
一座山消失了。

894
00:50:16,680 --> 00:50:17,440
Very good, simon.
非常好，Simon。

895
00:50:18,450 --> 00:50:20,080
So basically,
基本上，

896
00:50:20,090 --> 00:50:21,200
in our example,
在我们的例子中，

897
00:50:22,130 --> 00:50:27,910
only $100 are going to be added to the balance and the 200 will be lost.
只有100美元将被添加到余额中，而200美元将会丢失。

898
00:50:32,100 --> 00:50:32,640
Okay.
好的。

899
00:50:36,250 --> 00:50:37,680
There are many examples,
有很多例子，

900
00:50:38,520 --> 00:50:39,620
like in this example,
就像在这个例子中一样，

901
00:50:40,240 --> 00:50:42,360
thread one is x say,
线程一是x说，

902
00:50:42,370 --> 00:50:45,390
x one and set by is still.
x one 和 set by 仍然有效。

903
00:50:45,980 --> 00:50:47,350
This case is simple, right?
这个案例很简单，对吗？

904
00:50:47,360 --> 00:50:49,660
They are separate thread, separate data structure.
它们是独立的线程，独立的数据结构。

905
00:50:49,670 --> 00:50:50,650
They don't interfere.
它们不会干扰。

906
00:50:50,910 --> 00:50:51,850
Everything is fine.
一切都好。

907
00:50:54,030 --> 00:50:55,290
However, in this case,
然而，在这种情况下，

908
00:50:55,630 --> 00:50:58,770
they have operate on a common variable.
他们对一个共享变量进行操作。

909
00:51:02,090 --> 00:51:03,850
What are the possible values of x here?
这里的x可能有哪些可能的值？

910
00:51:08,440 --> 00:51:11,000
Why don't you take a little bit of time and answer this question?
为什么不花点时间回答这个问题呢？

911
00:51:17,390 --> 00:51:23,850
If I run thread one and thread a and thread b the initial value of y is 12.
如果我同时运行线程一、线程a和线程b，y的初始值为12。

912
00:51:26,060 --> 00:51:27,460
What results I can get here?
在这里我可以得到什么结果？

913
00:51:33,940 --> 00:51:34,550
One answer.
一个答案。

914
00:51:35,130 --> 00:51:36,270
Please more answers.
请提供更多的问题。

915
00:51:40,200 --> 00:51:40,830
Okay.
好的。

916
00:51:44,510 --> 00:51:45,210
Excellent.
很好。

917
00:51:46,490 --> 00:51:46,740
Right.
好的。

918
00:51:46,750 --> 00:51:49,220
So you need to take all why is 12?
所以你需要弄清楚为什么是12吗？

919
00:51:50,140 --> 00:51:51,750
But I still remember so in,
但是我仍然记得那样的事情，

920
00:51:52,100 --> 00:51:55,310
say, 3 days is running to completion.
说，还剩3天就要完成了。

921
00:51:56,790 --> 00:51:57,170
Right?
对吗？

922
00:52:01,480 --> 00:52:04,480
Then what you get is 13.
那么你得到的是13。

923
00:52:04,490 --> 00:52:04,870
Right?
对吗？

924
00:52:06,380 --> 00:52:08,020
Now say thread this,
现在说线程这个词。

925
00:52:08,030 --> 00:52:09,460
france before saturday.
在周六之前到达法国。

926
00:52:10,090 --> 00:52:10,810
What happens?
发生了什么事情？

927
00:52:11,140 --> 00:52:13,540
Why is to it over as well?
为什么它也结束了？

928
00:52:14,300 --> 00:52:16,750
Then you multiply by 2 service 4.
然后你将服务4乘以2。

929
00:52:17,980 --> 00:52:19,910
And then here you are going to have five,
然后在这里你将会有五个，

930
00:52:23,120 --> 00:52:23,560
right?
对的？

931
00:52:25,140 --> 00:52:32,860
Or you can only run the first instruction of b before you run a again,
或者你可以在再次运行a之前只运行b的第一条指令。

932
00:52:32,870 --> 00:52:36,860
you initialize y we stood over I 12 initial value,
你初始化了一个名为y的变量，初始值为12。

933
00:52:37,290 --> 00:52:38,500
and the result will be three.
结果将是三。

934
00:52:40,930 --> 00:52:42,280
You see pretty complicated,
你看起来很复杂，

935
00:52:42,290 --> 00:52:46,130
but also fun to write for to do this exercises.
但也很有趣写这些练习。

936
00:52:46,140 --> 00:52:46,650
Oops.
哎呀。

937
00:52:47,960 --> 00:52:49,600
But this is even simple examples.
但这些只是简单的例子。

938
00:52:49,610 --> 00:52:51,800
X is equal one and x equal two.
X等于一，X等于二。

939
00:52:52,890 --> 00:52:54,050
What is the result?
结果是什么？

940
00:52:54,060 --> 00:52:55,730
Not that means you get one or two.
这并不意味着你只能得到一个或两个。

941
00:52:56,670 --> 00:53:02,680
For fun, if the instruction to store data is not deterministic,
如果存储数据的指令不确定的话，那就只是为了好玩而已。

942
00:53:02,910 --> 00:53:05,390
you can even get something in between.
你甚至可以得到中间的东西。

943
00:53:06,440 --> 00:53:06,760
Right?
对吗？

944
00:53:08,190 --> 00:53:12,110
Sorry, if the instruction to store the data in memory is not atomic,
抱歉，如果将数据存储到内存的指令不是原子操作的话，

945
00:53:12,490 --> 00:53:14,330
I said, no, not their music, which is wrong.
我说的是，不是他们的音乐，这是错误的。

946
00:53:14,960 --> 00:53:15,820
It's nonatomic.
这是非原子操作。

947
00:53:17,190 --> 00:53:17,530
Right.
好的。

948
00:53:18,410 --> 00:53:20,090
We learn more about atomic instruction.
我们学习了更多关于原子指令的知识。

949
00:53:21,410 --> 00:53:22,320
So it's a mess.
所以这是一团糟。

950
00:53:28,200 --> 00:53:30,310
So to understand the concurrent program,
为了理解并发程序，

951
00:53:30,320 --> 00:53:32,270
like in this past example, you've seen,
就像你之前看到的例子一样，

952
00:53:32,280 --> 00:53:34,470
you need to know what is the indivisible operation?
你需要知道什么是不可分割操作吗？

953
00:53:34,600 --> 00:53:36,570
What is atomic operation?
原子操作是指在执行过程中不会被中断的操作。它要么完全执行成功，要么完全不执行，不存在部分执行的情况。原子操作通常用于多线程或并发编程中，以确保数据的一致性和并发操作的正确性。

954
00:53:36,580 --> 00:53:37,930
An atomic operation?
原子操作是指在执行过程中不会被中断的操作。它要么完全执行成功，要么完全不执行。在多线程或并发环境中，原子操作可以确保数据的一致性和可靠性。

955
00:53:38,660 --> 00:53:40,750
What is an atomic operation is indivisible?
原子操作是不可分割的操作。

956
00:53:40,760 --> 00:53:47,990
You can interrupt in between in the middle is a run or doesn't run at all.
你可以在运行过程中或者根本不运行时中断。

957
00:53:49,090 --> 00:53:51,610
That's all right.
没问题。

958
00:53:53,190 --> 00:53:59,490
You cannot just have upset of the output of running half of atomic operation.
你不能仅仅因为运行一半的原子操作的输出而感到不满意。

959
00:53:59,750 --> 00:54:02,180
Now, your output is the upset.
现在，你的输出是不正常的。

960
00:54:02,190 --> 00:54:10,270
Output is either as if the entire operation runs or none of the operation
输出要么是整个操作都执行完毕，要么是整个操作都没有执行。

961
00:54:10,280 --> 00:54:10,990
as a run at all.
完全无法运行。

962
00:54:12,360 --> 00:54:14,070
This is a fundamental building block.
这是一个基本的构建模块。

963
00:54:16,870 --> 00:54:18,090
On most machines,
在大多数计算机上，

964
00:54:18,330 --> 00:54:19,960
load and stores are atomic.
加载和存储是原子操作。

965
00:54:21,190 --> 00:54:27,640
The world exam wild examples in the previous slide cannot happen in this case,
前一张幻灯片中的世界考试狂野示例在这种情况下不会发生。

966
00:54:29,000 --> 00:54:30,400
but many atomics,
但是有很多原子操作，

967
00:54:30,410 --> 00:54:31,520
many instructions.
很多指令。

968
00:54:31,900 --> 00:54:36,450
And here we are talking about processor instructions are not atomic.
在这里，我们正在讨论处理器指令不是原子操作。

969
00:54:37,310 --> 00:54:38,910
Double precisions have not atomic,
双精度浮点数没有原子性。

970
00:54:38,920 --> 00:54:40,350
so you can interrupt in the middle.
所以你可以在中途中断。

971
00:54:40,940 --> 00:54:45,190
And there are instructions on the old computers run,
旧计算机上有运行指令。

972
00:54:45,200 --> 00:54:47,220
which copy a whole area.
复制整个区域。

973
00:54:48,380 --> 00:54:49,150
They are not atomic.
它们不是原子的。

974
00:54:50,600 --> 00:54:51,030
Right?
对吗？

975
00:54:51,410 --> 00:54:52,790
If bad things happen,
如果发生不好的事情，

976
00:54:52,800 --> 00:54:57,880
you can see the results only of a partially running instruction.
你只能看到部分执行指令的结果。

977
00:55:02,210 --> 00:55:02,650
Now,
现在，

978
00:55:04,160 --> 00:55:08,420
if we run, if we know only what are the atomic instructions,
如果我们运行，只知道原子指令，

979
00:55:08,430 --> 00:55:09,420
this is helpful,
这很有帮助，

980
00:55:10,340 --> 00:55:11,610
but it's still not enough,
但这还不够，

981
00:55:12,320 --> 00:55:15,460
because you can see that atomicity,
因为你可以看到原子性，

982
00:55:15,470 --> 00:55:22,200
it's a very convenient way to control the access to a share of variables.
这是一种非常方便的方式来控制对一组变量的访问。

983
00:55:23,700 --> 00:55:24,380
Because atomistic,
由于原子性，

984
00:55:24,390 --> 00:55:29,100
if I can say all this bunch of instructions is not going to be interrupted.
如果我能说所有这一堆指令不会被中断。

985
00:55:29,110 --> 00:55:32,610
I don't need to be worried that someone will read.
我不需要担心有人会阅读。

986
00:55:32,620 --> 00:55:33,190
All right?
好吗？

987
00:55:33,490 --> 00:55:35,220
Or I am executing these operations.
或者我正在执行这些操作。

988
00:55:36,130 --> 00:55:37,410
You remember how these are called?
你还记得这些被称为什么吗？

989
00:55:38,150 --> 00:55:39,400
It's critical section, right?
是的，这是临界区。

990
00:55:42,310 --> 00:55:43,340
The way to do it,
做这件事的方法是，

991
00:55:43,680 --> 00:55:45,470
in general, you do is, example, is a lock.
通常情况下，你所做的是，例如，使用锁。

992
00:55:46,640 --> 00:55:47,520
You have one lock,
你有一个锁，

993
00:55:48,680 --> 00:55:50,110
and you acquire the lock,
并且你获得了锁定。

994
00:55:51,240 --> 00:55:53,100
and you execute some code.
然后你执行一些代码。

995
00:55:54,180 --> 00:55:55,210
While you have the lock,
在你拥有锁的时候，

996
00:55:55,220 --> 00:55:56,810
no one else can acquire the lock.
没有其他人可以获取锁。

997
00:55:59,480 --> 00:56:02,250
So no one else may be able to execute these instructions.
因此，其他人可能无法执行这些指令。

998
00:56:03,260 --> 00:56:04,680
And then you release a lock when you are done.
当你完成后，释放锁。

999
00:56:07,500 --> 00:56:09,260
And the threads, libraries,
以及线程、库，


1000
00:56:09,570 --> 00:56:11,610
they do have the lock,
他们确实有这把锁。

1001
00:56:12,260 --> 00:56:12,970
primitive.
原语。

1002
00:56:18,140 --> 00:56:19,500
How do you fix it?
你如何修复它？

1003
00:56:20,000 --> 00:56:21,350
The previous example,
之前的例子，

1004
00:56:21,650 --> 00:56:26,720
remember, when multiple threats can run this at the same time,
请记住，当多个线程同时运行时，

1005
00:56:27,150 --> 00:56:32,320
they can run at the same time and then can access data at the same time.
它们可以同时运行，并且可以同时访问数据。

1006
00:56:35,840 --> 00:56:37,100
Simply simple,
简单而简单，

1007
00:56:37,920 --> 00:56:38,340
right?
对的吗？

1008
00:56:39,000 --> 00:56:44,040
You acquire the lock before you execute all the instruction on operation,
在执行操作的所有指令之前，您需要先获取锁。

1009
00:56:44,050 --> 00:56:45,000
on an account,
在一个账户上，

1010
00:56:45,750 --> 00:56:46,880
and then you release a clock.
然后你释放一个时钟。

1011
00:56:49,190 --> 00:56:52,580
This is what in the middle of the acquiring and releasing the lock
这是在获取和释放锁之间的过程中发生的事情。

1012
00:56:52,590 --> 00:56:54,140
is called critical section.
被称为临界区。

1013
00:56:57,050 --> 00:56:59,720
If multiple threads want to execute the same code,
如果多个线程想要执行相同的代码，

1014
00:57:00,010 --> 00:57:01,710
only one will execute at a given time.
在给定的时间内只有一个会被执行。

1015
00:57:04,140 --> 00:57:07,260
Very simple on thread,
非常简单的线程，

1016
00:57:07,270 --> 00:57:12,050
and then thread b and thread cok
然后线程 b 和线程 cok

1017
00:57:15,500 --> 00:57:19,010
but you need all this value of the same lock or the same lock
但是你需要将所有这些值锁定在同一个锁或同一个锁上。

1018
00:57:19,020 --> 00:57:23,290
should be shared by all states want to access the same critical
应该由所有想要访问相同关键资源的状态共享

1019
00:57:26,420 --> 00:57:26,770
section.
部分。

1020
00:57:27,990 --> 00:57:28,720
So remember,
所以记住，

1021
00:57:29,630 --> 00:57:30,160
okay.
好的。

1022
00:57:31,180 --> 00:57:35,250
These 23 notions synchronization using a topping operation to ensure
这23个概念使用一种称为"topping"操作来实现同步。

1023
00:57:35,260 --> 00:57:39,110
cooperation between threats for
威胁之间的合作

1024
00:57:39,120 --> 00:57:41,470
now only slows and stores,
现在只是减速和存储。

1025
00:57:41,480 --> 00:57:44,500
we assume are atomic mutual exclusion.
我们假设是原子互斥的。

1026
00:57:44,900 --> 00:57:48,580
We ensure that only one thread as a particular thing at a given time.
我们确保在任意时刻只有一个线程拥有某个特定的东西。

1027
00:57:50,250 --> 00:57:50,620
Right?
对吗？

1028
00:57:50,870 --> 00:57:55,660
This means that one thread exclude another thread from running the same code.
这意味着一个线程排斥另一个线程运行相同的代码。

1029
00:57:56,430 --> 00:58:02,280
And critical section is a either side of the mutual exclusion coin.
关键区域是互斥性的两面硬币。

1030
00:58:02,830 --> 00:58:05,070
And critical section basically define,
临界区基本上是定义了

1031
00:58:05,080 --> 00:58:08,790
which is the sequence of instruction on the code,
代码中的指令顺序是什么？

1032
00:58:09,220 --> 00:58:14,710
which is can be executed by a single thread at a given time.
在给定时间内只能由一个线程执行的任务。

1033
00:58:19,450 --> 00:58:20,650
Here is another example,
这是另一个例子，

1034
00:58:21,650 --> 00:58:28,280
thread a and thread b thread a start with I initialize to zero,
线程a和线程b。线程a从I初始化为零开始。

1035
00:58:28,950 --> 00:58:30,270
and then adds one.
然后再加一。

1036
00:58:31,190 --> 00:58:32,530
Has a loop adds one.
循环增加一个。

1037
00:58:33,360 --> 00:58:38,850
And when you get to ten exits and say, brings a wings,
当你到达第十个出口时，说出"带来一双翅膀"。

1038
00:58:39,550 --> 00:58:42,830
thread b is doing similar things,
线程 b 正在做类似的事情，

1039
00:58:42,840 --> 00:58:44,110
but decrement.
但是递减。

1040
00:58:45,210 --> 00:58:47,410
Start with I zero, decrements it.
从零开始，将其递减。

1041
00:58:47,840 --> 00:58:53,380
And if you reach to minus ten bos both of them,
如果你把它们都减到负十，

1042
00:58:53,390 --> 00:58:54,700
they share these variables.
它们共享这些变量。

1043
00:58:57,240 --> 00:58:58,380
What is the result here?
这里的结果是什么？

1044
00:58:59,730 --> 00:59:00,950
Who is a or b
谁是a或b？

1045
00:59:09,170 --> 00:59:13,490
let's only 200 minutes remaining.
只剩下200分钟了。

1046
00:59:13,500 --> 00:59:16,660
So let's get a little bit of energy.
那么让我们来获得一些能量吧。

1047
00:59:20,320 --> 00:59:21,750
Could be easier, right?
可能会更容易，对吧？

1048
00:59:22,100 --> 00:59:22,940
You cannot know.
你无法知道。

1049
00:59:24,000 --> 00:59:24,400
Right?
对吗？

1050
00:59:28,190 --> 00:59:29,580
Let me ask you another question.
让我再问你一个问题。

1051
00:59:32,720 --> 00:59:35,090
Are you guaranteed that at least wanna win?
你能保证至少想要赢吗？

1052
00:59:47,050 --> 00:59:47,530
Now?
现在吗？

1053
00:59:48,990 --> 00:59:52,250
Excellent, at least on induction.
很好，至少在归纳推理方面是优秀的。

1054
00:59:52,640 --> 00:59:53,110
Now,
现在，

1055
00:59:54,600 --> 00:59:57,110
because in the worst case, you see these three instruction,
因为在最坏的情况下，你会看到这三条指令。

1056
00:59:57,120 --> 00:59:58,670
I is equal I plus one.
我等于我加一。

1057
00:59:58,970 --> 01:00:00,310
I is equally die medicine.
我同样需要药物。

1058
01:00:00,630 --> 01:00:04,100
What happens if you have contact switching
如果发生了上下文切换，会发生什么情况？

1059
01:00:04,360 --> 01:00:07,950
and between saturday and thread b and this thread only execute
在星期六和线程B之间，只有这个线程执行。

1060
01:00:07,960 --> 01:00:08,630
this instruction.
这个指令。

1061
01:00:10,470 --> 01:00:10,860
Right?
对吗？

1062
01:00:11,950 --> 01:00:13,750
You are get stuck with the same value.
你被困在相同的数值中。

1063
01:00:14,300 --> 01:00:15,060
You never finish.
你永远不会完成。

1064
01:00:15,750 --> 01:00:16,270
None of this.
没有这些。

1065
01:00:16,280 --> 01:00:16,950
Let's finish this.
让我们完成这个。

1066
01:00:19,400 --> 01:00:19,760
Excellent.
非常好。

1067
01:00:19,770 --> 01:00:20,280
Thank you.
谢谢你。

1068
01:00:31,250 --> 01:00:32,760
It's again, this is the inner loop,
又是这个了，这是内循环。

1069
01:00:32,770 --> 01:00:35,600
and this is we see what is happening under the hood.
这样我们就能看到底层发生了什么。

1070
01:00:36,200 --> 01:00:39,070
Although the fact that what you see is that in the program,
尽管你在程序中看到的是这样的事实，

1071
01:00:39,600 --> 01:00:40,910
it's even more subtle.
这更加微妙。

1072
01:00:41,380 --> 01:00:43,530
Because when he sees a program in the previous slide,
因为当他看到前一张幻灯片上的程序时，

1073
01:00:43,540 --> 01:00:45,330
let me just we should have said,
让我来，我们应该说，

1074
01:00:45,630 --> 01:00:49,360
when you see this, I I plus one or I I minus one,
当你看到这个时，我会将I加一或者I减一。

1075
01:00:49,720 --> 01:00:52,380
actually, maybe you think that this is also atomic,
实际上，也许你认为这也是原子操作，

1076
01:00:53,750 --> 01:00:56,970
that means executes to completion,
这意味着执行直到完成。

1077
01:00:58,930 --> 01:00:59,820
cannot be interrupted.
不能被中断。

1078
01:01:01,060 --> 01:01:01,850
It's not true.
这是不真实的。

1079
01:01:01,860 --> 01:01:04,530
Remember, only lord loves and stores are at all.
记住，只有上帝爱和储存是永恒的。

1080
01:01:05,410 --> 01:01:05,840
Actually,
实际上，

1081
01:01:05,850 --> 01:01:09,920
things are even more complicated because I and I plus one and I is I
事情变得更加复杂，因为我和我加一再加上我就是我。

1082
01:01:09,930 --> 01:01:12,940
minus one can be interrupted in the middle.
负一可以在中间被中断。

1083
01:01:14,040 --> 01:01:15,250
And this is one example,
这是一个例子，

1084
01:01:17,570 --> 01:01:17,950
right?
是的，正确。

1085
01:01:18,610 --> 01:01:19,930
Where you execute,
你在哪里执行，

1086
01:01:21,570 --> 01:01:25,420
you interleave the instruction from three and three b and the result
你将指令从三个和三个B交错执行，并得到结果。

1087
01:01:25,430 --> 01:01:27,390
here is what?
这是什么？

1088
01:01:29,560 --> 01:01:30,790
Nothing changes.
没有任何变化。

1089
01:01:40,810 --> 01:01:41,980
Because in the middle,
因为在中间，

1090
01:01:43,140 --> 01:01:44,640
you read the same values,
你读取了相同的值，

1091
01:01:46,500 --> 01:01:48,820
you write the same at the same location.
你在相同的位置写了相同的内容。

1092
01:01:48,830 --> 01:01:49,860
And in the middle,
而在中间，

1093
01:01:50,780 --> 01:01:52,810
we want is a value on and is abstract on.
我们想要的是一个具体的值和一个抽象的概念。

1094
01:01:53,890 --> 01:01:54,620
So nothing changed.
所以没有任何变化。

1095
01:01:56,680 --> 01:01:57,070
Okay?
好的？

1096
01:02:00,030 --> 01:02:00,760
So,
所以，

1097
01:02:03,780 --> 01:02:04,850
and typically,
通常情况下，

1098
01:02:04,860 --> 01:02:06,490
this is called race conditions.
这被称为竞态条件。

1099
01:02:06,500 --> 01:02:08,210
When you have two strides attempting blocks,
当你有两个步幅尝试阻塞时，

1100
01:02:08,220 --> 01:02:13,030
the same data at the same time with one of them performing the right.
同时使用相同的数据，其中一个执行正确的操作。

1101
01:02:18,050 --> 01:02:19,210
So how do you fix it?
那么你要如何修复它呢？

1102
01:02:19,770 --> 01:02:24,240
We know now you put a lock that is fix it.
我们现在知道你放了一个固定的锁。

1103
01:02:27,270 --> 01:02:29,020
Not really, because we discussed, right?
不是真的，因为我们已经讨论过了，对吧？

1104
01:02:29,030 --> 01:02:31,580
You can execute this block of instruction,
你可以执行这个指令块。

1105
01:02:31,590 --> 01:02:32,860
ysy plus one,
ysy 加一,

1106
01:02:33,750 --> 01:02:36,190
and then execute the second block of instruction.
然后执行第二个指令块。

1107
01:02:36,890 --> 01:02:40,670
And it's true that you are going to see the changes.
而且你将会看到这些变化是真实存在的。

1108
01:02:41,820 --> 01:02:44,560
But before they execute the next while,
但在执行下一个 while 循环之前，

1109
01:02:47,740 --> 01:02:50,270
the value was updated to the same value.
该值已更新为相同的值。

1110
01:02:53,400 --> 01:02:53,800
Right?
对吗？

1111
01:02:58,070 --> 01:02:59,430
And the main.here,
这里是主要的.h文件。

1112
01:02:59,440 --> 01:03:02,890
and I need probably to got it be faster.
我可能需要让它变得更快。

1113
01:03:03,390 --> 01:03:05,430
Concurrency is hard like, look,
并发编程很难，就像这样，

1114
01:03:05,750 --> 01:03:07,070
these simple examples.
这些简单的例子。

1115
01:03:07,960 --> 01:03:09,400
There are a bunch of instructions,
有一堆指令。

1116
01:03:09,410 --> 01:03:10,440
just a few instructions.
只是一些指示。

1117
01:03:10,450 --> 01:03:10,800
What?
什么？

1118
01:03:11,470 --> 01:03:13,290
Three instruction, four instructions,
三个指令，四个指令，

1119
01:03:13,890 --> 01:03:14,890
even that is hard.
即使那也很困难。

1120
01:03:15,890 --> 01:03:17,900
Now, imagine that you have thousands,
现在，想象一下你有成千上万个...

1121
01:03:18,390 --> 01:03:20,460
tens of thousands of instructions.
数以万计的指令。

1122
01:03:22,890 --> 01:03:24,680
There are many such issues.
有许多类似的问题。

1123
01:03:27,370 --> 01:03:30,870
And these are just some examples.
这只是一些例子。

1124
01:03:30,880 --> 01:03:34,630
He says there are 25 radiation therapy machines.
他说有25台放射治疗机。

1125
01:03:36,180 --> 01:03:38,640
As a result of this kind of race condition,
由于这种竞态条件的存在，

1126
01:03:38,650 --> 01:03:42,070
concurrency of not being careful,
不小心的并发性

1127
01:03:43,950 --> 01:03:50,880
accessing the same variable from different threads resulted in an overdose,
从不同的线程访问同一个变量导致了过度使用。

1128
01:03:51,510 --> 01:03:52,530
which cause even death.
这甚至可能导致死亡。

1129
01:03:55,580 --> 01:03:58,340
It was improper synchronization between the input thread
这是输入线程之间的不正确同步。

1130
01:03:59,230 --> 01:04:03,070
and the positioning high software where to apply the
定位高软件适用于哪些领域？

1131
01:04:03,920 --> 01:04:10,240
radiation marked by find a priority inversion.
辐射标记发现了一个优先级反转。

1132
01:04:12,640 --> 01:04:13,180
Proud you.
为你感到骄傲。

1133
01:04:13,190 --> 01:04:16,240
Inversion here means that basically,
这里的"逆序"基本上意味着，

1134
01:04:16,250 --> 01:04:17,320
what happens?
发生了什么事情？

1135
01:04:17,840 --> 01:04:19,680
You have a high priority job.
你有一个高优先级的任务。

1136
01:04:19,690 --> 01:04:21,280
A high will learn more about that.
高手会更多地了解这个。

1137
01:04:22,120 --> 01:04:30,550
A high priority thread waiting for something from a low priority thread.
一个高优先级的线程正在等待来自低优先级线程的某个东西。

1138
01:04:31,570 --> 01:04:33,700
But the hybrid thread contains a lock,
但是混合线程包含一个锁。

1139
01:04:33,710 --> 01:04:34,740
maintains a lock,
维护一个锁

1140
01:04:36,100 --> 01:04:40,780
which is required by the operator threat to update that value or to do
操作员威胁要更新该值或执行某个操作。

1141
01:04:40,790 --> 01:04:44,310
something for its high priority thread.
为其高优先级线程提供一些东西。

1142
01:04:45,480 --> 01:04:47,120
Wait, but you cannot do it,
抱歉，我可以帮你翻译英文成中文。有什么需要我帮忙的吗？

1143
01:04:48,410 --> 01:04:53,200
because the critical section is owned by high priority threat.
因为临界区被高优先级线程占用。

1144
01:04:53,580 --> 01:04:54,430
So you get hacked.
所以你被黑客攻击了。

1145
01:04:56,030 --> 01:04:57,100
It's another things,
这是另一件事情，

1146
01:04:58,330 --> 01:05:00,090
toyota and control acceleration.
丰田和控制加速。

1147
01:05:00,400 --> 01:05:08,960
This was 256,000 lines of seek out and whatever 11,000 global variables.
这是256,000行的查找代码和大约11,000个全局变量。

1148
01:05:11,070 --> 01:05:13,300
So here it is inconsistent with your exclusion.
所以这与你的排除不一致。

1149
01:05:14,980 --> 01:05:15,400
Right?
对吗？

1150
01:05:16,090 --> 01:05:18,360
Acceleration was uncontrollable, right?
加速度是无法控制的，对吗？

1151
01:05:18,370 --> 01:05:21,910
You just doesn't respond.
你只是没有回应。

1152
01:05:21,920 --> 01:05:23,190
You click a little bit.
你点击一下。

1153
01:05:23,800 --> 01:05:26,080
The carrot takes off,
胡萝卜起飞了，

1154
01:05:26,510 --> 01:05:30,030
like you would floor the acceleration battle.
就像你会全力加速一样。

1155
01:05:34,890 --> 01:05:39,270
Next, let's look about a little bit more sophisticated things.
接下来，让我们来看一些更复杂的东西。

1156
01:05:41,580 --> 01:05:44,430
Let's look at about queue,
让我们来看一下队列。

1157
01:05:45,370 --> 01:05:46,460
producer, consumer,
生产者，消费者

1158
01:05:47,280 --> 01:05:48,330
with a banded buffer.
使用带状缓冲区。

1159
01:05:48,590 --> 01:05:49,870
Why this is important.
为什么这很重要。

1160
01:05:50,090 --> 01:05:51,310
Remember about pipes.
记得使用管道。

1161
01:05:51,790 --> 01:05:53,830
Last time, we learned about pipes.
上次，我们学习了关于管道的内容。

1162
01:05:54,410 --> 01:05:55,300
Pipes is above,
管道在上面，

1163
01:05:55,840 --> 01:05:56,500
is a cube.
是一个立方体。

1164
01:05:57,710 --> 01:05:59,160
You put that one in the queue,
你把那个放进队列中。

1165
01:05:59,170 --> 01:06:03,760
one end of the queue and get the data from the other end of the queue.
从队列的一端放入数据，从队列的另一端获取数据。

1166
01:06:06,180 --> 01:06:07,020
When you do a pipe,
当你使用管道时，

1167
01:06:07,030 --> 01:06:10,180
all this is also and you do the piping between different pieces.
所有这些也是你负责在不同组件之间进行管道传输。

1168
01:06:10,750 --> 01:06:16,090
When you change different shell comments,
当你切换不同的shell注释时，

1169
01:06:16,100 --> 01:06:17,130
the same thing happened.
发生了同样的事情。

1170
01:06:20,010 --> 01:06:24,600
And we'll have another example of cover machine later.
稍后我们将再次介绍一个覆盖机的示例。

1171
01:06:25,010 --> 01:06:25,500
Okay?
好的？

1172
01:06:28,020 --> 01:06:29,100
And there are many examples.
还有许多例子。

1173
01:06:29,370 --> 01:06:30,270
But this is what you want.
但这是你想要的。

1174
01:06:32,140 --> 01:06:35,720
Ideally, you put at one end of the buffer,
理想情况下，您将数据放置在缓冲区的一端。

1175
01:06:35,730 --> 01:06:38,480
and you read from a different end of the buffer, and typically,
你从缓冲区的另一端读取数据，并且通常情况下，

1176
01:06:38,490 --> 01:06:39,720
there is circular buffers.
有循环缓冲区。

1177
01:06:40,380 --> 01:06:41,650
There is years to handle.
有很多年要处理。

1178
01:06:45,620 --> 01:06:48,370
You have immediately to deal with several problems,
你需要立即处理几个问题，

1179
01:06:48,380 --> 01:06:49,690
how to tell if full,
如何判断是否已满？

1180
01:06:51,130 --> 01:06:53,120
how to take the buffer is empty.
如何判断缓冲区是否为空。

1181
01:06:55,870 --> 01:06:57,430
What to do, if is a buffer is full?
如果缓冲区已满，应该怎么办？

1182
01:06:57,440 --> 01:06:58,230
What to do is above?
上面是什么要做的事情？

1183
01:06:58,240 --> 01:06:58,830
For example,
例如，

1184
01:06:59,740 --> 01:07:00,670
one needs to be atomic.
需要保证原子性。

1185
01:07:04,090 --> 01:07:10,980
Let's take a simply that let's think about what is the simple implementation.
让我们来举一个简单的例子，思考一下什么是简单的实现方式。

1186
01:07:10,990 --> 01:07:12,560
All right?
好吗？

1187
01:07:13,190 --> 01:07:17,210
The producer, what you need to do while the buffer is full,
当缓冲区已满时，生产者需要做的是：

1188
01:07:19,000 --> 01:07:19,880
don't do anything.
不要做任何事情。

1189
01:07:20,470 --> 01:07:23,230
You cannot put another item because you don't have anywhere to put it.
你无法放置另一个物品，因为你没有地方放它。

1190
01:07:25,080 --> 01:07:26,450
If the buffer is not full,
如果缓冲区不满，

1191
01:07:26,460 --> 01:07:27,650
you incure the item,
你承担了该物品。

1192
01:07:30,190 --> 01:07:32,280
because you need to do this operation,
因为你需要执行这个操作，

1193
01:07:32,290 --> 01:07:33,780
you want to be atomic.
你想要保持原子性。

1194
01:07:35,870 --> 01:07:39,330
You are going to guard it,
你将要守卫它，

1195
01:07:39,660 --> 01:07:41,850
be a a with a lock.
成为一个带锁的对象。

1196
01:07:46,780 --> 01:07:48,750
Can anyone tell me why you need to do this?
有人可以告诉我为什么你需要这样做吗？

1197
01:07:50,880 --> 01:07:51,650
What can happen?
会发生什么？

1198
01:07:52,170 --> 01:07:53,500
What can happen if I don't look?
如果我不看会发生什么？

1199
01:08:08,050 --> 01:08:09,360
You may have buffer overflow.
你可能遇到了缓冲区溢出问题。

1200
01:08:10,300 --> 01:08:10,870
Excellent.
非常好。

1201
01:08:15,930 --> 01:08:16,130
Right?
对吗？

1202
01:08:16,140 --> 01:08:18,610
Because you can have two producers, two threads,
因为你可以有两个生产者，两个线程。

1203
01:08:22,050 --> 01:08:25,190
and one execute while both executed, while buffered.
当两个操作都被执行时，其中一个是执行操作，而另一个是缓冲操作。

1204
01:08:26,780 --> 01:08:27,730
Both are happy.
两个都很开心。

1205
01:08:29,030 --> 01:08:31,890
The buffer is just one place for only one item,
缓冲区只能容纳一个项目。

1206
01:08:34,450 --> 01:08:34,800
right?
是的，没错。

1207
01:08:35,340 --> 01:08:39,310
But both are going to pass of the wild.
但两者都会经历一段艰难的时期。

1208
01:08:42,490 --> 01:08:44,240
But now, once is interrupted,
但是现在，一旦被中断，

1209
01:08:46,190 --> 01:08:47,030
obviously, right?
显然，对吗？

1210
01:08:47,640 --> 01:08:50,120
And the other one is going to include the item.
另一个将包括该项目。

1211
01:08:51,540 --> 01:08:52,920
Now, the buffer is full.
现在，缓冲区已满。

1212
01:08:53,860 --> 01:08:55,030
But for the first,
但是首先，

1213
01:08:55,040 --> 01:08:58,470
for the soldiers interrupted or were suspended resumes,
对于被打断或暂停的士兵简历，

1214
01:08:59,320 --> 01:09:01,720
he doesn't know he's going to try to add another item,
他不知道他打算尝试添加另一项。

1215
01:09:03,470 --> 01:09:04,450
and I have the overflow.
我遇到了溢出问题。

1216
01:09:06,240 --> 01:09:06,760
Okay?
好的？

1217
01:09:07,320 --> 01:09:09,150
Now is at the queue, the same.
现在在队列中，一样的。

1218
01:09:09,160 --> 01:09:11,990
You do lock for this critical section,
你需要为这个关键区域加锁。

1219
01:09:12,000 --> 01:09:14,240
and you wait now is a buffer is empty.
你现在等待的是一个缓冲区为空。

1220
01:09:14,250 --> 01:09:15,240
You don't do anything.
你什么都不需要做。

1221
01:09:15,250 --> 01:09:17,750
If the buffer is not empty, you are going to delete it.
如果缓冲区不为空，你将要删除它。

1222
01:09:20,610 --> 01:09:20,980
Right.
好的。

1223
01:09:27,600 --> 01:09:28,000
Now,
现在，

1224
01:09:28,990 --> 01:09:31,420
let's assume now for this crowd,
让我们现在假设针对这个群体，

1225
01:09:32,790 --> 01:09:33,750
if we do this,
如果我们这样做，

1226
01:09:36,230 --> 01:09:38,220
will we ever come out of the way?
我们会走出困境吗？

1227
01:09:39,590 --> 01:09:40,260
This is a question.
这是一个问题。

1228
01:09:59,690 --> 01:10:01,280
Say that is nothing is a buffer.
说"如果没有缓冲区"。

1229
01:10:06,840 --> 01:10:07,210
Right?
对吗？

1230
01:10:10,640 --> 01:10:11,550
Then that's fine, right?
那么这样就可以了，对吗？

1231
01:10:11,560 --> 01:10:13,670
You are going to build a buffer.
你要构建一个缓冲区。

1232
01:10:16,710 --> 01:10:18,230
But let me ask you this question.
但是让我问你这个问题。

1233
01:10:18,880 --> 01:10:21,900
Maybe not an answer I see.
也许不是我所期望的答案。

1234
01:10:23,470 --> 01:10:26,370
Now you can block on the consumer exact,
现在你可以在消费者上进行阻塞。

1235
01:10:28,280 --> 01:10:29,870
let's say that the queue is empty,
假设队列是空的，

1236
01:10:31,260 --> 01:10:32,620
and the consumer executes,
并且消费者执行，

1237
01:10:33,390 --> 01:10:34,430
it acquires a lock,
它获取了一个锁。

1238
01:10:37,240 --> 01:10:41,830
and then it executes a while and is stuck,
然后它执行了一个while循环并且被卡住了。

1239
01:10:43,680 --> 01:10:45,120
because there is nothing in the buffer.
因为缓冲区中没有任何内容。

1240
01:10:46,120 --> 01:10:49,900
The only one who can put something in the buffer a is a producer.
唯一能够向缓冲区 a 中放入数据的是生产者。

1241
01:10:50,620 --> 01:10:51,900
But in order for the producer,
但是为了生产者，

1242
01:10:51,910 --> 01:10:54,500
but something is a buffer, is to acquire the log.
但是有些东西是一个缓冲区，用于获取日志。

1243
01:10:57,570 --> 01:10:59,890
But it cannot acquire the log because owned by the brasilia.
但它无法获取日志，因为它是由巴西利亚拥有的。

1244
01:10:59,900 --> 01:11:03,130
So your hand,
所以你的手，

1245
01:11:08,990 --> 01:11:09,670
you don't work.
你不工作。

1246
01:11:15,840 --> 01:11:16,870
How can you do it?
你可以怎样做呢？

1247
01:11:18,300 --> 01:11:20,160
One solution is to release a lock.
一个解决方案是释放锁。

1248
01:11:23,490 --> 01:11:24,990
If the buffer is full,
如果缓冲区已满，

1249
01:11:27,170 --> 01:11:29,930
we need to release a look if the buffer is full to give a chance
如果缓冲区已满，我们需要释放一个锁，以便给其他进程一个机会。

1250
01:11:29,940 --> 01:11:31,690
to the consumer to consume from the rough,
给消费者提供从原材料中消费的机会

1251
01:11:36,100 --> 01:11:36,450
right?
对的吗？

1252
01:11:40,190 --> 01:11:41,400
And then acquire the buffer.
然后获取缓冲区。

1253
01:11:42,110 --> 01:11:42,270
Right?
对吗？

1254
01:11:42,280 --> 01:11:43,710
You see what you done here.
你看到你在这里做了什么。

1255
01:11:44,790 --> 01:11:45,180
Right?
对吗？

1256
01:11:46,220 --> 01:11:48,740
You acquired before you check again whether the buffer is full.
在再次检查缓冲区是否已满之前，您已经获取了它。

1257
01:11:49,270 --> 01:11:51,710
You release this to give a chance to consumer to execute.
您发布这个是为了给消费者一个执行的机会。

1258
01:11:52,050 --> 01:11:56,000
You acquire the buffer back to check back whether the buffer is for the loop.
你重新获取缓冲区，以检查缓冲区是否用于循环。

1259
01:12:05,650 --> 01:12:07,770
What happens when one is waiting for the other?
当一个进程等待另一个进程时会发生什么？

1260
01:12:08,840 --> 01:12:14,860
Like I said in this thing will be
就像我之前说的，这件事会发生。

1261
01:12:19,670 --> 01:12:24,870
it could work for multiple clock.
它可以适用于多个时钟。

1262
01:12:24,880 --> 01:12:26,550
Orders will discuss this a little bit later.
稍后会讨论这个订单。

1263
01:12:28,210 --> 01:12:29,160
Let me just,
让我来，

1264
01:12:36,620 --> 01:12:41,790
then there are other things we can do here.
那么我们在这里还有其他事情可以做。

1265
01:12:41,800 --> 01:12:42,750
And this, right?
这个，对吗？

1266
01:12:42,760 --> 01:12:46,150
Abstraction of synchronizing threads that share memory.
共享内存的线程同步抽象化。

1267
01:12:47,000 --> 01:12:48,250
Locks is an abstraction,
锁是一种抽象概念，

1268
01:12:59,850 --> 01:13:01,180
but it's not the only abstraction.
但这并不是唯一的抽象。

1269
01:13:03,790 --> 01:13:06,280
And let me just see it's a question here.
让我看看这是一个问题。

1270
01:13:10,870 --> 01:13:12,620
Let me go back,
让我回去，

1271
01:13:12,630 --> 01:13:15,260
and it's important to understand that.
这一点非常重要，需要理解。

1272
01:13:17,160 --> 01:13:18,430
The question here,
这里的问题是，

1273
01:13:21,920 --> 01:13:24,750
it's what happens when one is waiting for?
当一个人在等待时会发生什么？

1274
01:13:24,760 --> 01:13:27,550
The why do we need to acquire the law?
为什么我们需要了解法律？

1275
01:13:28,460 --> 01:13:29,500
We need to acquire the log,
我们需要获取日志。

1276
01:13:29,510 --> 01:13:33,240
because here what happens in the while loop?
因为在这个 while 循环中发生了什么？

1277
01:13:34,190 --> 01:13:35,220
In the y loop,
在y循环中，

1278
01:13:35,230 --> 01:13:36,580
it's an empty instruction.
这是一条空指令。

1279
01:13:37,230 --> 01:13:39,060
You need to repeat the you repeatedly.
你需要重复你自己多次。

1280
01:13:39,070 --> 01:13:39,900
What you want is this.
你想要的是这个。

1281
01:13:39,910 --> 01:13:40,260
Why?
为了方便理解和交流，我会将英文翻译成中文。这样可以确保信息的准确传达，并帮助您更好地理解相关内容。如果您有任何问题或需要进一步的帮助，请随时告诉我。

1282
01:13:40,790 --> 01:13:46,230
You repeatedly check whether buffer is full and been between the checks,
你会反复检查缓冲区是否已满，并在检查之间进行操作。

1283
01:13:46,670 --> 01:13:48,300
you release and acquire the buffer.
你释放和获取缓冲区。

1284
01:13:48,870 --> 01:13:52,010
We need to be in critical section through check the buffer,
我们需要通过检查缓冲区来进入临界区。

1285
01:13:52,020 --> 01:13:56,050
because you don't want to be the buffer to be modified while you
因为您不希望在修改缓冲区时被干扰到

1286
01:13:56,060 --> 01:13:59,950
are checking about checking whether is full that has to be
正在检查是否已满。

1287
01:13:59,960 --> 01:14:00,750
critical section.
临界区

1288
01:14:01,710 --> 01:14:03,350
But between multiple checks,
但是在多次检查之间，

1289
01:14:03,850 --> 01:14:05,000
you want to release the lock.
你想释放锁。

1290
01:14:05,510 --> 01:14:06,900
So the consumer can consume.
所以消费者可以消费。

1291
01:14:08,330 --> 01:14:10,770
That's right.
没错。

1292
01:14:14,030 --> 01:14:20,520
So another way to do it is a more generally using some of us.
另一种方法是更普遍地利用我们中的一些人。

1293
01:14:21,010 --> 01:14:22,550
We did this summer force.
我们进行了这个夏季的强制训练。

1294
01:14:22,560 --> 01:14:25,030
We learn slightly a little bit about them.
我们稍微了解一点关于它们的信息。

1295
01:14:25,250 --> 01:14:27,390
This is just recalling what we learned.
这只是回顾我们所学的内容。

1296
01:14:27,720 --> 01:14:28,870
There are two similar force,
有两种相似的力量

1297
01:14:29,440 --> 01:14:34,480
sorry, to primitives on the same time for is p is an atomic operation,
抱歉，对于原语p的同时执行是一个原子操作。

1298
01:14:34,740 --> 01:14:38,990
which waits for the semaphore to become positives and decrement by one.
该函数等待信号量变为正数，并将其减一。

1299
01:14:39,550 --> 01:14:40,920
If zero is just,
如果零是公正的，

1300
01:14:42,390 --> 01:14:43,990
it's weights is blocked.
它的权重被阻塞了。

1301
01:14:44,480 --> 01:14:50,560
And b we just increment the semaphore and wake up any other thread which
然后我们只需增加信号量并唤醒任何其他线程

1302
01:14:50,570 --> 01:14:52,320
wasted for which waits for the semester.
浪费了等待学期的时间。

1303
01:14:54,380 --> 01:14:54,690
All right.
好的。

1304
01:14:57,130 --> 01:15:00,220
Some efforts are like integers in the sense that you
有些努力就像整数一样，因为它们

1305
01:15:00,230 --> 01:15:01,770
can increment and decrement them,
可以对它们进行递增和递减操作，

1306
01:15:02,070 --> 01:15:03,640
except there are no negative values.
除非没有负值。

1307
01:15:04,320 --> 01:15:07,540
The only way you can increment and they could be commanded them is to use
唯一的方法是使用递增命令来增加它们。

1308
01:15:07,550 --> 01:15:08,640
AP and b function.
AP 和 b 函数。

1309
01:15:11,020 --> 01:15:11,320
Right?
对吗？

1310
01:15:13,430 --> 01:15:14,580
This operation,
这个操作，

1311
01:15:14,590 --> 01:15:18,610
December for these operations are atomic.
这些操作在12月份是原子的。

1312
01:15:19,070 --> 01:15:20,060
Bnb are atomic.
Bnb是原子性的。

1313
01:15:23,950 --> 01:15:25,980
This is a railroad analogy.
这是一个铁路的类比。

1314
01:15:26,270 --> 01:15:28,710
You can implement, like, for instance, in this case,
你可以实现，例如，在这种情况下，

1315
01:15:28,720 --> 01:15:30,740
you have two lines, two railroad lines,
你有两条线路，两条铁路线。

1316
01:15:31,790 --> 01:15:32,330
two rails.
两条轨道。

1317
01:15:33,290 --> 01:15:33,620
Right?
对吗？

1318
01:15:35,560 --> 01:15:38,360
You increment, you put the value of the semaphore to two.
你递增，将信号量的值设为2。

1319
01:15:39,490 --> 01:15:43,440
So you can have an engine parked on online,
所以你可以将引擎停放在线上。

1320
01:15:44,220 --> 01:15:46,090
then an engine park on second line.
然后一辆引擎停在第二行。

1321
01:15:46,100 --> 01:15:49,450
You notice that every time I haven't accepted an engine,
你注意到每次我没有接受一个引擎时，

1322
01:15:49,460 --> 01:15:51,210
I decrement the value.
我将值减一。

1323
01:15:51,670 --> 01:15:52,630
Now its value is zero.
现在它的值是零。

1324
01:15:53,590 --> 01:15:55,020
You have another engine is stopped.
你有另一个引擎停止了。

1325
01:15:55,030 --> 01:15:57,180
It cannot get in because the value is zero.
无法进入，因为值为零。

1326
01:15:57,920 --> 01:16:03,830
Now, when one leaves is going to increment the semaphore and the slide,
现在，当有人离开时，将会增加信号量和滑块。

1327
01:16:03,840 --> 01:16:05,510
the third engine can enter,
第三个引擎可以进入。

1328
01:16:07,200 --> 01:16:07,210
right?
对的？

1329
01:16:07,220 --> 01:16:07,960
And so forth.
等等，诸如此类。

1330
01:16:09,730 --> 01:16:16,580
So you can use some of us to implement which mutual exclusion.
所以你可以使用我们中的一些人来实现哪种互斥机制。

1331
01:16:17,400 --> 01:16:21,350
This equivalent to having a semaphore is a binary value 01.
这相当于拥有一个二进制值为01的信号量。

1332
01:16:23,480 --> 01:16:24,590
How do you do that?
你是如何做到的？

1333
01:16:25,820 --> 01:16:31,530
You do AP on the summer for you initialize the summer for to one and use AP
你在暑假期间进行高级研究课程，以便为你的暑期计划做准备，并利用高级研究课程的知识。

1334
01:16:32,590 --> 01:16:33,580
so the first thread which
所以第一个线程

1335
01:16:33,590 --> 01:16:38,850
calls some p is going to enter the critical section because you
调用了某个p，即将进入临界区，因为你

1336
01:16:38,860 --> 01:16:40,250
can decrement value to zero.
可以将值递减至零。

1337
01:16:40,260 --> 01:16:42,540
The second one is going to copy.
第二个将要复制。

1338
01:16:43,470 --> 01:16:45,030
While the first one is the first study,
第一个是第一项研究。

1339
01:16:45,040 --> 01:16:49,310
the second in the critical section cannot enter in the critical section,
第二个进入临界区的进程无法进入临界区。

1340
01:16:49,400 --> 01:16:50,470
because some are four is zero,
因为有些是四个是零，

1341
01:16:52,020 --> 01:16:53,540
where the first summer Ford leaves,
福特第一次离开的夏天在哪里？

1342
01:16:53,550 --> 01:16:57,140
the summer critical section is going to increment the summer for.
夏季临界区将对夏季计数器进行递增操作。

1343
01:16:57,150 --> 01:16:58,990
So second one comes.
所以第二个来了。

1344
01:17:00,000 --> 01:17:00,320
Right?
对吗？

1345
01:17:02,230 --> 01:17:02,980
We also say,
我们也这样说，

1346
01:17:02,990 --> 01:17:05,940
in this case that the summer for implements scheduling constraints,
在这种情况下，夏季用于实施调度约束。

1347
01:17:11,890 --> 01:17:12,960
and also,
而且，

1348
01:17:12,970 --> 01:17:14,040
this is about,
这是关于...

1349
01:17:14,610 --> 01:17:15,040
sorry,
抱歉，有什么我可以帮助您的吗？

1350
01:17:16,910 --> 01:17:20,640
we a second use case which you also learned last time.
我们有一个第二个使用案例，你上次也学过。

1351
01:17:20,990 --> 01:17:24,230
It was about waiting,
这是关于等待的问题。

1352
01:17:24,620 --> 01:17:26,680
a thread waiting for another thread to finish.
一个线程等待另一个线程完成。

1353
01:17:28,040 --> 01:17:31,810
You need the call, and this was implementing joint operation.
你需要调用这个函数，并且这是实现联合操作的。

1354
01:17:32,510 --> 01:17:33,710
But I remember this code.
但是我记得这段代码。

1355
01:17:35,530 --> 01:17:36,920
You have a thread join.
你有一个线程加入。

1356
01:17:38,760 --> 01:17:40,670
And that's your,
这是你的，

1357
01:17:43,730 --> 01:17:49,290
you are going to wait for the thread to finish that adjoining.
你需要等待该线程完成。

1358
01:17:49,800 --> 01:17:52,280
You run a thread and you added for Free to finish, right?
你运行了一个线程，并且添加了一个"Free"来表示完成，对吗？

1359
01:17:53,430 --> 01:17:54,340
How you do that?
你是怎么做到的？

1360
01:17:54,700 --> 01:17:57,690
You are going to have a semi for which is initialize to zero.
你将拥有一个初始化为零的半字节。

1361
01:17:59,300 --> 01:18:00,850
When you start the thread,
当你启动线程时，

1362
01:18:05,360 --> 01:18:09,850
when you sorry, when you start when you finish a thread,
当你抱歉时，当你开始一个线程时，当你结束一个线程时，

1363
01:18:10,930 --> 01:18:12,980
you increment the semaphore to one.
你将信号量增加到一。

1364
01:18:14,720 --> 01:18:18,040
And then let me take it back.
然后让我把它拿回来。

1365
01:18:18,460 --> 01:18:19,880
We initialize a thread to zero.
我们将一个线程初始化为零。

1366
01:18:22,780 --> 01:18:24,170
When you start the thread,
当你启动线程时，

1367
01:18:26,230 --> 01:18:27,150
nothing happens.
没有任何反应。

1368
01:18:27,450 --> 01:18:31,490
And the main thread is going to wait to execute strategy.
主线程将等待执行策略。

1369
01:18:32,340 --> 01:18:33,820
And it's going to be blocked,
而且它将被阻止。

1370
01:18:35,580 --> 01:18:36,700
because the summer 40,
因为夏天很热。

1371
01:18:39,600 --> 01:18:44,040
when the set finishes on for which I'm waiting,
当我等待的集合完成时，

1372
01:18:45,800 --> 01:18:48,480
then the thread is going to increment the Singapore.
然后线程将增加新加坡的计数。

1373
01:18:49,610 --> 01:18:50,280
And now,
现在，

1374
01:18:51,640 --> 01:18:57,140
the p in the thread join can decline the summer for and can finish.
线程的join函数中的p可以拒绝夏季并完成任务。

1375
01:18:59,600 --> 01:19:01,870
And this is only say we implement scheduling constants.
这只是说我们实现了调度常量。

1376
01:19:04,270 --> 01:19:04,800
Okay?
好的？

1377
01:19:06,730 --> 01:19:07,720
We are a little bit slow.
我们进展有点慢。

1378
01:19:07,730 --> 01:19:16,400
Let me just go over announcements.
让我来看一下公告。

1379
01:19:18,580 --> 01:19:21,580
Let me find the announcement and we had a going to be done.
让我找一下公告，我们马上就要完成了。

1380
01:19:22,970 --> 01:19:24,040
So announcements,
所以，公告，

1381
01:19:25,280 --> 01:19:27,110
very quick announcements today.
今天的公告非常简短。

1382
01:19:28,680 --> 01:19:34,480
Please sign up for design reviews.
请报名参加设计评审。

1383
01:19:35,660 --> 01:19:39,450
The design documents also don't forget that due Friday.
设计文档也别忘了要在周五前提交。

1384
01:19:40,530 --> 01:19:41,030
Next week,
下周，

1385
01:19:41,040 --> 01:19:48,670
you are going to get the feedback on your design documents from your ta you
你将从你的助教那里得到关于你的设计文档的反馈。

1386
01:19:48,680 --> 01:19:48,910
need to
需要

1387
01:19:48,920 --> 01:19:51,190
assign for that to schedule that meeting.
安排一个人来安排那次会议。

1388
01:19:52,080 --> 01:19:53,830
And the homework one is due today.
作业一也是今天截止。

1389
01:19:53,840 --> 01:19:54,910
So good luck with that.
祝你好运。

1390
01:19:56,360 --> 01:19:58,950
So good luck again with the homework,
祝你再次完成作业顺利。

1391
01:19:59,480 --> 01:20:02,730
good luck with the design documents and see you all next week.
祝你在设计文档上好运，下周见。

1392
01:20:03,650 --> 01:20:04,090
Thank you.
谢谢你。

