1
00:00:00,000 --> 00:00:19,400
 Hello everyone. So, welcome. So we are going to continue our lecture on virtual memory.

2
00:00:19,400 --> 00:00:26,400
 And we are going to start discussion on caching and TLBs, which stands for translation lookaside

3
00:00:26,400 --> 00:00:31,440
 buffers.

4
00:00:31,440 --> 00:00:42,960
 So if you recall, address translation as a name implies, it's about translating the addresses

5
00:00:42,960 --> 00:00:49,120
 which are viewed by the application by the CPUs into physical addresses. And there are

6
00:00:49,120 --> 00:01:00,040
 a couple of reasons why we want to have these different kind of addresses for the application

7
00:01:00,040 --> 00:01:12,440
 and versus the physical addresses. And some of them are about providing the illusion to

8
00:01:12,440 --> 00:01:20,800
 each application, it has its own machine, its own resources, including the memory, which

9
00:01:20,800 --> 00:01:29,320
 means that then you need to map the address space of each of the application in the same

10
00:01:29,320 --> 00:01:37,960
 physical space, which is physical memory. And also another reason is protection because

11
00:01:37,960 --> 00:01:46,280
 you want to protect the address space of one application from another. And also sharing,

12
00:01:46,280 --> 00:01:51,640
 controlled sharing, if you remember, in which actually some parts of the address space you

13
00:01:51,640 --> 00:01:58,280
 want to be shared. For instance, the address space, which contains a code of a shared library,

14
00:01:58,280 --> 00:02:02,880
 of a library, which is a code of a library, which is used by two applications like Windows

15
00:02:02,880 --> 00:02:08,680
 library on your own Windows machine, you do not want to replicate that code in each application,

16
00:02:08,680 --> 00:02:19,040
 you want to share that code. And typically the sharing happens, it's handled by one of

17
00:02:19,040 --> 00:02:28,280
 these components, a chip, which is called memory management unit. So this was originally

18
00:02:28,280 --> 00:02:37,600
 was a standard on chip, which was you put near your, between the processor and the memory.

19
00:02:37,600 --> 00:02:47,720
 But of course, in the modern processors, it's just a component of that processor. And one

20
00:02:47,720 --> 00:02:58,040
 of the techniques to do address translation was a segment, we're using multi-segment model.

21
00:02:58,040 --> 00:03:07,200
 And in this case, if you remember, each segment is represented by a base and a limit. And

22
00:03:07,200 --> 00:03:15,680
 now the virtual address, the address, which is seen by the CPU and as seen by the application,

23
00:03:15,680 --> 00:03:25,040
 is split into two. The first part, the first few bits represent an index in the segment

24
00:03:25,040 --> 00:03:33,840
 table. And then there is an offset. So when you have a virtual address, you look at the

25
00:03:33,840 --> 00:03:39,080
 first field, which is a segment number, the first bits represent the segment number, use

26
00:03:39,080 --> 00:03:49,480
 that to index into segment table. And then in that segment table, you are going to find

27
00:03:49,480 --> 00:03:56,440
 the base of the segment and the limit. And you are going to compute the physical address

28
00:03:56,440 --> 00:04:05,560
 by adding the offset, which is the second field in the virtual address to the base,

29
00:04:05,560 --> 00:04:15,240
 the segment base. And of course, you are also going to check whether the address is generated

30
00:04:15,240 --> 00:04:27,160
 is less than the limit. So it's within the segment. You also have in some architecture,

31
00:04:27,160 --> 00:04:37,240
 actually in Intel x86, instead of having the first bits in the address, in the virtual

32
00:04:37,240 --> 00:04:46,600
 address, it's presenting the base indexing into the segment table. You have just a bunch

33
00:04:46,600 --> 00:04:52,960
 of segments. You have initially have four segments and these segments are base segments

34
00:04:52,960 --> 00:05:06,760
 are stored in special registers like ES, this is S is for the stack and three other registers.

35
00:05:06,760 --> 00:05:12,240
 Okay. And then you compute the address by taking the virtual address and you are going

36
00:05:12,240 --> 00:05:23,640
 to add it to the segment register. And that's how you are going to compute the physical

37
00:05:23,640 --> 00:05:31,480
 address. Finally, there is a bit valid or not valid. And this is one use of this one

38
00:05:31,480 --> 00:05:37,360
 is that not all segments of all applications can fit in the physical memory at the same

39
00:05:37,360 --> 00:05:43,880
 time. So when you run out of space in the physical memory and you want to load your

40
00:05:43,880 --> 00:05:51,800
 certain new application and your program, you need to allocate space in the physical

41
00:05:51,800 --> 00:05:58,040
 memory for that new program, the segments of the new program. You may take one of the

42
00:05:58,040 --> 00:06:02,400
 existing segments of an application which doesn't run and you are going to store it

43
00:06:02,400 --> 00:06:09,320
 on the disk. Okay. And so then for the segment is no longer in memory. So then you can say

44
00:06:09,320 --> 00:06:17,460
 it's not, you can use this bit to specify that. So whenever next time when you are looking

45
00:06:17,460 --> 00:06:27,800
 for something in that segment, then you are going to get an exception and the exception

46
00:06:27,800 --> 00:06:32,480
 is going to be treated by the operating system and the operating system will bring the segment

47
00:06:32,480 --> 00:06:43,920
 from the disk to memory before executing that instruction. Okay. So this is some examples.

48
00:06:43,920 --> 00:06:57,320
 So here it's a simple, an example of an architecture is four segments. The address is 16 bits. The

49
00:06:57,320 --> 00:07:05,280
 first two bits of the address are used to specify the segment number. And because we

50
00:07:05,280 --> 00:07:10,200
 have four segments, we need only two bits. So these are bits 15 and 14 and the rest of

51
00:07:10,200 --> 00:07:15,440
 these from 13 to zero represent the offset. On the left hand side, you can see the address

52
00:07:15,440 --> 00:07:21,680
 space, the virtual address space. So as seen by the processor, by the application. And

53
00:07:21,680 --> 00:07:29,720
 we have our traditional four segments, the code segments, the data, the stack segments,

54
00:07:29,720 --> 00:07:35,760
 and this is also, we added a shared segment. Think about this is either the data or the

55
00:07:35,760 --> 00:07:45,400
 code which you may want to share with another application. So here in green, you have the

56
00:07:45,400 --> 00:07:54,200
 tables, the segment table, again, four entries for code, data, shared and the stack. And

57
00:07:54,200 --> 00:08:01,400
 you see you have the base and the limit for each of these segments. So now let's see what

58
00:08:01,400 --> 00:08:05,960
 happens. So for instance, and on the right hand side, you have the physical address.

59
00:08:05,960 --> 00:08:10,000
 For simplicity in this case, the physical address and the virtual address spaces, they

60
00:08:10,000 --> 00:08:17,760
 have the same size. Okay. So say you are going from the code, you are going to execute the

61
00:08:17,760 --> 00:08:24,880
 instruction in the code segment. And so where is that going to be mapped in the physical

62
00:08:24,880 --> 00:08:34,820
 address space? Well, if you look about in the segment table, because the first two bits

63
00:08:34,820 --> 00:08:40,480
 of everything in the code segment are zero. So therefore you are going to identify the

64
00:08:40,480 --> 00:08:50,980
 first entry in the segment table and you have a base of 4,000 in hexa decimal format. So

65
00:08:50,980 --> 00:09:01,680
 therefore you have to add 4,000 to every address, the virtual address is a code segment and

66
00:09:01,680 --> 00:09:09,340
 to get the corresponding physical address for the code in the physical address space.

67
00:09:09,340 --> 00:09:19,540
 Okay. Then for the data, the data starts in the virtual address space at 4,000. This means

68
00:09:19,540 --> 00:09:30,500
 that what are the first two bits of any address in the data segment? Why don't you tell me?

69
00:09:30,500 --> 00:09:40,920
 It should be a very simple answer here. So the first, you have 16 bits. When we use a

70
00:09:40,920 --> 00:09:49,500
 hexadecimal representation, right? Four bits represent one digit. So now we have four here

71
00:09:49,500 --> 00:09:59,300
 first. What does it mean? What are the first four bits representing the four? How do you

72
00:09:59,300 --> 00:10:21,780
 write four in binary representation? Okay. So here it is. I'm writing this in our chat.

73
00:10:21,780 --> 00:10:32,500
 So four in binary representation, if you want to represent it using four bits, it's what?

74
00:10:32,500 --> 00:10:41,940
 0, 1, 0, 0, right? This is it, right? It's 1, 0, 0 is four in the binary representation,

75
00:10:41,940 --> 00:10:52,220
 which means that the first two bits for any address in the data segments are one. The

76
00:10:52,220 --> 00:11:03,900
 segment number here is what? 0, 1. Now it's not 0, 0, 1. It's 0, 1 because it's only the

77
00:11:03,900 --> 00:11:13,940
 first bits. But it is correct, you know, it can move. Okay. So it's 0, 1. This is what

78
00:11:13,940 --> 00:11:24,220
 you have, right? So therefore, to translate any address in the data segment, what do you

79
00:11:24,220 --> 00:11:31,980
 need to do? You go to the second entry in the segment table, the one which the segment

80
00:11:31,980 --> 00:11:40,100
 ID number is one. And the base here is 4800. So what you need to do is that you are going

81
00:11:40,100 --> 00:11:51,140
 to add in order to translate any address in the data segment, you need to add to it 4800.

82
00:11:51,140 --> 00:12:02,580
 And for the shared segment, this, you know, the things go similarly. For the shared segment,

83
00:12:02,580 --> 00:12:10,820
 they started at 8000. So the first four bits is 8, 8. What is the binary representation

84
00:12:10,820 --> 00:12:28,020
 of 8? It's exactly. So the first two bits are 1, 0. So the segment number, it's 1, 0

85
00:12:28,020 --> 00:12:34,580
 is 2, right? Because you take only the first two bits. And finally, stack C. What is C?

86
00:12:34,580 --> 00:12:47,900
 The representation, binary representation of C. You should remember this, right? It's

87
00:12:47,900 --> 00:12:58,860
 review. It's 1, 1, 0, 0. It's exactly. Very good, right? So the first two bits are 1,

88
00:12:58,860 --> 00:13:07,820
 1. So it's 3, number 3. So of course, it's the last entry in the table. And for the stack,

89
00:13:07,820 --> 00:13:16,460
 the base is 0, right? So you add the base offset to the base. So we started from 0,

90
00:13:16,460 --> 00:13:27,340
 0, 0. Okay. Does it make sense? Okay. Let's look at this other example. By the way, you

91
00:13:27,340 --> 00:13:37,180
 should try. These are some very important slides because you may expect not only to

92
00:13:37,180 --> 00:13:44,980
 understand how the address translation works, which is one of the fundamental mechanisms

93
00:13:44,980 --> 00:13:52,340
 in used by any in today's processors, leveraged by the operating system to provide virtual

94
00:13:52,340 --> 00:14:01,380
 memory abstraction, but also because you can expect problems like this in your next meter.

95
00:14:01,380 --> 00:14:09,700
 Okay. So now let's look at this piece of code and see what happens under the hood. And we

96
00:14:09,700 --> 00:14:16,220
 are assuming this piece of code is going to run on the previous architecture from I just

97
00:14:16,220 --> 00:14:23,980
 showed you in the last slide. Okay. So you have the segment table is the same. And now

98
00:14:23,980 --> 00:14:31,740
 is a code. So the code starts at 240, right? So basically the entire address is 0, 2, 4,

99
00:14:31,740 --> 00:14:41,420
 0, but you don't show the first four bits, which are 0, right? Okay. So now let's see

100
00:14:41,420 --> 00:14:49,440
 what happens. And this is pseudo assembly language code. And let's see what happens

101
00:14:49,440 --> 00:14:56,660
 when we type this code. The first instruction is a main. And basically what this instruction

102
00:14:56,660 --> 00:15:10,940
 is doing, it loads an address, which is bar X into register A0, right? Now this code is

103
00:15:10,940 --> 00:15:20,740
 run in the user process, the user process, see virtual addresses. So all the addresses

104
00:15:20,740 --> 00:15:29,900
 you see here are virtual addresses. Okay. But now the code and the data, they are actually

105
00:15:29,900 --> 00:15:38,460
 stored in the physical memory. So in order to read the instructions and access the data,

106
00:15:38,460 --> 00:15:48,140
 we need to translate the virtual addresses to the physical address. Okay. So the address,

107
00:15:48,140 --> 00:15:52,460
 the instruction, first we need to fetch the instruction in order to execute the instructions.

108
00:15:52,460 --> 00:15:58,020
 The instruction again is in physical memory. So the address, the virtual address, it's

109
00:15:58,020 --> 00:16:05,220
 0, 2, 4, 0, like we discussed. And here it's a binary representation of the address. So

110
00:16:05,220 --> 00:16:16,100
 the first two bits are 0. So the segment ID, the segment number is 0. So therefore, in

111
00:16:16,100 --> 00:16:26,060
 order to translate this address, virtual address, 2, 4, 0, to a physical address, we need to

112
00:16:26,060 --> 00:16:36,180
 add the base address corresponding to the segment. So the base is 4,000 and the virtual

113
00:16:36,180 --> 00:16:46,020
 offset, right, is 2, 4, 0, right? The virtual offset. The offset is the black bits in the

114
00:16:46,020 --> 00:16:58,500
 address. The bits encoding the segment identifier are the green bits, obviously. Okay. So you

115
00:16:58,500 --> 00:17:05,480
 have to add all the offset, which is 2, 4, 0, to 4,000, which is a base. And therefore

116
00:17:05,480 --> 00:17:12,060
 you are going to get the physical address 4,240. And now you are going to use this address

117
00:17:12,060 --> 00:17:17,820
 to fetch the instruction from the memory. And the instruction is basically, like I told

118
00:17:17,820 --> 00:17:25,140
 you, is to load the address, which is VAREX address, which is 4050, this is the virtual

119
00:17:25,140 --> 00:17:36,460
 address, into register A0. Now, after that, you execute the instruction, you would know

120
00:17:36,460 --> 00:17:44,020
 very well what happens. Next, the program counter, it's incremented by 4, right? Because

121
00:17:44,020 --> 00:17:51,860
 here assuming that there are instructions, they occupy 4 bytes. Okay. The next instruction

122
00:17:51,860 --> 00:18:05,580
 address is 244. Okay. So let's execute the next instruction. It's again, in the next

123
00:18:05,580 --> 00:18:13,420
 instruction, you are going to see, you have now the address is 244, like I mentioned.

124
00:18:13,420 --> 00:18:19,520
 Again, the physical, if you look at the, this will also be in the code segment. So you need

125
00:18:19,520 --> 00:18:25,620
 to add the base, which is 4,000. The physical address will be 4244. And you are going to

126
00:18:25,620 --> 00:18:37,780
 get the next instruction, which is gel, to jump to this string length address label.

127
00:18:37,780 --> 00:18:47,420
 And this is exactly what you do it. But before jumping, here we store the return address.

128
00:18:47,420 --> 00:18:52,740
 So after we execute the function string length, we need to return where? To the next instruction

129
00:18:52,740 --> 00:19:02,980
 after the jump. The next instruction after the jump would be 0x248. Okay. So therefore

130
00:19:02,980 --> 00:19:08,320
 we are going to, we assume here that we have a return address registers, which stores a

131
00:19:08,320 --> 00:19:14,180
 return address. So we are going to load into the return address 0248. And this is done

132
00:19:14,180 --> 00:19:27,940
 automatically by the compiled code, by your application. And then you move in the program

133
00:19:27,940 --> 00:19:32,500
 counter, the address where you want to jump. So the address you want to jump, the label

134
00:19:32,500 --> 00:19:38,940
 string length is corresponding to the address 360. Okay. So you are going to jump there

135
00:19:38,940 --> 00:19:46,500
 and you are going to execute that next instruction, which will be the address 360. 360 is again

136
00:19:46,500 --> 00:19:51,460
 is in the segment code. In order to compute the physical address, you are going to add

137
00:19:51,460 --> 00:20:01,860
 the base, which is 4,000. So 4,000 plus 360 is 400, 360. And then you are going to read

138
00:20:01,860 --> 00:20:09,220
 from the physical memory you are going to read. And this instruction is basically initialized

139
00:20:09,220 --> 00:20:18,460
 this account. So put a zero in a register of zero. Okay. And once you execute that,

140
00:20:18,510 --> 00:20:21,950
 to the next instruction.

141
00:20:21,950 --> 00:20:27,870
 And the next instruction, it's at the address 364.

142
00:20:27,870 --> 00:20:32,990
 And this next instruction, it loads

143
00:20:32,990 --> 00:20:35,430
 what is at this particular address, which

144
00:20:35,430 --> 00:20:36,630
 is stored in A0.

145
00:20:36,630 --> 00:20:39,150
 So remember that what we're storing in A0,

146
00:20:39,150 --> 00:20:41,870
 it was VARX address.

147
00:20:41,870 --> 00:20:45,510
 So this VARX address is 4050.

148
00:20:45,510 --> 00:20:50,710
 So now we want to load in register T0

149
00:20:50,710 --> 00:20:56,230
 the content of the address VARX, so the address 4050.

150
00:20:56,230 --> 00:20:59,990
 So when we want to do that and we want to access it,

151
00:20:59,990 --> 00:21:03,070
 to see what is the content at that virtual address,

152
00:21:03,070 --> 00:21:06,110
 the virtual address is 4050.

153
00:21:06,110 --> 00:21:08,110
 And this is a binary representation.

154
00:21:08,110 --> 00:21:10,630
 The first two bits are 01.

155
00:21:10,630 --> 00:21:14,550
 So the segment index, which corresponds to this address,

156
00:21:14,550 --> 00:21:16,150
 it's 01.

157
00:21:16,150 --> 00:21:22,150
 And therefore, the base address of that segment is 4800.

158
00:21:22,150 --> 00:21:26,350
 So therefore, you need to add the 4800 to what?

159
00:21:26,350 --> 00:21:27,670
 To the offset.

160
00:21:27,670 --> 00:21:29,350
 So what is the offset here?

161
00:21:29,350 --> 00:21:31,550
 The offset here, notice, is 50.

162
00:21:31,550 --> 00:21:36,310
 So the virtual address is 4050.

163
00:21:36,310 --> 00:21:39,630
 But remember, the first two bits of this address

164
00:21:39,630 --> 00:21:41,510
 represent the segment ID.

165
00:21:41,510 --> 00:21:42,710
 That's 01.

166
00:21:42,710 --> 00:21:46,510
 And the last, in this case, 14 bits,

167
00:21:46,510 --> 00:21:48,470
 represents the offset.

168
00:21:48,470 --> 00:21:52,590
 But the last 14 bits is 50.

169
00:21:52,590 --> 00:21:54,950
 So now, the offset is 50.

170
00:21:54,950 --> 00:22:02,470
 It's, again, offset is a black digits, 0 or 1.

171
00:22:02,470 --> 00:22:07,270
 So then you are going to add the offset

172
00:22:07,270 --> 00:22:09,470
 to the base, which is 4800.

173
00:22:09,470 --> 00:22:12,350
 So the physical address you are going to compute is 4800.

174
00:22:12,350 --> 00:22:20,830
 And you are going to load the byte from that address to T0.

175
00:22:20,830 --> 00:22:24,150
 And you increment the program count.

176
00:22:24,150 --> 00:22:25,830
 So the main thing to note here is

177
00:22:25,830 --> 00:22:30,110
 that everything which is in what the processor sees,

178
00:22:30,110 --> 00:22:34,830
 everything what is in the registers of the processors,

179
00:22:34,830 --> 00:22:38,270
 all these are virtual addresses.

180
00:22:38,270 --> 00:22:41,350
 The translation happens only where

181
00:22:41,350 --> 00:22:45,670
 you are going to access the memory.

182
00:22:45,670 --> 00:22:48,750
 So the memory management units really

183
00:22:48,750 --> 00:22:52,790
 sits between the arithmetic logical units

184
00:22:52,790 --> 00:22:56,470
 and all the registers and the memory.

185
00:22:56,470 --> 00:22:57,750
 OK?

186
00:22:57,750 --> 00:22:58,750
 Any questions?

187
00:22:58,750 --> 00:23:08,310
 OK.

188
00:23:08,310 --> 00:23:10,150
 We spent quite a bit of time on this one.

189
00:23:10,150 --> 00:23:11,310
 But this is important.

190
00:23:11,310 --> 00:23:16,310
 Please make sure that you understand this example.

191
00:23:16,310 --> 00:23:17,390
 OK?

192
00:23:17,390 --> 00:23:22,870
 As you will see from the previous years

193
00:23:22,870 --> 00:23:25,790
 and previous exams, you are going

194
00:23:25,790 --> 00:23:28,550
 to see a lot of problems like this one.

195
00:23:28,550 --> 00:23:38,390
 So a few things about segmentation.

196
00:23:38,390 --> 00:23:40,870
 The one problem with the segmentation is nice.

197
00:23:40,870 --> 00:23:43,230
 It's a very elegant solution.

198
00:23:43,230 --> 00:23:46,590
 But you are going to translate on every instruction,

199
00:23:46,590 --> 00:23:47,470
 everything.

200
00:23:47,470 --> 00:23:53,750
 Even fetch an instruction, access, read some data,

201
00:23:53,750 --> 00:23:55,190
 write some data from the memory.

202
00:23:55,190 --> 00:24:04,830
 And virtual address space has holes, right?

203
00:24:04,830 --> 00:24:08,950
 Because you are not going to use everything in your virtual

204
00:24:08,950 --> 00:24:09,430
 address.

205
00:24:09,430 --> 00:24:16,350
 And that's why you use a segmentation in the first part,

206
00:24:16,350 --> 00:24:21,830
 in the first thing, in the first place.

207
00:24:21,830 --> 00:24:23,870
 Because if you think about if you

208
00:24:23,870 --> 00:24:27,990
 have the code and the segment, the segment grows.

209
00:24:27,990 --> 00:24:30,830
 You put the segment as a high addresses

210
00:24:30,830 --> 00:24:34,070
 because it grows to the smaller, grows downwards

211
00:24:34,070 --> 00:24:35,550
 to the smaller addresses.

212
00:24:35,550 --> 00:24:37,390
 And for instance, the data segment,

213
00:24:37,390 --> 00:24:39,470
 you have to be as a lower address

214
00:24:39,470 --> 00:24:41,070
 because it's growing up.

215
00:24:41,070 --> 00:24:43,310
 OK?

216
00:24:43,310 --> 00:24:45,070
 Whilst the stack growing down.

217
00:24:45,070 --> 00:24:46,270
 So you need to separate them.

218
00:24:46,270 --> 00:24:49,630
 And between them, there is a gap.

219
00:24:49,630 --> 00:24:54,270
 So if you have segments, if you don't have the gap,

220
00:24:54,270 --> 00:24:56,030
 sorry, if you don't have the segments,

221
00:24:56,030 --> 00:25:00,990
 that gap will occupy space in the physical memory.

222
00:25:00,990 --> 00:25:02,910
 Space could have been used, empty space

223
00:25:02,910 --> 00:25:07,310
 could have been used to allocate to other processes,

224
00:25:07,310 --> 00:25:09,590
 other applications.

225
00:25:09,590 --> 00:25:13,110
 However, if I have these two segments now,

226
00:25:13,110 --> 00:25:15,350
 each segment can have--

227
00:25:15,350 --> 00:25:18,750
 one segment can have data, one segment can have the stack.

228
00:25:18,750 --> 00:25:22,710
 And then they are going to be mapped on the physical memory.

229
00:25:22,710 --> 00:25:24,710
 And the gap, I don't need to map it.

230
00:25:24,710 --> 00:25:27,430
 I don't need to just waste the space

231
00:25:27,430 --> 00:25:28,390
 on the physical memory.

232
00:25:28,390 --> 00:25:31,270
 [SIDE CONVERSATION]

233
00:25:31,270 --> 00:25:39,670
 So now, the one thing to notice here is I said,

234
00:25:39,670 --> 00:25:44,230
 OK, you allocate segments for the stack and the data.

235
00:25:44,230 --> 00:25:47,590
 But if I allocate, then how--

236
00:25:47,590 --> 00:25:50,430
 allocate the stack at a certain size

237
00:25:50,430 --> 00:25:54,350
 and allocate that physical memory for the stack

238
00:25:54,350 --> 00:25:57,910
 at that given size, what happens when the stack grows?

239
00:25:57,910 --> 00:26:00,230
 And you know that stack grows because as I

240
00:26:00,230 --> 00:26:03,590
 call more functions or say recursive programs,

241
00:26:03,590 --> 00:26:08,070
 every call puts the arguments and puts the return values

242
00:26:08,070 --> 00:26:11,510
 and so forth on the stack.

243
00:26:11,510 --> 00:26:14,150
 OK, so how do I do that?

244
00:26:14,150 --> 00:26:18,630
 Well, in that sense, when I'm going to browse the stack,

245
00:26:18,630 --> 00:26:23,590
 for instance, then I'm going to access an address

246
00:26:23,590 --> 00:26:26,590
 outside the limit.

247
00:26:26,590 --> 00:26:28,990
 And that will generate an exception.

248
00:26:28,990 --> 00:26:32,790
 The exception will be treated by the operating system, which

249
00:26:32,790 --> 00:26:37,550
 is going to grow the stack, OK, grow the limit

250
00:26:37,550 --> 00:26:42,590
 or modify the base, and provide more room now

251
00:26:42,590 --> 00:26:46,750
 so the program can add-- put more things on the stack.

252
00:26:46,750 --> 00:26:48,750
 The same thing for the heap.

253
00:26:48,750 --> 00:26:52,470
 OK, there is a question here.

254
00:26:52,470 --> 00:26:56,150
 Why did we not translate var x in the first line

255
00:26:56,150 --> 00:26:58,270
 on the previous slide?

256
00:26:58,270 --> 00:26:59,990
 So that's a very good question.

257
00:26:59,990 --> 00:27:02,110
 Why didn't translate var x?

258
00:27:02,110 --> 00:27:04,710
 Remember what I said?

259
00:27:04,710 --> 00:27:08,910
 Everything that's in the registers is virtual addresses.

260
00:27:08,910 --> 00:27:11,710
 These are all virtual addresses.

261
00:27:11,710 --> 00:27:15,350
 Because the rule is that the addresses are only

262
00:27:15,350 --> 00:27:20,310
 translated when I am going to access a memory.

263
00:27:20,310 --> 00:27:22,790
 In this case, I am not accessing the memory.

264
00:27:22,790 --> 00:27:27,910
 Var x is just a virtual address, right?

265
00:27:27,910 --> 00:27:30,110
 I don't need to access the memory for that.

266
00:27:30,110 --> 00:27:31,630
 When I need to access the memory,

267
00:27:31,630 --> 00:27:34,750
 then I'm going to read the content

268
00:27:34,750 --> 00:27:36,630
 as a virtual address.

269
00:27:36,630 --> 00:27:40,430
 And then I need to find the corresponding physical address.

270
00:27:40,430 --> 00:27:42,950
 And then I do translation.

271
00:27:42,950 --> 00:27:50,470
 But everything that is in the process, in the registers,

272
00:27:50,470 --> 00:27:55,350
 it's virtual addresses, basically.

273
00:27:55,350 --> 00:27:55,870
 OK?

274
00:27:55,870 --> 00:28:07,910
 Of course, you need to protect the segment table.

275
00:28:07,910 --> 00:28:14,230
 Only the operating system has to be able to modify it.

276
00:28:14,230 --> 00:28:16,230
 And also, it provides--

277
00:28:16,230 --> 00:28:18,910
 the operating system provides protections

278
00:28:18,910 --> 00:28:21,150
 for different segments, for instance,

279
00:28:21,150 --> 00:28:26,390
 to make the code segment being read only.

280
00:28:26,390 --> 00:28:29,150
 OK?

281
00:28:29,150 --> 00:28:33,270
 Now, let's say we do a context switching now.

282
00:28:33,270 --> 00:28:35,550
 What do we need to save and restore

283
00:28:35,550 --> 00:28:37,790
 on context switching when you have a process context

284
00:28:37,790 --> 00:28:38,590
 switching?

285
00:28:42,390 --> 00:28:51,510
 So besides, as you know that we need to save a bunch of things

286
00:28:51,510 --> 00:28:58,230
 like file identifiers and things like that,

287
00:28:58,230 --> 00:29:06,230
 the other thing we need to store now is the segment table.

288
00:29:06,230 --> 00:29:08,670
 Because the segment table, as I've shown you,

289
00:29:08,670 --> 00:29:11,950
 in the previous slide, in the previous examples,

290
00:29:11,950 --> 00:29:15,070
 you have one segment table per virtual address space.

291
00:29:15,070 --> 00:29:16,630
 And you have one virtual address space

292
00:29:16,630 --> 00:29:20,910
 per process or per application.

293
00:29:20,910 --> 00:29:25,830
 So when you switch context switch a process,

294
00:29:25,830 --> 00:29:29,390
 you have also to save the segment table

295
00:29:29,390 --> 00:29:31,590
 because the next process is going to run.

296
00:29:31,590 --> 00:29:33,830
 It's going to have its own segment table.

297
00:29:33,830 --> 00:29:39,030
 Also, like I mentioned earlier on,

298
00:29:39,030 --> 00:29:47,670
 some of the segments of the process which is no longer

299
00:29:47,670 --> 00:29:51,510
 running can be stored on the disk

300
00:29:51,510 --> 00:29:57,790
 in order to make room for the segments of the next process

301
00:29:57,790 --> 00:29:58,270
 being run.

302
00:29:58,270 --> 00:30:04,750
 This again, this is what happens is that again,

303
00:30:04,750 --> 00:30:06,590
 if not all segments within memory,

304
00:30:06,590 --> 00:30:08,750
 you save them on the disk and you swap them.

305
00:30:08,750 --> 00:30:14,830
 So basically, the P1, say process P1,

306
00:30:14,830 --> 00:30:23,910
 it's-- we switch from process P1 to P2.

307
00:30:23,910 --> 00:30:30,990
 Then we can save the segment of process P1 on the disk

308
00:30:30,990 --> 00:30:34,190
 to make room for the segment of process P2

309
00:30:34,190 --> 00:30:36,070
 to be brought in the memory.

310
00:30:36,070 --> 00:30:41,070
 Of course, if you have to do that,

311
00:30:41,070 --> 00:30:47,350
 the context switch cost will grow dramatically.

312
00:30:47,350 --> 00:30:50,830
 So you need to be very careful about what you switch off

313
00:30:50,830 --> 00:30:56,950
 or what you swap out and swap in because you really

314
00:30:56,950 --> 00:30:59,430
 want to minimize your operation on the disk.

315
00:30:59,430 --> 00:31:02,750
 And we are going to learn about that the next couple

316
00:31:02,750 --> 00:31:03,350
 of lectures.

317
00:31:03,350 --> 00:31:10,870
 The problem is fragmentation.

318
00:31:10,870 --> 00:31:14,030
 Problems with segmentation, one of the biggest problems

319
00:31:14,030 --> 00:31:21,390
 is fragmentation because now you need to store different--

320
00:31:21,390 --> 00:31:24,830
 you need to be able to have to store

321
00:31:24,830 --> 00:31:29,630
 and to fit segments of different sizes in memory.

322
00:31:29,630 --> 00:31:31,350
 And if you remember the last lecture,

323
00:31:31,350 --> 00:31:35,430
 we had an example in which you leave a lot of gaps.

324
00:31:35,430 --> 00:31:39,670
 And you can get to a point in which you have many gaps

325
00:31:39,670 --> 00:31:42,990
 in the physical memory, but none of the gaps

326
00:31:42,990 --> 00:31:51,150
 can be big enough to store a new segment,

327
00:31:51,150 --> 00:31:55,350
 despite the fact that if you add them, all the gaps--

328
00:31:55,350 --> 00:31:59,190
 it's much, much more than what is needed by one--

329
00:31:59,190 --> 00:32:00,750
 by that segment.

330
00:32:00,750 --> 00:32:03,350
 Think about you have 100 gaps.

331
00:32:03,350 --> 00:32:05,830
 Each gap is 1 gigabyte.

332
00:32:05,830 --> 00:32:11,470
 And so you have 100 gigabytes in total of available memory.

333
00:32:11,470 --> 00:32:16,150
 But now you have one segment which requires 2 gigabytes.

334
00:32:16,150 --> 00:32:19,670
 So you have plenty of available space,

335
00:32:19,670 --> 00:32:23,270
 but none of the available spaces,

336
00:32:23,270 --> 00:32:25,670
 contiguous spaces is large enough

337
00:32:25,670 --> 00:32:28,830
 to store that segment, 2 gigabyte segment.

338
00:32:28,830 --> 00:32:31,230
 OK.

339
00:32:31,230 --> 00:32:34,990
 So if you do that, you can take one

340
00:32:34,990 --> 00:32:37,870
 of the segments which are there to addition

341
00:32:37,870 --> 00:32:39,750
 to one of these 1 gigabyte gap.

342
00:32:39,750 --> 00:32:42,470
 And you are going to store on the disk.

343
00:32:42,470 --> 00:32:44,910
 You are swapping out to make more room.

344
00:32:44,910 --> 00:32:46,950
 Or you can move segments around.

345
00:32:46,950 --> 00:32:47,430
 OK?

346
00:32:47,430 --> 00:32:55,230
 So there are two kinds of fragmentations.

347
00:32:55,230 --> 00:32:57,870
 Both of them waste space.

348
00:32:57,870 --> 00:33:01,470
 Internal fragmentation, you don't need all the memory

349
00:33:01,470 --> 00:33:02,750
 within allocated chunks.

350
00:33:02,750 --> 00:33:03,630
 And this is also--

351
00:33:03,630 --> 00:33:09,590
 and then external, which is free gaps within allocated chunks.

352
00:33:09,590 --> 00:33:11,990
 So what in the example I mentioned to you,

353
00:33:11,990 --> 00:33:14,710
 I was talking about the external fragmentation.

354
00:33:14,710 --> 00:33:17,550
 OK?

355
00:33:17,550 --> 00:33:19,470
 And next, we are going to talk also

356
00:33:19,470 --> 00:33:21,710
 about internal fragmentation.

357
00:33:26,150 --> 00:33:28,430
 OK.

358
00:33:28,430 --> 00:33:32,230
 So basically, this is about another view

359
00:33:32,230 --> 00:33:33,550
 about the general--

360
00:33:33,550 --> 00:33:35,950
 how the address translation happens.

361
00:33:35,950 --> 00:33:38,030
 This providing a little more intuition

362
00:33:38,030 --> 00:33:41,230
 by showing two virtual address spaces mapped

363
00:33:41,230 --> 00:33:44,670
 to the same physical address space.

364
00:33:44,670 --> 00:33:45,710
 OK?

365
00:33:45,710 --> 00:33:49,190
 And these programs 1 and programs 2,

366
00:33:49,190 --> 00:33:52,630
 or this process 1 and process 2, the virtual address

367
00:33:52,630 --> 00:33:57,750
 spaces to each of them can look absolutely identical.

368
00:33:57,750 --> 00:34:01,070
 Think about you're on the same application, two instances

369
00:34:01,070 --> 00:34:03,430
 of the same application.

370
00:34:03,430 --> 00:34:06,870
 But of course, the translation, while in the virtual space

371
00:34:06,870 --> 00:34:09,390
 are identical, you have in both virtual spaces

372
00:34:09,390 --> 00:34:13,390
 the same thing at the same addresses, virtual addresses.

373
00:34:13,390 --> 00:34:16,430
 When you are going to map these virtual addresses

374
00:34:16,430 --> 00:34:18,830
 to the physical address space, when

375
00:34:18,830 --> 00:34:20,270
 you are going to translate them, you

376
00:34:20,270 --> 00:34:21,830
 are going to translate in such a way

377
00:34:21,830 --> 00:34:23,270
 that they are not going to conflict.

378
00:34:23,270 --> 00:34:32,510
 So now, with segmentation, we have

379
00:34:32,510 --> 00:34:36,830
 this external fragmentation.

380
00:34:36,830 --> 00:34:44,630
 And sometimes, it's harder to allocate storage

381
00:34:44,630 --> 00:34:48,750
 to variable size chunks.

382
00:34:48,750 --> 00:34:50,910
 So there is a solution for that.

383
00:34:50,910 --> 00:34:54,190
 And a solution for that, which is very simple,

384
00:34:54,190 --> 00:34:58,910
 is about instead of allocating variable size chunks,

385
00:34:58,910 --> 00:35:01,270
 you allocate fixed size chunks.

386
00:35:01,270 --> 00:35:02,750
 And these are called pages.

387
00:35:02,750 --> 00:35:08,150
 So every chunk of physical memory

388
00:35:08,150 --> 00:35:12,390
 is equivalent to the same that it has the same size.

389
00:35:12,390 --> 00:35:20,590
 And this can allow you to simplify a lot of things.

390
00:35:20,590 --> 00:35:23,870
 For instance, how do you handle allocation?

391
00:35:23,870 --> 00:35:26,150
 So one way to handle the allocation

392
00:35:26,150 --> 00:35:28,670
 is to have a bit vector.

393
00:35:28,670 --> 00:35:33,470
 And each bit in the vector represent one page.

394
00:35:33,470 --> 00:35:37,510
 And the value 0 is that whether that page has been allocated

395
00:35:37,510 --> 00:35:42,070
 from the physical memory or and 1 if it was allocated.

396
00:35:42,070 --> 00:35:47,630
 So if you want to find a page in physical memory you can allocate,

397
00:35:47,630 --> 00:35:51,470
 you just find a 0 in this bit vector.

398
00:35:51,470 --> 00:35:59,150
 Now, what about the size of the pages?

399
00:35:59,150 --> 00:36:03,270
 If the pages are too large, again, all pages

400
00:36:03,270 --> 00:36:04,150
 are the same size.

401
00:36:04,150 --> 00:36:05,430
 What is the problem?

402
00:36:05,430 --> 00:36:07,310
 What is the problem if the pages are too large?

403
00:36:07,310 --> 00:36:17,830
 [AUDIO OUT]

404
00:36:17,830 --> 00:36:20,910
 Wasty spice, internal fragmentation, excellent.

405
00:36:20,910 --> 00:36:26,430
 So I buy it and add it on.

406
00:36:26,430 --> 00:36:31,950
 And cost of context switching can be higher

407
00:36:31,950 --> 00:36:35,390
 if you need to swap that page out.

408
00:36:35,390 --> 00:36:37,350
 That's correct.

409
00:36:37,350 --> 00:36:41,350
 But yes, the main thing is about internal fragmentation.

410
00:36:41,350 --> 00:36:44,230
 Because if you think about, if you have these pages,

411
00:36:44,230 --> 00:36:46,830
 say you have a page of 1 gigabyte,

412
00:36:46,830 --> 00:36:50,750
 if your program is only 1 megabyte,

413
00:36:50,750 --> 00:36:54,550
 you waste enormous, most of the space.

414
00:36:54,550 --> 00:36:56,670
 So you want small pages.

415
00:36:56,670 --> 00:36:59,310
 OK?

416
00:36:59,310 --> 00:37:01,310
 The problem with the small pages,

417
00:37:01,310 --> 00:37:02,910
 what is the problem with the small pages?

418
00:37:02,910 --> 00:37:07,550
 [AUDIO OUT]

419
00:37:07,550 --> 00:37:08,990
 Any guess?

420
00:37:08,990 --> 00:37:14,550
 [AUDIO OUT]

421
00:37:14,550 --> 00:37:17,710
 Lots of accounting, more translation is yes.

422
00:37:17,710 --> 00:37:18,910
 Lots of accounting.

423
00:37:18,910 --> 00:37:21,910
 I wouldn't say more translations and larger page table.

424
00:37:21,910 --> 00:37:24,430
 OK, you already know about it.

425
00:37:24,430 --> 00:37:25,150
 Yes.

426
00:37:25,150 --> 00:37:28,470
 But it's accounting is hard.

427
00:37:28,470 --> 00:37:30,110
 You have to deal with more things.

428
00:37:30,430 --> 00:37:30,950
 Right.

429
00:37:30,950 --> 00:37:37,910
 And OK, so let's see.

430
00:37:37,910 --> 00:37:40,270
 So now, how do you do the translation?

431
00:37:40,270 --> 00:37:44,830
 But there are not many more translation because--

432
00:37:44,830 --> 00:37:45,790
 in theory, right?

433
00:37:45,790 --> 00:37:48,870
 Because you still need to-- every virtual address,

434
00:37:48,870 --> 00:37:52,870
 you need to translate your physical address.

435
00:37:52,870 --> 00:37:55,510
 The little bit of truth of that, the higher overhead

436
00:37:55,510 --> 00:37:58,350
 per translation could be.

437
00:37:58,350 --> 00:38:00,710
 But the number of translation is basically the same.

438
00:38:00,710 --> 00:38:05,950
 Yeah, works on cache can be that as well.

439
00:38:05,950 --> 00:38:07,630
 Yeah.

440
00:38:07,630 --> 00:38:13,310
 OK, so how is a translation works with paging?

441
00:38:13,310 --> 00:38:15,150
 It's very similar with segmentation,

442
00:38:15,150 --> 00:38:17,270
 but with a few differences.

443
00:38:17,270 --> 00:38:21,630
 So first of all, you have a page table.

444
00:38:21,630 --> 00:38:25,870
 And the virtual address, as again, is in two parts.

445
00:38:25,870 --> 00:38:29,550
 We have a virtual page number and an offset.

446
00:38:29,550 --> 00:38:32,470
 But there is a difference.

447
00:38:32,470 --> 00:38:35,990
 The offset is not added to a base address.

448
00:38:35,990 --> 00:38:38,790
 The offset of the address remains the same.

449
00:38:38,790 --> 00:38:43,510
 So with translation, when you use paging, what happens,

450
00:38:43,510 --> 00:38:46,350
 it's only the virtual page part.

451
00:38:46,350 --> 00:38:49,510
 The first field changes, right?

452
00:38:49,510 --> 00:38:52,950
 A virtual page number is replaced

453
00:38:52,950 --> 00:38:55,430
 by a physical page number.

454
00:38:55,430 --> 00:38:56,790
 That's it.

455
00:38:56,790 --> 00:39:01,390
 So the same like previously, the first bits, in this case,

456
00:39:01,390 --> 00:39:03,870
 the virtual page number in the previous case

457
00:39:03,870 --> 00:39:08,590
 was a segment number, are going to index in the page table.

458
00:39:08,590 --> 00:39:11,590
 But in the page table, what you are going to find,

459
00:39:11,590 --> 00:39:14,830
 you have a page number, which is a physical page number.

460
00:39:14,830 --> 00:39:17,230
 And you are going to take that physical page number,

461
00:39:17,230 --> 00:39:20,110
 and you are going to concatenate with the offset

462
00:39:20,110 --> 00:39:21,390
 of the virtual address.

463
00:39:21,390 --> 00:39:23,230
 So the offset of the physical address

464
00:39:23,230 --> 00:39:24,910
 and the offset of the physical address

465
00:39:24,910 --> 00:39:28,590
 are the same, OK?

466
00:39:28,590 --> 00:39:35,430
 Typical page sizes are between 4 kilobytes and 16 kilobytes

467
00:39:35,430 --> 00:39:36,670
 are quite small.

468
00:39:36,670 --> 00:39:38,070
 4 kilobytes means what?

469
00:39:38,070 --> 00:39:39,910
 12 bits, you need 12 bits.

470
00:39:39,910 --> 00:39:46,870
 And 16 kilobytes, you need another 14 bits, right?

471
00:39:52,630 --> 00:39:56,830
 So if you have even smaller pages, right?

472
00:39:56,830 --> 00:39:59,390
 And this is where you see the number,

473
00:39:59,390 --> 00:40:01,590
 the problem with the small pages.

474
00:40:01,590 --> 00:40:03,790
 So you have a 32-bit address.

475
00:40:03,790 --> 00:40:07,270
 And you are going to use 1 kilobyte pages.

476
00:40:07,270 --> 00:40:09,270
 So you need 10 bits offset.

477
00:40:09,270 --> 00:40:11,430
 This is what you need, 10 bits offset.

478
00:40:11,430 --> 00:40:16,190
 And therefore, the virtual page number, the number of bits

479
00:40:16,190 --> 00:40:19,470
 there is 22 bits, 32 minus 10, 22 bits.

480
00:40:19,470 --> 00:40:22,270
 So therefore, the page table have 4 million sentences.

481
00:40:22,270 --> 00:40:22,770
 Huge.

482
00:40:22,770 --> 00:40:29,070
 And just think about if you have 64 bits address.

483
00:40:29,070 --> 00:40:38,150
 So in order to do that, for instance, you are--

484
00:40:38,150 --> 00:40:40,720
 you are also going to not allocate space

485
00:40:40,720 --> 00:40:47,040
 for the entire maximum size page table.

486
00:40:47,040 --> 00:40:50,280
 So you are going to just grow this page table as you

487
00:40:50,280 --> 00:40:52,720
 add more pages to it.

488
00:40:52,720 --> 00:40:55,480
 And therefore, you are going to have in addition to the page

489
00:40:55,480 --> 00:40:59,720
 table pointer, which represent the start of the page table,

490
00:40:59,720 --> 00:41:04,480
 also the page table size, which is, as the name implies,

491
00:41:04,480 --> 00:41:06,680
 the size of the page table, which can be increased

492
00:41:06,680 --> 00:41:10,760
 as you add more tables, as you allocate more pages

493
00:41:10,760 --> 00:41:11,720
 and you are--

494
00:41:11,720 --> 00:41:16,880
 so that you allocate more entries,

495
00:41:16,880 --> 00:41:18,740
 you add more entries to the page table.

496
00:41:18,740 --> 00:41:23,700
 Also, with each page, you are going

497
00:41:23,700 --> 00:41:29,920
 to have a bunch of bits which represents some--

498
00:41:29,920 --> 00:41:35,080
 we are going to discuss them more a little bit later.

499
00:41:35,080 --> 00:41:36,720
 So keep in mind about these bits.

500
00:41:36,720 --> 00:41:44,800
 We are going to give an example a few slides later.

501
00:41:44,800 --> 00:41:48,880
 So this is a very simple page table.

502
00:41:48,880 --> 00:41:55,200
 You have a four-by space, so it's a trivial example.

503
00:41:55,200 --> 00:41:56,880
 You have this on the virtual memory.

504
00:41:56,880 --> 00:42:02,880
 You have four pages starting from 0, 4, and 8.

505
00:42:02,880 --> 00:42:06,920
 And then you have a page table only with three entries,

506
00:42:06,920 --> 00:42:12,880
 because you have three pages in the virtual memory.

507
00:42:12,880 --> 00:42:17,200
 So assume that the address space here

508
00:42:17,200 --> 00:42:23,960
 is has equivalent of 8 bits, so it's 64 bytes.

509
00:42:23,960 --> 00:42:28,800
 So the address, if you need for the page table,

510
00:42:28,800 --> 00:42:32,160
 again, if you have four bits, you need only two bits

511
00:42:32,160 --> 00:42:35,920
 to represent four bytes, to address four bytes.

512
00:42:35,920 --> 00:42:40,560
 So therefore, the last two bits represent the offset,

513
00:42:40,560 --> 00:42:43,600
 and the first six bits represent what?

514
00:42:43,600 --> 00:42:47,640
 Represent the page number.

515
00:42:47,640 --> 00:42:53,760
 OK, so if you want A, it's at the address 0 here.

516
00:42:53,760 --> 00:42:56,720
 So if you want to translate the address 0,

517
00:42:56,720 --> 00:43:03,400
 then the page number identifies the first entry in the table.

518
00:43:03,400 --> 00:43:06,240
 The first entry in the table contains four.

519
00:43:06,240 --> 00:43:10,360
 So now four is a new physical page number,

520
00:43:10,360 --> 00:43:13,560
 so you are going to concatenate these four

521
00:43:13,560 --> 00:43:17,000
 with the offset, which is 0.

522
00:43:17,000 --> 00:43:20,560
 So you are going to get 0x10.

523
00:43:20,560 --> 00:43:26,560
 OK?

524
00:43:26,560 --> 00:43:28,880
 The same thing, similar things happen

525
00:43:28,880 --> 00:43:35,840
 if you want to access the first address, the address four,

526
00:43:35,840 --> 00:43:37,480
 the virtual address four.

527
00:43:37,480 --> 00:43:39,480
 The virtual address four now is going

528
00:43:39,480 --> 00:43:41,800
 to lead you, because the offset is one,

529
00:43:41,800 --> 00:43:44,720
 is going to lead you to the second entry in the page table.

530
00:43:44,720 --> 00:43:47,280
 The second entry in the page table contains three,

531
00:43:47,280 --> 00:43:49,760
 so you are going to concatenate three with zero,

532
00:43:49,760 --> 00:43:50,920
 which is the offset.

533
00:43:50,920 --> 00:43:57,120
 You are going to get to the address 0c, physical address,

534
00:43:57,120 --> 00:43:58,360
 and so forth.

535
00:43:58,360 --> 00:44:00,480
 OK?

536
00:44:00,480 --> 00:44:01,400
 Any questions?

537
00:44:01,400 --> 00:44:07,600
 So question here, why was space size issues

538
00:44:07,600 --> 00:44:10,040
 in between 4 kilobytes and 16 kilobytes?

539
00:44:10,040 --> 00:44:12,960
 This is, again, always a trade-off.

540
00:44:12,960 --> 00:44:15,760
 The smaller the table, the smaller the page,

541
00:44:15,760 --> 00:44:17,440
 the smaller the internal fragmentation,

542
00:44:17,440 --> 00:44:21,080
 so the less wasted space.

543
00:44:21,080 --> 00:44:23,920
 However, the smaller the page, the larger the page tables

544
00:44:23,920 --> 00:44:28,040
 are, so therefore, it's much more context switching,

545
00:44:28,040 --> 00:44:29,840
 actually, can be more expensive.

546
00:44:29,840 --> 00:44:37,400
 Good question.

547
00:44:37,400 --> 00:44:39,920
 OK?

548
00:44:39,920 --> 00:44:44,520
 And these are some other translation.

549
00:44:44,520 --> 00:44:47,080
 Translating the address five, it's

550
00:44:47,080 --> 00:44:49,960
 going to translate to the address in this case

551
00:44:49,960 --> 00:44:56,600
 is basically 117, and I think there is another example.

552
00:44:56,600 --> 00:45:00,280
 Nine is going-- sorry.

553
00:45:00,280 --> 00:45:02,360
 Previous case, the address six was

554
00:45:02,360 --> 00:45:06,920
 translating to the address 116, and the second case,

555
00:45:06,920 --> 00:45:13,760
 the address nine is going to translate to address five.

556
00:45:13,760 --> 00:45:15,120
 No, physical address five.

557
00:45:15,120 --> 00:45:18,600
 [AUDIO OUT]

558
00:45:18,600 --> 00:45:37,320
 So there is an anonymous question

559
00:45:37,320 --> 00:45:43,920
 asking about if the 0x12345678 is the address,

560
00:45:43,920 --> 00:45:48,560
 could the first 123456 can be the offset?

561
00:45:48,560 --> 00:45:57,560
 Now, again, the offset are the last bits in the address.

562
00:45:57,560 --> 00:45:58,640
 OK?

563
00:45:58,640 --> 00:46:02,880
 So in this particular case, again, the offset,

564
00:46:02,880 --> 00:46:08,160
 if you look at the first one, example here, the offset,

565
00:46:08,160 --> 00:46:12,200
 it's one, zero, are the black bits,

566
00:46:12,200 --> 00:46:15,560
 and the page number are the red bits.

567
00:46:15,560 --> 00:46:24,680
 So the offset is two in this case, and the page number,

568
00:46:24,680 --> 00:46:26,360
 it's one.

569
00:46:26,360 --> 00:46:29,240
 And page number one selects the second entry

570
00:46:29,240 --> 00:46:32,360
 in the page table, which is three, so it's one, one.

571
00:46:32,360 --> 00:46:35,440
 And the offset remains one, zero,

572
00:46:35,440 --> 00:46:38,800
 so now I have one, one, one, zero, which is basically e.

573
00:46:39,200 --> 00:46:42,320
 [AUDIO OUT]

574
00:46:42,320 --> 00:46:43,720
 OK.

575
00:46:43,720 --> 00:46:46,000
 What about sharing?

576
00:46:46,000 --> 00:46:50,200
 Well, if you want to share a page between processes,

577
00:46:50,200 --> 00:46:54,440
 these are not RPT-E's, right?

578
00:46:54,440 --> 00:46:57,160
 You just-- you have each of the processes

579
00:46:57,160 --> 00:46:59,320
 has its own page table, and if you

580
00:46:59,320 --> 00:47:03,280
 want to share the same pages, then the corresponding entries

581
00:47:03,280 --> 00:47:07,120
 are going to point to the same physical table.

582
00:47:07,120 --> 00:47:07,600
 That's it.

583
00:47:07,600 --> 00:47:09,880
 [AUDIO OUT]

584
00:47:09,880 --> 00:47:12,960
 Very elegant.

585
00:47:12,960 --> 00:47:15,280
 Where is page sharing used?

586
00:47:15,280 --> 00:47:17,960
 Kernel region of the processes.

587
00:47:17,960 --> 00:47:25,560
 So of every-- so for the processes,

588
00:47:25,560 --> 00:47:28,280
 you have a kernel region, as you remember,

589
00:47:28,280 --> 00:47:31,040
 so every process has the same--

590
00:47:31,040 --> 00:47:32,880
 all the processes, they have to see

591
00:47:32,880 --> 00:47:36,680
 that you are going to share this code, the kernel code,

592
00:47:36,680 --> 00:47:39,680
 across all the processes, because the same code is not

593
00:47:39,680 --> 00:47:40,440
 going to change.

594
00:47:40,440 --> 00:47:50,080
 You can-- and by the way, this is protected.

595
00:47:50,080 --> 00:47:52,320
 It's like the kernel will have--

596
00:47:52,320 --> 00:47:58,800
 the process only can access at the user level

597
00:47:58,800 --> 00:48:00,680
 when I'm talking about the kernel region.

598
00:48:00,680 --> 00:48:02,480
 I'm not talking about kernel region being

599
00:48:02,480 --> 00:48:03,520
 accessed by the process.

600
00:48:03,520 --> 00:48:07,280
 I'm talking about the kernel regions associated

601
00:48:07,280 --> 00:48:09,560
 with the process, which is accessed by the kernel

602
00:48:09,560 --> 00:48:13,280
 during the context switching.

603
00:48:13,280 --> 00:48:20,440
 During different processes running the same binary,

604
00:48:20,440 --> 00:48:25,560
 you don't need to duplicate that because the code is read only.

605
00:48:25,560 --> 00:48:28,560
 User level libraries, like I mentioned,

606
00:48:28,560 --> 00:48:30,360
 or even sharing the data between--

607
00:48:30,360 --> 00:48:32,680
 you can share the data between the processes.

608
00:48:32,680 --> 00:48:34,560
 You can use a shared memory.

609
00:48:34,560 --> 00:48:42,760
 So this is another example.

610
00:48:42,760 --> 00:48:46,200
 This is a summary of paging.

611
00:48:46,200 --> 00:48:49,520
 On the left-hand side, you have the virtual memory view.

612
00:48:49,520 --> 00:48:53,480
 On the right-hand side, you have the physical memory view.

613
00:48:53,480 --> 00:48:57,800
 And in the middle, you have the page table.

614
00:48:57,800 --> 00:49:01,200
 You see that many entries in the tables are null,

615
00:49:01,200 --> 00:49:03,600
 but this is a full page table.

616
00:49:03,600 --> 00:49:08,800
 And here, we are assuming an 8-bits address.

617
00:49:08,800 --> 00:49:12,320
 And now, the offset are the last three bits.

618
00:49:12,320 --> 00:49:16,600
 So the base size is 2 power 3, so it's 8 bytes.

619
00:49:16,600 --> 00:49:21,480
 And the page number is 5 bits.

620
00:49:21,480 --> 00:49:23,640
 So you are going to have 2 power 5.

621
00:49:23,640 --> 00:49:30,120
 You have 32 entries in the page table up to.

622
00:49:30,120 --> 00:49:30,920
 OK.

623
00:49:30,920 --> 00:49:32,760
 So now, the one thing--

624
00:49:32,760 --> 00:49:36,760
 and on the right-hand side, you have, again,

625
00:49:36,760 --> 00:49:38,360
 like the physical memory.

626
00:49:38,360 --> 00:49:42,480
 So one thing here I just want to show you, and earlier on,

627
00:49:42,480 --> 00:49:45,120
 I said that, well, the stack--

628
00:49:45,120 --> 00:49:49,040
 how the stack and the heap grows here.

629
00:49:49,040 --> 00:49:52,880
 So now, the stack, again, grows downwards,

630
00:49:52,880 --> 00:49:57,680
 so grows going to lower addresses.

631
00:49:57,680 --> 00:50:02,160
 And you see here, the stack, it's on the right-hand side.

632
00:50:02,160 --> 00:50:06,440
 And with what I represented here, with the gray,

633
00:50:06,440 --> 00:50:09,640
 the pages with gray are all OK, are all reallocated.

634
00:50:09,640 --> 00:50:13,440
 So only the pages which are white are not allocated yet.

635
00:50:13,440 --> 00:50:15,160
 So let's see what happens and how

636
00:50:15,160 --> 00:50:17,200
 you are going to grow the stack.

637
00:50:17,200 --> 00:50:19,640
 So now, the problem is that, let's say

638
00:50:19,640 --> 00:50:22,560
 that I want to grow the stack by two pages.

639
00:50:22,560 --> 00:50:24,640
 I decide to grow the stack by two pages

640
00:50:24,640 --> 00:50:25,840
 in the virtual memory.

641
00:50:25,840 --> 00:50:29,120
 The virtual memory, I can very conveniently grow the stack

642
00:50:29,120 --> 00:50:31,480
 because I have enough space in the virtual memory.

643
00:50:31,480 --> 00:50:33,440
 However, in the physical memory, if I'm

644
00:50:33,440 --> 00:50:38,560
 going to try to grow it, I can allocate another page.

645
00:50:38,560 --> 00:50:41,000
 You can allocate another page.

646
00:50:41,000 --> 00:50:43,000
 Maybe you have only room for another page

647
00:50:43,000 --> 00:50:45,400
 there if you want to allocate contiguously

648
00:50:45,400 --> 00:50:47,480
 the pages to the stack.

649
00:50:47,480 --> 00:50:50,560
 But the point is a page with a translation

650
00:50:50,560 --> 00:50:55,800
 that these pages do not need to be allocated contiguously.

651
00:50:55,800 --> 00:50:58,040
 So therefore, the only thing you can do,

652
00:50:58,040 --> 00:50:59,960
 the only thing you need to do, you

653
00:50:59,960 --> 00:51:04,440
 need to find room for two other pages.

654
00:51:04,440 --> 00:51:07,240
 And you are going to allocate these pages for the stack.

655
00:51:07,240 --> 00:51:10,720
 But again, they don't need to be contiguous.

656
00:51:10,720 --> 00:51:13,000
 Whatever is contiguous in the virtual memory

657
00:51:13,000 --> 00:51:15,240
 doesn't need to be contiguous in the physical memory.

658
00:51:24,800 --> 00:51:25,800
 OK.

659
00:51:25,800 --> 00:51:39,480
 So now the biggest problem and the challenge, the table size,

660
00:51:39,480 --> 00:51:41,080
 if you're in the simplest version,

661
00:51:41,080 --> 00:51:46,080
 in the simple instantiation, in the simplest implementation,

662
00:51:46,080 --> 00:51:48,600
 the type of size repeats.

663
00:51:48,600 --> 00:51:53,680
 It's equal with the number of pages in the virtual memory.

664
00:51:53,680 --> 00:51:56,120
 And this can be absolutely huge.

665
00:51:56,120 --> 00:52:02,320
 So let's give Satek an example.

666
00:52:02,320 --> 00:52:05,960
 So you have 32 bits address space.

667
00:52:05,960 --> 00:52:11,160
 So you have 4 gigabytes address, virtual address space.

668
00:52:11,160 --> 00:52:21,240
 And these are just the units for you to remember.

669
00:52:21,240 --> 00:52:24,160
 So the one thing to remember here and one confusion

670
00:52:24,160 --> 00:52:29,920
 I've seen often is that when you are going--

671
00:52:29,920 --> 00:52:32,520
 when you are talking about the memory,

672
00:52:32,520 --> 00:52:37,600
 we are talking about the power of two units.

673
00:52:37,600 --> 00:52:41,840
 So 1 kilobyte is 2 power 10.

674
00:52:41,840 --> 00:52:45,440
 1 megabyte, 2 power 10.

675
00:52:45,440 --> 00:52:48,360
 And gigabyte, 2 power 10.

676
00:52:48,360 --> 00:52:58,080
 When we are talking about bandwidth and how much

677
00:52:58,080 --> 00:53:02,240
 capacity, network capacity, we are talking in power of 10.

678
00:53:02,240 --> 00:53:10,960
 1 kilobyte or 1 kilobit, it's 1,000 bits.

679
00:53:10,960 --> 00:53:17,880
 1 gigabyte, 1 gigabit represent what?

680
00:53:17,880 --> 00:53:19,920
 It's 1 billion bits.

681
00:53:19,920 --> 00:53:27,640
 So now, assume the typical page size is 4 kilobytes.

682
00:53:27,640 --> 00:53:28,800
 So it's 2 power 10.

683
00:53:28,800 --> 00:53:37,320
 We need 10 bits to address any byte in a 4 kilobyte page.

684
00:53:37,320 --> 00:53:42,960
 So therefore, OK.

685
00:53:42,960 --> 00:53:45,800
 Sorry, we need 12, what I'm talking about.

686
00:53:45,800 --> 00:53:51,440
 If the page is 4 kilobytes, this means 2 power 12.

687
00:53:51,440 --> 00:53:56,160
 So therefore, I need 12 bits to address any byte within a page.

688
00:53:56,160 --> 00:53:58,840
 So the offset is 10 bits.

689
00:53:58,840 --> 00:54:04,440
 And therefore, if the offset is 10 bits,

690
00:54:04,440 --> 00:54:12,000
 the page number, it's 32 minus 12 is 20 bits.

691
00:54:12,000 --> 00:54:21,720
 So now, the page table size can have as big as 4 megabytes.

692
00:54:21,720 --> 00:54:26,400
 Right?

693
00:54:26,400 --> 00:54:29,520
 Why is 4 megabytes?

694
00:54:29,520 --> 00:54:34,920
 Because each of the entry in the page table

695
00:54:34,920 --> 00:54:37,360
 needs to have 20 bits.

696
00:54:37,360 --> 00:54:43,160
 And then you are also going to have some other, like you see,

697
00:54:43,160 --> 00:54:45,160
 some other flags associated.

698
00:54:45,160 --> 00:54:49,000
 So you have 32 bits for each entry.

699
00:54:49,000 --> 00:54:52,800
 So it's 4 bytes, and you have 2 power 20 entries.

700
00:54:52,800 --> 00:54:54,360
 So it's 4 megabytes total.

701
00:54:57,520 --> 00:55:00,200
 So this was a lot of memory.

702
00:55:00,200 --> 00:55:02,480
 And now, think about this was in the past

703
00:55:02,480 --> 00:55:05,840
 when you have 32 bits was the standard,

704
00:55:05,840 --> 00:55:08,680
 but now the standard is 64 bits.

705
00:55:08,680 --> 00:55:10,840
 There is no way, right?

706
00:55:10,840 --> 00:55:13,480
 If you try to do the same thing here,

707
00:55:13,480 --> 00:55:17,000
 you are going to have 30 exabytes, which

708
00:55:17,000 --> 00:55:19,040
 is only for the page table.

709
00:55:19,040 --> 00:55:22,040
 Actually, you don't have enough physical memory

710
00:55:22,040 --> 00:55:26,760
 to store that page table.

711
00:55:26,760 --> 00:55:28,160
 This is really a lot of space.

712
00:55:28,160 --> 00:55:31,160
 So what is the solution here?

713
00:55:31,160 --> 00:55:31,680
 Right?

714
00:55:31,680 --> 00:55:34,680
 And by the way, all this space is empty.

715
00:55:34,680 --> 00:55:36,280
 Most of this-- no, no, not all of this.

716
00:55:36,280 --> 00:55:38,240
 Most of this space is empty because you don't

717
00:55:38,240 --> 00:55:39,680
 have as many page tables.

718
00:55:39,680 --> 00:55:42,600
 You have very few page tables, right?

719
00:55:42,600 --> 00:55:47,400
 So which are actually allocated.

720
00:55:47,400 --> 00:55:48,840
 So what is a--

721
00:55:48,840 --> 00:55:53,840
 so this is a big problem, and we are looking for a solution.

722
00:55:53,840 --> 00:55:56,000
 So a little bit of a discussion about page table

723
00:55:56,000 --> 00:55:57,040
 before going forward.

724
00:55:57,040 --> 00:56:02,880
 So what do you need to switch on the page table?

725
00:56:02,880 --> 00:56:10,240
 When a context switch happens, what do you need to do?

726
00:56:10,240 --> 00:56:13,360
 You need to have a page for the table point--

727
00:56:13,360 --> 00:56:18,000
 the page table pointer, so the beginning of the page table

728
00:56:18,000 --> 00:56:21,440
 and the limit, the size of the page table.

729
00:56:24,000 --> 00:56:34,480
 Again, remember about the dual mode operation, because these

730
00:56:34,480 --> 00:56:41,200
 space tables can be only modified and accessed

731
00:56:41,200 --> 00:56:42,480
 by the kernel.

732
00:56:42,480 --> 00:56:49,240
 You cannot let an application access these space tables,

733
00:56:49,240 --> 00:56:51,080
 because then they can change the page table,

734
00:56:51,080 --> 00:56:56,000
 and they can point to anywhere, to any other address,

735
00:56:56,000 --> 00:57:02,120
 including the kernel or the address of other applications.

736
00:57:02,120 --> 00:57:09,160
 And now let's look at the pros and cons.

737
00:57:09,160 --> 00:57:13,280
 On the pros side, it's a very simple memory allocation.

738
00:57:13,280 --> 00:57:15,480
 Remember, you have a bit vector, 0 or 1,

739
00:57:15,480 --> 00:57:19,560
 whether the page is allocated or not in the physical memory.

740
00:57:19,560 --> 00:57:23,920
 The bit vector contains one bit for each page

741
00:57:23,920 --> 00:57:26,760
 in the physical memory.

742
00:57:26,760 --> 00:57:27,600
 Easy to share.

743
00:57:27,600 --> 00:57:31,960
 The cons we've seen.

744
00:57:31,960 --> 00:57:34,560
 If the address space is very sparse,

745
00:57:34,560 --> 00:57:35,920
 the page table can be huge.

746
00:57:35,920 --> 00:57:48,560
 So again, if the page table is big,

747
00:57:48,560 --> 00:57:50,400
 then you need also probably to context switch.

748
00:57:50,400 --> 00:57:52,320
 You cannot keep all the time in the memory.

749
00:57:52,320 --> 00:58:00,760
 If the process is a page table of a process,

750
00:58:00,760 --> 00:58:07,000
 if the process is now switched off

751
00:58:07,000 --> 00:58:10,480
 and is no longer using the CPU, you may want--

752
00:58:10,480 --> 00:58:11,600
 it was preempted.

753
00:58:11,600 --> 00:58:14,480
 You may want to take the page table of that process

754
00:58:14,480 --> 00:58:16,760
 and swap on the disk.

755
00:58:16,760 --> 00:58:19,720
 But if that is large, then the overhead is very large.

756
00:58:19,720 --> 00:58:27,800
 So the TLDR here, the page table,

757
00:58:27,800 --> 00:58:32,640
 the paging is a technique with elegant solution.

758
00:58:32,640 --> 00:58:35,480
 Very simple to implement.

759
00:58:35,480 --> 00:58:39,480
 Provides low internal fragmentation

760
00:58:39,480 --> 00:58:42,200
 if the pages are small.

761
00:58:42,200 --> 00:58:49,640
 On the downside, the problem we encounter

762
00:58:49,640 --> 00:58:52,040
 is because the page tables can be huge.

763
00:58:52,040 --> 00:58:57,720
 So what is the solution?

764
00:58:57,720 --> 00:59:00,200
 Well, the solution is you know, you

765
00:59:00,200 --> 00:59:01,960
 represent the same technique, right?

766
00:59:01,960 --> 00:59:04,640
 You recursively do it.

767
00:59:04,640 --> 00:59:08,080
 And it's multilevel paging.

768
00:59:08,080 --> 00:59:11,280
 Look, if the page tables are very large,

769
00:59:11,280 --> 00:59:14,520
 then why don't we have a page table for that page table,

770
00:59:14,520 --> 00:59:16,400
 right?

771
00:59:16,400 --> 00:59:21,200
 Or you can combine paging segmentations, OK?

772
00:59:21,200 --> 00:59:28,440
 So and these are the two solutions.

773
00:59:28,440 --> 00:59:31,200
 Segment mapping, you are going to have segments.

774
00:59:31,200 --> 00:59:35,640
 And in the segments, you are going to have--

775
00:59:35,640 --> 00:59:37,320
 you know, you page the segments.

776
00:59:40,240 --> 00:59:42,400
 And then in the page tables, you are

777
00:59:42,400 --> 00:59:45,640
 going to page the page tables.

778
00:59:45,640 --> 00:59:49,200
 And let's look about how this is working.

779
00:59:49,200 --> 01:00:01,960
 So the core, remember that the page table

780
01:00:01,960 --> 01:00:04,640
 is a map between the virtual page number

781
01:00:04,640 --> 01:00:07,760
 and the physical page number.

782
01:00:07,760 --> 01:00:08,640
 This is what it is.

783
01:00:08,640 --> 01:00:14,000
 So a simple page table is just a lookup table.

784
01:00:14,000 --> 01:00:19,080
 VPN, the virtual page number, it's

785
01:00:19,080 --> 01:00:21,760
 an index in this table which contains a physical page

786
01:00:21,760 --> 01:00:22,240
 number.

787
01:00:22,240 --> 01:00:30,640
 By the way, what other map structures can you think of?

788
01:00:30,640 --> 01:00:34,760
 There are many of them, trees, hash table, and so forth.

789
01:00:34,760 --> 01:00:36,920
 But obviously, these are more complicated.

790
01:00:36,920 --> 01:00:39,280
 More complicated means higher overhead,

791
01:00:39,280 --> 01:00:42,920
 even though they can have slower storage overhead.

792
01:00:42,920 --> 01:00:45,000
 The beautiful things about the page table

793
01:00:45,000 --> 01:00:48,440
 is very quick to access, right?

794
01:00:48,440 --> 01:00:51,480
 It's just an index.

795
01:00:51,480 --> 01:00:54,200
 If you use the trees and hash tables,

796
01:00:54,200 --> 01:00:56,560
 and we'll see about that.

797
01:00:56,560 --> 01:00:58,940
 They are much more space efficient.

798
01:00:58,940 --> 01:01:03,620
 You don't need to maintain all the entries, which you know, for it, there is no table,

799
01:01:03,620 --> 01:01:07,580
 but accessing those is much more expensive.

800
01:01:07,580 --> 01:01:13,900
 There's a trade-off here.

801
01:01:13,900 --> 01:01:20,840
 So one simple solution is like we mentioned is to have to do the problem of having very

802
01:01:20,840 --> 01:01:27,220
 big page tables is to page these page tables.

803
01:01:27,220 --> 01:01:31,060
 And basically, here is a two-level page table.

804
01:01:31,060 --> 01:01:38,400
 And here is that instead of now the address has three fields.

805
01:01:38,400 --> 01:01:42,200
 At the end is the offset like before, no difference here.

806
01:01:42,200 --> 01:01:52,180
 But what was previously corresponding to the page number, now you split into two fields,

807
01:01:52,180 --> 01:02:01,500
 which corresponds to virtual page numbers or page indexes for the two-level pages.

808
01:02:01,500 --> 01:02:11,600
 So the first 10 bits in this case represents a virtual p1 index.

809
01:02:11,600 --> 01:02:17,940
 So indexing the first level table, page table.

810
01:02:17,940 --> 01:02:29,700
 And this is going to take you-- it's going to contain an address to a page containing

811
01:02:29,700 --> 01:02:34,300
 the page table entries at the second level.

812
01:02:34,300 --> 01:02:38,320
 OK?

813
01:02:38,320 --> 01:02:46,540
 So in order to compute now the entire physical address, use a p1 index to find the address

814
01:02:46,540 --> 01:03:01,540
 of the page containing the physical page number, which is stored in the second level.

815
01:03:01,540 --> 01:03:06,660
 And this physical page number is going to be concatenated with the offset like before.

816
01:03:06,660 --> 01:03:09,480
 And now you have the physical address.

817
01:03:09,480 --> 01:03:10,480
 OK?

818
01:03:10,480 --> 01:03:15,520
 So it's the same thing, the same thing.

819
01:03:15,520 --> 01:03:21,480
 The only difference is that now you split the physical page number into a part which

820
01:03:21,480 --> 01:03:31,400
 is going to index into a page table, first-level page table, which contains the address of

821
01:03:31,400 --> 01:03:35,080
 a second-level page table.

822
01:03:35,080 --> 01:03:42,220
 And the second field in this page number is going to index in the second-level page table.

823
01:03:42,220 --> 01:03:50,300
 And at that entry, corresponding entry, you are going to have physical page number.

824
01:03:50,300 --> 01:03:54,340
 And you can have many more levels.

825
01:03:54,340 --> 01:03:55,940
 So now these are some announcements.

826
01:03:55,940 --> 01:04:01,200
 We are just 15 minutes before the class, so ends.

827
01:04:01,200 --> 01:04:03,060
 But here are some announcements.

828
01:04:03,060 --> 01:04:06,120
 So you release a midterm score.

829
01:04:06,120 --> 01:04:11,980
 And please check Piazza for grading policies.

830
01:04:11,980 --> 01:04:14,600
 I think you did quite well.

831
01:04:14,600 --> 01:04:23,780
 The scores and the distribution is very much in line with that of the past midterms in

832
01:04:23,780 --> 01:04:28,160
 the recent years.

833
01:04:28,160 --> 01:04:34,200
 The Project 2 Design Document, remember, is due by this at the end of this Friday.

834
01:04:34,200 --> 01:04:40,460
 And the Homework 3 is due on Sunday at the end of the day.

835
01:04:40,460 --> 01:04:49,260
 So if you want an extra credit point, please feel free to meet semester survey and check

836
01:04:49,260 --> 01:04:50,660
 on Piazza for details.

837
01:04:50,660 --> 01:04:51,660
 OK?

838
01:04:51,660 --> 01:04:55,860
 So it's free, free extra credit.

839
01:04:55,860 --> 01:04:58,460
 The next lecture, I'll be out of town.

840
01:04:58,460 --> 01:05:05,300
 And Nathan Pemberton, who's a senior PhD student, which is expert both in architectures and

841
01:05:05,300 --> 01:05:09,620
 systems, is going to teach this class.

842
01:05:09,620 --> 01:05:12,600
 He's a fantastic teacher, fun.

843
01:05:12,600 --> 01:05:15,420
 I really urge you to attend his lecture.

844
01:05:15,420 --> 01:05:20,380
 They are going to be a lot more fun than my lectures.

845
01:05:20,380 --> 01:05:23,140
 So he's a great presenter.

846
01:05:23,140 --> 01:05:33,380
 So remember that I mentioned to you now that in a page table entry, besides a physical

847
01:05:33,380 --> 01:05:43,340
 page number, we are going also to have some bits.

848
01:05:43,340 --> 01:05:44,900
 And here is an example.

849
01:05:44,900 --> 01:05:50,340
 So let's take our previous examples in which you are going to have an offset of the-- you

850
01:05:50,340 --> 01:05:53,460
 have a 32-bits address.

851
01:05:53,460 --> 01:05:54,820
 The offset is 12 bits.

852
01:05:54,820 --> 01:05:59,860
 So the physical page number is 20 bits.

853
01:05:59,860 --> 01:06:01,400
 OK?

854
01:06:01,400 --> 01:06:10,140
 So now for in a page table, what you need, you need the physical page number, which is

855
01:06:10,140 --> 01:06:11,780
 these 20 bits.

856
01:06:11,780 --> 01:06:16,100
 So what about the rest of the rest of the rest of the rest of the bits?

857
01:06:16,100 --> 01:06:23,460
 So for the rest of the 12 bits, you are going to have a bunch of flags, which are used--

858
01:06:23,460 --> 01:06:26,820
 so you have different use.

859
01:06:26,820 --> 01:06:30,420
 You can use it in different ways.

860
01:06:30,420 --> 01:06:31,700
 But here is an example.

861
01:06:31,700 --> 01:06:36,540
 And this is from Intel Architecture.

862
01:06:36,540 --> 01:06:41,460
 So these are examples about these bits.

863
01:06:41,460 --> 01:06:47,420
 And we are going to start from the least significant bits.

864
01:06:47,420 --> 01:06:48,420
 0 is p.

865
01:06:48,420 --> 01:06:51,500
 This is present.

866
01:06:51,500 --> 01:06:53,300
 It's the same as valid.

867
01:06:53,300 --> 01:06:56,500
 Is the page present in physical memory or not?

868
01:06:56,500 --> 01:06:58,300
 W, writable.

869
01:06:58,300 --> 01:07:00,940
 Can you write on this page or not?

870
01:07:00,940 --> 01:07:03,900
 If it's 0, then it's read only.

871
01:07:03,900 --> 01:07:04,900
 U is user accessible.

872
01:07:04,900 --> 01:07:09,460
 Is this page accessible only by user?

873
01:07:09,460 --> 01:07:11,460
 OK.

874
01:07:11,460 --> 01:07:14,360
 PWT, page write transparent.

875
01:07:14,360 --> 01:07:16,180
 This is related with a cache.

876
01:07:16,180 --> 01:07:22,980
 Typically you have caches to reduce the latency to access the data.

877
01:07:22,980 --> 01:07:27,900
 And when you have caches, the problem, the question is about how you are going to update

878
01:07:27,900 --> 01:07:32,420
 the physical memory, the data in the physical memory.

879
01:07:32,420 --> 01:07:36,620
 And there are two ways here we are going to learn.

880
01:07:36,620 --> 01:07:41,500
 But one way is that whenever we are going to access and we are going to write to the

881
01:07:41,500 --> 01:07:49,340
 cache and modify the data, we are also going to modify the data in the physical memory.

882
01:07:49,340 --> 01:07:53,620
 And this is page writes transparent.

883
01:07:53,620 --> 01:07:57,400
 PCD is page cache disabled.

884
01:07:57,400 --> 01:07:59,500
 You cannot cache the pages.

885
01:07:59,500 --> 01:08:03,340
 A, it's access page has been accessed recently.

886
01:08:03,340 --> 01:08:05,500
 This is used also for caching.

887
01:08:05,500 --> 01:08:11,580
 If it's accessed recently, and the next two are the same, also for caching.

888
01:08:11,580 --> 01:08:15,740
 You want to know whether the page was accessed recently and whether it's dirty, whether it

889
01:08:15,740 --> 01:08:17,740
 was written.

890
01:08:17,740 --> 01:08:23,200
 And the physical memory associated with physical memory was not updated.

891
01:08:23,200 --> 01:08:25,100
 So you need to know about that.

892
01:08:25,100 --> 01:08:34,900
 And then you are going, we may decide to page that to-- this is-- OK, how do I say?

893
01:08:34,900 --> 01:08:43,700
 So these two bits, the only thing you need to know now, are used when deciding what page

894
01:08:43,700 --> 01:08:48,180
 to swap out of the memory to make room for new pages.

895
01:08:48,180 --> 01:08:53,860
 Fundamentally, you do not want to swap out a page of a process which will be accessed

896
01:08:53,860 --> 01:08:54,860
 immediately.

897
01:08:54,860 --> 01:09:12,180
 And OK, that's a question.

898
01:09:12,180 --> 01:09:17,620
 The PCD means-- the question is that PCD means-- it's about what PCD means.

899
01:09:17,620 --> 01:09:21,420
 The PCD means that the page is not cached.

900
01:09:21,420 --> 01:09:25,780
 And again, the reason you may choose to not cache a page is that, for instance, in multiprocessor

901
01:09:25,780 --> 01:09:34,860
 systems, multi-core systems, when you have concurrency on the same page, you have a page

902
01:09:34,860 --> 01:09:40,080
 which is shared to different processes which run on different processors.

903
01:09:40,080 --> 01:09:43,380
 And they can concurrently access that page.

904
01:09:43,380 --> 01:09:49,320
 And if you want to update the page, if it's cached, each processor cached, then you have

905
01:09:49,320 --> 01:09:51,540
 a cache coherency problem.

906
01:09:51,540 --> 01:09:55,040
 And if you want to simplify that problem, if you want to remove that problem, you can

907
01:09:55,040 --> 01:10:01,540
 say, OK, this page is never going to be cached.

908
01:10:01,540 --> 01:10:03,260
 OK.

909
01:10:03,260 --> 01:10:05,160
 OK.

910
01:10:05,160 --> 01:10:13,160
 So example of how to use PTEs, invalid PTEs is that-- again, even this one can imply different

911
01:10:13,160 --> 01:10:20,020
 things in the operating system besides how to use these flags.

912
01:10:20,020 --> 01:10:23,660
 So one-- yeah.

913
01:10:23,660 --> 01:10:30,300
 And one we use is that-- which I didn't mention-- is that the address space is actually not valid.

914
01:10:30,300 --> 01:10:31,300
 Right?

915
01:10:31,300 --> 01:10:34,300
 It doesn't-- it's not allocated.

916
01:10:34,300 --> 01:10:40,160
 But another way is basically, say, the page direct-- that page is not in the memory.

917
01:10:40,160 --> 01:10:41,160
 It's on the disk.

918
01:10:41,160 --> 01:10:42,160
 Right?

919
01:10:42,160 --> 01:10:48,820
 In that case, you need-- it's a trap to the operating system exception.

920
01:10:48,820 --> 01:10:52,480
 It results into a trap to the operating system.

921
01:10:52,480 --> 01:10:55,900
 And the operating system is going to figure out where is the page is stored and is going

922
01:10:55,900 --> 01:11:00,100
 to bring it to memory.

923
01:11:00,100 --> 01:11:02,260
 And this is going to be used by the main page.

924
01:11:02,260 --> 01:11:04,460
 We are going to learn about that.

925
01:11:04,460 --> 01:11:09,280
 Another use here is about copy on write for the PTE.

926
01:11:09,280 --> 01:11:14,340
 So basically, when you fork, remember that the fork-- when you fork a process, a fork

927
01:11:14,340 --> 01:11:16,580
 process copy actually is a parent process.

928
01:11:16,580 --> 01:11:17,580
 Right?

929
01:11:17,580 --> 01:11:18,580
 It has everything.

930
01:11:18,580 --> 01:11:23,340
 And now the question is, do you want to copy it right away?

931
01:11:23,340 --> 01:11:24,700
 Right?

932
01:11:24,700 --> 01:11:26,940
 And are you going to copy everything?

933
01:11:26,940 --> 01:11:33,560
 And it's not smart to do it because, for instance, the code of the process-- of the parent process

934
01:11:33,560 --> 01:11:36,580
 is the same code you are-- the child process is going to execute.

935
01:11:36,580 --> 01:11:39,660
 The code is read only, so you don't need to copy it.

936
01:11:39,660 --> 01:11:42,160
 But the same is also true about the data.

937
01:11:42,160 --> 01:11:43,160
 Right?

938
01:11:43,160 --> 01:11:48,160
 Do you want to copy-- to move that-- to copy the data from the process address space to

939
01:11:48,160 --> 01:11:49,880
 the child address space?

940
01:11:49,880 --> 01:11:53,800
 Well, the answer there is that only if the child-- ideally, only if the child accesses

941
01:11:53,800 --> 01:11:54,800
 it.

942
01:11:54,800 --> 01:11:55,800
 Right?

943
01:11:55,800 --> 01:11:56,800
 And writes it.

944
01:11:56,800 --> 01:11:57,800
 Right?

945
01:11:57,800 --> 01:12:05,020
 So when-- so that's what-- so initially, when you are going to create-- because you want

946
01:12:05,020 --> 01:12:11,680
 to reduce the overhead to create a deforca process, the fork process can share the entire

947
01:12:11,680 --> 01:12:15,520
 address-- the entire address space to the parent process.

948
01:12:15,520 --> 01:12:16,600
 OK?

949
01:12:16,600 --> 01:12:20,920
 So the reads are very-- the reads are going to the same memory.

950
01:12:20,920 --> 01:12:22,400
 It's memory efficient.

951
01:12:22,400 --> 01:12:23,400
 It's fast.

952
01:12:23,400 --> 01:12:24,400
 Right?

953
01:12:24,400 --> 01:12:26,040
 To fork.

954
01:12:26,040 --> 01:12:36,540
 And but then the only one you can start doing it is when you write it.

955
01:12:36,540 --> 01:12:48,340
 So when you write a page, now, only now, you are going to create a copy of that page for

956
01:12:48,340 --> 01:12:50,100
 the child.

957
01:12:50,100 --> 01:12:54,880
 And now the child can write and read from that copy.

958
01:12:54,880 --> 01:13:01,740
 But as long as you want to read, you can read from the same memory-- physical memory-- which

959
01:13:01,740 --> 01:13:07,440
 is shared with the parent.

960
01:13:07,440 --> 01:13:11,040
 Another use case here, it's a zero fill on demand.

961
01:13:11,040 --> 01:13:20,960
 So say you allocate, say, 10 gigabytes of memory, and you want to initialize to zero.

962
01:13:20,960 --> 01:13:29,760
 That initialization can take seconds, many seconds, just to do this initialization.

963
01:13:29,760 --> 01:13:34,860
 So you don't want to pay the overhead then when you are going to allocation.

964
01:13:34,860 --> 01:13:38,400
 So instead what you can do, you can do zero fill on demand.

965
01:13:38,400 --> 01:13:46,760
 So the OS knows that this page needs to be zero, but initially doesn't make them zero.

966
01:13:46,760 --> 01:13:50,560
 It makes them zero only when you access that page.

967
01:13:50,560 --> 01:13:55,920
 And that's perfectly fine because you amortize zeroing it.

968
01:13:55,920 --> 01:14:03,800
 Or even better, maybe the application is not going to ever touch every byte which is allocating

969
01:14:03,800 --> 01:14:05,800
 these 10 gigabytes.

970
01:14:05,800 --> 01:14:13,960
 So it's, again, some smart ways to use this PD.

971
01:14:13,960 --> 01:14:28,880
 So sharing with multiple level pages, you can see here you have two processes.

972
01:14:28,880 --> 01:14:36,800
 Each process has its own page table hierarchy.

973
01:14:36,800 --> 01:14:43,920
 And the first level page, you can see for each process, it's pointed from-- you have

974
01:14:43,920 --> 01:14:52,960
 the page table pointer and page table pointer prime for the two page tables, different page

975
01:14:52,960 --> 01:14:55,900
 tables, first level page tables.

976
01:14:55,900 --> 01:14:59,880
 And then each of them, they have point to second level page tables.

977
01:14:59,880 --> 01:15:04,960
 And what you can see here is that some of the second level page tables are shared.

978
01:15:04,960 --> 01:15:15,560
 And obviously, all the pages to which entries in the shared page tables point to are also

979
01:15:15,560 --> 01:15:21,440
 shared.

980
01:15:21,440 --> 01:15:32,160
 And finally, you remember, we started with solving this problem that the page tables

981
01:15:32,160 --> 01:15:35,080
 can become extremely large.

982
01:15:35,080 --> 01:15:43,000
 And if we have-- but many of the entries from these huge page tables are null, so contains

983
01:15:43,000 --> 01:15:45,640
 no information.

984
01:15:45,640 --> 01:15:53,560
 And we said that the two level page table is going to solve that, address that problem,

985
01:15:53,560 --> 01:15:55,420
 or at least alleviate that problem.

986
01:15:55,420 --> 01:15:56,860
 And here is an example.

987
01:15:56,860 --> 01:16:03,400
 So if you remember, this is an example, and let me just try to go back here.

988
01:16:03,400 --> 01:16:05,040
 So this is a previous example.

989
01:16:05,040 --> 01:16:12,920
 So this is an example in which you are going to have, if you can see, this was a one level

990
01:16:12,920 --> 01:16:14,180
 table.

991
01:16:14,180 --> 01:16:16,400
 So you have, I think, 72 entries.

992
01:16:16,400 --> 01:16:19,820
 Many of these entries are null.

993
01:16:19,820 --> 01:16:28,680
 And this is a corresponding example.

994
01:16:28,680 --> 01:16:40,000
 This is a corresponding example.

995
01:16:40,000 --> 01:16:42,080
 So you can see and you can count.

996
01:16:42,080 --> 01:16:51,540
 You have much fewer-- it requires fewer-- less storage for storing these page tables.

997
01:16:51,540 --> 01:16:58,800
 And certainly, you have much more fewer null entries.

998
01:16:58,800 --> 01:17:03,580
 So let me just continue.

999
01:17:03,580 --> 01:17:07,940
 We have just a few more minutes.

1000
01:17:07,940 --> 01:17:12,460
 And this also shows you about how the translation is done.

1001
01:17:12,460 --> 01:17:20,140
 So in this particular case, we have, for the first level page table, we use three bits.

1002
01:17:20,140 --> 01:17:21,660
 For the second level, two bits.

1003
01:17:21,660 --> 01:17:27,020
 And for the offset, three bits.

1004
01:17:27,020 --> 01:17:30,860
 So in the best case scenario, the size of the page tables is the number of pages used

1005
01:17:30,860 --> 01:17:39,240
 by the program in the virtual memory, unlike the previous case in which the number of pages

1006
01:17:39,240 --> 01:17:44,180
 was the one available in the physical memory.

1007
01:17:44,180 --> 01:17:51,620
 The price to pay here is that you have one more additional memory access, because you

1008
01:17:51,620 --> 01:18:04,140
 need to index on both page tables at both levels.

1009
01:18:04,140 --> 01:18:15,580
 So how about about segments, segments and pages?

1010
01:18:15,580 --> 01:18:18,140
 This is another way to do it.

1011
01:18:18,140 --> 01:18:24,760
 We have two level tables, but another way to solve similar problems is to combine segmentation

1012
01:18:24,760 --> 01:18:25,760
 with paging.

1013
01:18:25,760 --> 01:18:32,620
 So in this case, again, you have the address is split into three fields.

1014
01:18:32,620 --> 01:18:35,880
 But the first field represents a segment number.

1015
01:18:35,880 --> 01:18:40,140
 The second field represents a virtual page number within that segment.

1016
01:18:40,140 --> 01:18:42,580
 And then you have the offset.

1017
01:18:42,580 --> 01:18:49,660
 So it's a very similar approach.

1018
01:18:49,660 --> 01:18:53,300
 Is again here, what do you need to save and store when context switching?

1019
01:18:53,300 --> 01:18:58,300
 You need to store the segment table, you need to store the page table for that process.

1020
01:18:58,300 --> 01:19:04,700
 How do you share the data across different segments when you have these both segments

1021
01:19:04,700 --> 01:19:07,620
 and paging?

1022
01:19:07,620 --> 01:19:09,180
 It's the same very similar way.

1023
01:19:09,180 --> 01:19:18,860
 You are going to have from two different processes, they can share the pages by simply having

1024
01:19:18,860 --> 01:19:27,280
 the base by sharing the segment.

1025
01:19:27,280 --> 01:19:30,860
 If you want to send a bunch of pages, you are going to put all these pages in the same

1026
01:19:30,860 --> 01:19:37,860
 segment and you are going to share the segment.

1027
01:19:37,860 --> 01:19:46,680
 So let me do this one last slide and then I'm going to stop here.

1028
01:19:46,680 --> 01:19:53,580
 So when you have multi-level translation pages, what are the pros and cons?

1029
01:19:53,580 --> 01:20:01,140
 So the big pro is that you get to is much less space for the page tables.

1030
01:20:01,140 --> 01:20:02,140
 That's it.

1031
01:20:02,140 --> 01:20:08,740
 So the paging themselves, they have the big advantage that it's fixed size, so they retain

1032
01:20:08,740 --> 01:20:10,060
 the simplicity.

1033
01:20:10,060 --> 01:20:14,820
 You have no external fragmentation, you have only internal fragmentation.

1034
01:20:14,820 --> 01:20:23,360
 The cons is that the page tables can be huge because they need to be continuous because

1035
01:20:23,360 --> 01:20:25,500
 you need to index into that.

1036
01:20:25,500 --> 01:20:33,580
 And therefore you need to have multiple level of tables in order to get the memory allocation,

1037
01:20:33,580 --> 01:20:40,500
 to get efficient memory allocation for the page tables.

1038
01:20:40,500 --> 01:20:45,140
 But the big problem is that now you need to have multiple lookups for translation because

1039
01:20:45,140 --> 01:20:54,600
 you need to have a lookup for each level, for each page level.

1040
01:20:54,600 --> 01:21:03,400
 So let's stop here and again, please attend Nathan's lecture on Thursday and I'll see

1041
01:21:03,400 --> 01:21:07,340
 you next Monday.

1042
01:21:07,340 --> 01:21:09,300
 Thanks.

1043
01:21:09,300 --> 01:21:10,580
 So we are done.

1044
01:21:10,580 --> 01:21:13,620
 Let me just stop recording.

