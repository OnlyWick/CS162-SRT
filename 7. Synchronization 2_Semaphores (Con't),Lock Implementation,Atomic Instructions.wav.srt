1
00:00:00,000 --> 00:00:15,920
 Hello, everyone. Welcome to the seven lectures. So today we are going to continue our discussion

2
00:00:15,920 --> 00:00:25,840
 about concurrency. And this will happen also over the next couple of lectures. And as well

3
00:00:25,840 --> 00:00:33,600
 as we are going to discuss about lock implementation, which is one of the main primitives helping

4
00:00:33,600 --> 00:00:38,560
 us always controlling concurrency.

5
00:00:38,560 --> 00:00:49,720
 So remember about, again, this picture-- excuse me-- in which basically we are going to have

6
00:00:49,720 --> 00:01:01,560
 a program. And here what we are trying to do is how this program is going to yield the

7
00:01:01,560 --> 00:01:07,600
 access to the CPU to another program. If you remember, this was the old examples in which--

8
00:01:07,600 --> 00:01:12,760
 one of the first examples in which you have two instructions. The first one trying to

9
00:01:12,760 --> 00:01:19,800
 print-- to compute pi and print pi, and then the second instruction trying to print the

10
00:01:19,800 --> 00:01:27,960
 class list, if I remember correctly. And the point there is that if you try to print pi,

11
00:01:27,960 --> 00:01:34,520
 which means also you need to compute all the digits, you'll never end because pi has an

12
00:01:34,520 --> 00:01:38,720
 infinite number of decimals.

13
00:01:38,720 --> 00:01:45,200
 So then the solution was that while you are computing pi, you are going to give from time

14
00:01:45,200 --> 00:01:53,960
 to time access to the CPU to another process to continue. Otherwise, the CPU will be only

15
00:01:53,960 --> 00:01:57,280
 hauled by this compute pi program.

16
00:01:57,280 --> 00:02:06,240
 Now yield, it's a system call. And the system call is going to result in a trap to the kernel.

17
00:02:06,240 --> 00:02:17,720
 And the kernel will then take over, and it will suspend the current program thread and

18
00:02:17,720 --> 00:02:25,920
 run a new one. And this is a pseudocode, very simple. So this kind of you see, run your

19
00:02:25,920 --> 00:02:33,640
 thread. This is what is a function run by the kernel, which basically picks a new thread

20
00:02:33,640 --> 00:02:38,320
 and switch from the current thread, which is in blue here, to the new thread. And it's

21
00:02:38,320 --> 00:02:46,760
 doing some housekeeping and some cleanup when it's going to do this-- update some counters

22
00:02:46,760 --> 00:02:52,320
 at the time, for instance, a thread run and things like that.

23
00:02:52,320 --> 00:02:58,440
 Now the question, obviously, the key is like there are two things we want to understand

24
00:02:58,440 --> 00:03:02,960
 is like how to pick a new thread and how you are going to switch from the current thread

25
00:03:02,960 --> 00:03:14,840
 to the new thread. And if you remember, obviously, in order to do that, we need to save the state

26
00:03:14,840 --> 00:03:22,280
 of the current thread and then to initialize the registers of the processor, the PC counter,

27
00:03:22,280 --> 00:03:31,920
 with the values, with the state of the new thread, and then execute that new thread.

28
00:03:31,920 --> 00:03:41,240
 And one of these-- one important part of the state of a thread, if you remember, is a stack.

29
00:03:41,240 --> 00:03:45,960
 And let's look a little bit more into more details about these four simple examples in

30
00:03:45,960 --> 00:03:54,400
 which you are going to have two functions, a and b. a equals b, and b is that execute

31
00:03:54,400 --> 00:04:00,320
 a loop. And within that loop, you yield every time you execute the loop.

32
00:04:00,320 --> 00:04:09,320
 And suppose that we have two threads, s and b, and running this program. So both of them

33
00:04:09,320 --> 00:04:16,920
 run this program. So thread s is called function a here. And this is on the stack. You remember

34
00:04:16,920 --> 00:04:23,000
 that the stack grows from the high addresses to the low addresses. And on the stack, you

35
00:04:23,000 --> 00:04:31,960
 are going to have the return values, the return address after you execute the function, as

36
00:04:31,960 --> 00:04:36,760
 well as when you call a function, you are going to put on the stack the arguments for

37
00:04:36,760 --> 00:04:41,560
 that function. Of course, here, there are no arguments. But that happens in general.

38
00:04:41,560 --> 00:04:47,920
 So you have a first, which you call, you put on the stack, then b. And this is the one

39
00:04:47,920 --> 00:04:56,640
 which executes the while loop, and then is going to execute and run yield. And then,

40
00:04:56,640 --> 00:05:06,680
 again, yield is going to call the operating system. And the operating system, it's going

41
00:05:06,680 --> 00:05:14,320
 to execute the run new thread, and switch to the new thread. And when you switch, it's

42
00:05:14,320 --> 00:05:19,240
 going to run the other thread, c. We said that we have two threads in the system. And

43
00:05:19,240 --> 00:05:27,320
 the new thread will basically execute the same thing. And therefore, it's going to execute

44
00:05:27,320 --> 00:05:37,160
 a and b and b whenever it's going to execute the while, it's going to yield. So again,

45
00:05:37,160 --> 00:05:42,720
 you go to the operating system. And then you ping pong between the two threads. This is

46
00:05:42,720 --> 00:05:44,960
 what will happen.

47
00:05:44,960 --> 00:05:50,880
 So now, it's again, one thing we need to do when you are going to switch from the current

48
00:05:50,880 --> 00:05:59,240
 thread to the new thread, is we need to save the state of the current thread. So what that

49
00:05:59,240 --> 00:06:06,720
 means is that registers, you see, R0 to R7, these are registers. And then sb is a stack

50
00:06:06,720 --> 00:06:14,920
 pointer. And CPU is a return pointer. So the pointer of the next instruction should be

51
00:06:14,920 --> 00:06:22,760
 executed when I am going to resume the execution of this thread.

52
00:06:22,760 --> 00:06:27,660
 And now, the next thing we need to now to take care of the new thread. So we are going

53
00:06:27,660 --> 00:06:37,720
 to update the register of the processor, the stack pointers, and PC with the new-- sorry,

54
00:06:37,720 --> 00:06:46,700
 with the corresponding state of the new thread we want to run. And by the way, you see where

55
00:06:46,700 --> 00:06:54,400
 this state is stored? What is stored? It's in TCP, right? It's thread control block.

56
00:06:54,400 --> 00:07:00,220
 So I hope this kind of makes sense and it's pretty simple. Now, obviously, you need to

57
00:07:00,220 --> 00:07:04,980
 be careful when you implement that. And by the way, if you have any questions, let me

58
00:07:04,980 --> 00:07:09,460
 know. I'll be happy to answer as always.

59
00:07:09,460 --> 00:07:15,580
 So of course, you need to be very careful. I mean, for instance, if you forget to save

60
00:07:15,580 --> 00:07:24,340
 or store a particular register, say, and register32, then what will happen? Well, sometimes, you

61
00:07:24,340 --> 00:07:32,660
 have some things that happen. But what happens, it will very much depend about whether the

62
00:07:32,660 --> 00:07:37,460
 value in that register is going to be used by the program. If it's not going to be used,

63
00:07:37,460 --> 00:07:42,460
 nothing will happen. But if it's going to be used, you are going to see probably random--

64
00:07:42,460 --> 00:07:46,720
 is it random results or random failures?

65
00:07:46,720 --> 00:07:57,680
 And then, of course, you say, well, why wouldn't you then store-- you test carefully the entire

66
00:07:57,680 --> 00:08:06,240
 code. Well, the testing the entire code, especially testing it exhaustively, is very difficult

67
00:08:06,240 --> 00:08:10,800
 because there are many, many, many combinations. Why is there many combinations? There are

68
00:08:10,800 --> 00:08:19,100
 many combinations because a thread can be interrupted anywhere. So if you have a thread

69
00:08:19,100 --> 00:08:28,580
 which is-- you have 1,000 instructions, it can be interrupted after each of these instructions.

70
00:08:28,580 --> 00:08:33,300
 And you have another thread which has another 1,000 instructions. Now you have combination

71
00:08:33,300 --> 00:08:36,580
 about where you are going to interrupt the first thread, and you are going to resume

72
00:08:36,580 --> 00:08:45,320
 the second thread like 1 million. And there are many, many stories about errors, in some

73
00:08:45,320 --> 00:08:52,080
 cases which are found after a long time. Like for instance, in this case, it was a very

74
00:08:52,080 --> 00:09:01,320
 early kernel, Topaz. You can see based on the size. So it was obviously very well tested.

75
00:09:01,320 --> 00:09:13,320
 But it was one thing what happened is that it was one instruction, one correctly saving

76
00:09:13,320 --> 00:09:20,620
 the state of a thread depending of whether the kernel size was less than 1 megabyte.

77
00:09:20,620 --> 00:09:25,780
 And initially, it was less than 1 megabyte. But over time, like with any software, the

78
00:09:25,780 --> 00:09:33,660
 size increased. And people, developers forgot about this limitation. And when it did happen

79
00:09:33,660 --> 00:09:43,840
 and the size increased over 1 megabyte, then they started to get spurious errors. And this

80
00:09:43,840 --> 00:09:50,680
 kind of like we will discuss, these kind of errors are also very hard to debug because

81
00:09:50,680 --> 00:09:57,400
 they are not deterministic. So obviously again, like when you design, be very, very careful.

82
00:09:57,400 --> 00:10:01,100
 Design for simplicity, simple code, it's easier to check.

83
00:10:01,110 --> 00:10:04,270
 complex code and all, you know.

84
00:10:04,270 --> 00:10:10,150
 So now one of the question is about,

85
00:10:10,150 --> 00:10:16,370
 we are switching between two threads.

86
00:10:16,370 --> 00:10:21,270
 We are also switching, you know, it's context switching.

87
00:10:21,270 --> 00:10:24,850
 And you also have, we also refer as context switching,

88
00:10:24,850 --> 00:10:28,170
 when we are switching between two processes, okay?

89
00:10:29,470 --> 00:10:32,750
 Now, so, and this again, we discussed this in the past,

90
00:10:32,750 --> 00:10:36,430
 but let me repeat because it's a very important aspect.

91
00:10:36,430 --> 00:10:40,310
 When you do process switching,

92
00:10:40,310 --> 00:10:42,470
 you know, switch between two processes,

93
00:10:42,470 --> 00:10:44,830
 which means at the end of the day,

94
00:10:44,830 --> 00:10:46,830
 because you are switching between two threads

95
00:10:46,830 --> 00:10:48,270
 in a different processes,

96
00:10:48,270 --> 00:10:53,270
 that switch is much more expensive, okay?

97
00:10:53,270 --> 00:10:56,630
 And the reason that switch is much more expensive

98
00:10:56,630 --> 00:10:59,230
 is simple because the state associated

99
00:10:59,230 --> 00:11:02,510
 with the process is much larger, right?

100
00:11:02,510 --> 00:11:07,310
 You need, again, the process is also on another space, right?

101
00:11:07,310 --> 00:11:09,990
 It's also on the file descriptors, okay?

102
00:11:09,990 --> 00:11:14,630
 So fundamentally it's a lot of more things you need to do

103
00:11:14,630 --> 00:11:18,510
 when you switch a context versus a switching a thread, okay?

104
00:11:18,510 --> 00:11:20,630
 And these are the numbers, actually,

105
00:11:20,630 --> 00:11:25,310
 the context, the switching between processes

106
00:11:25,310 --> 00:11:28,830
 can take between, in this case for this numbers,

107
00:11:28,830 --> 00:11:30,470
 again, depends on the implementation,

108
00:11:30,470 --> 00:11:31,790
 depends on the hardware.

109
00:11:31,790 --> 00:11:34,070
 So take these numbers that are grain of salt,

110
00:11:34,070 --> 00:11:36,990
 they are only supposed to give you the relative sense

111
00:11:36,990 --> 00:11:39,550
 about the relative difference.

112
00:11:39,550 --> 00:11:41,430
 So when you switch between processes,

113
00:11:41,430 --> 00:11:44,190
 it can be like between three and four microseconds.

114
00:11:44,190 --> 00:11:45,030
 When you switch between two threads,

115
00:11:45,030 --> 00:11:47,230
 it's only 100 nanoseconds.

116
00:11:47,230 --> 00:11:48,390
 So in this particular case,

117
00:11:48,390 --> 00:11:52,830
 you can see that your overhead is 30, 40 times higher

118
00:11:52,830 --> 00:11:54,510
 when you switch between processes

119
00:11:54,510 --> 00:11:59,510
 as compared when you switch just between two threads, okay?

120
00:11:59,510 --> 00:12:05,790
 And the frequency of context switching here,

121
00:12:05,790 --> 00:12:10,510
 we are talking, is about 10 or 100 milliseconds.

122
00:12:10,510 --> 00:12:13,990
 Of course, you don't want to context switch all the time.

123
00:12:13,990 --> 00:12:17,790
 You want to context switch still fast enough,

124
00:12:17,790 --> 00:12:22,790
 but not as fast so that the amount of computation

125
00:12:22,790 --> 00:12:24,830
 is the same order of magnitude

126
00:12:24,830 --> 00:12:29,830
 of the amount of overhead it takes to switch, okay?

127
00:12:29,830 --> 00:12:34,190
 So we have a question here from Ashit.

128
00:12:34,190 --> 00:12:36,470
 Isn't it trivial to change the address space

129
00:12:36,470 --> 00:12:40,430
 because you just change the pointer

130
00:12:40,430 --> 00:12:42,710
 and for file receiver again,

131
00:12:42,710 --> 00:12:45,510
 don't you just change this process track to 0.2?

132
00:12:45,510 --> 00:12:49,710
 It's more than that.

133
00:12:49,710 --> 00:12:54,070
 You also need to have the buffers,

134
00:12:54,070 --> 00:12:57,510
 if you remember the, for instance, file stream IO.

135
00:12:57,510 --> 00:13:01,070
 And the other things you need to do is fundamentally,

136
00:13:01,070 --> 00:13:03,430
 you need to have the entire page table.

137
00:13:03,430 --> 00:13:06,950
 You need to take care of it

138
00:13:06,950 --> 00:13:10,110
 because the page table that is a translation

139
00:13:10,110 --> 00:13:13,110
 of the address, virtual addresses, the physical addresses,

140
00:13:17,110 --> 00:13:22,110
 this is what each process owns.

141
00:13:22,110 --> 00:13:30,350
 Yeah, and also when you switch the address space,

142
00:13:30,350 --> 00:13:35,750
 then you can, because you are going to have

143
00:13:35,750 --> 00:13:40,630
 probably some of the pages, which of the process,

144
00:13:40,630 --> 00:13:44,630
 which are going to be evicted from the memory

145
00:13:44,630 --> 00:13:46,270
 to make room for new processes.

146
00:13:46,270 --> 00:13:50,630
 And they are going to go to disk or whatever SSD.

147
00:13:50,630 --> 00:13:53,750
 So therefore you may also have to do some work

148
00:13:53,750 --> 00:13:57,390
 to get some pages in when you switch between the processes.

149
00:13:57,390 --> 00:14:04,670
 Even cheaper, you can actually use

150
00:14:04,670 --> 00:14:07,230
 without the operating system support,

151
00:14:07,230 --> 00:14:13,830
 you can use yield in the user level.

152
00:14:13,830 --> 00:14:16,750
 So the application actually is,

153
00:14:16,750 --> 00:14:21,230
 there are thread libraries, user level thread libraries.

154
00:14:21,230 --> 00:14:23,190
 These are libraries which provide you

155
00:14:23,190 --> 00:14:24,790
 like a thread interface,

156
00:14:24,790 --> 00:14:27,830
 but the operating system doesn't know anything about it.

157
00:14:27,830 --> 00:14:32,830
 Okay, and then what happens when you use a thread,

158
00:14:32,830 --> 00:14:36,110
 a user level thread, then when you call yield,

159
00:14:36,110 --> 00:14:38,710
 you call the library which is running the same process.

160
00:14:38,710 --> 00:14:41,430
 Again, it's not a system kernel.

161
00:14:41,430 --> 00:14:44,470
 And then that library is going to invoke,

162
00:14:44,470 --> 00:14:46,230
 you are going to just make a call,

163
00:14:46,230 --> 00:14:50,310
 a function call to another thread in the same process.

164
00:14:50,310 --> 00:14:51,910
 So this is very, very lightweight,

165
00:14:51,910 --> 00:14:53,190
 it's just a function call.

166
00:14:53,190 --> 00:14:56,630
 And this is some of the first systems

167
00:14:56,630 --> 00:14:59,990
 that have been implemented at the application level.

168
00:14:59,990 --> 00:15:02,790
 And in this case, all fundamentally,

169
00:15:02,790 --> 00:15:05,790
 all these user level threads are going to be

170
00:15:08,270 --> 00:15:13,070
 basically mapped on say one CPU.

171
00:15:13,070 --> 00:15:16,190
 Now, with a kernel, in general,

172
00:15:16,190 --> 00:15:19,070
 kernel also uses some threads, right?

173
00:15:19,070 --> 00:15:21,470
 And the number of, and these are kernel threads,

174
00:15:21,470 --> 00:15:24,150
 and in general, you map the user thread

175
00:15:24,150 --> 00:15:25,910
 on the kernel threads.

176
00:15:25,910 --> 00:15:29,590
 And the kernel thread typically uses a number,

177
00:15:29,590 --> 00:15:34,590
 the number of kernel threads is typically equal

178
00:15:34,950 --> 00:15:39,310
 with the number of CPUs or the number of cores, okay?

179
00:15:39,310 --> 00:15:42,910
 And again, you have, typically you have few tens of cores

180
00:15:42,910 --> 00:15:46,390
 on your CPU, but you can have then thousand

181
00:15:46,390 --> 00:15:50,830
 or tens of thousand of user level threads, okay?

182
00:15:50,830 --> 00:15:55,310
 And when the kernel has a concept of thread,

183
00:15:55,310 --> 00:15:57,950
 then what will happen, you are going to map

184
00:15:57,950 --> 00:16:00,590
 the user thread on top on kernel threads.

185
00:16:02,150 --> 00:16:07,150
 Okay, let's look, yeah, easy server overhead, okay,

186
00:16:07,150 --> 00:16:15,750
 on context, switch between processes purely

187
00:16:15,750 --> 00:16:17,350
 if you have to switch out the address space,

188
00:16:17,350 --> 00:16:19,750
 that's a big part of it, yes.

189
00:16:19,750 --> 00:16:24,550
 Again, there are also file descriptors and things like that,

190
00:16:24,550 --> 00:16:27,550
 but the address space is a big part of it, okay?

191
00:16:27,550 --> 00:16:32,550
 Okay, so in today's lecture, we are going to talk,

192
00:16:32,550 --> 00:16:38,030
 or in the first part of today's lecture,

193
00:16:38,030 --> 00:16:43,030
 we are going to talk about this one to one thread model.

194
00:16:43,030 --> 00:16:48,190
 And in the one to one thread model, actually,

195
00:16:48,190 --> 00:16:51,910
 in this particular case, we are going to have,

196
00:16:51,910 --> 00:16:55,230
 for one user thread, we are going to have assumed

197
00:16:55,230 --> 00:16:56,270
 there is a kernel thread.

198
00:16:56,270 --> 00:16:58,430
 So this means that for one user thread,

199
00:16:58,430 --> 00:17:02,950
 we are going to have a CPU to run on, okay?

200
00:17:02,950 --> 00:17:04,830
 So this is, again, it's another figure,

201
00:17:04,830 --> 00:17:09,190
 another representation for you to better understand

202
00:17:09,190 --> 00:17:14,110
 how things are working under the hood, okay?

203
00:17:14,110 --> 00:17:17,350
 So here is, again, you have two processes,

204
00:17:17,350 --> 00:17:21,630
 this rounded yellow boxes, and each process,

205
00:17:21,630 --> 00:17:24,310
 you have fewer threads.

206
00:17:24,310 --> 00:17:26,350
 Each thread has its own state,

207
00:17:26,350 --> 00:17:29,550
 and then they have some state they share with the process,

208
00:17:29,550 --> 00:17:31,630
 like memory and I/O state.

209
00:17:31,630 --> 00:17:34,150
 And then this is OS with green,

210
00:17:34,150 --> 00:17:35,910
 and you have a CPU scheduler,

211
00:17:35,910 --> 00:17:40,590
 which picks on which CPU the thread will run.

212
00:17:40,590 --> 00:17:44,790
 And initially, let's assume that we have one CPU, okay?

213
00:17:44,790 --> 00:17:50,790
 So now let's look at the switch overhead.

214
00:17:50,790 --> 00:17:53,990
 Now, the switch overhead, there are multiple cases here.

215
00:17:53,990 --> 00:17:56,390
 The switch overhead of two threads, again,

216
00:17:56,390 --> 00:18:00,150
 eventually what you run on the CPU, it's a thread, right?

217
00:18:00,150 --> 00:18:03,790
 So the switch overhead between two threads,

218
00:18:03,790 --> 00:18:07,230
 if they are on the same process, it's very low, right?

219
00:18:07,230 --> 00:18:09,430
 Because only you need to switch your CPUs,

220
00:18:09,430 --> 00:18:15,910
 you need to save and resume the thread state, right?

221
00:18:15,910 --> 00:18:19,350
 Which is small.

222
00:18:20,510 --> 00:18:24,910
 Now, if you need to go from one thread in one process

223
00:18:24,910 --> 00:18:26,750
 into a thread in a different process,

224
00:18:26,750 --> 00:18:29,350
 now you need also to switch the context of processes.

225
00:18:29,350 --> 00:18:32,550
 So then the switch overhead is high.

226
00:18:32,550 --> 00:18:34,910
 Now, why do you have threads and processes?

227
00:18:34,910 --> 00:18:38,070
 Well, because the processes,

228
00:18:38,070 --> 00:18:41,070
 while this context between processes is slow,

229
00:18:41,070 --> 00:18:43,390
 they provide something threads do not provide,

230
00:18:43,390 --> 00:18:46,950
 and that is protection, right?

231
00:18:46,950 --> 00:18:48,990
 So the protection between two threads

232
00:18:48,990 --> 00:18:51,390
 running in the same process is very low

233
00:18:51,390 --> 00:18:53,670
 is because they are sharing the same memory.

234
00:18:53,670 --> 00:18:55,790
 So one thread can read and write

235
00:18:55,790 --> 00:19:00,790
 from the memory of the data of another thread, okay?

236
00:19:00,790 --> 00:19:05,590
 While if the threads run on different processes,

237
00:19:05,590 --> 00:19:08,590
 that's not possible, okay?

238
00:19:08,590 --> 00:19:11,150
 Now, sharing overhead, as we know,

239
00:19:11,150 --> 00:19:15,430
 and we learned last past lectures,

240
00:19:15,430 --> 00:19:19,350
 threads and you may want to share data

241
00:19:19,350 --> 00:19:21,950
 because the applications are pretty complex

242
00:19:21,950 --> 00:19:25,510
 and they want to communicate with multiple threads,

243
00:19:25,510 --> 00:19:28,190
 they want to communicate with each other.

244
00:19:28,190 --> 00:19:31,270
 Now, if there are two threads that are in the same process,

245
00:19:31,270 --> 00:19:33,150
 it's very easy for them to communicate.

246
00:19:33,150 --> 00:19:34,710
 It's also low overhead.

247
00:19:34,710 --> 00:19:35,550
 Why?

248
00:19:35,550 --> 00:19:37,790
 Because they can't communicate through the shared memory,

249
00:19:37,790 --> 00:19:40,350
 the memory they share in the same process, right?

250
00:19:40,350 --> 00:19:43,350
 So you just read and write to the memory, super easy.

251
00:19:43,350 --> 00:19:46,150
 On the other hand, if these are two processes,

252
00:19:46,150 --> 00:19:48,950
 the threads are in two processes, then what do you know?

253
00:19:48,950 --> 00:19:52,030
 What you know is overhead is much higher

254
00:19:52,030 --> 00:19:54,190
 because how you can communicate between two processes.

255
00:19:54,190 --> 00:19:55,110
 Do you remember?

256
00:19:55,110 --> 00:19:57,750
 You can use pipe, you can use sockets,

257
00:19:57,750 --> 00:20:01,030
 but all, or you can read and write from a file.

258
00:20:01,030 --> 00:20:02,590
 But all of these operations...

259
00:20:02,590 --> 00:20:05,900
 are far more expensive than reading and writing from the memory.

260
00:20:05,900 --> 00:20:14,060
 So what about the parallelism? Well, in the case of parallelism here,

261
00:20:14,060 --> 00:20:18,620
 there is no parallelism because you have only one core. You can run only once at a time.

262
00:20:18,620 --> 00:20:26,140
 And here it's a more general example in which you have four cores. So you can have

263
00:20:26,140 --> 00:20:31,580
 four different kernel threads running at the same time. So now you have parallelism.

264
00:20:31,580 --> 00:20:39,260
 And now you need to-- the sharing overhead is a little bit even more complex.

265
00:20:39,260 --> 00:20:47,900
 Because if you have the same process, it's low. And different processes is high. But now there

266
00:20:47,900 --> 00:20:54,540
 are different processes-- it actually turns out that if you have simultaneous cores,

267
00:20:55,660 --> 00:21:01,980
 so they are running-- you can have processes-- OK, so this is more complicated. But you can

268
00:21:01,980 --> 00:21:08,300
 have kernel threads running on the same core. And we see next why, how you can have that.

269
00:21:08,300 --> 00:21:13,820
 Then the overhead of communication, of sharing, is lower. And this is what I meant.

270
00:21:13,820 --> 00:21:20,540
 It's a concept of multithreading or hyperthreading. Actually, it's hyperthreading,

271
00:21:20,540 --> 00:21:24,940
 right? Simultaneous multithreading or hyperthreading. This is what we are talking about.

272
00:21:24,940 --> 00:21:37,980
 So, so far, in everything I said, I said you can run one thread on one core. OK?

273
00:21:37,980 --> 00:21:48,700
 So-- but it turns out that in practice, you can run at the same time multiple--

274
00:21:48,700 --> 00:21:53,260
 one multiple thread in general only two threads on the same core.

275
00:21:53,980 --> 00:22:04,060
 Right? And this is called hyperthreading. OK? And almost all processors today provide it.

276
00:22:04,060 --> 00:22:12,060
 Right? It's actually when you look at Amazon, for those of you, they give-- they say vCPU,

277
00:22:12,060 --> 00:22:18,620
 virtual CPU. A virtual CPU is actually a hyperthread. It's not one core necessary.

278
00:22:19,980 --> 00:22:26,700
 So what is the idea? So here is a thing-- look at these figures. Do you see my pointer,

279
00:22:26,700 --> 00:22:33,500
 my pointer on the screen? Can someone answer if you see my pointer?

280
00:22:33,500 --> 00:22:47,180
 Yes, perfect. OK. So here is a time on the vertical. And here are-- if you remember from

281
00:22:47,180 --> 00:22:57,100
 61c, the processor have in the arithmetic logical unit and everything, there are different components.

282
00:22:57,100 --> 00:23:08,620
 Right? You need to fetch the instruction. Then you need to-- and then you may use different

283
00:23:08,620 --> 00:23:15,980
 components like adds or from the arithmetic processor units, logical unit, to perform that

284
00:23:15,980 --> 00:23:24,940
 operation. OK? So each of these line, it's an instruction. OK? And vertical, each of the

285
00:23:24,940 --> 00:23:33,420
 vertical is one component in the process, in that core. So this color, what is color, this means

286
00:23:33,420 --> 00:23:43,180
 that this instruction, right, where is a color is that particular instruction uses that component.

287
00:23:43,980 --> 00:23:51,260
 Right? So for instance, from this example, in the first instruction using the first and the

288
00:23:51,260 --> 00:23:56,620
 third component. OK? But not using-- it doesn't use the second one. And then for the next,

289
00:23:56,620 --> 00:24:05,980
 actually, I was not accurate. Sorry. Each of these lines represent a cycle, instruction cycle.

290
00:24:05,980 --> 00:24:11,580
 Right? Many instructions, they run in a single cycle, some of them. But some of them do not.

291
00:24:11,580 --> 00:24:22,220
 OK? So it's instruction cycle. So in this cycle, these two, first and the third component are used.

292
00:24:22,220 --> 00:24:29,500
 In the next cycle, there is no component being used. And maybe this is because it is tall.

293
00:24:29,500 --> 00:24:33,740
 You know, the data is not available, and the instruction cannot proceed or something like that,

294
00:24:34,300 --> 00:24:41,980
 and so forth. So the main point here is that not all components are used at the same time.

295
00:24:41,980 --> 00:24:53,420
 OK? So then what you can do then is basically to run two streams of instructions

296
00:24:53,420 --> 00:25:03,420
 from two different threads. And if a stream doesn't use all the components at the same time,

297
00:25:04,380 --> 00:25:12,300
 then the other stream can use them. So that's kind of the intuition. One stream of instructions

298
00:25:12,300 --> 00:25:19,260
 doesn't use all the components of the core at all times. So you can take advantage of that

299
00:25:19,260 --> 00:25:28,140
 to support the second stream to better use these other components. So that's why you can run two

300
00:25:28,700 --> 00:25:35,100
 streams of instruction on virtually the same hardware. So just better utilizing the particular

301
00:25:35,100 --> 00:25:44,620
 core. That's what it is. OK? So it basically provides you the illusion that now you can run

302
00:25:44,620 --> 00:25:54,380
 multiple-- like you have multiple cores. Of course, the speedup is nonlinear because sometimes you

303
00:25:54,380 --> 00:26:00,460
 have conflicts, right? You have the two stream instruction at the given cycle. They want to use

304
00:26:00,460 --> 00:26:13,500
 the same components. But this is super useful technique. And it's used by almost every processor.

305
00:26:14,540 --> 00:26:29,740
 OK? So now, a file-- remember, a process can relinquish access to the CPU in multiple ways.

306
00:26:29,740 --> 00:26:37,260
 Right? One is voluntarily yield. Another one is I/O. Right? So when it's making an I/O,

307
00:26:37,260 --> 00:26:40,780
 when it's calling an I/O operation, like in this case, it is from a file.

308
00:26:42,220 --> 00:26:45,100
 OK. Then it's another question. Let me try to answer the question.

309
00:26:45,100 --> 00:26:51,100
 Are some components not used even if we do pipelining? Yes. Because pipelining means

310
00:26:51,100 --> 00:27:00,140
 there are multiple-- you can also have stalls and dependencies in the pipelines, across instruction

311
00:27:00,140 --> 00:27:06,860
 in the pipelines. So the answer is yes. Actually, all the processors already do pipeline.

312
00:27:11,100 --> 00:27:18,460
 And pipelining, yeah, it helps you to-- each instruction, new instruction to every lock cycle,

313
00:27:18,460 --> 00:27:25,580
 you start a new instruction. Yeah. But pipelining helps with utilization, but it doesn't solve it

314
00:27:25,580 --> 00:27:33,980
 entirely. Great question. OK. Let's go back. So here, again, we are going to show the stack.

315
00:27:33,980 --> 00:27:42,540
 And you have copy file called read. And when call read, read it again. It's a system call.

316
00:27:42,540 --> 00:27:50,060
 You call the kernel, kernel read. And what is the kernel doing? Well, it's going to start the read

317
00:27:50,060 --> 00:27:56,700
 operation. But before you get the answer to the read operation, the CPU is free. So therefore,

318
00:27:56,700 --> 00:28:04,780
 it's going to switch to suspend you, you being the copy file program, and give the CPU to another

319
00:28:04,780 --> 00:28:18,300
 thread. The same thing happens. And the same-- it is similar when you have signals and joins or

320
00:28:19,180 --> 00:28:31,660
 operations on a node. OK? And finally, one question we also asked in the past,

321
00:28:31,660 --> 00:28:38,940
 what happens if there is no-- the program doesn't voluntarily yield the CPU, there is no IO,

322
00:28:39,500 --> 00:28:50,860
 and general never waits. Right? So in that case, you still need to multiply the CPU

323
00:28:50,860 --> 00:28:56,620
 between different threads. And the way you do it using external events, external events like

324
00:28:56,620 --> 00:29:05,340
 interrupts, in particular, timer interrupts. Right? So you program the timer to give an interrupt

325
00:29:05,340 --> 00:29:11,260
 every 100 milliseconds. When you get this interrupt, the kernel is going to switch from

326
00:29:11,260 --> 00:29:18,780
 the current thread to a different thread. OK? So that's what it is.

327
00:29:18,780 --> 00:29:29,900
 So let's see another question. It seems like hyperthreading benefits concurrency. What about

328
00:29:30,700 --> 00:29:35,420
 parallelism? It definitely also benefits parallelism because you are going to have now,

329
00:29:35,420 --> 00:29:41,100
 if you have-- you are going to double the number of threads you are going to run at the same time.

330
00:29:41,100 --> 00:29:55,500
 OK? So this is a picture which basically shows you here the CPU. And then it shows you how you

331
00:29:55,500 --> 00:30:01,340
 are going to interface with different devices. Right? And again, the way you interface actually

332
00:30:01,340 --> 00:30:03,580
 the operating system with the--

333
00:30:03,580 --> 00:30:06,750
 the different devices is through these interrupts.

334
00:30:06,750 --> 00:30:11,170
 When an event which requires the attention of the kernel happens,

335
00:30:11,170 --> 00:30:16,290
 that device has to go in to generate this kind of event,

336
00:30:16,290 --> 00:30:17,570
 which is interrupt.

337
00:30:17,570 --> 00:30:24,890
 So and you can also have software interrupts.

338
00:30:24,890 --> 00:30:29,890
 Like SQL is a software interrupt.

339
00:30:29,890 --> 00:30:31,990
 It doesn't come from a device.

340
00:30:31,990 --> 00:30:36,770
 It comes from another process or it comes from the kernel.

341
00:30:36,770 --> 00:30:40,290
 And this is a timer, which is a special kind of interrupt

342
00:30:40,290 --> 00:30:41,290
 like we discussed.

343
00:30:41,290 --> 00:30:48,850
 And for interrupt, you can mask interrupts and we'll see.

344
00:30:48,850 --> 00:30:52,970
 And the interrupts, they have some priority.

345
00:30:52,970 --> 00:31:00,810
 And the higher priority interrupts, for instance,

346
00:31:00,810 --> 00:31:04,530
 can interrupt the lower priority interrupt.

347
00:31:04,530 --> 00:31:05,750
 But this is what you have.

348
00:31:05,750 --> 00:31:07,370
 You have basically, this is actually

349
00:31:07,370 --> 00:31:11,690
 this hardware, this kind of different lines,

350
00:31:11,690 --> 00:31:21,290
 hardware lines in an interrupt list.

351
00:31:21,290 --> 00:31:28,090
 And then the kernel will always look at the highest interrupt

352
00:31:28,090 --> 00:31:31,810
 and will treat the highest interrupt.

353
00:31:31,810 --> 00:31:36,290
 And if a higher interrupt than the one you are currently

354
00:31:36,290 --> 00:31:39,650
 treating occurs, then you are going

355
00:31:39,650 --> 00:31:41,970
 to switch to treat the higher interrupt.

356
00:31:41,970 --> 00:31:45,490
 And then you come back to finish treating the lower interrupt.

357
00:31:45,490 --> 00:31:54,650
 The software interrupts can be cleared by softwares.

358
00:31:54,650 --> 00:31:58,810
 And CPU can disable all interrupts with some internal

359
00:31:58,810 --> 00:32:01,170
 flags.

360
00:32:01,170 --> 00:32:03,250
 So I don't want to be interrupted because what

361
00:32:03,250 --> 00:32:05,170
 I'm doing is very important.

362
00:32:05,170 --> 00:32:14,250
 And there is also some non-maskable interrupts,

363
00:32:14,250 --> 00:32:17,650
 which you don't have anything to do.

364
00:32:17,650 --> 00:32:20,410
 Like for instance, reset.

365
00:32:20,410 --> 00:32:22,290
 It's a non-maskable interrupt.

366
00:32:22,290 --> 00:32:24,610
 Right?

367
00:32:24,610 --> 00:32:29,810
 So you have to just kill and reset

368
00:32:29,810 --> 00:32:32,330
 everything on the computer and restart.

369
00:32:32,330 --> 00:32:33,170
 That's one example.

370
00:32:33,170 --> 00:32:41,090
 So now, this is an example about how the network interrupt

371
00:32:41,090 --> 00:32:41,610
 occurs.

372
00:32:41,610 --> 00:32:45,330
 So say you execute these instructions.

373
00:32:45,330 --> 00:32:47,410
 And now you get an external interrupt

374
00:32:47,410 --> 00:32:50,130
 because a packet arrives.

375
00:32:50,130 --> 00:32:56,610
 So the kernel needs to copy the data into the kernel buffer.

376
00:32:56,610 --> 00:32:58,530
 So what do you do?

377
00:32:58,530 --> 00:33:01,890
 So first of all, you flush the pipeline,

378
00:33:01,890 --> 00:33:04,770
 the pipeline of the processor from the state

379
00:33:04,770 --> 00:33:07,530
 of the current instructions.

380
00:33:07,530 --> 00:33:13,850
 You save the program counter.

381
00:33:13,850 --> 00:33:16,090
 So to know when you are going to resume,

382
00:33:16,090 --> 00:33:17,490
 where you are going to come back,

383
00:33:17,490 --> 00:33:19,050
 what is the program counter, you have

384
00:33:19,050 --> 00:33:23,930
 to come back to, and disable all the interrupts.

385
00:33:23,930 --> 00:33:29,010
 Because now you need to do some work

386
00:33:29,010 --> 00:33:33,050
 and you don't want to be interrupted.

387
00:33:33,050 --> 00:33:36,530
 And basically, what you do here, you raise the priority

388
00:33:36,530 --> 00:33:38,730
 and you mask all the lower level interrupts

389
00:33:38,730 --> 00:33:40,850
 because I don't want to be interrupted

390
00:33:40,850 --> 00:33:46,850
 by lower level interrupts when you do that.

391
00:33:46,850 --> 00:33:54,930
 And you save the registers for this current thread.

392
00:33:54,930 --> 00:33:58,170
 And you dispatch to the handler of the interrupt

393
00:33:58,170 --> 00:33:59,890
 because you need to treat the interrupt.

394
00:33:59,890 --> 00:34:05,050
 In this particular case, read the data from the network.

395
00:34:05,050 --> 00:34:07,210
 Transfer the network packets from Harvard

396
00:34:07,210 --> 00:34:09,370
 to the kernel buffers.

397
00:34:09,370 --> 00:34:12,090
 Once you are done with that, you restore the registers.

398
00:34:15,890 --> 00:34:20,530
 And you clear current interrupt because you are done with it.

399
00:34:20,530 --> 00:34:27,090
 You disable all interrupts again to do your work.

400
00:34:27,090 --> 00:34:30,810
 You don't want to be interrupted by the kernel.

401
00:34:30,810 --> 00:34:32,610
 And you restore the priority.

402
00:34:32,610 --> 00:34:40,770
 You then clear the masks, the mask which are clear here.

403
00:34:43,530 --> 00:34:47,050
 The mask which you set here to not be interrupted,

404
00:34:47,050 --> 00:34:48,210
 now you clear it.

405
00:34:48,210 --> 00:34:50,850
 Basically saying, now I can be interrupted by anything.

406
00:34:50,850 --> 00:34:57,490
 And now I return from the interrupt.

407
00:34:57,490 --> 00:35:00,090
 So that's it.

408
00:35:00,090 --> 00:35:00,970
 So it's very simple.

409
00:35:00,970 --> 00:35:11,610
 And it's again, an interrupt, though,

410
00:35:11,610 --> 00:35:14,170
 to think about it's a hardware-involved context

411
00:35:14,170 --> 00:35:15,210
 switch, right?

412
00:35:15,210 --> 00:35:19,970
 There is no separate stack.

413
00:35:19,970 --> 00:35:23,250
 There is no decision of what to run next.

414
00:35:23,250 --> 00:35:24,130
 It's very clear.

415
00:35:24,130 --> 00:35:30,850
 I am going to run the handler to treat the interrupt.

416
00:35:30,850 --> 00:35:38,650
 And I am going to go back to the program I just interrupted.

417
00:35:38,650 --> 00:35:39,130
 OK?

418
00:35:39,130 --> 00:35:47,810
 So like we mentioned, one way to interrupt a program now

419
00:35:47,810 --> 00:35:53,610
 and give control to another program

420
00:35:53,610 --> 00:35:58,730
 is simply by using the timer interrupt, right?

421
00:35:58,730 --> 00:36:01,250
 As the timer interrupt, when the interrupt happens,

422
00:36:01,250 --> 00:36:06,170
 timer interrupt happens, you are going to--

423
00:36:06,170 --> 00:36:11,170
 kernel is going to execute this timer interrupt handle.

424
00:36:11,170 --> 00:36:14,050
 And the timer interrupt handle or team,

425
00:36:14,050 --> 00:36:17,370
 it's doing some housekeeping.

426
00:36:17,370 --> 00:36:21,650
 It's again, update some counters and things like that.

427
00:36:21,650 --> 00:36:24,250
 And then run new thread.

428
00:36:24,250 --> 00:36:25,810
 Right?

429
00:36:25,810 --> 00:36:28,650
 And you know that your new threads, what it's doing,

430
00:36:28,650 --> 00:36:30,770
 saves the state of the current thread.

431
00:36:30,770 --> 00:36:34,530
 OK?

432
00:36:34,530 --> 00:36:40,570
 Initialize the state into registers of the new thread

433
00:36:40,570 --> 00:36:42,970
 and start the new thread.

434
00:36:42,970 --> 00:36:46,210
 And in between, you need to decide which new thread

435
00:36:46,210 --> 00:36:48,850
 you are going to run.

436
00:36:48,850 --> 00:36:50,210
 OK?

437
00:36:50,210 --> 00:36:52,730
 So this is what we are talking about, right?

438
00:36:52,730 --> 00:36:59,570
 You initialize the registers field of the PCB,

439
00:36:59,570 --> 00:37:03,250
 your stack pointer with PC return address,

440
00:37:03,250 --> 00:37:08,570
 and also in this case, is a functions and the function

441
00:37:08,570 --> 00:37:09,490
 arguments.

442
00:37:09,490 --> 00:37:12,130
 You pointer to this function and the pointer

443
00:37:12,130 --> 00:37:14,650
 to the function to the list of function arguments, which

444
00:37:14,650 --> 00:37:17,890
 you put into registers, in this case, a0 and a1.

445
00:37:17,890 --> 00:37:19,650
 OK?

446
00:37:19,650 --> 00:37:21,090
 And then what about the stack?

447
00:37:21,090 --> 00:37:22,690
 So again, the stack is in the memory.

448
00:37:22,690 --> 00:37:24,290
 The memory is sold by the processor.

449
00:37:24,290 --> 00:37:27,370
 You don't need to do anything other than pointing

450
00:37:27,370 --> 00:37:30,370
 to the correct location of the stack, which

451
00:37:30,370 --> 00:37:32,730
 is a stack pointer.

452
00:37:32,730 --> 00:37:35,530
 OK?

453
00:37:35,530 --> 00:37:39,250
 So again, let's see what happens here.

454
00:37:39,250 --> 00:37:42,170
 In this particular case, this is the old one,

455
00:37:42,170 --> 00:37:44,730
 in which basically we went through this one.

456
00:37:44,730 --> 00:37:50,210
 So here, use yield, which is voluntarily relinquish the CPU

457
00:37:50,210 --> 00:37:52,450
 to be used by another thread.

458
00:37:52,450 --> 00:37:56,450
 And when this happened, you set up the new thread.

459
00:37:56,450 --> 00:38:06,690
 You are going to initialize the pointers and registers

460
00:38:06,690 --> 00:38:11,250
 of the processors with the values from the PCB

461
00:38:11,250 --> 00:38:13,250
 from the thread control block.

462
00:38:13,250 --> 00:38:14,570
 Right?

463
00:38:14,570 --> 00:38:16,250
 OK?

464
00:38:16,250 --> 00:38:21,930
 So and then you are going to run the new thread.

465
00:38:21,930 --> 00:38:22,410
 OK?

466
00:38:25,370 --> 00:38:29,650
 So this thread root, this is a root

467
00:38:29,650 --> 00:38:31,610
 for all the thread routines.

468
00:38:31,610 --> 00:38:34,970
 So when you have to switch it from one thread

469
00:38:34,970 --> 00:38:39,410
 to another thread, this is what you are going to execute.

470
00:38:39,410 --> 00:38:40,730
 OK?

471
00:38:40,730 --> 00:38:44,010
 And the thread root, what it takes,

472
00:38:44,010 --> 00:38:48,410
 it takes this address to the function of the thread

473
00:38:48,410 --> 00:38:49,450
 you want to execute.

474
00:38:49,450 --> 00:38:49,730
 Right?

475
00:38:49,730 --> 00:38:51,810
 Remember, a thread is just a function

476
00:38:51,810 --> 00:38:53,610
 you have to execute at the end of the day.

477
00:38:53,610 --> 00:38:54,370
 Right?

478
00:38:54,370 --> 00:38:56,930
 So you need to provide to this thread root

479
00:38:56,930 --> 00:39:03,130
 the function of the new thread to execute and the arguments.

480
00:39:03,130 --> 00:39:05,250
 Right?

481
00:39:05,250 --> 00:39:10,330
 Again, you do some housekeeping.

482
00:39:10,330 --> 00:39:13,250
 You do the user mode switch.

483
00:39:13,250 --> 00:39:15,170
 So now you are in the kernel.

484
00:39:15,170 --> 00:39:18,130
 So you need to go to the user mode,

485
00:39:18,130 --> 00:39:20,730
 because the application runs in the user mode,

486
00:39:20,730 --> 00:39:25,130
 and then simply invoke the function, the thread function,

487
00:39:25,130 --> 00:39:26,330
 with the arguments.

488
00:39:26,330 --> 00:39:29,290
 And you are done.

489
00:39:29,290 --> 00:39:32,290
 OK?

490
00:39:32,290 --> 00:39:34,250
 And like I mentioned, the housekeeping

491
00:39:34,250 --> 00:39:37,170
 includes things like recording the start time of the thread,

492
00:39:37,170 --> 00:39:43,010
 how long the thread is run on the CPU,

493
00:39:43,010 --> 00:39:46,770
 and other statistics, number of context switchings,

494
00:39:46,770 --> 00:39:49,610
 and things like that.

495
00:39:49,610 --> 00:39:52,370
 Obviously, the stack will grow and shrink

496
00:39:52,370 --> 00:39:53,890
 with execution of a thread.

497
00:39:53,890 --> 00:40:02,930
 And when you return from this function,

498
00:40:02,930 --> 00:40:05,810
 this is you call the thread field.

499
00:40:05,810 --> 00:40:07,260
 What is a thread finish?

500
00:40:07,260 --> 00:40:08,220
 Okay.

501
00:40:08,220 --> 00:40:11,740
 Is you need to execute another thread, right?

502
00:40:11,740 --> 00:40:14,880
 So you need to find and wake up a sleeping thread.

503
00:40:14,880 --> 00:40:21,060
 So now you're really going to concurrence.

504
00:40:21,060 --> 00:40:25,060
 And it's again,

505
00:40:25,060 --> 00:40:28,100
 once you have multiple threads running at the same time

506
00:40:30,760 --> 00:40:35,760
 and have the kernel non-deterministically decide

507
00:40:35,760 --> 00:40:38,600
 at what point to interrupt a thread,

508
00:40:38,600 --> 00:40:41,640
 to suspend it and resume another thread.

509
00:40:41,640 --> 00:40:45,280
 Now you need to be very careful.

510
00:40:45,280 --> 00:40:47,640
 And you need to be careful

511
00:40:47,640 --> 00:40:50,600
 because these threads can share the same data.

512
00:40:50,600 --> 00:40:57,040
 If there is no shared state, it's fine, no problems.

513
00:40:57,040 --> 00:41:00,080
 But if the state is shared, then you can run it,

514
00:41:00,080 --> 00:41:01,520
 we can run into problems.

515
00:41:01,520 --> 00:41:06,160
 So here, or you want to be very careful on the design

516
00:41:06,160 --> 00:41:11,160
 and you should try to what we call correctness by design,

517
00:41:11,160 --> 00:41:14,560
 meaning that you need to convince yourself.

518
00:41:14,560 --> 00:41:16,840
 Maybe in some case you can even prove

519
00:41:16,840 --> 00:41:20,920
 that the design of, despite the fact

520
00:41:20,920 --> 00:41:25,920
 that multiple concurrent threads can access the same data.

521
00:41:25,920 --> 00:41:30,920
 The design is correct, nothing bad happened, right?

522
00:41:30,920 --> 00:41:36,640
 Recall again, different executions

523
00:41:36,640 --> 00:41:41,120
 and the execution we really care about is B and C

524
00:41:41,120 --> 00:41:43,040
 where threads are interleaved

525
00:41:43,040 --> 00:41:44,680
 or they are running at the same time.

526
00:41:44,680 --> 00:41:47,420
 So they can touch the data at the same time.

527
00:41:47,420 --> 00:41:53,360
 And this is extremely, extremely important, right?

528
00:41:53,360 --> 00:41:54,920
 And here is an example.

529
00:41:55,760 --> 00:41:58,280
 To drive home the point

530
00:41:58,280 --> 00:42:01,680
 that handling the concurrency is important.

531
00:42:01,680 --> 00:42:04,480
 So think about ATM, you have an ATM

532
00:42:04,480 --> 00:42:08,360
 and you have obviously with ATM,

533
00:42:08,360 --> 00:42:13,360
 you want to either deposit or withdraw money, right?

534
00:42:13,360 --> 00:42:16,400
 And the state assumes that it's in a database.

535
00:42:16,400 --> 00:42:21,960
 So you need to be very careful here, okay?

536
00:42:23,040 --> 00:42:27,100
 So you're supposed to implement this functionality, right?

537
00:42:27,100 --> 00:42:31,640
 So then you have,

538
00:42:31,640 --> 00:42:35,360
 you need to process fundamentally,

539
00:42:35,360 --> 00:42:37,680
 you have to have an infinite loop

540
00:42:37,680 --> 00:42:42,040
 where you wait for requests from the users

541
00:42:42,040 --> 00:42:44,480
 and then you process the requests, right?

542
00:42:44,480 --> 00:42:48,060
 As a request is basically specifying operation,

543
00:42:48,060 --> 00:42:50,600
 withdrawal or deposit,

544
00:42:51,600 --> 00:42:56,260
 account ID and the amount, right?

545
00:42:56,260 --> 00:42:58,720
 This is you receive the request

546
00:42:58,720 --> 00:43:01,480
 and then you process the request, right?

547
00:43:01,480 --> 00:43:04,880
 The process request is simple, right?

548
00:43:04,880 --> 00:43:09,880
 If it's a deposit, you deposit the amount in account ID,

549
00:43:09,880 --> 00:43:14,800
 if it's withdrawal,

550
00:43:14,800 --> 00:43:19,380
 you get the, you subtract the amount from the deposit.

551
00:43:19,380 --> 00:43:20,220
 Okay?

552
00:43:20,220 --> 00:43:25,020
 And the deposit functions, what is a deposit function?

553
00:43:25,020 --> 00:43:26,460
 How does it look like?

554
00:43:26,460 --> 00:43:28,500
 You get account ID, you get the account,

555
00:43:28,500 --> 00:43:30,780
 the account data structure from the account ID

556
00:43:30,780 --> 00:43:35,020
 and you add the amount to the balance

557
00:43:35,020 --> 00:43:37,620
 and then you store the account,

558
00:43:37,620 --> 00:43:42,460
 read account, modify the account, store the account, okay?

559
00:43:42,460 --> 00:43:48,380
 So if you do this thing, right?

560
00:43:49,300 --> 00:43:54,260
 At one given time, you are only to serve a single request.

561
00:43:54,260 --> 00:43:56,860
 Okay?

562
00:43:56,860 --> 00:44:00,180
 So what is the problem with that?

563
00:44:00,180 --> 00:44:02,740
 The problem is can be very slow.

564
00:44:02,740 --> 00:44:04,380
 And why slow?

565
00:44:04,380 --> 00:44:06,940
 Because, not because of computation,

566
00:44:06,940 --> 00:44:10,120
 adding numbers is super fast, right?

567
00:44:10,120 --> 00:44:14,420
 What is slow is to access a database,

568
00:44:14,420 --> 00:44:17,340
 to get the account information from the database

569
00:44:17,340 --> 00:44:20,180
 and to store the account information to the database.

570
00:44:20,180 --> 00:44:23,760
 That is what is slow.

571
00:44:23,760 --> 00:44:28,780
 And during this time, the program is blocked,

572
00:44:28,780 --> 00:44:33,660
 just waiting for the database operation to complete.

573
00:44:33,660 --> 00:44:38,440
 And the opportunity here is to overlap communication

574
00:44:38,440 --> 00:44:43,220
 with a, you know, database IO, with a computation.

575
00:44:43,220 --> 00:44:48,220
 So while you wait for an account to be read

576
00:44:48,220 --> 00:44:52,280
 from the database or written to the database,

577
00:44:52,280 --> 00:44:56,700
 you can very well serve other users.

578
00:44:56,700 --> 00:45:00,300
 And by the way, the users actually in this case,

579
00:45:00,300 --> 00:45:02,860
 they can operate on different accounts,

580
00:45:02,860 --> 00:45:04,100
 on their own accounts.

581
00:45:04,100 --> 00:45:08,060
 So how do you do that?

582
00:45:08,060 --> 00:45:11,780
 So one way to do it, and this is typical,

583
00:45:11,780 --> 00:45:13,100
 is called event-driven.

584
00:45:13,100 --> 00:45:17,540
 And with the event-driven approach,

585
00:45:17,540 --> 00:45:22,220
 you basically split the requests, right?

586
00:45:22,220 --> 00:45:26,020
 In multiple pieces.

587
00:45:26,020 --> 00:45:29,060
 One piece, for instance, you start on request

588
00:45:29,060 --> 00:45:34,060
 is basically, for instance, this piece can only start the IO.

589
00:45:34,060 --> 00:45:38,300
 It can only make the request to the database.

590
00:45:38,300 --> 00:45:41,060
 And then you switch, you end up.

591
00:45:41,900 --> 00:45:46,900
 And you wait for an event to come from the database,

592
00:45:46,900 --> 00:45:51,700
 basically saying, and from, you know,

593
00:45:51,700 --> 00:45:53,140
 then the operating system saying,

594
00:45:53,140 --> 00:45:58,140
 this request has been set, has been, you know, completed.

595
00:45:58,140 --> 00:46:00,700
 Now there is a data.

596
00:46:00,700 --> 00:46:03,780
 Now you can go to continue the request to read the data.

597
00:46:03,780 --> 00:46:06,860
 Okay?

598
00:46:06,860 --> 00:46:10,720
 So this is kind of the things you're doing, right?

599
00:46:11,200 --> 00:46:14,920
 By hand, you are going to basically say that

600
00:46:14,920 --> 00:46:16,240
 in the programming by hand,

601
00:46:16,240 --> 00:46:19,000
 I think that you're interested in the program.

602
00:46:19,000 --> 00:46:22,640
 You make sure that there is no part of the program

603
00:46:22,640 --> 00:46:27,640
 that's wait for, is blocked for the IO request to complete.

604
00:46:27,640 --> 00:46:31,320
 Okay?

605
00:46:31,320 --> 00:46:38,800
 But now this way to write programs is pretty,

606
00:46:39,800 --> 00:46:42,400
 it's pretty hard.

607
00:46:42,400 --> 00:46:43,980
 What if you miss the blocking IO?

608
00:46:43,980 --> 00:46:47,620
 Well, then you are going to block.

609
00:46:47,620 --> 00:46:52,680
 The performer is going to suffer, right?

610
00:46:52,680 --> 00:46:54,800
 What if you, what do you have your,

611
00:46:54,800 --> 00:46:59,800
 your function has hundreds of IOs.

612
00:46:59,800 --> 00:47:03,200
 Well, you need to split it into hundreds of pieces.

613
00:47:03,200 --> 00:47:08,000
 Very hard to reason and debug.

614
00:47:08,000 --> 00:47:11,120
 Okay. However, this is super fast.

615
00:47:11,120 --> 00:47:14,940
 It's even faster than threads, right?

616
00:47:14,940 --> 00:47:17,940
 There is not even context switching between threads.

617
00:47:17,940 --> 00:47:19,360
 Okay. Super fast.

618
00:47:19,360 --> 00:47:23,960
 So this is used when you really, really need performance,

619
00:47:23,960 --> 00:47:25,320
 like graphical programming.

620
00:47:25,320 --> 00:47:30,840
 So now the obvious question is that,

621
00:47:30,840 --> 00:47:33,600
 and this is what we brought in this example,

622
00:47:33,600 --> 00:47:36,640
 then you may say, well, but what about threads?

623
00:47:36,640 --> 00:47:39,000
 We just said that threads can handle a concurrency.

624
00:47:39,000 --> 00:47:40,360
 It's a unit of concurrency.

625
00:47:40,360 --> 00:47:46,280
 Indeed. And using threads, you can do this much easier.

626
00:47:46,280 --> 00:47:48,440
 Right?

627
00:47:48,440 --> 00:47:52,160
 So let's see how this is done.

628
00:47:52,160 --> 00:47:53,220
 Right?

629
00:47:53,220 --> 00:47:55,440
 You basically, you run each of these operation

630
00:47:55,440 --> 00:47:56,640
 in different threads.

631
00:47:56,640 --> 00:47:59,840
 Right? You can do another thread.

632
00:47:59,840 --> 00:48:01,760
 Each operation can be another thread.

633
00:48:01,760 --> 00:48:03,200
 Of course you have a thread,

634
00:48:03,200 --> 00:48:06,080
 you can have a thread pool to make sure that you have,

635
00:48:06,080 --> 00:48:08,720
 you don't have a huge number of threads.

636
00:48:08,720 --> 00:48:10,360
 So the system is going to crash

637
00:48:10,360 --> 00:48:12,440
 like we learned in the last lecture.

638
00:48:12,440 --> 00:48:14,820
 But otherwise the only thing you need to do,

639
00:48:14,820 --> 00:48:18,800
 each operation is a different thread.

640
00:48:18,800 --> 00:48:22,560
 Because if you remember from what we learned,

641
00:48:22,560 --> 00:48:26,900
 when a thread is going to wait for an IO operation,

642
00:48:26,900 --> 00:48:28,400
 it's going to be suspended.

643
00:48:28,400 --> 00:48:34,040
 And the kernel will let another thread to run.

644
00:48:35,340 --> 00:48:36,180
 Okay?

645
00:48:36,180 --> 00:48:41,720
 The problems are here is that, okay,

646
00:48:41,720 --> 00:48:46,720
 now it's the two threads can access the same data.

647
00:48:46,720 --> 00:48:51,400
 And here is a very simple example.

648
00:48:51,400 --> 00:48:53,940
 Okay?

649
00:48:53,940 --> 00:48:58,940
 And, you know, we have maybe here two threads,

650
00:48:58,940 --> 00:49:02,980
 two threads which are depositing in the same account.

651
00:49:02,980 --> 00:49:04,160
 Right?

652
00:49:04,160 --> 00:49:06,220
 And look what happened here, right?

653
00:49:06,220 --> 00:49:08,960
 The thread one is reading the balance.

654
00:49:08,960 --> 00:49:13,840
 After that, the thread two reads the balance.

655
00:49:13,840 --> 00:49:20,920
 And then add the amount to the balance,

656
00:49:20,920 --> 00:49:22,200
 which is in R1,

657
00:49:22,200 --> 00:49:26,140
 and then save the balance.

658
00:49:26,140 --> 00:49:31,820
 But now I am going to resume to thread one.

659
00:49:31,820 --> 00:49:33,780
 And thread one, the first thing it's doing,

660
00:49:33,780 --> 00:49:36,500
 it's at its own amount with a balance,

661
00:49:36,500 --> 00:49:39,600
 and then store the balance.

662
00:49:39,600 --> 00:49:41,900
 So what did I do?

663
00:49:41,900 --> 00:49:44,280
 What is this code accomplishing?

664
00:49:44,280 --> 00:49:46,280
 What is not accomplishing?

665
00:49:46,280 --> 00:49:47,180
 What happens here?

666
00:49:47,180 --> 00:49:49,520
 What is the end behavior?

667
00:49:49,520 --> 00:49:55,160
 I have a balance, you know, thread one say,

668
00:49:55,160 --> 00:49:58,360
 I want to add to the balance $100,

669
00:49:58,360 --> 00:50:01,860
 thread two, I want to add to the balance $200.

670
00:50:01,860 --> 00:50:03,860
 $200.

671
00:50:03,860 --> 00:50:13,860
 [BLANK_AUDIO]

672
00:50:13,860 --> 00:50:09,600
 So I should have added to the balance $300.

673
00:50:09,600 --> 00:50:11,640
 But if I execute the code, what happens?

674
00:50:11,640 --> 00:50:16,600
 Amount is lost.

675
00:50:16,600 --> 00:50:18,400
 Very good Simon.

676
00:50:18,400 --> 00:50:22,080
 So basically in our example,

677
00:50:22,080 --> 00:50:26,240
 only $100 are going to be added to the balance

678
00:50:26,240 --> 00:50:27,780
 and the 200 will be lost.

679
00:50:27,780 --> 00:50:33,640
 Okay.

680
00:50:33,640 --> 00:50:38,480
 And we have, there are many, many examples.

681
00:50:38,480 --> 00:50:42,120
 Like in this example, thread one, it's X,

682
00:50:42,120 --> 00:50:45,920
 say X one and thread B, Y is two.

683
00:50:45,920 --> 00:50:47,360
 This case is simple, right?

684
00:50:47,360 --> 00:50:49,480
 They are separate threads, separate data structure.

685
00:50:49,480 --> 00:50:50,880
 They don't interfere.

686
00:50:50,880 --> 00:50:51,960
 Everything is fine.

687
00:50:51,960 --> 00:50:55,560
 However, in this case,

688
00:50:55,560 --> 00:50:59,880
 they have operate on a common variable, Y.

689
00:51:02,040 --> 00:51:04,000
 What are the possible values of X here?

690
00:51:04,000 --> 00:51:10,000
 Why don't you take a little bit of time

691
00:51:10,000 --> 00:51:11,240
 and answer this question?

692
00:51:11,240 --> 00:51:20,840
 So if I run thread one and thread A and thread B,

693
00:51:20,840 --> 00:51:23,960
 the initial value of Y is 12.

694
00:51:23,960 --> 00:51:27,640
 What results I can get here?

695
00:51:27,640 --> 00:51:28,480
 Okay.

696
00:51:28,480 --> 00:51:35,480
 One answer, please.

697
00:51:35,480 --> 00:51:36,400
 More answers.

698
00:51:36,400 --> 00:51:41,040
 Okay.

699
00:51:41,040 --> 00:51:45,360
 Excellent.

700
00:51:45,360 --> 00:51:47,360
 Right?

701
00:51:47,360 --> 00:51:50,440
 So you need to take all, you know, Y is 12, right?

702
00:51:50,440 --> 00:51:55,440
 So remember, so in say thread A is running to completion.

703
00:51:56,800 --> 00:51:57,640
 Right?

704
00:51:57,640 --> 00:52:04,960
 Then what you get is 13, right?

705
00:52:04,960 --> 00:52:10,080
 Now say thread B runs before thread A.

706
00:52:10,080 --> 00:52:10,960
 What happens?

707
00:52:10,960 --> 00:52:14,280
 Well, Y is two, it operates to L.

708
00:52:14,280 --> 00:52:16,840
 Then you multiply by two, so Y is four.

709
00:52:16,840 --> 00:52:20,040
 And then here you are going to have five.

710
00:52:20,040 --> 00:52:23,960
 Right?

711
00:52:25,120 --> 00:52:28,360
 Or you can only run the first instruction of B

712
00:52:28,360 --> 00:52:30,440
 before you run A.

713
00:52:30,440 --> 00:52:37,200
 So again, you initialize Y with two over I 12 initial value,

714
00:52:37,200 --> 00:52:38,680
 and the result will be three.

715
00:52:38,680 --> 00:52:40,800
 Okay?

716
00:52:40,800 --> 00:52:43,280
 So you see, pretty complicated, but also fun

717
00:52:43,280 --> 00:52:46,200
 for to do these exercises.

718
00:52:46,200 --> 00:52:47,040
 Oops.

719
00:52:47,040 --> 00:52:49,640
 But this is even simple examples.

720
00:52:49,640 --> 00:52:51,840
 X is equal one and X equal two.

721
00:52:51,840 --> 00:52:54,040
 What is the result?

722
00:52:54,040 --> 00:52:56,440
 Non-deterministic, you get one or two.

723
00:52:56,440 --> 00:53:01,440
 And for fun, if the instruction to store data

724
00:53:01,440 --> 00:53:05,480
 is non-deterministic, you can even get something in between.

725
00:53:05,480 --> 00:53:07,240
 Right?

726
00:53:07,240 --> 00:53:09,000
 Sorry.

727
00:53:09,000 --> 00:53:11,320
 If the instruction to store the data in memory

728
00:53:11,320 --> 00:53:14,920
 is not atomic, I said, no, not deterministic, which is wrong.

729
00:53:14,920 --> 00:53:16,000
 It's non-atomic.

730
00:53:16,000 --> 00:53:18,360
 Right?

731
00:53:18,360 --> 00:53:20,480
 We learn more about atomic instructions.

732
00:53:20,480 --> 00:53:22,440
 So it's a mess.

733
00:53:22,440 --> 00:53:23,280
 Okay?

734
00:53:23,280 --> 00:53:30,360
 So to understand the concurrent program,

735
00:53:30,360 --> 00:53:32,480
 like in this past example you've seen,

736
00:53:32,480 --> 00:53:34,560
 we need to know what is the indivisible operation?

737
00:53:34,560 --> 00:53:36,400
 What is atomic operation?

738
00:53:36,400 --> 00:53:40,520
 An atomic operation, what is an atomic operation?

739
00:53:40,520 --> 00:53:41,480
 It's indivisible.

740
00:53:41,480 --> 00:53:44,440
 You can interrupt in the in between, in the middle.

741
00:53:44,440 --> 00:53:48,080
 Either run or doesn't run at all.

742
00:53:48,080 --> 00:53:49,880
 That's all.

743
00:53:49,880 --> 00:53:52,040
 Right?

744
00:53:53,040 --> 00:53:57,040
 You cannot just have observed the output

745
00:53:57,040 --> 00:53:59,600
 of running half of atomic operation.

746
00:53:59,600 --> 00:54:03,440
 Now, your output, it's observed output is either

747
00:54:03,440 --> 00:54:08,120
 as if the entire operation runs

748
00:54:08,120 --> 00:54:11,000
 or none of the operation does a run at all.

749
00:54:11,000 --> 00:54:14,200
 And this is a fundamental building block.

750
00:54:14,200 --> 00:54:19,880
 On most machines, load and stores are atomic.

751
00:54:20,800 --> 00:54:22,000
 Okay?

752
00:54:22,000 --> 00:54:26,160
 The wired examples in the previous slide

753
00:54:26,160 --> 00:54:27,720
 cannot happen in this case.

754
00:54:27,720 --> 00:54:31,760
 But many instructions,

755
00:54:31,760 --> 00:54:35,200
 and here we are talking about processor instructions,

756
00:54:35,200 --> 00:54:37,160
 are not atomic.

757
00:54:37,160 --> 00:54:38,880
 Double precisions have not atomic,

758
00:54:38,880 --> 00:54:40,840
 so you can interrupt in the middle.

759
00:54:40,840 --> 00:54:44,480
 And there are instructions on the old computers

760
00:54:44,480 --> 00:54:47,280
 which copy a whole array.

761
00:54:47,280 --> 00:54:49,240
 They are not atomic.

762
00:54:50,480 --> 00:54:51,320
 Right?

763
00:54:51,320 --> 00:54:52,760
 If bad things happen,

764
00:54:52,760 --> 00:54:57,760
 you can see the results only of a partially run instruction.

765
00:54:57,760 --> 00:55:04,800
 Now, of course, if we run,

766
00:55:04,800 --> 00:55:08,360
 if we know only what are the atomic instruction,

767
00:55:08,360 --> 00:55:12,160
 this is helpful, but it's still not enough

768
00:55:12,160 --> 00:55:15,400
 because we want, you know, you can see that atomicity,

769
00:55:15,400 --> 00:55:19,160
 it's a very convenient way to control the access.

770
00:55:19,160 --> 00:55:22,360
 To a shared variable.

771
00:55:22,360 --> 00:55:26,000
 Because atomicity, if I can say all these bunch

772
00:55:26,000 --> 00:55:29,160
 of instructions is not going to be interrupted.

773
00:55:29,160 --> 00:55:33,240
 I don't need to be worried that someone will read or write

774
00:55:33,240 --> 00:55:36,080
 or I am executing these operations.

775
00:55:36,080 --> 00:55:38,120
 You remember how these are called?

776
00:55:38,120 --> 00:55:39,560
 It's critical section, right?

777
00:55:39,560 --> 00:55:45,640
 And the way to do it, in general, you do is a lock.

778
00:55:46,600 --> 00:55:50,160
 You have one lock and you acquire the lock

779
00:55:50,160 --> 00:55:54,000
 and you execute some code.

780
00:55:54,000 --> 00:55:55,280
 And while you have the lock,

781
00:55:55,280 --> 00:55:56,960
 no one else can acquire the lock.

782
00:55:56,960 --> 00:56:03,240
 So no one else may be able to execute these instructions.

783
00:56:03,240 --> 00:56:05,320
 And then you release a lock when you are done.

784
00:56:05,320 --> 00:56:07,480
 Okay?

785
00:56:07,480 --> 00:56:09,560
 And the threads libraries,

786
00:56:09,560 --> 00:56:13,120
 they do have the lock primitive.

787
00:56:15,760 --> 00:56:16,600
 Okay?

788
00:56:16,600 --> 00:56:19,920
 How do we fix it?

789
00:56:19,920 --> 00:56:21,640
 The previous example,

790
00:56:21,640 --> 00:56:26,640
 remember when multiple threads can run at the same time,

791
00:56:26,640 --> 00:56:28,560
 they can run at the same time

792
00:56:28,560 --> 00:56:32,480
 and then can access data at the same time.

793
00:56:32,480 --> 00:56:38,960
 Well, simply, simple, right?

794
00:56:38,960 --> 00:56:43,200
 You acquire the lock before you execute all the instruction

795
00:56:43,200 --> 00:56:48,200
 on an account, and then you release a clock, right?

796
00:56:48,200 --> 00:56:51,800
 So this is what in the middle of acquiring

797
00:56:51,800 --> 00:56:54,320
 and releasing the lock is called critical section.

798
00:56:54,320 --> 00:56:59,960
 So if multiple threads want to execute the same code,

799
00:56:59,960 --> 00:57:01,920
 only one will execute at a given time.

800
00:57:01,920 --> 00:57:04,800
 Right? Very simple.

801
00:57:04,800 --> 00:57:08,960
 So one thread and then thread B and thread C.

802
00:57:08,960 --> 00:57:12,440
 Okay?

803
00:57:12,520 --> 00:57:17,520
 So, but you need all this value of the same lock

804
00:57:17,520 --> 00:57:21,520
 or the same lock should be shared by all the threads

805
00:57:21,520 --> 00:57:23,720
 who want to access the same critical section.

806
00:57:23,720 --> 00:57:27,920
 Okay?

807
00:57:27,920 --> 00:57:30,240
 So remember, okay?

808
00:57:30,240 --> 00:57:33,360
 These two, three notions, synchronization,

809
00:57:33,360 --> 00:57:36,760
 using atomic operation to ensure cooperation between threads

810
00:57:38,680 --> 00:57:43,280
 and for now only slow than stores we assume are atomic.

811
00:57:43,280 --> 00:57:46,680
 Mutual exclusion, we ensure that only one thread

812
00:57:46,680 --> 00:57:48,680
 has a particular thing at a given time.

813
00:57:48,680 --> 00:57:51,040
 Right?

814
00:57:51,040 --> 00:57:53,720
 This means that one thread exclude another thread

815
00:57:53,720 --> 00:57:56,360
 from running the same code.

816
00:57:56,360 --> 00:58:00,120
 And critical section is other side

817
00:58:00,120 --> 00:58:02,760
 of the mutual exclusion coin

818
00:58:02,760 --> 00:58:05,160
 and critical section basically define

819
00:58:05,160 --> 00:58:09,160
 which is a sequence of instruction or the code,

820
00:58:09,160 --> 00:58:14,160
 which is can be executed by a single thread at a given time.

821
00:58:14,160 --> 00:58:21,440
 Here is another example.

822
00:58:21,440 --> 00:58:22,760
 Thread A and thread B.

823
00:58:22,760 --> 00:58:28,840
 Thread A starts with I, it initialized to zero

824
00:58:28,840 --> 00:58:33,320
 and then arts one has a loop, arts one.

825
00:58:33,320 --> 00:58:38,320
 And when you get to 10 exits and say prints A wins.

826
00:58:38,320 --> 00:58:44,200
 Thread B is doing similar things, but decrementing.

827
00:58:44,200 --> 00:58:47,800
 Start with I zero decrements it.

828
00:58:47,800 --> 00:58:50,440
 And if you reach to minus 10, B wins.

829
00:58:50,440 --> 00:58:54,520
 Both of them, they share these variables.

830
00:58:54,520 --> 00:58:55,360
 Why?

831
00:58:55,360 --> 00:58:58,440
 So what is the result here?

832
00:58:58,440 --> 00:59:01,040
 Who wins A or B?

833
00:59:01,040 --> 00:59:03,200
 (silence)

834
00:59:03,200 --> 00:59:09,760
 Okay, let's,

835
00:59:09,760 --> 00:59:13,600
 only 20 minutes remaining.

836
00:59:13,600 --> 00:59:16,840
 So let's get a little bit of energy.

837
00:59:16,840 --> 00:59:18,600
 Yeah.

838
00:59:18,600 --> 00:59:22,040
 Could be either, right?

839
00:59:22,040 --> 00:59:24,520
 You cannot know, right?

840
00:59:24,520 --> 00:59:29,760
 Let me ask you another question.

841
00:59:30,800 --> 00:59:35,200
 Are you guaranteed that at least one will win?

842
00:59:35,200 --> 00:59:49,720
 Now, excellent.

843
00:59:49,720 --> 00:59:52,600
 I listen and action.

844
00:59:52,600 --> 00:59:55,840
 Now, because in the worst case,

845
00:59:55,840 --> 00:59:57,200
 you see these three instruction.

846
00:59:57,200 --> 01:00:00,600
 I is equal to I plus one, I is equal to I minus one.

847
01:00:00,600 --> 01:00:04,320
 What happens if you have context switching

848
01:00:04,320 --> 01:00:06,680
 and between thread A and thread B and this.

849
01:00:06,680 --> 01:00:10,390
 thread only executes this instruction.

850
01:00:10,390 --> 01:00:11,870
 Right?

851
01:00:11,870 --> 01:00:14,190
 You get stuck with the same value.

852
01:00:14,190 --> 01:00:15,670
 You never finish.

853
01:00:15,670 --> 01:00:18,150
 None of those threads finishes.

854
01:00:18,150 --> 01:00:19,270
 OK?

855
01:00:19,270 --> 01:00:19,790
 Excellent.

856
01:00:19,790 --> 01:00:20,270
 Thank you.

857
01:00:20,270 --> 01:00:32,790
 So it's again, this is an inner loop.

858
01:00:32,790 --> 01:00:35,930
 And this is-- we see what is happening under the hood.

859
01:00:35,930 --> 01:00:37,590
 And all those are facts that what

860
01:00:37,590 --> 01:00:39,270
 you see is that in the program, it's

861
01:00:39,270 --> 01:00:41,230
 actually even more subtle.

862
01:00:41,230 --> 01:00:43,550
 Because when you see the program in the previous slide,

863
01:00:43,550 --> 01:00:44,350
 let me just--

864
01:00:44,350 --> 01:00:47,830
 we should have said, when you see this i is i plus 1

865
01:00:47,830 --> 01:00:50,710
 or i is i minus 1, actually maybe you

866
01:00:50,710 --> 01:00:53,670
 think that this is also atomic.

867
01:00:53,670 --> 01:00:58,850
 That means executes to completion.

868
01:00:58,850 --> 01:01:00,870
 Cannot be interrupted.

869
01:01:00,870 --> 01:01:01,950
 But it's not true.

870
01:01:01,950 --> 01:01:05,190
 Remember, only loads and stores are atomic.

871
01:01:05,190 --> 01:01:07,310
 So actually, things are even more complicated.

872
01:01:07,310 --> 01:01:11,070
 Because i and i plus 1 and i is i minus 1

873
01:01:11,070 --> 01:01:13,950
 can be interrupted in the middle.

874
01:01:13,950 --> 01:01:17,470
 And this is one example.

875
01:01:17,470 --> 01:01:18,550
 Right?

876
01:01:18,550 --> 01:01:22,990
 Where you execute-- you interleave the instruction

877
01:01:22,990 --> 01:01:29,510
 from thread A and thread B. And the result here is what?

878
01:01:29,510 --> 01:01:30,430
 Nothing changes.

879
01:01:30,430 --> 01:01:30,930
 Right?

880
01:01:30,930 --> 01:01:37,570
 OK.

881
01:01:37,570 --> 01:01:46,430
 Because in the middle, you read the same values.

882
01:01:46,430 --> 01:01:49,030
 You write the same at the same location.

883
01:01:49,030 --> 01:01:53,750
 And in the middle, you add to the value 1 and subtract 1.

884
01:01:53,750 --> 01:01:56,590
 So nothing changes.

885
01:01:56,590 --> 01:01:57,070
 OK?

886
01:01:59,970 --> 01:02:06,530
 So it's-- and typically, this is called race conditions

887
01:02:06,530 --> 01:02:10,110
 when you have two threads attempting to access same data

888
01:02:10,110 --> 01:02:14,190
 at the same time with one of them performing a write.

889
01:02:14,190 --> 01:02:14,690
 OK?

890
01:02:14,690 --> 01:02:19,470
 So how do you fix it?

891
01:02:19,470 --> 01:02:20,430
 Well, we know now.

892
01:02:20,430 --> 01:02:23,310
 You put a lock.

893
01:02:23,310 --> 01:02:24,230
 Does this fix it?

894
01:02:24,230 --> 01:02:29,070
 Not really, because we discussed, right?

895
01:02:29,070 --> 01:02:33,630
 You can execute this block of instruction, y plus 1,

896
01:02:33,630 --> 01:02:36,790
 and then execute the second block of instruction.

897
01:02:36,790 --> 01:02:41,750
 And it's true that you are going to see the changes.

898
01:02:41,750 --> 01:02:47,690
 But before you execute the next while,

899
01:02:47,690 --> 01:02:50,250
 the value was updated to the same value.

900
01:02:50,250 --> 01:02:53,790
 Right?

901
01:02:57,970 --> 01:03:00,370
 And the main point here-- and I need probably

902
01:03:00,370 --> 01:03:03,310
 to go a little bit faster--

903
01:03:03,310 --> 01:03:04,630
 concurrency is hard.

904
01:03:04,630 --> 01:03:07,890
 Like, look, these simple examples,

905
01:03:07,890 --> 01:03:09,430
 there are a bunch of instructions,

906
01:03:09,430 --> 01:03:10,470
 just a few instructions.

907
01:03:10,470 --> 01:03:11,390
 What?

908
01:03:11,390 --> 01:03:13,790
 Three instructions, four instructions?

909
01:03:13,790 --> 01:03:15,830
 Even that is hard.

910
01:03:15,830 --> 01:03:19,630
 Now imagine that you have thousands, tens of thousands

911
01:03:19,630 --> 01:03:22,630
 of instructions.

912
01:03:22,630 --> 01:03:24,710
 And there are many, many such issues.

913
01:03:27,270 --> 01:03:30,950
 And these are just some examples.

914
01:03:30,950 --> 01:03:36,070
 This was TeraK-25, a radiation therapy machine.

915
01:03:36,070 --> 01:03:40,590
 As a result of this kind of race condition concurrency,

916
01:03:40,590 --> 01:03:45,390
 of not being careful, accessing the same variable

917
01:03:45,390 --> 01:03:51,410
 from different threads, resulted in an overdose,

918
01:03:51,410 --> 01:03:54,550
 which caused even death.

919
01:03:54,550 --> 01:03:55,510
 OK?

920
01:03:55,510 --> 01:03:59,150
 It was improper synchronization between the input thread

921
01:03:59,150 --> 01:04:04,910
 and the positioning software where to apply the radiation.

922
01:04:04,910 --> 01:04:12,550
 Mark Pathfinder priority inversion.

923
01:04:12,550 --> 01:04:17,750
 Priority inversion here means that basically what happens,

924
01:04:17,750 --> 01:04:20,110
 you have a high priority job.

925
01:04:20,110 --> 01:04:22,030
 We'll learn more about that.

926
01:04:22,030 --> 01:04:29,110
 A high priority thread waiting for something

927
01:04:29,110 --> 01:04:31,470
 from a low priority thread.

928
01:04:31,470 --> 01:04:33,710
 But the high priority thread contains a lock,

929
01:04:33,710 --> 01:04:37,670
 maintains a lock, which is required by the low priority

930
01:04:37,670 --> 01:04:42,110
 thread to update that value or to do something

931
01:04:42,110 --> 01:04:45,930
 for its high priority thread weights.

932
01:04:45,930 --> 01:04:51,750
 But it cannot do it because a critical section is owned

933
01:04:51,750 --> 01:04:53,430
 by high priority thread.

934
01:04:53,430 --> 01:04:55,990
 So you get hacked.

935
01:04:55,990 --> 01:04:58,230
 This is another thing.

936
01:04:58,230 --> 01:05:00,350
 Toyota uncontrolled acceleration.

937
01:05:00,350 --> 01:05:07,230
 This was 256,000 lines of C code and whatever,

938
01:05:07,230 --> 01:05:11,070
 11,000 global variables.

939
01:05:11,070 --> 01:05:15,910
 So here it was inconsistent mutual exclusion.

940
01:05:15,910 --> 01:05:18,430
 So acceleration was uncontrollable.

941
01:05:18,430 --> 01:05:21,870
 You just doesn't respond.

942
01:05:21,870 --> 01:05:26,430
 You click a little bit and the car takes off

943
01:05:26,430 --> 01:05:30,030
 like you would floor the acceleration pedal.

944
01:05:30,030 --> 01:05:37,030
 OK, so next let's look about a little bit more

945
01:05:37,030 --> 01:05:40,790
 sophisticated things.

946
01:05:40,790 --> 01:05:47,190
 And let's look at about a Q. Producer consumer

947
01:05:47,190 --> 01:05:48,430
 with a bandit buffer.

948
01:05:48,430 --> 01:05:50,070
 Why this is important?

949
01:05:50,070 --> 01:05:52,750
 Remember about pipes last time.

950
01:05:52,750 --> 01:05:54,310
 We learned about pipes.

951
01:05:54,310 --> 01:05:55,710
 Pipes is a buffer.

952
01:05:55,710 --> 01:06:00,630
 It's a Q. You put at one end of the Q

953
01:06:00,630 --> 01:06:06,030
 and get the data from the other end of the Q.

954
01:06:06,030 --> 01:06:08,110
 When you do a pipe, this is also when

955
01:06:08,110 --> 01:06:10,230
 you do the piping between different--

956
01:06:10,230 --> 01:06:16,190
 when you chain different shell commands,

957
01:06:16,190 --> 01:06:17,270
 the same thing happened.

958
01:06:17,270 --> 01:06:24,510
 And we'll have another example of Kog machine later.

959
01:06:24,510 --> 01:06:29,270
 And there are many examples.

960
01:06:29,270 --> 01:06:32,030
 But this is what you want.

961
01:06:32,030 --> 01:06:35,750
 Ideally, you put at one end of the buffer

962
01:06:35,750 --> 01:06:37,790
 and you read from a different end of the buffer.

963
01:06:37,790 --> 01:06:40,310
 And typically, there is circular buffers.

964
01:06:40,310 --> 01:06:41,670
 They're easiest to handle.

965
01:06:45,350 --> 01:06:48,430
 And you have immediately to deal with several problems.

966
01:06:48,430 --> 01:06:51,030
 How to tell if full?

967
01:06:51,030 --> 01:06:53,030
 How to tell if the buffer is empty?

968
01:06:53,030 --> 01:06:57,430
 What to do if the buffer is full?

969
01:06:57,430 --> 01:06:59,670
 What to do if the buffer is empty?

970
01:06:59,670 --> 01:07:02,230
 What needs to be atomic?

971
01:07:02,230 --> 01:07:03,870
 OK?

972
01:07:03,870 --> 01:07:06,190
 So let's take a simple example.

973
01:07:06,190 --> 01:07:13,110
 Let's think about what is a simple implementation.

974
01:07:13,110 --> 01:07:15,910
 The producer, what do you need to do?

975
01:07:15,910 --> 01:07:20,350
 While the buffer is full, don't do anything.

976
01:07:20,350 --> 01:07:22,270
 You cannot put another item because you don't

977
01:07:22,270 --> 01:07:24,990
 have where to put it.

978
01:07:24,990 --> 01:07:27,590
 If the buffer is not full, you can use the item.

979
01:07:27,590 --> 01:07:32,750
 And because you need to do this operation,

980
01:07:32,750 --> 01:07:41,950
 you want to be atomic, you are going to guard it with a lock.

981
01:07:42,950 --> 01:07:43,430
 OK?

982
01:07:43,430 --> 01:07:50,790
 Can anyone tell me why you need to do this?

983
01:07:50,790 --> 01:07:52,030
 What can happen?

984
01:07:52,030 --> 01:07:53,470
 What can happen if I don't lock?

985
01:07:53,470 --> 01:08:10,150
 Yes, you may have buffer overflow.

986
01:08:10,150 --> 01:08:12,150
 Excellent.

987
01:08:12,150 --> 01:08:20,350
 Right, because you can have two producers, two threads.

988
01:08:20,350 --> 01:08:21,950
 OK?

989
01:08:21,950 --> 01:08:26,510
 And one execute-- both execute while buffer.

990
01:08:26,510 --> 01:08:28,910
 And both are happy.

991
01:08:28,910 --> 01:08:31,830
 The buffer has just one place for only one item.

992
01:08:31,830 --> 01:08:34,990
 Right?

993
01:08:34,990 --> 01:08:42,350
 So both are going to pass of the while.

994
01:08:42,350 --> 01:08:47,510
 But now one is interrupted, obviously, right?

995
01:08:47,510 --> 01:08:51,310
 And the other one is going to execute the item.

996
01:08:51,310 --> 01:08:53,710
 So now the buffer is full.

997
01:08:53,710 --> 01:08:56,390
 But for the first producer which was interrupted

998
01:08:56,390 --> 01:09:00,070
 or was suspended, resumes, he doesn't know.

999
01:09:00,070 --> 01:09:03,310
 He's going to try to add another item.

1000
01:09:03,310 --> 01:09:06,110
 And now you have the overflow.

1001
01:09:06,110 --> 01:09:07,070
 OK?

1002
01:09:07,070 --> 01:09:08,590
 And now is the dequeue.

1003
01:09:08,590 --> 01:09:12,630
 The same you do lock for this critical section.

1004
01:09:12,630 --> 01:09:13,470
 And you wait now.

1005
01:09:13,470 --> 01:09:15,390
 If the buffer is empty, you don't do anything.

1006
01:09:15,390 --> 01:09:17,790
 If the buffer is not empty, you are going to dequeue it.

1007
01:09:17,790 --> 01:09:21,230
 Right?

1008
01:09:21,230 --> 01:09:32,670
 Now, let's assume now for this code,

1009
01:09:32,670 --> 01:09:39,510
 if we do this, would we ever come out of the way?

1010
01:09:39,510 --> 01:09:40,270
 This is a question.

1011
01:09:59,590 --> 01:10:02,870
 So say that nothing is above them.

1012
01:10:02,870 --> 01:10:07,270
 All right.

1013
01:10:07,780 --> 01:10:11,660
 Then that's fine, right?

1014
01:10:11,660 --> 01:10:16,780
 You are going to fill the buffer.

1015
01:10:16,780 --> 01:10:18,580
 But let me ask you this question.

1016
01:10:18,580 --> 01:10:21,620
 OK, maybe we're not unanswered.

1017
01:10:21,620 --> 01:10:23,580
 Let's see.

1018
01:10:23,580 --> 01:10:25,980
 Now you can block on the consumer.

1019
01:10:25,980 --> 01:10:26,980
 Exactly.

1020
01:10:26,980 --> 01:10:33,440
 So, let's say that the queue is empty and the consumer executes.

1021
01:10:33,440 --> 01:10:44,380
 It acquires the lock and then it executes a while and it's stuck because there is nothing

1022
01:10:44,380 --> 01:10:46,180
 in the buffer.

1023
01:10:46,180 --> 01:10:50,700
 And the only one who can put something in the buffer is the producer.

1024
01:10:50,700 --> 01:10:57,620
 But in order for the producer to put something in the buffer, he still acquires the lock.

1025
01:10:57,620 --> 01:11:02,520
 But it cannot acquire the lock because it's owned by the consumer.

1026
01:11:02,520 --> 01:11:05,100
 So your hand.

1027
01:11:05,100 --> 01:11:06,100
 OK.

1028
01:11:06,100 --> 01:11:12,740
 So it don't work.

1029
01:11:12,740 --> 01:11:15,720
 OK.

1030
01:11:15,720 --> 01:11:18,420
 So how can you do it?

1031
01:11:18,420 --> 01:11:25,220
 One solution is to release a lock, OK, if the buffer is full.

1032
01:11:25,220 --> 01:11:31,140
 We need to release a lock if the buffer is full to give a chance to the consumer to consume

1033
01:11:31,140 --> 01:11:33,300
 from the buffer.

1034
01:11:33,300 --> 01:11:34,680
 Right.

1035
01:11:34,680 --> 01:11:36,280
 OK.

1036
01:11:36,280 --> 01:11:41,560
 And then acquire the buffer.

1037
01:11:41,560 --> 01:11:46,400
 You see what we've done here.

1038
01:11:46,400 --> 01:11:49,280
 You acquire before you check again whether the buffer is full.

1039
01:11:49,280 --> 01:11:52,080
 You release this to give a chance to the consumer to execute.

1040
01:11:52,080 --> 01:11:59,240
 You acquire the buffer back to check back whether the buffer is full for the lock.

1041
01:11:59,240 --> 01:12:01,840
 OK.

1042
01:12:01,840 --> 01:12:08,940
 What happens when one is waiting for the other?

1043
01:12:08,940 --> 01:12:22,040
 Like I said in this thing, it could work.

1044
01:12:22,040 --> 01:12:23,800
 OK.

1045
01:12:23,800 --> 01:12:28,320
 And for multiple clockwise, we'll discuss this a little bit later.

1046
01:12:28,320 --> 01:12:42,040
 Let me just-- and then there are other things we can do here.

1047
01:12:42,040 --> 01:12:47,240
 And this write abstraction of synchronizing threads that share memory.

1048
01:12:47,240 --> 01:12:53,880
 Locks is one abstraction.

1049
01:12:53,880 --> 01:13:02,080
 And-- but it's not the only abstraction.

1050
01:13:02,080 --> 01:13:04,040
 OK.

1051
01:13:04,040 --> 01:13:07,880
 And let me just see the question here.

1052
01:13:07,880 --> 01:13:11,000
 OK.

1053
01:13:11,000 --> 01:13:17,040
 Let me go back and it's important to understand that.

1054
01:13:17,040 --> 01:13:26,640
 So the question here, it's what happens when one is waiting for the-- why do we need to

1055
01:13:26,640 --> 01:13:27,640
 acquire the lock?

1056
01:13:27,640 --> 01:13:34,320
 We need to acquire the lock because here what happens in the while loop?

1057
01:13:34,320 --> 01:13:37,280
 In the while loop, it's an empty instruction.

1058
01:13:37,280 --> 01:13:40,800
 You need to repeat the-- you repeat the-- what is this while?

1059
01:13:40,800 --> 01:13:44,640
 You repeat the check whether the buffer is full.

1060
01:13:44,640 --> 01:13:48,360
 And in between the checks, you release and acquire the buffer.

1061
01:13:48,360 --> 01:13:53,560
 We need to be in critical section to check the buffer because you don't want to be--

1062
01:13:53,560 --> 01:13:59,340
 the buffer to be modified while you are checking about-- checking whether it's full.

1063
01:13:59,340 --> 01:14:01,920
 So that has to be critical section.

1064
01:14:01,920 --> 01:14:08,480
 But between multiple checks, you want to release the lock so the consumer can consume.

1065
01:14:08,480 --> 01:14:11,440
 That's all.

1066
01:14:11,440 --> 01:14:12,880
 Right?

1067
01:14:12,880 --> 01:14:14,520
 OK.

1068
01:14:14,520 --> 01:14:21,040
 So another way to do it is a more general way using semaphores.

1069
01:14:21,040 --> 01:14:22,360
 And we did the semaphores.

1070
01:14:22,360 --> 01:14:25,040
 We learned slightly a little bit about them.

1071
01:14:25,040 --> 01:14:27,240
 This is just recalling what we learned.

1072
01:14:27,240 --> 01:14:31,640
 There are two semaphores, two primitives-- sorry, two primitives on the same semaphore.

1073
01:14:31,640 --> 01:14:37,920
 Sp is an atomic operation which waits for the semaphore to become positive, then decrements

1074
01:14:37,920 --> 01:14:39,640
 by one.

1075
01:14:39,640 --> 01:14:44,600
 If zero, it just-- its waits is blocked.

1076
01:14:44,600 --> 01:14:51,920
 And b, we just increment the semaphore and wake up any other thread which waits for the

1077
01:14:51,920 --> 01:14:54,360
 semaphore.

1078
01:14:54,360 --> 01:14:57,180
 Right?

1079
01:14:57,180 --> 01:15:02,000
 So semaphores are like integers in the sense that you can increment and decrement them

1080
01:15:02,000 --> 01:15:04,400
 except there are no negative values.

1081
01:15:04,400 --> 01:15:13,240
 And the only way you can increment them is to use the p and v functions.

1082
01:15:13,240 --> 01:15:19,080
 And these operations, these operations are atomic.

1083
01:15:19,080 --> 01:15:23,080
 P and v are atomic.

1084
01:15:23,080 --> 01:15:26,240
 So this is a railroad analogy.

1085
01:15:26,240 --> 01:15:31,800
 You can implement like, for instance, in this case, you have two lines, two railroad lines,

1086
01:15:31,800 --> 01:15:33,800
 two rails.

1087
01:15:33,800 --> 01:15:39,560
 So you increment-- you put the value of the semaphore to two.

1088
01:15:39,560 --> 01:15:46,160
 So you can have an engine parked on one line and then an engine parked on second line.

1089
01:15:46,160 --> 01:15:51,720
 You notice that every time I have accepted an engine, I decrement the value.

1090
01:15:51,720 --> 01:15:52,720
 Now its value is zero.

1091
01:15:52,720 --> 01:15:54,280
 So you have another engine.

1092
01:15:54,280 --> 01:15:55,280
 It stopped.

1093
01:15:55,280 --> 01:15:57,960
 It cannot get in because the value is zero.

1094
01:15:57,960 --> 01:16:06,080
 Now when one leaves, it's going to increment the semaphore and the third engine can enter.

1095
01:16:06,080 --> 01:16:07,080
 Right?

1096
01:16:07,080 --> 01:16:09,880
 And so forth.

1097
01:16:09,880 --> 01:16:17,400
 So you can use semaphores to implement mutual exclusion.

1098
01:16:17,400 --> 01:16:22,800
 And this is equivalent to having a semaphore with a binary value, zero or one.

1099
01:16:22,800 --> 01:16:23,800
 Right?

1100
01:16:23,800 --> 01:16:25,880
 So how do you do that?

1101
01:16:25,880 --> 01:16:33,160
 You do a P on the semaphore, you initialize the semaphore to one and use a P. So the first

1102
01:16:33,160 --> 01:16:39,480
 thread which calls p is going to enter the critical section because you can decrement

1103
01:16:39,480 --> 01:16:40,480
 value to zero.

1104
01:16:40,480 --> 01:16:47,880
 The second one is going to call p while the first thread in the critical section cannot

1105
01:16:47,880 --> 01:16:51,160
 enter in the critical section because semaphore is zero.

1106
01:16:51,160 --> 01:16:57,440
 When the first semaphore leaves the critical section, it's going to increment the semaphore.

1107
01:16:57,440 --> 01:17:00,080
 So the second one comes.

1108
01:17:00,080 --> 01:17:01,520
 Right?

1109
01:17:01,520 --> 01:17:08,200
 We also say in this case that the semaphore implements scheduling constraints.

1110
01:17:08,200 --> 01:17:12,160
 Right?

1111
01:17:12,160 --> 01:17:21,080
 And also this is about, sorry, a second use case, which you'll also learn last time, it

1112
01:17:21,080 --> 01:17:28,080
 was about waiting, a thread waiting for another thread to finish.

1113
01:17:28,080 --> 01:17:29,080
 You need the code.

1114
01:17:29,080 --> 01:17:31,800
 And this was implementing join operation.

1115
01:17:31,800 --> 01:17:32,800
 Right?

1116
01:17:32,800 --> 01:17:35,560
 Remember this code.

1117
01:17:35,560 --> 01:17:49,800
 You have a thread join and you are going to wait for the thread to finish the other join.

1118
01:17:49,800 --> 01:17:53,400
 You run a thread and you wait for it to finish.

1119
01:17:53,400 --> 01:17:54,740
 And how you do that?

1120
01:17:54,740 --> 01:17:59,240
 You are going to have a semaphore which is initialized to zero.

1121
01:17:59,240 --> 01:18:14,880
 And when you start the thread, when you finish a thread, you increment the semaphore to one.

1122
01:18:14,880 --> 01:18:18,480
 And then, okay, let me take it back.

1123
01:18:18,480 --> 01:18:21,000
 You initialize the thread to zero.

1124
01:18:21,000 --> 01:18:22,000
 Okay?

1125
01:18:22,000 --> 01:18:27,520
 When you start the thread, nothing happens.

1126
01:18:27,520 --> 01:18:32,420
 And the main thread is going to wait to execute thread join.

1127
01:18:32,420 --> 01:18:39,720
 And it's going to be blocked because the semaphore is zero.

1128
01:18:39,720 --> 01:18:47,800
 When the thread finishes for which I am waiting, then the thread is going to increment the

1129
01:18:47,800 --> 01:18:49,720
 semaphore.

1130
01:18:49,720 --> 01:18:57,520
 And now the P in the thread join can decrement the semaphore and can finish.

1131
01:18:57,520 --> 01:18:58,520
 Okay?

1132
01:18:58,520 --> 01:19:03,200
 And this is when we say we implement scheduling constraints.

1133
01:19:03,200 --> 01:19:04,240
 Okay?

1134
01:19:04,240 --> 01:19:07,840
 So, this we are a little bit slow.

1135
01:19:07,840 --> 01:19:15,560
 Let me just go over announcements.

1136
01:19:15,560 --> 01:19:23,040
 Let me find the announcement and we are going to be done.

1137
01:19:23,040 --> 01:19:28,960
 So announcements, very quick announcements today.

1138
01:19:28,960 --> 01:19:35,720
 Please sign up for design reviews.

1139
01:19:35,720 --> 01:19:40,800
 The design documents also, don't forget, are due Friday.

1140
01:19:40,800 --> 01:19:48,600
 Next week, you are going to get the feedback on your design documents from your TA.

1141
01:19:48,600 --> 01:19:52,280
 So you need to sign to schedule that meeting.

1142
01:19:52,280 --> 01:19:53,980
 And the homework one is due today.

1143
01:19:53,980 --> 01:19:56,700
 So good luck with that.

1144
01:19:56,700 --> 01:19:59,560
 So good luck again with the homework.

1145
01:19:59,560 --> 01:20:03,080
 Good luck with the design documents and see you all next week.

1146
01:20:03,080 --> 01:20:04,080
 Thank you.

1147
01:20:04,080 --> 01:20:15,060
 [ Silence ]

