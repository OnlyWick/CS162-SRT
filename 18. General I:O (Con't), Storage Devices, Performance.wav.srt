1
00:00:00,000 --> 00:00:28,800
 Hello, everyone. So welcome to the 18th lecture of CS162 2021. So today we are going to talk

2
00:00:28,800 --> 00:00:43,600
 about general input output. And just to summarize, so far we have studied abstractions, the API

3
00:00:43,600 --> 00:00:52,240
 which is provided by the operating system to the application to run a process. We talk

4
00:00:52,240 --> 00:01:00,400
 quite a bit about the virtual memory, demand paging, how to manage the physical memory,

5
00:01:00,400 --> 00:01:11,440
 and about virtualization. And we also talk about synchronization and scheduling. Okay?

6
00:01:11,440 --> 00:01:19,120
 So and how to manage the CPU resources and how to synchronize to have multiple processes

7
00:01:19,120 --> 00:01:29,840
 and multiple threads, accessing the same resources and how they can cooperate in order to implement

8
00:01:29,840 --> 00:01:39,600
 some more complex functionality. Okay? So now one thing we haven't talked as much so far is about

9
00:01:39,600 --> 00:01:47,600
 input and output. And obviously the input output is a fundamental part of any computer system,

10
00:01:47,600 --> 00:01:54,880
 because that's why how we interact with the computers through some input output devices

11
00:01:54,880 --> 00:02:04,640
 like keyboards, mouse, cameras, and things like that. And also this is how the computer itself

12
00:02:04,640 --> 00:02:09,280
 interact with the environment and with us, displaying information on the screen,

13
00:02:09,280 --> 00:02:17,120
 printing information, and other things like that. Right? Now the biggest problem, and this is

14
00:02:17,760 --> 00:02:26,400
 what also makes this also this lecture a little bit maybe harder, is that

15
00:02:26,400 --> 00:02:33,360
 it's there are a huge variety of this input output devices.

16
00:02:33,360 --> 00:02:40,160
 Right? Actually, if you think about others, like memory, memory is pretty simple. It's an array

17
00:02:40,160 --> 00:02:46,320
 of addressable bytes. Right? That's pretty much what it is. If you think about the CPUs and so

18
00:02:46,320 --> 00:02:54,640
 forth, from our perspective, it's a resource which we want to probably time slice in time,

19
00:02:54,640 --> 00:03:04,720
 time slice, so then we can visualize it. So we created this illusion that every process has

20
00:03:04,720 --> 00:03:13,360
 access to its own machine, virtual machine. Right? But if you look about input output

21
00:03:13,920 --> 00:03:22,320
 devices, this is a huge variety. And not only in terms of the sizes, not only in terms of the speed

22
00:03:22,320 --> 00:03:31,040
 they operate at, you can have networking, which is hundreds of gigabytes per second versus keyboard,

23
00:03:31,040 --> 00:03:41,680
 which is one character per whatever second. But also in terms of reliability, in some cases,

24
00:03:41,680 --> 00:03:46,800
 you can lose information like packets on the network can be lost. So you need to recover.

25
00:03:46,800 --> 00:03:53,200
 So in all aspects in low dimension, you have a huge variety. And yet the operating system

26
00:03:53,200 --> 00:04:00,240
 needs to cope with this variety in a reasonable way. Right? You don't want to be exposed.

27
00:04:00,240 --> 00:04:05,920
 And what that means, you don't want your program, when you are developing your program, to think

28
00:04:05,920 --> 00:04:16,000
 about each of these input devices in a different way. Right? And this is the role of the operating

29
00:04:16,000 --> 00:04:23,120
 system. Again, despite this huge variety to provide us with an interface, which is reasonable,

30
00:04:23,120 --> 00:04:36,160
 which is reasonable, you know, scoped, and you can make sense of it. And you don't need to,

31
00:04:36,160 --> 00:04:43,760
 you know, think about different concepts or you are going to operate on different IOD devices.

32
00:04:43,760 --> 00:04:51,840
 Okay. And this is a, if you remember, this is a figure we have shown a few times in the past.

33
00:04:52,400 --> 00:05:00,000
 And here this protection boundary switches down here, it's also abstracts away

34
00:05:00,000 --> 00:05:04,880
 this input output devices.

35
00:05:04,880 --> 00:05:15,120
 Okay. So today we are going to talk about how you are going to get the impact, you know,

36
00:05:15,120 --> 00:05:21,600
 how you are going to get this kind of input from these devices. And eventually,

37
00:05:21,600 --> 00:05:26,480
 where do you need to get this input? This input from these devices, you need to put in memory.

38
00:05:26,480 --> 00:05:31,440
 Right? Because why? Because your program, in order to operate to the input,

39
00:05:31,440 --> 00:05:37,360
 it has to find the input in memory because the program operates only on data in memory.

40
00:05:37,360 --> 00:05:47,680
 Right. And that's pretty much it. Now, this is one example, and this is an old example,

41
00:05:48,720 --> 00:05:56,320
 many years back. And this is from Sun Enterprise. Again, Sun, it was a big company of workstations

42
00:05:56,320 --> 00:06:07,200
 and it was acquired many years back by Oracle. But in the heyday, this was a great company.

43
00:06:07,200 --> 00:06:14,560
 And if you think about the devices and only looking in terms of the speed,

44
00:06:14,560 --> 00:06:19,680
 you have keyboards, like I mentioned, and the system bus, the system bus, it's learning the

45
00:06:19,680 --> 00:06:29,840
 system bus on the machine, which connects different devices, which are on the same enclosure on the

46
00:06:29,840 --> 00:06:36,160
 machine, like for instance, this storage and things like that. There are differences,

47
00:06:36,160 --> 00:06:41,920
 it's two orders of magnitude. So you need to provide interfaces which can cope with such a huge

48
00:06:44,080 --> 00:06:49,040
 variation in the speed. Okay.

49
00:06:49,040 --> 00:06:56,960
 So this means that, and you need to have something which works very well

50
00:06:56,960 --> 00:07:07,680
 when you have high throughput. So the overhead for transfer per byte should be very low. At the

51
00:07:07,680 --> 00:07:15,840
 same time, if it's something very slow, you shouldn't just waste time waiting for the slow

52
00:07:15,840 --> 00:07:22,400
 devices. It's like if something happens one per second, you cannot wait once for the entire second

53
00:07:22,400 --> 00:07:29,760
 to get one character. Okay. This is another way to look about, and this is to put everything in

54
00:07:29,760 --> 00:07:34,640
 one picture about what we learned so far and what we are going to learn today. Right on the left

55
00:07:34,640 --> 00:07:41,840
 hand side, you have the processor and the processor obviously has the CPU, but in addition to CPU has

56
00:07:41,840 --> 00:07:51,600
 some storage, right? And the storage comes into registers, then a bunch of caches, L1 and L2 cache,

57
00:07:51,600 --> 00:07:58,640
 which are the server core. And then you have an L3 cache and the L3 cache typically shared

58
00:07:58,640 --> 00:08:07,680
 across multiple cores. And then you have memory and secondary storage and maybe another tertiary

59
00:08:07,680 --> 00:08:18,080
 storage and so forth. And the difference between this kind of storage hierarchy, it's obviously

60
00:08:18,080 --> 00:08:27,120
 like going from registers all the way from this to disk storage. You have at each level, it's much

61
00:08:27,120 --> 00:08:34,560
 larger capacity, but also higher life latency. Right? So we learn about that. And we learn that

62
00:08:34,560 --> 00:08:40,880
 about caching, we learned about demand paging and so forth. And in addition to that, here on the top

63
00:08:40,880 --> 00:08:52,160
 with the yellow, you have all these devices, which again, needs to be available, the data which is

64
00:08:52,160 --> 00:08:58,400
 read from these devices to be available to processor. And then for the processor to write

65
00:08:58,400 --> 00:09:06,560
 data to these devices, like to storage, to screen for you to see an image. And typically all these

66
00:09:06,560 --> 00:09:14,560
 devices are, they have a controller and this controller is what the name implies, controls

67
00:09:14,560 --> 00:09:19,360
 these devices because these devices are different. In some sense, this yellow box provides this

68
00:09:19,360 --> 00:09:27,200
 magical interface, which is reasonably uniform across all the devices to the processor and to

69
00:09:27,200 --> 00:09:34,000
 the programmer. But in the back is doing this heavy lifting to uniformize these APIs by dealing

70
00:09:34,000 --> 00:09:45,200
 with such a heterogeneous set of devices. Okay. So now let's look a little bit into more details

71
00:09:45,200 --> 00:09:50,720
 to see how things are on a computer. Right. And this is what you have on your computer. This is

72
00:09:50,720 --> 00:10:00,080
 actually on your laptop or iPad. At some level, this is what you have. Okay. And you have processors,

73
00:10:00,080 --> 00:10:06,160
 obviously, and you may have other, you may have GPUs, you may have a network card here.

74
00:10:06,160 --> 00:10:12,400
 Of course, you have some storage devices, you may have big speakers, internal and external speakers,

75
00:10:13,040 --> 00:10:20,320
 you may have a printer, of course, keyboards, you have the monitor, and many more. Right. So again,

76
00:10:20,320 --> 00:10:26,800
 you need to take all this information from these devices to get into process, and then to write

77
00:10:26,800 --> 00:10:31,920
 back information at least to some devices, some of these devices, of course, you don't need to

78
00:10:31,920 --> 00:10:36,320
 write back information to the keyboard, keyboard is only an input device. As a printer, it's only

79
00:10:36,320 --> 00:10:42,400
 an output device. And how do you connect them? Right. So first of all, how you wire them.

80
00:10:43,120 --> 00:10:49,520
 So it turns out that the way you wire them is through this bus, you have a bus, right? So

81
00:10:49,520 --> 00:10:56,880
 everything goes to a bus, everything, including actually even the memory on the machine. And the

82
00:10:56,880 --> 00:11:04,000
 data is sent through this bus. Okay. And this is how you get the data into the processor. This is

83
00:11:04,000 --> 00:11:11,440
 how you get the data out of the processors through one bus. And more precisely, what is a bus?

84
00:11:12,240 --> 00:11:22,320
 It represents the set of specifications. It specifies what are the wires, how many wires

85
00:11:22,320 --> 00:11:34,560
 they have, it has, and how you connect to it. And then on top of that, it has to provide an API.

86
00:11:35,680 --> 00:11:43,840
 Read, write, how do you read and write from this bus? And you also have how you are going to

87
00:11:43,840 --> 00:11:51,680
 address a particular device. And for the particular device, you also have not only data reading,

88
00:11:51,680 --> 00:11:58,080
 reading data, but you have also control data, right? Like for instance, for a disk, like you'll

89
00:11:58,080 --> 00:12:03,680
 see, you need to tell the disk where a particular block is on the disk to read or to write.

90
00:12:05,440 --> 00:12:12,880
 This is happening through the control lines, right? And the controller, like you see the

91
00:12:12,880 --> 00:12:20,320
 yellow box, is going to decide and instruct using the control line, a device, what to do,

92
00:12:20,320 --> 00:12:29,280
 and where to get the data from or to write the data to. And then there is also the protocol. You

93
00:12:29,280 --> 00:12:35,200
 have multiple devices which are going to send the data on the same bus. So what do you need to do?

94
00:12:36,000 --> 00:12:42,320
 Right? Not all of them can send the data at the same time, right? In general, you have only one

95
00:12:42,320 --> 00:12:47,520
 device being able to send data on the bus at a given time. So this means that you need to

96
00:12:47,520 --> 00:12:52,240
 arbitrate. If more than one device wants to send the data on the bus at the same time,

97
00:12:52,240 --> 00:12:56,400
 then you need to arbitrate who is going to be allowed to send and who is going to wait.

98
00:12:57,200 --> 00:13:10,800
 Okay. And of course, the devices here are, again, remember about they are very different in speed.

99
00:13:10,800 --> 00:13:18,400
 The devices which are close to the processor, like memory, things like that, they are very,

100
00:13:18,400 --> 00:13:27,280
 very fast. The ones which are very remote, like are much slower, like say, you know,

101
00:13:27,280 --> 00:13:37,760
 keyboard or printer. So now why a bus? This is very important. It may seem that this is obvious.

102
00:13:37,760 --> 00:13:43,440
 Of course, it's a bus, right? But think about what is the alternative. So an obvious alternative here,

103
00:13:44,000 --> 00:13:49,760
 it will be to connect every device to the processor, right? And if the two devices have

104
00:13:49,760 --> 00:13:55,360
 to communicate among themselves, you're also going to connect between them, right? The problem is that

105
00:13:55,360 --> 00:14:01,520
 then you are going to have, in the worst case, you have n devices and you can have, you know,

106
00:14:01,520 --> 00:14:10,640
 n square connection. You don't want that. It's very complicated. Okay? So that's why what you

107
00:14:10,640 --> 00:14:15,120
 want, you have this bus and everyone is connected to the bus and then it's beautiful. Then you

108
00:14:15,120 --> 00:14:23,600
 multiplex the bus in time. But the problem is that if you multiplex in time, then it may be

109
00:14:23,600 --> 00:14:29,040
 very inefficient because remember all these devices have very, very different speeds.

110
00:14:29,040 --> 00:14:36,720
 So, you know, like for instance, if I'm going the keyboard, right, it's like a key, right? You

111
00:14:36,720 --> 00:14:42,880
 click a key and it takes a gain. It's like every one second. It's like, it's very inefficient way

112
00:14:42,880 --> 00:14:52,880
 of that bus, right? Because in the same time, you may send if, you know, from memory, you can send

113
00:14:52,880 --> 00:15:04,640
 hundreds of gigabits per second, which means, you know, a few tens of gigabytes per second. Okay?

114
00:15:04,640 --> 00:15:08,720
 So it's very inefficient, right? You don't, you know, if you have slow devices,

115
00:15:08,720 --> 00:15:16,720
 very inefficient for very fast devices. Okay. And so that's one of the big problems.

116
00:15:16,720 --> 00:15:26,160
 Advantage against simplicity, everyone connects to it. The standard bus is today's,

117
00:15:26,160 --> 00:15:33,520
 is PCI is called Peripheral Component Interconnect. And it started as a parallel bus. Parallel bus,

118
00:15:33,520 --> 00:15:42,400
 meaning that at one device at a time is going to use to be able to send data and it can send data

119
00:15:42,400 --> 00:15:49,920
 in parallel. If he sends, you know, and the weights of the bus represents how many bits you can send

120
00:15:49,920 --> 00:15:55,920
 in parallel. So for instance, if you have 128 bits, this means that you are going to be able to

121
00:15:55,920 --> 00:16:08,240
 send in one clock cycle, 128 bits, right? And you multiply this, this, this bus like we discussed,

122
00:16:08,240 --> 00:16:17,040
 but now the problem, if it's a slow device, then you are going to, you know, use, and also it

123
00:16:17,040 --> 00:16:22,960
 doesn't have, it sends only eight bits while the bus is 128 bits. You are going to waste on 20

124
00:16:22,960 --> 00:16:31,120
 bits while this device is alone using the bus for sending just eight bits. Okay. So I'm going to,

125
00:16:31,120 --> 00:16:46,240
 to stop here. Any questions about so far? Okay. So this is a little bit again, it's like very

126
00:16:46,240 --> 00:16:50,640
 descriptive, a lot of heterogeneity. So maybe a little bit boring, but it will, it will change.

127
00:16:51,680 --> 00:16:58,240
 So now you may have heard about PCI express bus. So what is the problem is that it's parallel.

128
00:16:58,240 --> 00:17:06,240
 This is great. You know, it's simple, but only one device can use at the same time. And if it's

129
00:17:06,240 --> 00:17:12,480
 a slow device, you waste so much time for the fast devices. So PCI express is pretty smart.

130
00:17:12,480 --> 00:17:17,120
 So it's no longer, no longer parallel bus. You still have multiple lines,

131
00:17:17,840 --> 00:17:26,000
 but they are serial channels. And you can, now a device can choose how many lines it's going to send.

132
00:17:26,000 --> 00:17:36,560
 Do you use to send? Right? So for instance, if you have a very slow device, like your keyboard,

133
00:17:36,560 --> 00:17:44,960
 right, you can use to send everything on one line, right? And you leave all the other lines for

134
00:17:44,960 --> 00:17:58,080
 others, like memory, right access to memory or the storage. Okay. So this allows the slow devices

135
00:17:58,080 --> 00:18:09,600
 to share the PCI bus with fast devices in an efficient way. And again, the beauty of this,

136
00:18:10,320 --> 00:18:20,000
 of Linux and Unix behind it, before it was that, you know, the ability to support all of these,

137
00:18:20,000 --> 00:18:27,360
 you know, not only to migrate from PCI to PCI express, but again, to provide a pretty uniform

138
00:18:27,360 --> 00:18:37,360
 interface across all these devices. Okay. And also the API itself remains the same,

139
00:18:37,360 --> 00:18:42,080
 most pretty much the same. And this is quite amazing, right? If you think about it,

140
00:18:42,080 --> 00:18:49,040
 because Unix, when it was designed, Unix, I mean, a lot of

141
00:18:49,040 --> 00:18:57,760
 things you have today, maybe they are not available then. You don't, you didn't have

142
00:18:58,960 --> 00:19:08,800
 GPUs for instance. I'm sure you didn't have a lot of this kind of game, you know, game inputs,

143
00:19:08,800 --> 00:19:19,920
 devices, right? And many other things, right? So despite that, you started to connect things

144
00:19:22,240 --> 00:19:32,000
 to the computer, which are not envisioned when people designed the operating system in the first

145
00:19:32,000 --> 00:19:38,000
 place. The operating system was still being able to preserve the same API. Of course, you need to

146
00:19:38,000 --> 00:19:48,320
 implement controllers or drivers, which are going to provide, you know, to support these devices

147
00:19:48,880 --> 00:19:57,280
 and provide the same kind of abstraction like before, right? We'll talk more about that. Okay.

148
00:19:57,280 --> 00:20:05,520
 Anyway, here is an example of the PCI architecture. Today, you have a PCI number zero,

149
00:20:05,520 --> 00:20:16,640
 PCI number zero here. And this is very fast one. This is connected to the CPU

150
00:20:17,360 --> 00:20:24,080
 and the CPU is also having a memory bus to the RAM. Then there is a PCI bridge here.

151
00:20:24,080 --> 00:20:28,160
 You have another PCI bus. This PCI bus is a little...

152
00:20:28,160 --> 00:20:38,420
 bit typically slower. And this connects the storage devices, for instance, a scanner,

153
00:20:38,420 --> 00:20:46,560
 and all the webcam, mouse and keyboard. And then you have another bridge here from PCI

154
00:20:46,560 --> 00:20:57,260
 to ESA. So ISI, it was an older bus standard. So you may still have devices, for instance,

155
00:20:57,260 --> 00:21:08,500
 hard disk drives, which support, which implements this standard and connect to this ISI bus.

156
00:21:08,500 --> 00:21:16,220
 And this is a bridge, so then you can use these devices on PCI architecture.

157
00:21:16,220 --> 00:21:29,500
 So here, let's go into a little bit more detail. So how does a processor talk to all these

158
00:21:29,500 --> 00:21:43,820
 devices? So here is a CPU and you have the memory and you have a memory bus here. And

159
00:21:43,820 --> 00:21:53,740
 now you have, this is connected through a bus adapter to get data from this device controller.

160
00:21:53,740 --> 00:22:01,460
 Right, remember, each device has a controller. And the device, you send the instructions

161
00:22:01,460 --> 00:22:09,000
 about what data to get or to write. And the controller is talking with the device to get

162
00:22:09,000 --> 00:22:17,220
 what the program asks for. Now, within a device controller, a device controller is quite complicated.

163
00:22:17,220 --> 00:22:21,460
 Actually many device controllers, they have their own processor. So it's like their own

164
00:22:21,460 --> 00:22:27,640
 computer, right? They have ARM processor and so forth to implement the program, which is

165
00:22:27,640 --> 00:22:34,100
 going to control that device. Of course, we have a bus interface to send the data in and

166
00:22:34,100 --> 00:22:42,540
 out to connect to the other buses in the system. And it has a memory, you can, for instance,

167
00:22:42,540 --> 00:22:51,280
 for doing, for caching data. For instance, when you send data to the printer, you can

168
00:22:51,280 --> 00:22:56,140
 assume that it's not like you send one byte is printed, you send one byte is printed.

169
00:22:56,140 --> 00:23:03,640
 No, you send a lot, almost the entire file, or you can send the entire file, which is

170
00:23:03,640 --> 00:23:11,420
 kind of stored, that is part of it in local memory, and then it's printed from there.

171
00:23:11,420 --> 00:23:16,220
 And then this is very important. You have a set of registers here, which are, these

172
00:23:16,220 --> 00:23:31,220
 are the registers to which they are used to interact with this controller. They are used

173
00:23:31,220 --> 00:23:40,420
 to tell the controller what to do, right? And, you know, read, write, or configure,

174
00:23:40,420 --> 00:23:46,140
 to configure the controller in a particular way. It's also to get the status of the controller.

175
00:23:46,140 --> 00:23:50,660
 The status of the controller can be busy, right? The printer is busy, right? Showing

176
00:23:50,660 --> 00:23:56,380
 the status, not sorry, this is the status of the device controlled by the controller.

177
00:23:56,380 --> 00:24:03,740
 Okay, another important thing, if you remember, we have this kind of interrupts, right? You

178
00:24:03,740 --> 00:24:08,900
 remember about the interrupts? And one of the main issues of interrupt is to react when

179
00:24:08,900 --> 00:24:15,960
 something happens in the external world. And one of the main use cases there, it's about

180
00:24:15,960 --> 00:24:24,700
 when you have some data to get from a device, from the network, for instance, or when some

181
00:24:24,700 --> 00:24:33,980
 device needs attention, right? So that's what the interrupt controller and the controller

182
00:24:33,980 --> 00:24:38,340
 is going to raise some interrupts. And the interrupts are, if you remember, the operating

183
00:24:38,340 --> 00:24:43,100
 system, depending on the interrupt, is going to have an interrupt handler, which is going

184
00:24:43,100 --> 00:24:54,220
 to handle that interrupt, right? The network card has, and another controller has new data,

185
00:24:54,220 --> 00:25:00,480
 is going to interrupt, to raise an interrupt, the OS is going to handle that interrupt,

186
00:25:00,480 --> 00:25:09,900
 and is going to read the data from the controller. Okay. Now, how do I interact? How do I program

187
00:25:09,900 --> 00:25:19,120
 these controllers? There are two ways. Port mapped IO, in and out instructions. So basically

188
00:25:19,120 --> 00:25:25,520
 here for the Intel architecture in particular, you have say out 0x21. So this is an address.

189
00:25:25,520 --> 00:25:33,900
 This is an IO. So each IO has its own address. Each IO device has its own address. And basically

190
00:25:33,900 --> 00:25:45,860
 out 0x21, AL means that the content of register AL is a register. So the content of that register

191
00:25:45,860 --> 00:25:53,280
 will be written on that output, at that address, to that output, will be written to that output.

192
00:25:53,280 --> 00:26:04,260
 And you have the corresponding in and from a particular port address. And then the data

193
00:26:04,260 --> 00:26:14,520
 from that port is going to be written in register AL, for instance. Okay. So you have special

194
00:26:14,520 --> 00:26:22,880
 instructions here, right? And special addresses for these devices. On the other hand, you

195
00:26:22,880 --> 00:26:30,100
 can have memory mapped IO. And this is pretty cool. You basically reserve your, you configure

196
00:26:30,100 --> 00:26:39,840
 some addresses in the memory, in the RAM. Okay. And this being are connected to these

197
00:26:39,840 --> 00:26:46,440
 input output devices. Okay. And then the only thing you do, you use load and store, because

198
00:26:46,440 --> 00:26:54,360
 it's memory. Load means if I am going to put the data there at that particular address,

199
00:26:54,360 --> 00:27:06,480
 that data is going to be sent to the corresponding device. Right? If I get, if I read the data

200
00:27:06,480 --> 00:27:13,120
 from that, from a particular address, which is memory mapped address, then I'm going to

201
00:27:13,120 --> 00:27:22,040
 read data from the corresponding device. Make sense? This is an example about memory mapped,

202
00:27:22,040 --> 00:27:33,000
 right? And this is really used for graphics. Right? So typically, typically here, what

203
00:27:33,000 --> 00:27:40,660
 you have is that, you know, like your screen is a bitmap. Right? You know that, right?

204
00:27:40,660 --> 00:27:50,700
 So the screen, the control of a screen, sees the same memory, you know, have a region,

205
00:27:50,700 --> 00:27:59,700
 you devote a region of your RAM, you devote to that, to the screen. And when you are going,

206
00:27:59,700 --> 00:28:06,920
 and then you, when you are going to modify this memory, see how, what you modify, you

207
00:28:06,920 --> 00:28:14,700
 see immediately on the screen. Right? And so, so from here, display memory is from this

208
00:28:14,700 --> 00:28:25,280
 address 800, whatever, 10,000 to 800, 8,000, whatever, F000, this is a display memory.

209
00:28:25,280 --> 00:28:33,040
 In addition to that, you may have also a command queue, because you may have, you can provide

210
00:28:33,040 --> 00:28:44,200
 some commands to the display, you know, for instance, because you may have, like, higher

211
00:28:44,200 --> 00:28:50,900
 level abstractions, rather than just writing and reading, writing individuals in the individual

212
00:28:50,900 --> 00:28:57,440
 bits, like, for instance, generating triangles, right, you are going to basically command,

213
00:28:57,440 --> 00:29:04,340
 give a command to the controller, the controller, which is a graphic card is going to, to generate

214
00:29:04,340 --> 00:29:11,540
 this kind of, say, triangles to create much faster, to render much faster, some, you know,

215
00:29:11,540 --> 00:29:25,680
 impressive, you know, objects. Okay. So this is, this is one thing. So again, that in summary

216
00:29:25,680 --> 00:29:32,680
 from in summary here, in this is very simple example, you are going to have a region on

217
00:29:32,680 --> 00:29:41,120
 the RAM, which is seen both by processor, and is seen by both and also by the controller,

218
00:29:41,120 --> 00:29:48,880
 the video controller, right. And when you write, when the processor writes to this address,

219
00:29:48,880 --> 00:30:13,600
 to this memory, you see it on the screen. So, any questions? Now, it turns out that

220
00:30:13,600 --> 00:30:19,320
 today with this, everyone knows about GPUs, you know, graphical processing units, and

221
00:30:19,320 --> 00:30:24,680
 the GPUs, they have actually their own memory. So you don't have the sharing. And the reason

222
00:30:24,680 --> 00:30:30,160
 for that, because the memory thing on the because the memory is a GPU, if the memory

223
00:30:30,160 --> 00:30:37,240
 is on the GPU, that is much, much faster. So you can, you know, render much faster,

224
00:30:37,240 --> 00:30:45,160
 much quicker. That's one of the reasons. This is for you to know. And of course, you can

225
00:30:45,160 --> 00:30:52,760
 protect this memory regions using address translation like we know. Now, here is an

226
00:30:52,760 --> 00:31:01,320
 interesting thing. So far, we saw it, we told, I told you how it's, you know, that you have

227
00:31:01,320 --> 00:31:07,080
 this processor, and you have all these other storage devices and IO devices around it,

228
00:31:07,080 --> 00:31:11,920
 and they are connected by the bus. But if a look in the processor into a processor itself,

229
00:31:11,920 --> 00:31:17,120
 you see some similar things, because in a processor is not a monolith. In a processor,

230
00:31:17,120 --> 00:31:23,160
 remember, you have multiple cores, you have multiple caches, and so forth. So how, and

231
00:31:23,160 --> 00:31:31,680
 actually many CPUs today, they also have graphic unit, right? Or neural unit, right, like some

232
00:31:31,680 --> 00:31:39,560
 of the Apple chips have. Right? So, and then how do you connect those? Well, the answer

233
00:31:39,560 --> 00:31:49,000
 is through a bus, right? Okay. So it's again, it's like what you see is outside, you know,

234
00:31:49,000 --> 00:31:53,640
 you know, outside the CPU, it's also pretty similar inside the CPU, you have different

235
00:31:53,640 --> 00:31:58,800
 components, like here are a few examples, like I mentioned, and they are connected by

236
00:31:58,800 --> 00:32:05,280
 a bus. By the way, HDX is a software guard extension. So this is basically, it's a software,

237
00:32:05,280 --> 00:32:11,120
 it's a hardware enclave for people who, you know, for people who took a security course,

238
00:32:11,120 --> 00:32:24,120
 a class. And yeah. And then you are going to have, then you are going to connect outside

239
00:32:24,120 --> 00:32:29,960
 the CPU, you are going to connect to the memory, DDR, this is the memory. And you are going

240
00:32:29,960 --> 00:32:37,560
 also, you see here, you are going to have a PCI Express, right? This is how you connect

241
00:32:37,560 --> 00:32:47,800
 to the PCI Express to the rest of your devices. This is another way to look at, this is again,

242
00:32:47,800 --> 00:32:53,200
 Skylake system configuration. This is the same GPU here. It's pretty old, but today's

243
00:32:53,200 --> 00:33:03,560
 on the ones today are not very different. Okay. And you have, you have here, basically,

244
00:33:03,560 --> 00:33:13,440
 you know, you have, this is a core, and this is connected to memory. Then you have the

245
00:33:13,440 --> 00:33:23,280
 PCI Express, it's again to directly connect to other I/O devices. And then you have this

246
00:33:23,280 --> 00:33:31,120
 bridge, and you have another chip which connects to other I/O devices. And this typically saves

247
00:33:31,120 --> 00:33:40,840
 a little bit slower devices in general, right? USB, audio, video, LAN, and so forth. So it's

248
00:33:40,840 --> 00:33:50,600
 again the same picture, emphasizing this pattern of multiple components being connected by

249
00:33:50,600 --> 00:34:15,720
 bus, fast buses. Okay, any questions? So now I mentioned to you that one of the

250
00:34:15,720 --> 00:34:26,280
 beauty and the successes of Unix and Linux, obviously, is that they were able to provide

251
00:34:26,280 --> 00:34:40,680
 an API which remain pretty much the same over time, despite a proliferation of I/O devices.

252
00:34:40,680 --> 00:34:52,220
 And the reason for that is because obviously, they got abstraction, right, right. And they

253
00:34:52,220 --> 00:34:58,320
 already recognize early on, there are different type of devices and they are going to handle

254
00:34:58,320 --> 00:35:09,720
 with different with these devices slightly different. So how, how these devices are segmented?

255
00:35:09,720 --> 00:35:16,600
 First is data granularity. When I'm going to read and write from a device, what is the

256
00:35:16,600 --> 00:35:23,080
 granularity of the data I'm going to use? Lowest granularity is like byte, in some cases,

257
00:35:23,080 --> 00:35:27,400
 there is bit but it's rare, it's byte, right? You read one byte at a time, you write one

258
00:35:27,400 --> 00:35:33,320
 byte at a time. But there are other devices, many other devices where you write at a higher

259
00:35:33,320 --> 00:35:44,640
 granularity, like a block, like to disk, or reading or writing from a disk, or reading

260
00:35:44,640 --> 00:35:50,460
 or writing from the network. So it's it's, it's a level of granularity, it's a packet.

261
00:35:50,460 --> 00:35:59,520
 So now, let's make a little bit this class more interactive. Why do you think that? Why

262
00:35:59,520 --> 00:36:06,840
 byte is not is not enough? Why not just have the ability to read and write only at the

263
00:36:06,840 --> 00:36:36,280
 background? Anyone can tell me? It's exactly what's bad. Yeah. And actually,

264
00:36:36,280 --> 00:36:47,420
 and this is correct. So if you write and read as a by granarity, then you need to this means

265
00:36:47,420 --> 00:36:55,760
 if you if you think about from the perspective, this is an API to the publication. And I want

266
00:36:55,760 --> 00:37:05,000
 to read and write a byte, this translates to a system call, a system call, translate

267
00:37:05,000 --> 00:37:16,400
 to a context switch. So the overhead, right, to read and write a byte is non trivial. Right?

268
00:37:16,400 --> 00:37:29,800
 You cannot sustain keep up with very fast IO devices. Okay. So that's the reason. So

269
00:37:29,800 --> 00:37:41,720
 byte is fine for keyboard, right? But it's not going to be fine for sending, you know,

270
00:37:41,720 --> 00:37:51,400
 data to a gigabit per second. Because the fixed cost of send operation or receiving

271
00:37:51,400 --> 00:38:01,000
 operation is too high. Okay. But they got it right from day one, because they have to

272
00:38:01,000 --> 00:38:09,840
 support the disk. Okay. And the disk couldn't do it efficiently at byte level. So they have

273
00:38:09,840 --> 00:38:28,640
 to have blocks. Okay, good. Access pattern, sequential versus random. You know, some devices

274
00:38:28,640 --> 00:38:40,400
 this must be accessed sequentially if you have a tape and others are randomly. Now,

275
00:38:40,400 --> 00:38:48,840
 also there are devices which are under this access pattern beyond it's like, are you going

276
00:38:48,840 --> 00:38:55,160
 and we are going to talk more about that? Do you need to monitor that IO device all

277
00:38:55,160 --> 00:38:59,280
 the time to see what happens or you are going to get interrupts when something happens?

278
00:38:59,280 --> 00:39:05,880
 Right? Like with a keyboard or a card. But now let me ask you again, it's like, for instance,

279
00:39:05,880 --> 00:39:11,320
 about sequential versus random. Why not have only one? Forget about tape for now. Right?

280
00:39:11,320 --> 00:39:15,040
 Remove tape, you know, because that with tape it's obvious, right? It's like, you know,

281
00:39:15,040 --> 00:39:24,000
 it's that, you know, it's, you have to access data on sequentially. But even without that,

282
00:39:24,000 --> 00:39:31,160
 tell me, why not have random? Right? Because if I have random access pattern, then it doesn't

283
00:39:31,160 --> 00:39:37,840
 make sense. I mean, I can emulate sequential, right? I start from one and then I say one,

284
00:39:37,840 --> 00:39:43,200
 now I want to get two, three, four, five, six by three, two, three, four, five, six,

285
00:39:43,200 --> 00:39:49,760
 right? After all, in memory, I have only random access. I don't have sequential access. So

286
00:39:49,760 --> 00:40:03,040
 why sequential access? Why not random? Yes, Michael. Yeah, it's good. We'll learn. Because

287
00:40:03,040 --> 00:40:11,360
 the random may involve some non-trivial overhead to locate that random piece of information.

288
00:40:11,360 --> 00:40:18,840
 That's why. Like we'll see with the disks. And therefore, if I'm going to store the bytes

289
00:40:18,840 --> 00:40:24,160
 and I can read or write them sequentially, it's going to be much, much faster. So you

290
00:40:24,160 --> 00:40:31,640
 see in both these cases, you can do, you can get away only have read/write as a level of

291
00:40:31,640 --> 00:40:39,320
 byte and only accessing randomly. But you are going to leave a lot of performance on

292
00:40:39,320 --> 00:40:45,940
 the table. So block and sequential, block randomization and sequential access pattern,

293
00:40:45,940 --> 00:40:55,700
 one of the main reasons they are used is for performance reasons. Okay.

294
00:40:55,730 --> 00:40:59,410
 Now the transfer mechanism, how is this?

295
00:40:59,410 --> 00:41:02,910
 Program I/O or DMA, Direct Memory Access.

296
00:41:02,910 --> 00:41:09,110
 Program I/O means the processor takes a byte from one device

297
00:41:09,110 --> 00:41:11,590
 and transfers to another device.

298
00:41:11,590 --> 00:41:18,710
 Like for instance, takes a block of data from the disk

299
00:41:18,710 --> 00:41:22,270
 and put it in memory.

300
00:41:22,270 --> 00:41:25,730
 It's doing in, out, and low stuff.

301
00:41:25,730 --> 00:41:26,250
 It's simple.

302
00:41:26,250 --> 00:41:32,930
 You can program everything through the computer.

303
00:41:32,930 --> 00:41:34,970
 The disadvantage is that you are going

304
00:41:34,970 --> 00:41:36,490
 to use a CPU for doing that.

305
00:41:36,490 --> 00:41:39,370
 You are going to consume these resources just moving

306
00:41:39,370 --> 00:41:42,690
 the data around, not doing useful work.

307
00:41:42,690 --> 00:41:46,390
 The second way is Direct Memory Access.

308
00:41:46,390 --> 00:41:48,490
 And now this is a smart one.

309
00:41:48,490 --> 00:41:55,670
 In this case, you say you are going to deal with two devices.

310
00:41:55,670 --> 00:41:58,070
 And basically, you are going to tell one controller

311
00:41:58,070 --> 00:42:02,830
 from one device, well, you have to transfer the data directly

312
00:42:02,830 --> 00:42:05,250
 to this other device.

313
00:42:05,250 --> 00:42:07,770
 This CPU is going to send instructions

314
00:42:07,770 --> 00:42:09,810
 how the transfer should happen.

315
00:42:09,810 --> 00:42:13,970
 But then the transfer happens between the devices

316
00:42:13,970 --> 00:42:17,310
 without the CPU being involved.

317
00:42:17,310 --> 00:42:20,170
 And here is an example.

318
00:42:20,170 --> 00:42:23,170
 And typically, this is one of the devices is typically

319
00:42:23,170 --> 00:42:25,230
 memory.

320
00:42:25,230 --> 00:42:27,450
 And here what happens?

321
00:42:27,450 --> 00:42:31,110
 So you have a PCI bus and you have a memory.

322
00:42:31,110 --> 00:42:33,210
 And here you have a disk.

323
00:42:33,210 --> 00:42:36,410
 And I want to transfer the data from the disk to the memory,

324
00:42:36,410 --> 00:42:40,350
 to read the data from the disk into memory.

325
00:42:40,350 --> 00:42:42,210
 These are the steps.

326
00:42:42,210 --> 00:42:44,310
 The CPU number one.

327
00:42:44,310 --> 00:42:47,330
 The CPU is going to--

328
00:42:47,330 --> 00:42:54,810
 the program starts to say, I want

329
00:42:54,810 --> 00:42:57,690
 to read the data from the disk.

330
00:42:57,690 --> 00:43:03,050
 Now, under the hood, the OS is going to handle that

331
00:43:03,050 --> 00:43:06,810
 and is going to send a message, control message,

332
00:43:06,810 --> 00:43:10,330
 to the IDA disk, the controller disk controller telling it,

333
00:43:10,330 --> 00:43:20,650
 OK, you need to get this data to this address in the memory.

334
00:43:20,650 --> 00:43:28,790
 Address X. Now, the controller is going to tell this, OK,

335
00:43:28,790 --> 00:43:30,790
 I need to--

336
00:43:30,790 --> 00:43:33,850
 I was instructed to move this data,

337
00:43:33,850 --> 00:43:39,850
 to transfer this data to memory, to this address X.

338
00:43:39,850 --> 00:43:42,130
 And now the DMA is doing the rest.

339
00:43:42,130 --> 00:43:45,850
 The DMA, not the CPU, is going to handle the transfer

340
00:43:45,850 --> 00:43:48,850
 from the disk controller to the memory.

341
00:43:48,850 --> 00:43:54,530
 So the DMA is going to read the data from the ID

342
00:43:54,530 --> 00:43:58,450
 and then drive the data on the CPU bus to the memory.

343
00:43:58,450 --> 00:44:06,610
 Once the transfer is completed, the DMA

344
00:44:06,610 --> 00:44:09,330
 is going to send an interrupt to the CPU telling,

345
00:44:09,330 --> 00:44:10,010
 I am ready.

346
00:44:10,010 --> 00:44:18,650
 Any questions?

347
00:44:18,650 --> 00:44:25,850
 Pretty cool, right?

348
00:44:25,850 --> 00:44:37,130
 So when do I/O devices are notifying the operating system?

349
00:44:37,130 --> 00:44:38,730
 Right?

350
00:44:38,730 --> 00:44:39,690
 Two reasons.

351
00:44:39,690 --> 00:44:45,290
 When it was-- well, the OS--

352
00:44:45,290 --> 00:44:47,010
 think about from the OS perspective,

353
00:44:47,010 --> 00:44:48,770
 what do you need to know?

354
00:44:48,770 --> 00:44:51,570
 On the other hand, you need to know if you are instructed,

355
00:44:51,570 --> 00:44:53,410
 you have instructed a controller,

356
00:44:53,410 --> 00:44:56,930
 I/O controller to perform some operation.

357
00:44:56,930 --> 00:45:04,090
 You want to know when that operation is completed.

358
00:45:04,090 --> 00:45:07,570
 The second is if there is an error.

359
00:45:07,570 --> 00:45:09,050
 Right?

360
00:45:09,050 --> 00:45:13,410
 OK.

361
00:45:13,410 --> 00:45:19,570
 So and like you mentioned, one way to handle that

362
00:45:19,570 --> 00:45:21,730
 is I/O interrupt.

363
00:45:21,730 --> 00:45:23,610
 Whenever there is one of these events

364
00:45:23,610 --> 00:45:29,410
 that OS needs to know about, the I/O controller

365
00:45:29,410 --> 00:45:32,610
 raises an interrupt.

366
00:45:32,610 --> 00:45:34,010
 OK.

367
00:45:34,010 --> 00:45:36,650
 Why this is good?

368
00:45:36,650 --> 00:45:38,610
 The CPU doesn't need to worry about.

369
00:45:38,610 --> 00:45:41,050
 I'm going-- the CPU is going to--

370
00:45:41,050 --> 00:45:49,130
 the device-- the I/O controller is going to let the CPU know

371
00:45:49,130 --> 00:45:53,850
 and something worse knowing happens.

372
00:45:53,850 --> 00:45:58,210
 But also, you can handle unpredictable events

373
00:45:58,210 --> 00:46:02,050
 like a new packet arriving on the network.

374
00:46:02,050 --> 00:46:06,090
 The disadvantage is that the interrupts are expensive.

375
00:46:06,090 --> 00:46:07,930
 It's a context switch.

376
00:46:07,930 --> 00:46:11,610
 You know, when the CPU--

377
00:46:11,610 --> 00:46:18,330
 when I raise an interrupt, maybe most likely a process,

378
00:46:18,330 --> 00:46:20,970
 a user process was executed.

379
00:46:20,970 --> 00:46:22,450
 So you need to do a context switch

380
00:46:22,450 --> 00:46:27,410
 to go through the operating system, handle the interrupt,

381
00:46:27,410 --> 00:46:29,250
 and then to go back in the user mode

382
00:46:29,250 --> 00:46:30,690
 to continue running the process.

383
00:46:34,090 --> 00:46:36,570
 The other one is polling.

384
00:46:36,570 --> 00:46:39,170
 So this is operating system periodically check

385
00:46:39,170 --> 00:46:43,890
 a device specific status to see whether it's ready.

386
00:46:43,890 --> 00:46:47,490
 Remember that I showed you in the I/O controller,

387
00:46:47,490 --> 00:46:51,450
 one of these registers was called status.

388
00:46:51,450 --> 00:46:53,850
 So for instance, it's going to be a printer.

389
00:46:53,850 --> 00:46:54,610
 I was always--

390
00:46:54,610 --> 00:46:57,330
 I want to know when the printer is done,

391
00:46:57,330 --> 00:46:59,130
 when the printing is done.

392
00:46:59,130 --> 00:47:03,010
 So I can tell the user, OK, the printer is done.

393
00:47:03,010 --> 00:47:04,650
 Whatever you send to the printer is done.

394
00:47:04,650 --> 00:47:14,090
 So in that case, the controller has this status register,

395
00:47:14,090 --> 00:47:17,010
 and it's going to be updated when

396
00:47:17,010 --> 00:47:21,010
 the printer is no longer busy when

397
00:47:21,010 --> 00:47:23,490
 the file finished being printed.

398
00:47:23,490 --> 00:47:27,290
 And then the OS is periodically going to check on that.

399
00:47:27,290 --> 00:47:30,250
 And when it's no longer busy, it's

400
00:47:30,250 --> 00:47:34,810
 going to turn to the application.

401
00:47:34,810 --> 00:47:39,770
 Now the pro here is low overhead because the OS

402
00:47:39,770 --> 00:47:46,210
 is going to check on this between contact switches.

403
00:47:46,210 --> 00:47:49,650
 It doesn't need to do a contact switch to just to check.

404
00:47:49,650 --> 00:47:53,370
 This one, the operating system gets--

405
00:47:53,370 --> 00:47:55,250
 the kernel gets control.

406
00:47:55,250 --> 00:47:58,370
 It's also going to check this.

407
00:47:58,370 --> 00:48:03,090
 Now the con is that you check and nothing happens,

408
00:48:03,090 --> 00:48:07,490
 then that's wasted time, CPU cycles.

409
00:48:07,490 --> 00:48:09,370
 OK?

410
00:48:09,370 --> 00:48:13,370
 So now, typically you combine those.

411
00:48:13,370 --> 00:48:15,130
 There is no right solution.

412
00:48:15,130 --> 00:48:16,730
 That's why you have to do both of them.

413
00:48:16,730 --> 00:48:20,490
 If you do only one solution, why would

414
00:48:20,490 --> 00:48:22,930
 have I told you about both?

415
00:48:22,930 --> 00:48:25,850
 But let me take a step back now and ask you,

416
00:48:25,850 --> 00:48:30,050
 when are you going to use IO interrupts?

417
00:48:30,050 --> 00:48:34,050
 And there is a little bit of an answer here.

418
00:48:34,050 --> 00:48:39,330
 But I just want you to give the answer in your own words.

419
00:48:39,330 --> 00:48:42,090
 When do you think you should use IO interrupts?

420
00:48:42,090 --> 00:48:43,730
 When do you think you should use polling?

421
00:48:43,730 --> 00:48:49,410
 Give me another-- this is one example

422
00:48:49,410 --> 00:48:50,570
 you have here on the slide.

423
00:48:50,570 --> 00:48:51,650
 Give me another example.

424
00:48:51,650 --> 00:49:06,130
 [AUDIO OUT]

425
00:49:06,130 --> 00:49:08,690
 Let me ask you, keyboard, right?

426
00:49:08,690 --> 00:49:11,570
 Are you going to use polling or interrupts?

427
00:49:11,570 --> 00:49:18,250
 Human IO for interrupts.

428
00:49:18,250 --> 00:49:20,170
 OK, that's good.

429
00:49:20,170 --> 00:49:21,530
 Why is that?

430
00:49:21,530 --> 00:49:23,570
 Why human IO for interrupts?

431
00:49:23,570 --> 00:49:30,850
 Rare and slow and--

432
00:49:30,850 --> 00:49:34,930
 you see here?

433
00:49:34,930 --> 00:49:35,490
 Oh, sorry.

434
00:49:35,490 --> 00:49:40,170
 Unpredictable, right?

435
00:49:40,170 --> 00:49:41,570
 It's unpredictable.

436
00:49:41,570 --> 00:49:43,450
 If it's something unpredictable, it

437
00:49:43,450 --> 00:49:46,610
 doesn't make sense to poll forever, right,

438
00:49:46,610 --> 00:49:50,330
 for something rare to happen.

439
00:49:50,330 --> 00:49:51,330
 Yes, Gilbert.

440
00:49:51,330 --> 00:49:53,290
 So your interrupt for frequent sinks,

441
00:49:53,290 --> 00:49:57,370
 polling for stuff we need to continuously check.

442
00:49:57,370 --> 00:50:00,690
 Yes, or if something happens--

443
00:50:00,690 --> 00:50:09,210
 yeah, this for polling, someone, you

444
00:50:09,210 --> 00:50:12,450
 say this for polling, sometimes actually you don't use.

445
00:50:12,450 --> 00:50:12,930
 We'll see.

446
00:50:12,930 --> 00:50:15,970
 But it's not necessary that you are going to poll the disk.

447
00:50:15,970 --> 00:50:20,610
 Yeah.

448
00:50:20,610 --> 00:50:21,370
.

449
00:50:21,370 --> 00:50:32,770
 So yeah, for the keyboard, eventually it's again,

450
00:50:32,770 --> 00:50:35,450
 you have to use the interrupt because this

451
00:50:35,450 --> 00:50:40,170
 is to tell the operating system when some keyboard is pressed.

452
00:50:40,170 --> 00:50:45,090
 Because if you watch a movie for two hours

453
00:50:45,090 --> 00:50:50,570
 or whatever on your computer, you don't type anything, right?

454
00:50:50,570 --> 00:50:53,850
 Or zoom, like right now.

455
00:50:53,850 --> 00:50:57,250
 You are listening to this lecture, right?

456
00:50:57,250 --> 00:50:59,490
 I hope that you are not doing a lot of many things other

457
00:50:59,490 --> 00:51:01,410
 than listening to the lecture.

458
00:51:01,410 --> 00:51:03,450
 But still, right, it's like if you are listening,

459
00:51:03,450 --> 00:51:04,610
 you don't touch it.

460
00:51:04,610 --> 00:51:05,770
 You don't have the keyboard.

461
00:51:05,770 --> 00:51:06,890
 So it's very rare event.

462
00:51:06,890 --> 00:51:08,410
 Doesn't make a lot of sense to poll.

463
00:51:08,410 --> 00:51:13,090
 One of the things, the reason you poll

464
00:51:13,090 --> 00:51:15,970
 is like in this example, when things

465
00:51:15,970 --> 00:51:21,170
 happens extremely frequent, right?

466
00:51:21,170 --> 00:51:23,130
 Once you get, for instance, a packet here,

467
00:51:23,130 --> 00:51:25,890
 you get so many other packets one after another.

468
00:51:25,890 --> 00:51:30,010
 You cannot afford to have a context switching per packet.

469
00:51:30,010 --> 00:51:33,730
 When the context switching is--

470
00:51:33,730 --> 00:51:35,930
 the overhead of context switching

471
00:51:35,930 --> 00:51:42,810
 is larger than the time between the events,

472
00:51:42,810 --> 00:51:45,210
 it probably doesn't-- it's not worth the context switching.

473
00:51:45,210 --> 00:51:49,610
 It's not worth the interrupts, right?

474
00:51:49,610 --> 00:51:53,530
 Let me put it in another way.

475
00:51:53,530 --> 00:51:56,490
 So say context switching gets one millisecond

476
00:51:56,490 --> 00:51:59,250
 and picking some random number, right?

477
00:51:59,250 --> 00:52:06,730
 And then say an event happens every 10 microseconds.

478
00:52:06,730 --> 00:52:12,090
 It makes no sense to do the interrupts for event, right?

479
00:52:12,090 --> 00:52:17,130
 You just poll to see for that.

480
00:52:17,130 --> 00:52:21,890
 OK, very good.

481
00:52:21,890 --> 00:52:32,370
 So this is a structure in the kernel for the device.

482
00:52:32,370 --> 00:52:36,050
 So you have the system call interface.

483
00:52:36,050 --> 00:52:37,370
 We'll talk more about them.

484
00:52:37,370 --> 00:52:41,130
 And you have some for memory--

485
00:52:41,130 --> 00:52:43,330
 this is what we learned for all.

486
00:52:43,330 --> 00:52:45,810
 We have process management, memory management,

487
00:52:45,810 --> 00:52:47,370
 file systems.

488
00:52:47,370 --> 00:52:49,370
 And then you have the device control.

489
00:52:49,370 --> 00:52:52,530
 This is for I/O devices and then networking.

490
00:52:52,530 --> 00:52:54,650
 Networking typically is different in apps.

491
00:52:54,650 --> 00:52:58,170
 So the API also for networking is slightly different.

492
00:52:58,170 --> 00:53:10,730
 OK, so the device control--

493
00:53:10,730 --> 00:53:13,650
 what is-- when we say--

494
00:53:13,650 --> 00:53:17,610
 so the device control--

495
00:53:17,610 --> 00:53:25,530
 the control for the device, this is typically implemented

496
00:53:25,530 --> 00:53:27,050
 on the device itself.

497
00:53:27,050 --> 00:53:31,370
 But this device now has to also interface with the operating

498
00:53:31,370 --> 00:53:32,170
 system.

499
00:53:32,170 --> 00:53:35,090
 The piece of software which--

500
00:53:35,090 --> 00:53:44,290
 the piece of software which bridges the operating system

501
00:53:44,290 --> 00:53:53,410
 API with the controller API is called device driver.

502
00:53:53,410 --> 00:53:56,610
 And it's a piece of code which runs in the operating

503
00:53:56,610 --> 00:53:57,770
 system, in the kernel.

504
00:53:57,770 --> 00:54:03,090
 And it is the piece of code.

505
00:54:03,090 --> 00:54:08,490
 It implements the Unix I/O API.

506
00:54:08,490 --> 00:54:09,970
 What is that API?

507
00:54:09,970 --> 00:54:15,810
 Well, this is the thing which survived so many decades.

508
00:54:15,810 --> 00:54:22,050
 Remember, open, close in order to communicate to a device.

509
00:54:22,050 --> 00:54:24,370
 You open, you close.

510
00:54:24,370 --> 00:54:26,610
 Then read and write.

511
00:54:26,610 --> 00:54:31,610
 And you can read as a program or you can read as a program.

512
00:54:31,610 --> 00:54:37,690
 And IO-CTL, IO control, this is a escape patch.

513
00:54:37,690 --> 00:54:40,250
 Because each device can have--

514
00:54:40,250 --> 00:54:43,330
 is a little bit different, requires a little bit

515
00:54:43,330 --> 00:54:46,850
 different configurations.

516
00:54:46,850 --> 00:54:51,090
 This is what is IO-CTL is.

517
00:54:51,090 --> 00:54:55,290
 It's more for device specific control.

518
00:54:59,570 --> 00:55:03,810
 Now, the device driver is two halves.

519
00:55:03,810 --> 00:55:08,490
 One, which basically is executed in the user mode,

520
00:55:08,490 --> 00:55:10,690
 and the other one which is executed in the kernel.

521
00:55:10,690 --> 00:55:16,930
 Sorry.

522
00:55:16,930 --> 00:55:18,050
 I'm sorry.

523
00:55:18,050 --> 00:55:22,490
 Both top and half--

524
00:55:22,490 --> 00:55:25,690
 bottom and half of the device drivers

525
00:55:25,690 --> 00:55:27,650
 are executed in the kernel.

526
00:55:27,650 --> 00:55:33,530
 The top one, it provides--

527
00:55:33,530 --> 00:55:40,890
 it helps to provide the kernel IO API, which

528
00:55:40,890 --> 00:55:46,170
 is used by the user program to interact with these devices.

529
00:55:46,170 --> 00:55:47,730
 So let's see what happens.

530
00:55:47,730 --> 00:55:49,730
 So let's say you have a user program

531
00:55:49,730 --> 00:55:54,370
 and request an IO operation, say, to write data to the disk.

532
00:55:54,370 --> 00:56:01,130
 First of all, is that--

533
00:56:01,130 --> 00:56:08,610
 is the request already satisfied or something like that?

534
00:56:08,610 --> 00:56:11,850
 It's like this happens when this happens.

535
00:56:11,850 --> 00:56:13,890
 This happens, for instance, if I am going

536
00:56:13,890 --> 00:56:17,490
 to read some data from the disk.

537
00:56:17,490 --> 00:56:19,970
 And when I read the data from the disk,

538
00:56:19,970 --> 00:56:23,850
 the granularity at which the data is transferred from the disk

539
00:56:23,850 --> 00:56:25,410
 is larger than what I read.

540
00:56:25,410 --> 00:56:27,290
 Say, I read only 10 bytes.

541
00:56:27,290 --> 00:56:29,490
 But when I'm going to transfer from the disk,

542
00:56:29,490 --> 00:56:32,370
 I'm going to transfer one page is four kilobytes.

543
00:56:32,370 --> 00:56:36,650
 So these four kilobytes is already stored in memory.

544
00:56:36,650 --> 00:56:41,090
 So now, I am just going to--

545
00:56:41,090 --> 00:56:43,290
 if I read those first 10 bytes, then I

546
00:56:43,290 --> 00:56:44,450
 can read the next 10 bytes.

547
00:56:44,450 --> 00:56:45,530
 They're already in memory.

548
00:56:45,530 --> 00:56:50,050
 So I don't need to do invoke to touch the device again.

549
00:56:50,050 --> 00:56:53,730
 But let's say now it's not satisfied.

550
00:56:53,730 --> 00:56:55,970
 So now, I'm going to send the request to the device.

551
00:56:55,970 --> 00:57:05,490
 And well, send the request to the device driver.

552
00:57:05,490 --> 00:57:07,490
 The device driver is looking at the request.

553
00:57:07,490 --> 00:57:14,690
 And from here on, this code, it's device specific.

554
00:57:14,690 --> 00:57:22,090
 I process the request.

555
00:57:22,090 --> 00:57:25,850
 And then you send it to the device hardware.

556
00:57:25,850 --> 00:57:27,730
 So this is the device driver.

557
00:57:27,730 --> 00:57:29,850
 This is on the hardware.

558
00:57:29,850 --> 00:57:33,730
 So this part, it's on the kernel.

559
00:57:33,730 --> 00:57:36,050
 In the kernel, this part at the bottom

560
00:57:36,050 --> 00:57:37,330
 can be in the device driver.

561
00:57:37,330 --> 00:57:44,170
 It can be in the device itself.

562
00:57:44,170 --> 00:57:47,170
 And the device, the controller, is

563
00:57:47,170 --> 00:57:49,050
 going to execute the operation.

564
00:57:49,050 --> 00:57:51,650
 Say, for instance, instruct the disk

565
00:57:51,650 --> 00:57:53,410
 where to read the data from.

566
00:57:53,410 --> 00:57:55,370
 Then read the data.

567
00:57:55,370 --> 00:57:58,010
 Once it reads the data, it buffers.

568
00:57:58,010 --> 00:58:00,170
 It sends an interrupt.

569
00:58:00,170 --> 00:58:01,370
 Sorry.

570
00:58:01,370 --> 00:58:03,890
 And the interrupt is sent to the kernel.

571
00:58:03,890 --> 00:58:06,890
 The kernel is going to handle this interrupt.

572
00:58:06,890 --> 00:58:09,690
 It's going to get the data from the device.

573
00:58:09,690 --> 00:58:18,730
 And then it's going to see whether the I/O is completed.

574
00:58:18,730 --> 00:58:21,930
 And if it's completed, it's going to let the application

575
00:58:21,930 --> 00:58:24,450
 know.

576
00:58:24,450 --> 00:58:24,930
 OK.

577
00:58:24,930 --> 00:58:29,570
 Sounds good.

578
00:58:29,570 --> 00:58:31,050
 OK.

579
00:58:31,050 --> 00:58:34,010
 So the goal of the I/O subsystem-- so I/O,

580
00:58:34,010 --> 00:58:39,170
 it's, again, to provide this interface uniform interface.

581
00:58:39,170 --> 00:58:43,010
 And so that uniform interface means--

582
00:58:43,010 --> 00:58:45,890
 so uniform API means that the code

583
00:58:45,890 --> 00:58:49,530
 you wrote for one particular device

584
00:58:49,530 --> 00:58:54,250
 should work potentially with very minimal changes

585
00:58:54,250 --> 00:58:56,970
 for other devices.

586
00:58:56,970 --> 00:59:05,210
 So for instance, for this code, this switch opens some code

587
00:59:05,210 --> 00:59:07,810
 and then prints some output.

588
00:59:07,810 --> 00:59:10,410
 It works on multiple devices.

589
00:59:10,410 --> 00:59:14,850
 It works on this terminal.

590
00:59:14,850 --> 00:59:18,290
 If FD is a terminal, the file descriptor is a terminal.

591
00:59:18,290 --> 00:59:22,810
 It works for the disk if file descriptor is a file.

592
00:59:22,810 --> 00:59:27,170
 And it can also work on the printer.

593
00:59:27,170 --> 00:59:29,690
 The same code.

594
00:59:29,690 --> 00:59:30,170
 OK.

595
00:59:38,330 --> 00:59:45,050
 So now let's talk a little bit more about this interface

596
00:59:45,050 --> 00:59:49,690
 and why the interface, again, has been

597
00:59:49,690 --> 00:59:53,330
 so powerful and so general.

598
00:59:53,330 --> 00:59:56,730
 Like I mentioned to you, you have block devices.

599
00:59:56,730 --> 00:59:58,690
 You have block devices.

600
00:59:58,690 --> 01:00:02,730
 And for these block devices, you write the data,

601
01:00:02,730 --> 01:00:03,890
 the block reality.

602
01:00:03,890 --> 01:00:09,090
 And you have an open read, write, and seek, right?

603
01:00:09,090 --> 01:00:11,970
 Then you can have character devices.

604
01:00:11,970 --> 01:00:14,490
 And this is the level you read and write the data

605
01:00:14,490 --> 01:00:18,130
 at the level of a single character.

606
01:00:18,130 --> 01:00:20,770
 And for this, you have also open read.

607
01:00:20,770 --> 01:00:23,650
 But you have also for getting a single character,

608
01:00:23,650 --> 01:00:27,250
 you get a get input API.

609
01:00:27,250 --> 01:00:29,930
 And then for network devices, this

610
01:00:29,930 --> 01:00:33,490
 is different enough that you have a different API,

611
01:00:33,490 --> 01:00:35,130
 slightly different API.

612
01:00:35,130 --> 01:00:37,490
 You still have open and close, but you

613
01:00:37,490 --> 01:00:39,370
 have the concept of sockets.

614
01:00:39,370 --> 01:00:42,610
 And you still have reads and writes, read, write,

615
01:00:42,610 --> 01:00:44,090
 and open and close.

616
01:00:44,090 --> 01:00:45,570
 All of them are still--

617
01:00:45,570 --> 01:00:47,130
 you still have those.

618
01:00:47,130 --> 01:00:52,770
 But in addition, you have other richer API.

619
01:00:52,770 --> 01:00:56,730
 If you remember, you have connect, you have accept.

620
01:00:56,730 --> 01:00:59,370
 You have also something else, which is select.

621
01:00:59,370 --> 01:01:02,730
 Select is when you are going to listen on connection

622
01:01:02,730 --> 01:01:03,970
 from multiple computers.

623
01:01:03,970 --> 01:01:06,010
 You are going to learn more about that.

624
01:01:06,010 --> 01:01:12,170
 But these are the three standard interfaces provided

625
01:01:12,170 --> 01:01:14,930
 by the operating system.

626
01:01:14,930 --> 01:01:22,410
 And each of the devices falls in one of these categories.

627
01:01:22,410 --> 01:01:24,250
 Block device.

628
01:01:24,250 --> 01:01:25,990
 a character device or a network device.

629
01:01:25,990 --> 01:01:30,690
 Next,

630
01:01:30,690 --> 01:01:37,590
 how you are going with respect to timing,

631
01:01:37,590 --> 01:01:40,310
 how do you interact with the devices?

632
01:01:40,310 --> 01:01:43,650
 Well, there are a few ways to interact.

633
01:01:43,650 --> 01:01:45,850
 One is a blocking interface.

634
01:01:45,850 --> 01:01:47,050
 The blocking interface,

635
01:01:47,050 --> 01:01:50,050
 when you are going to perform an operation,

636
01:01:50,050 --> 01:01:52,670
 you are going to wait for that operation to finish.

637
01:01:53,590 --> 01:01:54,430
 Right?

638
01:01:54,430 --> 01:01:56,650
 When you request, say for instance,

639
01:01:56,650 --> 01:01:58,030
 when you read some data,

640
01:01:58,030 --> 01:02:01,650
 you are blocking until the data you requested is available.

641
01:02:01,650 --> 01:02:05,690
 Then it's non-blocking interface.

642
01:02:05,690 --> 01:02:10,690
 You don't, you know, you just write some data

643
01:02:10,690 --> 01:02:16,390
 and the call returns immediately before the data is written.

644
01:02:16,390 --> 01:02:18,750
 Okay?

645
01:02:18,750 --> 01:02:19,590
 Now,

646
01:02:21,030 --> 01:02:25,070
 so this is obviously you don't know the result,

647
01:02:25,070 --> 01:02:26,070
 but then you don't block.

648
01:02:26,070 --> 01:02:27,070
 So you are very efficient.

649
01:02:27,070 --> 01:02:28,590
 You don't write cycles on the CPU.

650
01:02:28,590 --> 01:02:31,230
 And then it's a synchronous interface.

651
01:02:31,230 --> 01:02:36,190
 And then this basically says,

652
01:02:36,190 --> 01:02:39,450
 I am going to request the data.

653
01:02:39,450 --> 01:02:40,510
 And by the way,

654
01:02:40,510 --> 01:02:41,630
 here what you need to do,

655
01:02:41,630 --> 01:02:43,730
 and let me know when you are done.

656
01:02:43,730 --> 01:02:47,270
 So I wanted to read the data and you need,

657
01:02:47,270 --> 01:02:49,850
 so read the data from this device.

658
01:02:49,850 --> 01:02:52,490
 And I'm telling you that you need to put the data

659
01:02:52,490 --> 01:02:54,010
 after this address in memory.

660
01:02:54,010 --> 01:02:55,850
 Okay?

661
01:02:55,850 --> 01:02:58,410
 And you put that in the address in memory and tell me,

662
01:02:58,410 --> 01:03:01,170
 you tell me when you are done with it.

663
01:03:01,170 --> 01:03:04,830
 This is a synchronous interface.

664
01:03:04,830 --> 01:03:05,670
 Okay?

665
01:03:05,670 --> 01:03:09,730
 So some announcements,

666
01:03:09,730 --> 01:03:10,890
 unfortunately, you know,

667
01:03:10,890 --> 01:03:14,410
 next week will be quite a week for you.

668
01:03:14,410 --> 01:03:18,090
 So the good thing is that after the next,

669
01:03:18,090 --> 01:03:19,790
 the following week, after the next week,

670
01:03:19,790 --> 01:03:21,370
 it's going to be easier.

671
01:03:21,370 --> 01:03:23,410
 And the Thanksgiving is coming soon.

672
01:03:23,410 --> 01:03:28,250
 But yeah, next week will be hard.

673
01:03:28,250 --> 01:03:31,830
 You have a homework for midterm too.

674
01:03:31,830 --> 01:03:32,910
 The review will be,

675
01:03:32,910 --> 01:03:34,710
 how all will be on Monday.

676
01:03:34,710 --> 01:03:37,010
 The time we are going to let you know the time.

677
01:03:37,010 --> 01:03:40,550
 The midterm will be on Wednesday

678
01:03:40,550 --> 01:03:44,570
 between seven, nine p.m. Pacific time.

679
01:03:44,570 --> 01:03:46,710
 As a project is due on,

680
01:03:48,190 --> 01:03:51,210
 at the end of the next week and tomorrow,

681
01:03:51,210 --> 01:03:54,890
 unfortunately yesterday, I had, like I mentioned,

682
01:03:54,890 --> 01:03:59,890
 a flight which was canceled and then rescheduled.

683
01:03:59,890 --> 01:04:03,970
 Between 11, 13 and 12, 13, I'll have my office hour.

684
01:04:03,970 --> 01:04:11,050
 Okay, let's move a little bit.

685
01:04:11,050 --> 01:04:14,170
 We have another 15 minutes.

686
01:04:14,170 --> 01:04:16,810
 So let's move quick now.

687
01:04:17,890 --> 01:04:19,210
 Storage devices.

688
01:04:19,210 --> 01:04:25,170
 So storage devices are where we store the data

689
01:04:25,170 --> 01:04:28,690
 and persistently, right?

690
01:04:28,690 --> 01:04:32,850
 They typically have much larger capacities than memory,

691
01:04:32,850 --> 01:04:35,710
 but they are slower, right?

692
01:04:35,710 --> 01:04:39,610
 And we have magnetic disk and flash memories, right?

693
01:04:39,610 --> 01:04:41,450
 There are two types.

694
01:04:41,450 --> 01:04:45,370
 Magnetic disks are, you know,

695
01:04:45,370 --> 01:04:49,490
 these are traditional ones, flash memories are newer,

696
01:04:49,490 --> 01:04:51,210
 but now are dominant.

697
01:04:51,210 --> 01:04:52,850
 They are more expensive.

698
01:04:52,850 --> 01:04:55,190
 They have provide better performance.

699
01:04:55,190 --> 01:04:58,990
 That's kind of the way to look at them.

700
01:04:58,990 --> 01:05:01,370
 These are some examples.

701
01:05:01,370 --> 01:05:05,170
 This is the disk drive, right?

702
01:05:05,170 --> 01:05:06,410
 You see here a platter.

703
01:05:06,410 --> 01:05:07,610
 You have here the heads.

704
01:05:07,610 --> 01:05:09,430
 We read and write the data.

705
01:05:09,430 --> 01:05:11,330
 And then you are going to have,

706
01:05:11,330 --> 01:05:13,290
 here is another hard drive.

707
01:05:13,290 --> 01:05:14,210
 This is the heads.

708
01:05:14,210 --> 01:05:17,130
 You have multiple platters on each drive the data,

709
01:05:17,130 --> 01:05:19,730
 and therefore you have heads on each platter,

710
01:05:19,730 --> 01:05:21,430
 for each platter.

711
01:05:21,430 --> 01:05:25,710
 And here it's a micro drive, this is this, right?

712
01:05:25,710 --> 01:05:27,730
 Now, just to give you a sense,

713
01:05:27,730 --> 01:05:32,390
 the first IBM personal computer, which was released in 1986.

714
01:05:32,390 --> 01:05:36,530
 So that was 35 years ago, right?

715
01:05:36,530 --> 01:05:42,130
 It has, the hard disk was $500.

716
01:05:42,130 --> 01:05:46,490
 It was 30 megabytes, not gigabytes, megabytes.

717
01:05:46,490 --> 01:05:50,270
 The seek time is how long it takes a random access.

718
01:05:50,270 --> 01:05:52,810
 It's those 30 to locate, you know,

719
01:05:52,810 --> 01:05:56,570
 to write the data randomly, or read the data randomly,

720
01:05:56,570 --> 01:05:59,150
 or between 30 and 40 milliseconds.

721
01:05:59,150 --> 01:06:02,870
 And the speed, the maximum speed of transferring the data,

722
01:06:02,870 --> 01:06:05,830
 what was one megabyte per second, okay?

723
01:06:05,830 --> 01:06:11,090
 So how it looks like, this is how hard drive it looks like.

724
01:06:11,090 --> 01:06:15,170
 You have the platters, the platter has two surfaces,

725
01:06:15,170 --> 01:06:18,910
 the up and down surface.

726
01:06:18,910 --> 01:06:20,970
 So you can write on both of them.

727
01:06:20,970 --> 01:06:23,690
 On each of them, you are going to have tracks,

728
01:06:23,690 --> 01:06:26,890
 and the tracks are divided in sectors.

729
01:06:26,890 --> 01:06:29,410
 So the sectors stores a block.

730
01:06:29,410 --> 01:06:34,210
 And this is a unit of storing, reading,

731
01:06:34,210 --> 01:06:36,650
 and writing data from the disk.

732
01:06:36,650 --> 01:06:41,170
 And that is written, reads and writes

733
01:06:41,170 --> 01:06:44,370
 are performed by the header, okay?

734
01:06:44,370 --> 01:06:48,330
 So let's now show this one by one.

735
01:06:48,330 --> 01:06:50,310
 This is a sector, okay?

736
01:06:50,310 --> 01:06:53,910
 So you have this ring of sectors.

737
01:06:53,910 --> 01:06:54,970
 This is a stack.

738
01:06:54,970 --> 01:07:00,610
 And then the corresponding tracks

739
01:07:00,610 --> 01:07:05,610
 on all platters represent a cylinder.

740
01:07:05,610 --> 01:07:10,370
 What is important about cylinder?

741
01:07:10,370 --> 01:07:15,370
 Is that the data from a cylinder can be written

742
01:07:15,370 --> 01:07:18,730
 and read without moving the heads.

743
01:07:18,730 --> 01:07:32,750
 Because the movement of heads,

744
01:07:32,750 --> 01:07:37,690
 which is called SICK operation, is expensive, right?

745
01:07:37,690 --> 01:07:42,490
 Okay.

746
01:07:42,490 --> 01:07:48,410
 So some numbers, the disk track,

747
01:07:48,410 --> 01:07:53,730
 the tracks are around one micron wide.

748
01:07:53,730 --> 01:07:55,810
 And this is very small.

749
01:07:55,810 --> 01:07:59,810
 The wavelength of light, it's only half a micron.

750
01:07:59,810 --> 01:08:04,810
 The resolution of human eyes is 50 microns.

751
01:08:04,810 --> 01:08:12,790
 So you have typically 100,000 tracks on a 2.5 inch disk.

752
01:08:12,790 --> 01:08:16,710
 And you have these tracks in general,

753
01:08:16,710 --> 01:08:19,550
 separated by some guard regions,

754
01:08:19,550 --> 01:08:22,190
 because you don't want right on a track

755
01:08:22,190 --> 01:08:25,030
 to influence the bits on the others

756
01:08:25,030 --> 01:08:28,670
 and corrupt, therefore, the bits on the nearby tracks.

757
01:08:28,670 --> 01:08:33,670
 Now, the tracks length varies, right?

758
01:08:33,670 --> 01:08:39,530
 The one which are closer to the edges

759
01:08:39,530 --> 01:08:44,530
 are larger than the one at the center.

760
01:08:44,530 --> 01:08:51,270
 And so typically, we are only using half of the radius,

761
01:08:51,270 --> 01:08:56,930
 only the tracks at the edges of that,

762
01:08:56,930 --> 01:09:00,290
 because you have more space to store information.

763
01:09:00,290 --> 01:09:05,790
 If you store it too close to the center,

764
01:09:05,790 --> 01:09:07,590
 the sector is too small.

765
01:09:07,590 --> 01:09:11,830
 You are going to get a lot of errors.

766
01:09:11,830 --> 01:09:20,390
 And this card, obviously huge right now,

767
01:09:20,390 --> 01:09:24,270
 there are terabytes in terms of capacity.

768
01:09:24,270 --> 01:09:28,510
 So in general, only a small part of this data,

769
01:09:28,510 --> 01:09:30,750
 which is stored on the disk is active, redrived.

770
01:09:30,750 --> 01:09:34,110
 The rest is used for being archived.

771
01:09:34,110 --> 01:09:35,190
 And this is important.

772
01:09:35,190 --> 01:09:38,070
 Before, in the early days, you archive the data

773
01:09:38,070 --> 01:09:40,430
 not on the disk, because it is quite expensive.

774
01:09:40,430 --> 01:09:42,650
 You archive the data on magnetic tapes.

775
01:09:42,650 --> 01:09:49,530
 One note, this is more like a footnote.

776
01:09:49,530 --> 01:09:50,890
 There is something which is called

777
01:09:50,890 --> 01:09:54,150
 single magnetic recording.

778
01:09:54,150 --> 01:09:57,090
 And in this case, instead of having a guard

779
01:09:57,090 --> 01:09:59,190
 between the tracks, you remember that I told you

780
01:09:59,190 --> 01:10:01,830
 that between tracks, you have the guards.

781
01:10:01,830 --> 01:10:06,090
 So you avoid writing, when you write on a track a bit

782
01:10:06,090 --> 01:10:11,090
 to influence the nearby tracks, right?

783
01:10:11,090 --> 01:10:18,030
 But in order in the race to add more and more bits,

784
01:10:18,030 --> 01:10:20,610
 to increase the capacity of the disks,

785
01:10:20,610 --> 01:10:23,750
 people came up with this technique,

786
01:10:23,750 --> 01:10:25,830
 which actually in some sense,

787
01:10:25,830 --> 01:10:28,630
 the tracks kind of almost overlap.

788
01:10:28,630 --> 01:10:31,730
 And obviously now you need to be very careful

789
01:10:31,730 --> 01:10:34,390
 and need to have much more complex,

790
01:10:34,390 --> 01:10:36,910
 digital signal processing techniques

791
01:10:36,910 --> 01:10:41,910
 in order to make sure that you avoid a bit being corrupted

792
01:10:41,910 --> 01:10:45,110
 by writing a bit in a nearby track.

793
01:10:45,110 --> 01:10:51,190
 So, magnetic disk,

794
01:10:52,470 --> 01:10:57,270
 it's again, you have the heads, cylinders, sectors,

795
01:10:57,270 --> 01:11:00,750
 and tracks, and now let's see what is the time

796
01:11:00,750 --> 01:11:06,590
 to read or write data, okay?

797
01:11:06,590 --> 01:11:09,190
 So first of all, this is how

798
01:11:09,190 --> 01:11:14,070
 the architecture looks like.

799
01:11:14,070 --> 01:11:19,730
 So the disk actually has a controller, right?

800
01:11:19,730 --> 01:11:22,430
 Like we mentioned many times before.

801
01:11:22,430 --> 01:11:25,750
 And you are going to get a request, right?

802
01:11:25,750 --> 01:11:29,870
 The controller gets a request, right?

803
01:11:29,870 --> 01:11:34,590
 And let me just show you where this request is coming from.

804
01:11:34,590 --> 01:11:36,990
 It's here.

805
01:11:36,990 --> 01:11:40,370
 You see the request, this is the request.

806
01:11:40,370 --> 01:11:44,370
 Okay?

807
01:11:44,370 --> 01:11:50,270
 And here we are talking about this device hardware.

808
01:11:50,270 --> 01:11:52,430
 (silence)

809
01:11:52,430 --> 01:12:01,990
 Okay.

810
01:12:01,990 --> 01:12:08,550
 So you get the request, and then you have a queue

811
01:12:08,550 --> 01:12:11,590
 because multiple application can request data

812
01:12:11,590 --> 01:12:14,330
 to read and write data from the same time.

813
01:12:14,330 --> 01:12:17,430
 So you need to queue this request, right?

814
01:12:18,690 --> 01:12:21,970
 And then you have the hardware controller,

815
01:12:21,970 --> 01:12:24,810
 which is going to take requests from this queue,

816
01:12:24,810 --> 01:12:28,650
 and that's going to satisfy the request.

817
01:12:28,650 --> 01:12:33,050
 Now, a request, when you satisfy the request, what happens?

818
01:12:33,050 --> 01:12:37,610
 You need to figure out and assume that you already know

819
01:12:37,610 --> 01:12:40,050
 where the data you need to read and to,

820
01:12:40,050 --> 01:12:42,290
 where the data is located, right?

821
01:12:42,290 --> 01:12:45,710
 And in order to, once you do that, you need to move that,

822
01:12:45,710 --> 01:12:47,610
 you need to, so you need to identify

823
01:12:47,610 --> 01:12:49,050
 what you need to identify.

824
01:12:49,050 --> 01:12:50,850
 You need to identify a sector.

825
01:12:50,850 --> 01:12:53,570
 A sector means to identify the track, right?

826
01:12:53,570 --> 01:12:56,230
 In order to get to a track, you need to move the disk,

827
01:12:56,230 --> 01:12:57,850
 to move the heads.

828
01:12:57,850 --> 01:13:02,630
 The overhead to move the disk is called seek time.

829
01:13:02,630 --> 01:13:07,490
 Then once you are above the corresponding track,

830
01:13:07,490 --> 01:13:11,290
 you need to wait for the proper sector

831
01:13:11,290 --> 01:13:16,590
 to come under the head so you can read and write.

832
01:13:16,590 --> 01:13:18,210
 This is the rotation time.

833
01:13:18,210 --> 01:13:19,930
 And finally, the transfer time,

834
01:13:19,930 --> 01:13:22,770
 the time to read and write the information from the sector.

835
01:13:22,770 --> 01:13:30,410
 Here are some numbers from some other magnetic disks.

836
01:13:30,410 --> 01:13:33,970
 It's a space like 14 terabytes.

837
01:13:33,970 --> 01:13:37,730
 It's pretty eight platters.

838
01:13:37,730 --> 01:13:40,950
 Typically the seek time is four to six milliseconds.

839
01:13:40,950 --> 01:13:45,210
 This rotation, like rotation speed,

840
01:13:45,210 --> 01:13:49,650
 the rotation per minute is like between 3,600 and 7,200.

841
01:13:49,650 --> 01:13:52,950
 There are also some of the new, you know,

842
01:13:52,950 --> 01:13:56,470
 faster disk at even 1,500 rotation per minute.

843
01:13:56,470 --> 01:13:59,670
 Average latency of,

844
01:13:59,670 --> 01:14:04,010
 rotation latency is between four and eight milliseconds.

845
01:14:04,010 --> 01:14:04,850
 Right?

846
01:14:04,850 --> 01:14:05,670
 This is, you know,

847
01:14:05,670 --> 01:14:08,630
 if it takes eight milliseconds for a full rotation,

848
01:14:08,630 --> 01:14:11,430
 then on average, you need to wait for four milliseconds

849
01:14:11,430 --> 01:14:15,430
 rotation latency in order for the sector

850
01:14:15,430 --> 01:14:17,430
 you are looking for to come under the disk,

851
01:14:17,430 --> 01:14:18,730
 under the head.

852
01:14:18,730 --> 01:14:26,170
 And transfer time between 50 and 250 megabytes per second.

853
01:14:26,170 --> 01:14:30,070
 The transfer sector is typically between

854
01:14:30,070 --> 01:14:34,530
 512 and one kilobyte and things like that.

855
01:14:34,530 --> 01:14:35,370
 Right?

856
01:14:35,370 --> 01:14:38,350
 They used to drop,

857
01:14:38,350 --> 01:14:41,390
 the cost used to drop by a factor of two every 1.5 years.

858
01:14:41,390 --> 01:14:42,650
 It's no longer true.

859
01:14:42,650 --> 01:14:47,850
 So now let's go through this example.

860
01:14:47,850 --> 01:14:54,510
 So assuming that we ignore the queuing

861
01:14:54,510 --> 01:14:56,050
 and the controller times.

862
01:14:56,050 --> 01:14:57,970
 Okay?

863
01:14:57,970 --> 01:15:02,150
 So we ignore this queuing time and the controller time.

864
01:15:02,150 --> 01:15:04,050
 Let's look only on the media time.

865
01:15:04,050 --> 01:15:09,090
 Assume the average seek time is five milliseconds.

866
01:15:10,970 --> 01:15:15,170
 Assume that the rotation, you know,

867
01:15:15,170 --> 01:15:19,230
 speed it's 7,200 rotation per minute.

868
01:15:19,230 --> 01:15:22,350
 So this means that it takes eight milliseconds

869
01:15:22,350 --> 01:15:24,330
 for a full rotation.

870
01:15:24,330 --> 01:15:29,450
 And the transfer rate assume is 50 megabytes.

871
01:15:29,450 --> 01:15:32,330
 Oh, so then the, sorry.

872
01:15:32,330 --> 01:15:37,330
 This is the transfer rate of 15 megabytes per second.

873
01:15:38,310 --> 01:15:41,030
 If it's a block size of four kilobytes, right?

874
01:15:41,030 --> 01:15:44,230
 So assuming the transfer rate is 50 megabytes per second.

875
01:15:44,230 --> 01:15:46,810
 If the block size is four kilobytes,

876
01:15:46,810 --> 01:15:51,810
 then it takes 0.8 milliseconds to transfer one sector.

877
01:15:51,810 --> 01:15:55,050
 Right?

878
01:15:55,050 --> 01:15:58,710
 You divide four kilobytes, the size of a sector,

879
01:15:58,710 --> 01:16:00,150
 on the transfer rate, right?

880
01:16:00,150 --> 01:16:00,990
 To get that by.

881
01:16:00,990 --> 01:16:07,250
 So then reading the block from a random place on the disk,

882
01:16:08,230 --> 01:16:11,430
 you need to seek first to the track.

883
01:16:11,430 --> 01:16:15,610
 You need to wait for the sector and then you read it.

884
01:16:15,610 --> 01:16:17,330
 So it takes nine milliseconds,

885
01:16:17,330 --> 01:16:19,070
 a little bit more than nine milliseconds.

886
01:16:19,070 --> 01:16:24,070
 Is equivalent to 450 kilobytes per second speed,

887
01:16:24,070 --> 01:16:26,970
 you know, transfer speed.

888
01:16:26,970 --> 01:16:30,470
 If you read the block from a random place

889
01:16:30,470 --> 01:16:34,110
 in the same cylinder, then if you do that,

890
01:16:34,110 --> 01:16:38,090
 you don't need to incur the seek time.

891
01:16:38,690 --> 01:16:43,690
 So now the latency is only 4.08 milliseconds,

892
01:16:43,690 --> 01:16:48,890
 which means that the data now rate

893
01:16:48,890 --> 01:16:53,710
 is one megabyte per second.

894
01:16:53,710 --> 01:16:56,910
 But now assume that you just need the same,

895
01:16:56,910 --> 01:16:58,530
 next sector on the track.

896
01:16:58,530 --> 01:17:00,810
 You sequentially read.

897
01:17:00,810 --> 01:17:05,810
 Then you don't need to incur the rotation delay either.

898
01:17:06,430 --> 01:17:08,790
 So it's 50 megabytes per second.

899
01:17:08,790 --> 01:17:12,250
 So it's 50 times bigger or 100 times bigger

900
01:17:12,250 --> 01:17:14,250
 if it's purely random.

901
01:17:14,250 --> 01:17:16,730
 So now you see why you have seek.

902
01:17:16,730 --> 01:17:18,870
 Also you have sequential access

903
01:17:18,870 --> 01:17:22,590
 and versus only random access, right?

904
01:17:22,590 --> 01:17:25,090
 If you can sequentially access the data,

905
01:17:25,090 --> 01:17:28,690
 it's so much faster, at least for the disk.

906
01:17:28,690 --> 01:17:31,530
 So the key to use a disk effectively

907
01:17:31,530 --> 01:17:35,130
 is to make sure that you, as much as possible,

908
01:17:35,130 --> 01:17:39,030
 you access the data sequentially, okay?

909
01:17:39,030 --> 01:17:44,110
 So now there is a lot of intelligence

910
01:17:44,110 --> 01:17:47,470
 in this embedded into this controller.

911
01:17:47,470 --> 01:17:52,510
 So the sectors, for instance,

912
01:17:52,510 --> 01:17:55,510
 you have sophisticated error correcting codes, right?

913
01:17:55,510 --> 01:18:00,770
 Because, you know, to avoid data corruption.

914
01:18:00,770 --> 01:18:01,970
 And this is very important

915
01:18:01,970 --> 01:18:05,290
 because if you store the data on a disk

916
01:18:05,290 --> 01:18:08,650
 and you trust that disk because it's stored persistently.

917
01:18:08,650 --> 01:18:12,370
 So if the data is corrupted, you know, you lost the data.

918
01:18:12,370 --> 01:18:14,650
 Sector sparing.

919
01:18:14,650 --> 01:18:16,410
 So it's again, it's like,

920
01:18:16,410 --> 01:18:20,730
 sometimes some sectors becomes bad.

921
01:18:20,730 --> 01:18:23,830
 You can no longer read and write data reliably from them.

922
01:18:23,830 --> 01:18:25,630
 So in that case, you remap them.

923
01:18:25,630 --> 01:18:27,770
 You forget about those and you remap that

924
01:18:27,770 --> 01:18:30,770
 to transfer it to another spare sector on the disk.

925
01:18:30,770 --> 01:18:32,310
 And this is done by the controller

926
01:18:32,310 --> 01:18:33,910
 transparently with the software.

927
01:18:33,910 --> 01:18:36,730
 Sleep sparing.

928
01:18:36,730 --> 01:18:39,530
 Now, if there is a bunch,

929
01:18:39,530 --> 01:18:43,710
 if the sector goes bad,

930
01:18:43,710 --> 01:18:46,930
 now the problem is that, you know,

931
01:18:46,930 --> 01:18:48,810
 now you no longer have sequential access.

932
01:18:48,810 --> 01:18:50,850
 If you want to preserve sequential access,

933
01:18:50,850 --> 01:18:52,930
 you may want to remap multiple sectors

934
01:18:52,930 --> 01:18:54,770
 to preserve the sequentiality.

935
01:18:54,770 --> 01:18:56,290
 And the last is track skewing.

936
01:18:56,290 --> 01:18:59,410
 And here I have a figure for you as a mean track skewing.

937
01:18:59,410 --> 01:19:01,290
 So this means that if I want,

938
01:19:01,290 --> 01:19:06,290
 if the data is stored sequentially on nearby tracks,

939
01:19:06,290 --> 01:19:09,450
 then I want to make sure that when I move

940
01:19:09,450 --> 01:19:12,410
 from one track to another, I don't waste time.

941
01:19:12,410 --> 01:19:16,050
 So here, you know, these are the sectors on track one.

942
01:19:16,050 --> 01:19:19,350
 So say I'm going to read on track one here, the head,

943
01:19:19,350 --> 01:19:21,650
 you know, I'm just finishing reading everything

944
01:19:21,650 --> 01:19:24,810
 on the track one and I want to move to track two.

945
01:19:24,810 --> 01:19:26,790
 The track two is the one inside.

946
01:19:26,790 --> 01:19:28,090
 Now, when I want to move,

947
01:19:28,090 --> 01:19:32,610
 then the first sector on track one, I'm going to shift.

948
01:19:32,610 --> 01:19:36,530
 So then this time,

949
01:19:36,530 --> 01:19:41,530
 when I'm going to move the head to track one,

950
01:19:41,530 --> 01:19:45,170
 by the time I moved, now sector zero comes,

951
01:19:45,170 --> 01:19:46,610
 is ready to be read.

952
01:19:46,610 --> 01:19:50,810
 If I don't do this, then while I move this head

953
01:19:50,810 --> 01:19:53,450
 from one sector, from one track to another,

954
01:19:53,450 --> 01:19:55,450
 I miss a sector zero and I need to wait

955
01:19:55,450 --> 01:19:57,490
 for an entire evolution of the disk

956
01:19:57,490 --> 01:20:00,610
 before I start reading it, right?

957
01:20:00,610 --> 01:20:05,170
 So, and I'm going to end up with this slide.

958
01:20:05,170 --> 01:20:09,410
 So this is an example of current hard disk drive.

959
01:20:09,410 --> 01:20:14,410
 It's like 20, 20, 18 terabytes is a hard drive,

960
01:20:14,410 --> 01:20:17,050
 nine platters, 18 hertz.

961
01:20:17,050 --> 01:20:19,410
 Each platter has two sides.

962
01:20:19,410 --> 01:20:22,130
 So one head for each side.

963
01:20:22,130 --> 01:20:24,350
 Four milliseconds, every six time.

964
01:20:25,690 --> 01:20:30,690
 A sector is four kilobytes, 7,200 RPM and so forth.

965
01:20:30,690 --> 01:20:36,130
 And 270 megabytes per second maximum transfer rate

966
01:20:36,130 --> 01:20:37,850
 costs 562.

967
01:20:37,850 --> 01:20:40,890
 Now let's compare with IBM personal computer drive,

968
01:20:40,890 --> 01:20:42,090
 the first drive.

969
01:20:42,090 --> 01:20:44,330
 This was 86, okay?

970
01:20:44,330 --> 01:20:48,990
 So the seek time is 10 times better, okay?

971
01:20:48,990 --> 01:20:54,850
 The transfer time is 300 times better.

972
01:20:55,850 --> 01:21:00,850
 But the capacity is 600,000 times better.

973
01:21:00,850 --> 01:21:05,570
 And the cost, it's almost the same, 600,000 times better.

974
01:21:05,570 --> 01:21:10,570
 So this is a progress we were able to get in 36 years.

975
01:21:10,570 --> 01:21:12,850
 Okay, so it's quite impressive.

976
01:21:12,850 --> 01:21:14,770
 Okay, so we are going to stop here

977
01:21:14,770 --> 01:21:17,350
 and next time we are going to start talking

978
01:21:17,350 --> 01:21:21,010
 with about solid SSDs.

979
01:21:24,050 --> 01:21:25,710
 Thanks everyone, okay.

980
01:21:25,710 --> 01:21:32,570
 Okay, I'm going to stop here

981
01:21:32,570 --> 01:21:34,570
 and I'm going to answer the questions.

982
01:21:34,570 --> 01:21:36,730
 (silence)

983
01:21:36,730 --> 01:21:38,890
 (silence)

984
01:21:38,890 --> 01:21:41,050
 (silence)

985
01:21:41,050 --> 01:21:43,210
 (silence)

986
01:21:43,210 --> 01:21:45,370
 (silence)

987
01:21:45,370 --> 01:21:47,530
 (silence)

988
01:21:47,530 --> 01:21:49,530
 .

989
01:21:49,530 --> 01:21:51,530
 you

