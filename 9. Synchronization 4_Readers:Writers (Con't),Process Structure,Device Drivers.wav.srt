1
00:00:00,000 --> 00:00:26,480
 Hello everyone. So welcome to the nice lecture. So this lecture, it's the content of this

2
00:00:26,480 --> 00:00:35,920
 lecture, it's included in your first midterm. And so that's quite important. And it's also

3
00:00:35,920 --> 00:00:40,240
 a very important lecture for your future homeworks and projects.

4
00:00:40,240 --> 00:00:52,640
 So, and we are going to continue our discussion about abstraction to implement critical sections

5
00:00:52,640 --> 00:01:01,280
 and synchronization between processes. And if you remember, last time we discussed that one of the

6
00:01:01,280 --> 00:01:08,240
 main abstraction which would make it easier to implement critical sections exclusion from

7
00:01:08,240 --> 00:01:13,520
 critical sections. So only one thread should be active in a critical section at a given time,

8
00:01:13,520 --> 00:01:21,120
 or LOBS. And we discussed the implementation of LOBS using interrupts. And then we said there

9
00:01:21,120 --> 00:01:31,680
 are some disadvantages of using interrupts and some dangers. And then we discuss about then using

10
00:01:31,680 --> 00:01:41,120
 atomic operation, which are more sophisticated than load and store to implement these LOBS.

11
00:01:41,120 --> 00:01:48,640
 And one of them, it will be like test and set. If you remember the test and set,

12
00:01:49,600 --> 00:02:02,640
 it takes a value and maintains a local variable. Think about test and set, maintains a local

13
00:02:02,640 --> 00:02:12,240
 variable. And the atomic operation is that taking a value, updating the local variable is a new

14
00:02:12,240 --> 00:02:20,080
 value, and then returning the previous value of the local variable. That's pretty much it.

15
00:02:20,080 --> 00:02:30,000
 And this is an implementation, again, we discussed last time of a lock acquire and lock release,

16
00:02:30,000 --> 00:02:41,440
 and using test and set. And basically, you test and set here also to implement

17
00:02:42,000 --> 00:02:54,640
 mutual exclusion of operating of the value, the value of the lock. So the value of the lock,

18
00:02:54,640 --> 00:03:02,240
 whether it is busy or free, determine whether you can enter or not in the critical section

19
00:03:02,240 --> 00:03:09,680
 of the program of the user. And now we have a second, we use test and set for a second smaller

20
00:03:09,680 --> 00:03:16,400
 critical section, which is only concerned of updating the lock value to be zero free.

21
00:03:16,400 --> 00:03:30,080
 And if you remember, all this synchronization primitives involves weight. And the reason for

22
00:03:30,080 --> 00:03:37,440
 that is because it's fundamental, because if you have two threads which wants to enter in the same

23
00:03:37,440 --> 00:03:45,440
 critical section, you can only allow one thread to enter in the critical section. And therefore,

24
00:03:45,440 --> 00:03:52,160
 the other thread has nothing else to do but wait for the first thread to finish.

25
00:03:52,160 --> 00:04:00,800
 So that's why waiting is fundamental. And the other thing to remember, if you wait,

26
00:04:01,920 --> 00:04:09,200
 one way to wait and it's easy to implement is to do busy waiting. You constantly check whether the

27
00:04:09,200 --> 00:04:15,760
 critical section is free, whether you can acquire the lock. But of course, this consumes the CPU

28
00:04:15,760 --> 00:04:26,160
 cycles without doing any useful work. So therefore, waiting what you want to, the best way

29
00:04:26,160 --> 00:04:33,360
 to implement waiting and the preferred way is to go to sleep. So to put the thread on the waiting queue

30
00:04:33,360 --> 00:04:41,760
 and then to be woken up when the previous thread exceeds the critical section.

31
00:04:41,760 --> 00:04:46,720
 Okay. So this is what you see here. If the value is busy, so if someone acquired the lock

32
00:04:46,720 --> 00:04:54,880
 and has acquired the lock, it's in the critical section, you put the thread on the wait queue,

33
00:04:54,880 --> 00:05:01,920
 and then you go to sleep, and then you reset this guard, which is again, this guard, it's about,

34
00:05:01,920 --> 00:05:12,640
 basically, you freeze a lock for the critical section, which is concerned with updating the busy

35
00:05:12,640 --> 00:05:24,000
 value. Okay. And whilst the value is busy, you set the value to be this,

36
00:05:24,000 --> 00:05:31,040
 you acquire the lock, and then you again set guard to zero. So therefore, you are

37
00:05:31,040 --> 00:05:42,880
 going to allow another thread to look and to read the lock value and modify it.

38
00:05:42,880 --> 00:05:46,080
 Okay. Any questions here?

39
00:05:53,360 --> 00:06:00,640
 Okay. So not again that we have the same discussion, we had the same discussion like

40
00:06:00,640 --> 00:06:08,960
 in the case of when using interrupt to implement acquire and release, and that is when we are going

41
00:06:08,960 --> 00:06:14,560
 to set the guard to zero. That is when you are going to disable the interrupts. And this needs

42
00:06:14,560 --> 00:06:21,680
 to be done. You cannot do before sleep, you cannot do before the thread on wait queue. Just remember,

43
00:06:22,320 --> 00:06:28,320
 why is that? You can look at the last lecture. So you need to do in some sense after, but then after

44
00:06:28,320 --> 00:06:35,760
 the thread itself, which call acquire cannot do it because it's sleeping. Okay. So that has to be

45
00:06:35,760 --> 00:06:41,920
 done either by the operating system or by the next thread, which is going to be scheduled to reset

46
00:06:41,920 --> 00:07:03,520
 the guard. Okay. So, and here it's a simple example. Oh, gosh. Ah, this is a great question.

47
00:07:03,520 --> 00:07:10,000
 So one question here is whether the guard and value will be on the heap. Yes, they're going

48
00:07:10,000 --> 00:07:16,080
 to be on, they're going to be a global variables. So yeah. So everyone can access them.

49
00:07:16,080 --> 00:07:29,760
 Okay. So now we've seen two implementations actually of acquire and release logs. And

50
00:07:29,760 --> 00:07:38,240
 one is using interrupts and the other one using test and set. And this basically shows is to show

51
00:07:38,240 --> 00:07:45,760
 you that actually the logic is very, very similar. And you can think about while test and set,

52
00:07:45,760 --> 00:07:54,800
 it's similarly disabled interrupts and enabling and resetting guard to zero is like enabling

53
00:07:54,800 --> 00:08:05,280
 interrupts. Okay. And this is again, the code for, we went over last lecture about implementing

54
00:08:05,280 --> 00:08:15,920
 acquire and release by disabling and enabling the interrupts. Okay. And if you remember also what we

55
00:08:15,920 --> 00:08:21,760
 did last time, when I talk about locks, we did in two stages. First of all, we said, we gave this

56
00:08:21,760 --> 00:08:27,760
 very trivial implementation of the locks. Acquire, you disable the interrupts. Why disable the

57
00:08:27,760 --> 00:08:34,640
 interrupts? Because you don't want new threads to interrupt you, right? While you are in

58
00:08:35,520 --> 00:08:40,960
 the critical section, right? And then the release is enabling the interrupts. But of course,

59
00:08:40,960 --> 00:08:47,120
 this was very dangerous because if you call at the user level, acquire and disable interrupts,

60
00:08:47,120 --> 00:08:51,600
 and you have a very long critical section or you make a mistake and you have an infinite

61
00:08:51,600 --> 00:08:57,200
 while loop in the critical section, then your computer will hack. Okay. You can do anything

62
00:08:57,200 --> 00:09:05,120
 about it. The only thing probably is power off, power on. Right? So therefore, the more

63
00:09:05,120 --> 00:09:13,440
 sophisticated implementation was to use disable and enable interrupts only for updating the value

64
00:09:13,440 --> 00:09:18,560
 of the lock. So now you have a value of the lock, which set to zero and use disable and enable

65
00:09:18,560 --> 00:09:25,200
 interrupts to update that value, right? Or to read that value. Okay. So now, yes, you still use

66
00:09:25,200 --> 00:09:33,360
 disable and enable interrupts, but now it's very short. The critical section is very short and is

67
00:09:33,360 --> 00:09:42,160
 going to finish very fast. Right? So, and if you look again, if you look now at the same example,

68
00:09:42,160 --> 00:09:48,320
 but now implementing acquire and release using test and set, we went again through two iterations.

69
00:09:48,320 --> 00:09:53,440
 The first iteration was very simple that while test and set value, so you are going, the value

70
00:09:53,440 --> 00:09:59,520
 is a lock value. So while the value, this is why the value is one, right? Again, the test and set

71
00:09:59,520 --> 00:10:10,720
 here, if value is one, it's going to return the previous value of the internal variable of test

72
00:10:10,720 --> 00:10:17,680
 and set, and then set that variable to the new value. Right? So if it's the previous one was zero,

73
00:10:17,680 --> 00:10:23,120
 return zero means there's a lock it's acquired, but now you set one. So next time when someone

74
00:10:23,120 --> 00:10:29,840
 tries the value is one, the internal variable is one. So the internal variables will not change and

75
00:10:29,840 --> 00:10:31,200
 this test and set returns one.

76
00:10:31,420 --> 00:10:34,460
 once you are going to be stuck in the while loop.

77
00:10:34,460 --> 00:10:36,720
 But it's again, the problem with this one,

78
00:10:36,720 --> 00:10:40,180
 and the release is simple, you set the value to zero.

79
00:10:40,180 --> 00:10:42,060
 But, and the problem with this one,

80
00:10:42,060 --> 00:10:44,260
 remember that this while loop,

81
00:10:44,260 --> 00:10:47,620
 it's again, it's like, it's busy waiting,

82
00:10:47,620 --> 00:10:49,720
 which we discussed that we want to wait.

83
00:10:49,720 --> 00:10:52,020
 We want to, sorry, it's busy waiting,

84
00:10:52,020 --> 00:10:54,500
 which you remember we want to avoid.

85
00:10:54,500 --> 00:10:58,580
 So again, in this case, we went to the second iteration,

86
00:10:58,580 --> 00:11:03,180
 which we just also presented again,

87
00:11:03,180 --> 00:11:05,980
 earlier in the lecture, today's lecture,

88
00:11:05,980 --> 00:11:09,080
 and you use the test and set

89
00:11:09,080 --> 00:11:12,100
 only to protect the critical sections,

90
00:11:12,100 --> 00:11:17,100
 which are concerned with updating the value of the lock.

91
00:11:17,100 --> 00:11:21,580
 And now again, this is much shorter critical section.

92
00:11:21,580 --> 00:11:23,740
 So the test and set will be,

93
00:11:23,740 --> 00:11:26,540
 we'll wait only for very short time.

94
00:11:26,540 --> 00:11:30,860
 And now instead of like in this case, you're waiting,

95
00:11:30,860 --> 00:11:32,620
 you are waiting as a previous case,

96
00:11:32,620 --> 00:11:35,820
 you are waiting as long as someone is in the critical

97
00:11:35,820 --> 00:11:37,160
 section to busy waiting.

98
00:11:37,160 --> 00:11:40,880
 So once you have the CPU cycles, in this case,

99
00:11:40,880 --> 00:11:45,220
 in the more refined iteration,

100
00:11:45,220 --> 00:11:48,060
 you are going to put the thread,

101
00:11:48,060 --> 00:11:51,100
 which is waiting on the wait queue, right?

102
00:11:51,100 --> 00:11:52,500
 So there is no busy waiting.

103
00:11:52,500 --> 00:11:55,980
 Okay.

104
00:11:55,980 --> 00:11:59,580
 Any questions here?

105
00:11:59,580 --> 00:12:06,300
 Okay.

106
00:12:06,300 --> 00:12:12,220
 So, so where we are going again, we synchronization.

107
00:12:12,220 --> 00:12:13,780
 So let's see what we've done.

108
00:12:13,780 --> 00:12:15,740
 We look at the, on the hardware support,

109
00:12:15,740 --> 00:12:17,820
 low stores, disable interrupts,

110
00:12:17,820 --> 00:12:19,620
 test and set and compare and swap.

111
00:12:19,620 --> 00:12:22,420
 These are similar for test and set and compare and swap.

112
00:12:23,540 --> 00:12:26,980
 They are much more useful than load and store.

113
00:12:26,980 --> 00:12:30,860
 And we saw how you can use these to implement locks.

114
00:12:30,860 --> 00:12:34,340
 And also we discussed abstraction about semaphores.

115
00:12:34,340 --> 00:12:39,340
 And yeah, and then next also later,

116
00:12:39,340 --> 00:12:42,220
 we are going to talk about monitors.

117
00:12:42,220 --> 00:12:44,660
 And it's again, the higher level,

118
00:12:44,660 --> 00:12:48,940
 the abstraction is easier will be for the programs,

119
00:12:48,940 --> 00:12:53,220
 for the application to implement mutual exclusion

120
00:12:53,220 --> 00:12:55,300
 and critical sections.

121
00:12:55,300 --> 00:12:59,860
 And so next we are going to go

122
00:12:59,860 --> 00:13:02,860
 and talk more about the abstraction.

123
00:13:02,860 --> 00:13:06,020
 Let's talk again about semaphores, right?

124
00:13:06,020 --> 00:13:09,980
 And if you remember, just to remind you,

125
00:13:09,980 --> 00:13:12,540
 the semaphores you have,

126
00:13:12,540 --> 00:13:15,660
 they are a little bit more sophisticated than locks.

127
00:13:15,660 --> 00:13:20,380
 A lock can have only two values, zero or one or busy and free.

128
00:13:21,340 --> 00:13:24,140
 With semaphores is like a counter, right?

129
00:13:24,140 --> 00:13:25,900
 The special counter, right?

130
00:13:25,900 --> 00:13:27,860
 It's like you have a primitive,

131
00:13:27,860 --> 00:13:29,620
 which increments the semaphore

132
00:13:29,620 --> 00:13:31,620
 and a primitive which decrements the semaphore.

133
00:13:31,620 --> 00:13:35,340
 And if semaphore is zero, then you are going to wait, right?

134
00:13:35,340 --> 00:13:38,860
 You are very much, you are waiting for a lock,

135
00:13:38,860 --> 00:13:40,980
 which is busy, okay?

136
00:13:40,980 --> 00:13:44,020
 So if you remember, so that's provides you a little bit more,

137
00:13:44,020 --> 00:13:47,740
 more, more,

138
00:13:50,740 --> 00:13:52,460
 a little bit more power.

139
00:13:52,460 --> 00:13:55,220
 And therefore it also gives you more,

140
00:13:55,220 --> 00:13:58,580
 if it gives you more functionality,

141
00:13:58,580 --> 00:14:00,500
 you can implement with the semaphore,

142
00:14:00,500 --> 00:14:02,340
 both critical sections,

143
00:14:02,340 --> 00:14:04,900
 but you also implement a mutual exclusion,

144
00:14:04,900 --> 00:14:09,100
 but you also implement scheduling constraints,

145
00:14:09,100 --> 00:14:13,300
 basically telling, signaling one process

146
00:14:13,300 --> 00:14:15,820
 from another process or a thread from another thread.

147
00:14:15,820 --> 00:14:20,380
 And if you remember the example we gave last time

148
00:14:20,380 --> 00:14:25,140
 about this was about, if you remember,

149
00:14:25,140 --> 00:14:28,300
 it was about implementing the thread join,

150
00:14:28,300 --> 00:14:31,580
 waiting the thread who launches,

151
00:14:31,580 --> 00:14:34,220
 create another thread waiting for the new create,

152
00:14:34,220 --> 00:14:36,620
 for the creative thread to finish, okay?

153
00:14:36,620 --> 00:14:38,020
 It's okay.

154
00:14:38,020 --> 00:14:42,100
 So now we are going to move from locks and semaphores

155
00:14:42,100 --> 00:14:44,500
 to a new abstraction, which is called monitors.

156
00:14:45,580 --> 00:14:50,580
 And monitors are better, are simply more powerful.

157
00:14:50,580 --> 00:14:56,140
 And the main idea is to split between

158
00:14:56,140 --> 00:15:00,980
 and supporting explicitly these two functionality

159
00:15:00,980 --> 00:15:05,380
 about mutual exclusion and scheduling constraints.

160
00:15:05,380 --> 00:15:08,020
 And you use locks for mutual exclusion

161
00:15:08,020 --> 00:15:10,420
 and what are called condition variable

162
00:15:10,420 --> 00:15:12,900
 for scheduling constraints, right?

163
00:15:13,780 --> 00:15:17,980
 So a monitor, it's a lock

164
00:15:17,980 --> 00:15:20,580
 and a zero or more conditional variable

165
00:15:20,580 --> 00:15:25,100
 for managing concurrent access to share data, okay?

166
00:15:25,100 --> 00:15:27,620
 And we'll talk more about that.

167
00:15:27,620 --> 00:15:31,300
 Some languages provide this natively

168
00:15:31,300 --> 00:15:35,300
 and most of the others,

169
00:15:35,300 --> 00:15:41,420
 you can use lock and conditionals variables

170
00:15:41,420 --> 00:15:44,340
 as a distinct abstractions.

171
00:15:44,340 --> 00:15:48,260
 So I'm going again, if you have any questions, let me know.

172
00:15:48,260 --> 00:15:52,420
 This is again, so these lectures,

173
00:15:52,420 --> 00:15:54,660
 the past lecture and these lectures

174
00:15:54,660 --> 00:15:56,660
 are not very easy to follow

175
00:15:56,660 --> 00:15:59,300
 because they are about concurrency,

176
00:15:59,300 --> 00:16:03,900
 are about programs which execute concurrently.

177
00:16:03,900 --> 00:16:05,620
 And like we discussed last time,

178
00:16:08,900 --> 00:16:13,380
 we as humans are not very used about handling many things

179
00:16:13,380 --> 00:16:14,860
 which happen at the same time.

180
00:16:14,860 --> 00:16:19,580
 We are much better in sequentializing things.

181
00:16:19,580 --> 00:16:21,980
 So it's perfectly fine,

182
00:16:21,980 --> 00:16:27,460
 if you feel this is a little bit more challenging,

183
00:16:27,460 --> 00:16:30,500
 but at the same time, this also means

184
00:16:30,500 --> 00:16:32,660
 that you should spend a little bit more time

185
00:16:32,660 --> 00:16:37,020
 to try to understand deeply what's happening here, okay?

186
00:16:37,060 --> 00:16:42,060
 So again, some languages provide monitors

187
00:16:42,060 --> 00:16:50,660
 and let's see what is a conditional variables.

188
00:16:50,660 --> 00:16:54,100
 So conditional variables, what is a conditional variable?

189
00:16:54,100 --> 00:16:56,940
 It's a queue of threads waiting for something

190
00:16:56,940 --> 00:17:01,140
 inside a critical section to happen, okay?

191
00:17:02,900 --> 00:17:07,020
 So, and the nice thing about the critical section,

192
00:17:07,020 --> 00:17:10,340
 send the conditional, sorry,

193
00:17:10,340 --> 00:17:14,420
 nice thing about the monitors and condition variables,

194
00:17:14,420 --> 00:17:17,940
 is conditional variables allow sleeping

195
00:17:17,940 --> 00:17:20,060
 inside the critical section,

196
00:17:20,060 --> 00:17:23,500
 by atomically releasing the lock at a time we go to sleep.

197
00:17:23,500 --> 00:17:27,980
 Okay, so what I mean by that, here is what I mean.

198
00:17:31,940 --> 00:17:35,140
 Okay, remember about this slide,

199
00:17:35,140 --> 00:17:38,700
 I'll go soon, you know, in again in presentation mode.

200
00:17:38,700 --> 00:17:43,700
 Here, it's again, if you try to acquire the lock

201
00:17:43,700 --> 00:17:48,740
 and the lock is busy, so the value is one,

202
00:17:48,740 --> 00:17:51,100
 you have to go to sleep.

203
00:17:51,100 --> 00:17:54,940
 And what we want, we want this to,

204
00:17:54,940 --> 00:17:58,860
 how we want this to happen is to put the thread

205
00:17:58,860 --> 00:17:59,900
 in the waiting queue.

206
00:18:00,940 --> 00:18:03,140
 But when you put the set of the waiting queue,

207
00:18:03,140 --> 00:18:08,100
 you need also to resell the guard, right?

208
00:18:08,100 --> 00:18:12,580
 To let other threads enter the critical section

209
00:18:12,580 --> 00:18:17,580
 to look at the value and maybe to modify the value, right?

210
00:18:17,580 --> 00:18:20,500
 So now the sleep and the guard

211
00:18:20,500 --> 00:18:24,340
 have to happen at the same time, okay?

212
00:18:24,340 --> 00:18:25,700
 So they need to be atomic.

213
00:18:28,700 --> 00:18:32,540
 And well, monitors provide,

214
00:18:32,540 --> 00:18:34,700
 and conditional variables for monitors,

215
00:18:34,700 --> 00:18:38,820
 provide you this atomicity between the threads going to sleep

216
00:18:38,820 --> 00:18:43,820
 and giving up, releasing the lock,

217
00:18:43,820 --> 00:18:45,660
 because guard is equal to zero,

218
00:18:45,660 --> 00:18:50,660
 release a lock associated with a guard atomically.

219
00:18:50,660 --> 00:18:52,860
 You don't need to worry about that.

220
00:18:52,860 --> 00:18:56,260
 That's what conditional variables in monitors

221
00:18:56,260 --> 00:18:57,780
 are going to do for you.

222
00:18:57,780 --> 00:19:00,500
 And that's why they are very useful.

223
00:19:00,500 --> 00:19:06,340
 Okay?

224
00:19:06,340 --> 00:19:10,540
 And here are the operations.

225
00:19:10,540 --> 00:19:14,420
 The operation, you wait for the lock, okay?

226
00:19:14,420 --> 00:19:17,340
 Which you can,

227
00:19:17,340 --> 00:19:23,140
 you can atomically, this is going to,

228
00:19:23,140 --> 00:19:26,140
 the operation is going to atomically release a lock

229
00:19:26,140 --> 00:19:27,100
 and go to sleep.

230
00:19:27,100 --> 00:19:31,420
 And you can require the lock later.

231
00:19:31,420 --> 00:19:36,420
 We'll have a few examples to make it more understandable.

232
00:19:36,420 --> 00:19:38,220
 And then you have signals.

233
00:19:38,220 --> 00:19:41,820
 You remember that one of the use of the semaphore

234
00:19:41,820 --> 00:19:45,580
 was to signal when a thread won an event,

235
00:19:45,580 --> 00:19:49,060
 right between two threads, right?

236
00:19:49,060 --> 00:19:52,380
 So now you have a very primitive, which is called,

237
00:19:52,380 --> 00:19:56,620
 you know, makes a lot of sense, a name is signal.

238
00:19:56,620 --> 00:19:59,900
 And you have also something which is called broadcast.

239
00:19:59,900 --> 00:20:04,900
 So the signal is waking a thread,

240
00:20:04,900 --> 00:20:08,380
 which is waiting for some particular event to happen.

241
00:20:08,380 --> 00:20:14,260
 Broadcast is waking multiple waiters,

242
00:20:14,260 --> 00:20:17,620
 all the waiters which wait for that event.

243
00:20:17,620 --> 00:20:19,740
 Signal, if there are multiple waiters,

244
00:20:19,740 --> 00:20:23,740
 it's going to wake only one.

245
00:20:25,060 --> 00:20:27,540
 And that's non-deterministic.

246
00:20:27,540 --> 00:20:30,420
 You know, you don't know which one is going to be waken up.

247
00:20:30,420 --> 00:20:33,460
 And in many cases, you don't care.

248
00:20:33,460 --> 00:20:36,860
 Broadcast wakes all of them, okay?

249
00:20:36,860 --> 00:20:44,180
 Okay, now, when you do operation

250
00:20:44,180 --> 00:20:46,340
 on the condition variables,

251
00:20:46,340 --> 00:20:49,420
 of course you need to own the lock, right?

252
00:20:49,420 --> 00:20:51,660
 Because this is in critical section.

253
00:20:51,660 --> 00:20:54,780
 This is one way to represent it.

254
00:20:54,780 --> 00:20:59,780
 The monitors, so X and Y are conditional variables.

255
00:20:59,780 --> 00:21:02,300
 Each of them is associated a Q.

256
00:21:02,850 --> 00:21:07,850
 And you have a lock which provides a mutual exclusion

257
00:21:07,850 --> 00:21:12,730
 with the shared data in this monitor.

258
00:21:12,730 --> 00:21:17,830
 The conditional variables are shared data.

259
00:21:17,830 --> 00:21:26,830
 But it's again, one of the main advantage,

260
00:21:26,830 --> 00:21:30,590
 you are allowed to wait in the critical section.

261
00:21:30,590 --> 00:21:34,090
 And this is not allowed for semaphores,

262
00:21:34,090 --> 00:21:37,830
 which makes the semaphores very much harder to use.

263
00:21:37,830 --> 00:21:40,050
 So now it's again, let's see,

264
00:21:40,050 --> 00:21:42,130
 and we are going to have a lot of examples.

265
00:21:42,130 --> 00:21:46,370
 So we give you a better sense about how these monitors,

266
00:21:46,370 --> 00:21:47,530
 how you use the monitors.

267
00:21:47,530 --> 00:21:51,250
 And also we are going to talk about how they are implemented.

268
00:21:51,250 --> 00:21:53,370
 So hopefully by the end of this lectures,

269
00:21:53,370 --> 00:21:57,010
 you are going to have a pretty good feeling about monitors.

270
00:21:59,330 --> 00:22:02,650
 So here is an infinite queue, synchronized queue.

271
00:22:02,650 --> 00:22:04,830
 You have producer, consumer.

272
00:22:04,830 --> 00:22:07,170
 It's infinite in the sense that the producer

273
00:22:07,170 --> 00:22:11,630
 can put any numbers of items in the queue, right?

274
00:22:11,630 --> 00:22:13,430
 The queue is infinite, right?

275
00:22:13,430 --> 00:22:14,270
 So how do you do it?

276
00:22:14,270 --> 00:22:17,050
 The producer is like you acquire the lock,

277
00:22:17,050 --> 00:22:18,370
 and release the lock.

278
00:22:18,370 --> 00:22:19,590
 You have a buffer lock.

279
00:22:19,590 --> 00:22:24,750
 And the consumer also acquires the lock

280
00:22:24,750 --> 00:22:26,310
 and release the lock, right?

281
00:22:26,310 --> 00:22:30,290
 And this is in order to protect the critical sections,

282
00:22:30,290 --> 00:22:32,070
 which are operating on the queue, right?

283
00:22:32,070 --> 00:22:34,970
 You don't want a producer and the consumer

284
00:22:34,970 --> 00:22:37,070
 to operate on the queue at the same time,

285
00:22:37,070 --> 00:22:40,710
 because inserting, adding a new element to the queue,

286
00:22:40,710 --> 00:22:42,110
 and removing an element from the queue

287
00:22:42,110 --> 00:22:43,790
 are not atomic operations.

288
00:22:43,790 --> 00:22:45,730
 And therefore bad things can happen

289
00:22:45,730 --> 00:22:49,990
 while you both of them are manipulating the pointers, right?

290
00:22:49,990 --> 00:22:54,950
 To insert or remove an element from the queue, okay?

291
00:22:54,950 --> 00:22:59,950
 And now you can use these condition variables,

292
00:22:59,950 --> 00:23:05,830
 like buff, you know, CV, in order to signal.

293
00:23:05,830 --> 00:23:08,990
 The producer, that's basically what it says.

294
00:23:08,990 --> 00:23:13,490
 The buff CV is a way for the producer

295
00:23:13,490 --> 00:23:18,490
 to signal the consumer that there are elements in the buffer,

296
00:23:18,490 --> 00:23:22,870
 in the queue, right?

297
00:23:22,870 --> 00:23:24,030
 So this is what it is.

298
00:23:24,030 --> 00:23:25,470
 You signal it.

299
00:23:25,470 --> 00:23:29,470
 And then what do you do from, in the consumer?

300
00:23:29,470 --> 00:23:34,850
 While it's empty, so look for the queue whether it's empty.

301
00:23:34,850 --> 00:23:37,470
 Right, it's in the critical section.

302
00:23:37,470 --> 00:23:40,510
 So it's fair to look at the queue,

303
00:23:40,510 --> 00:23:42,550
 because no one else will modify the queue

304
00:23:42,550 --> 00:23:46,310
 while you are in the critical section to operate on the queue.

305
00:23:46,310 --> 00:23:48,550
 And then you call this condition, wait.

306
00:23:48,550 --> 00:23:51,350
 So you're waiting for the signal for buff CV.

307
00:23:51,350 --> 00:23:54,390
 And you also, you see, this is the first argument

308
00:23:54,390 --> 00:23:55,830
 of condition wait.

309
00:23:55,830 --> 00:23:57,850
 And the second argument is buff lock.

310
00:23:57,850 --> 00:23:58,890
 Why is that?

311
00:23:58,890 --> 00:24:03,890
 Because if the queue is empty, right, this is true.

312
00:24:03,890 --> 00:24:11,710
 So this in condition wait, and what you are going to do

313
00:24:11,710 --> 00:24:15,210
 is basically you are going to put the thread to sleep

314
00:24:15,210 --> 00:24:18,310
 and you need to release a lock, right?

315
00:24:18,310 --> 00:24:22,750
 This basically tells the condition wait to release the lock

316
00:24:22,750 --> 00:24:24,610
 once the thread is put to sleep.

317
00:24:24,610 --> 00:24:32,030
 Remember, we want here to have atomic operation,

318
00:24:32,030 --> 00:24:35,950
 sleep the sleep and releasing the buffer

319
00:24:35,950 --> 00:24:37,450
 should be an atomic operation.

320
00:24:37,450 --> 00:24:45,350
 Aaron has a question here.

321
00:24:45,350 --> 00:24:50,350
 If you use a broadcast, it will create a race condition.

322
00:24:50,350 --> 00:24:52,510
 Not necessary, not necessary.

323
00:24:52,510 --> 00:24:55,210
 We'll see that in an example, right?

324
00:24:55,210 --> 00:25:00,210
 Because still, you can wake up all the waiters,

325
00:25:00,210 --> 00:25:04,350
 but only if all the waiters want to go

326
00:25:04,350 --> 00:25:05,910
 to the same critical section,

327
00:25:05,910 --> 00:25:08,730
 still only one will succeed, okay?

328
00:25:08,730 --> 00:25:12,290
 And the other one will go back to wait.

329
00:25:13,250 --> 00:25:17,210
 So you're still going to be okay, okay?

330
00:25:17,210 --> 00:25:22,190
 So, oh, sorry, okay.

331
00:25:22,190 --> 00:25:24,550
 Okay, so this is basically what happened here.

332
00:25:24,550 --> 00:25:34,150
 So now, and I think this was a question last time.

333
00:25:34,150 --> 00:25:37,890
 I don't remember who asked that question.

334
00:25:37,890 --> 00:25:40,610
 It was great question about what you remember

335
00:25:40,610 --> 00:25:44,950
 if you go to, I think was in the context of test on set,

336
00:25:44,950 --> 00:25:46,990
 why do you use while and not if?

337
00:25:46,990 --> 00:25:49,910
 It's a similar thing here and we'll explain why

338
00:25:49,910 --> 00:25:51,790
 and what is the difference.

339
00:25:51,790 --> 00:25:54,190
 And the problem here is that, you know,

340
00:25:54,190 --> 00:25:55,710
 if you look at this piece of code,

341
00:25:55,710 --> 00:25:58,470
 will you just the consumer wait for the queue

342
00:25:58,470 --> 00:26:03,350
 to be non-empty to have elements in order to be queue,

343
00:26:03,350 --> 00:26:08,350
 a new element from the queue, it has a while, right?

344
00:26:09,550 --> 00:26:13,350
 And the natural question you can ask, look, why, why?

345
00:26:13,350 --> 00:26:15,930
 Because the thread is going to sleep, right?

346
00:26:15,930 --> 00:26:18,730
 So why do you do that?

347
00:26:18,730 --> 00:26:22,970
 And it's true that it's a good question.

348
00:26:22,970 --> 00:26:25,330
 Let me start with that, right?

349
00:26:25,330 --> 00:26:29,230
 Okay, you see that why should I do the while?

350
00:26:29,230 --> 00:26:32,170
 Because it's again, it's like the thread is going to sleep

351
00:26:32,170 --> 00:26:33,690
 and it's going to be woken up

352
00:26:33,690 --> 00:26:39,530
 if another thread exceeds the critical section, right?

353
00:26:40,130 --> 00:26:41,590
 So I should test again.

354
00:26:41,590 --> 00:26:47,570
 And the answer here is that

355
00:26:47,570 --> 00:26:52,210
 it depends on the implementation, okay?

356
00:26:52,210 --> 00:26:55,290
 You can actually, depending on the implementation,

357
00:26:55,290 --> 00:27:00,290
 you can replace while with if, and that will be correct.

358
00:27:00,290 --> 00:27:01,750
 Okay?

359
00:27:01,750 --> 00:27:06,490
 So, and there are two implementations.

360
00:27:06,490 --> 00:27:08,770
 One in which you need to put while,

361
00:27:08,770 --> 00:27:11,770
 you have to have while, and the other one,

362
00:27:11,770 --> 00:27:14,130
 you need to have, you can use if.

363
00:27:14,130 --> 00:27:19,190
 The first one which requires you to have while

364
00:27:19,190 --> 00:27:22,050
 is called Mesa style, right?

365
00:27:22,050 --> 00:27:23,850
 And because it was implemented

366
00:27:23,850 --> 00:27:26,530
 in Xerox Spark Mesa operating system.

367
00:27:26,530 --> 00:27:28,970
 And this is what most operating system are using.

368
00:27:28,970 --> 00:27:32,650
 The one in which you can use if

369
00:27:32,650 --> 00:27:34,890
 is Hoare style implementation.

370
00:27:34,890 --> 00:27:38,250
 This is a British logician, Tony Hoare.

371
00:27:38,250 --> 00:27:43,250
 And in this case, you can use if, okay?

372
00:27:43,250 --> 00:27:45,650
 So let's see how Hoare monitors.

373
00:27:45,650 --> 00:27:49,130
 So this is a one you can use if, how they are implemented.

374
00:27:49,130 --> 00:27:50,970
 So here is how it's implemented.

375
00:27:50,970 --> 00:27:54,930
 You have acquire on both sides,

376
00:27:54,930 --> 00:27:59,930
 and let's say the first, you know,

377
00:27:59,930 --> 00:28:07,430
 sorry, so in both cases,

378
00:28:07,430 --> 00:28:10,710
 you obviously you protect the critical sections

379
00:28:10,710 --> 00:28:14,430
 by a buff lock, and the code on the left hand side

380
00:28:14,430 --> 00:28:17,350
 is going to send a signal.

381
00:28:17,350 --> 00:28:21,690
 And as a result of the signal,

382
00:28:21,690 --> 00:28:26,450
 the thread which are waiting on this conditional variable,

383
00:28:26,450 --> 00:28:30,770
 buff CV is going to wake up, right?

384
00:28:30,770 --> 00:28:34,310
 So the sled on the left is going to send a signal,

385
00:28:34,310 --> 00:28:39,310
 and the code on the right is going to be of a sled,

386
00:28:39,310 --> 00:28:44,490
 which is going to be open up by this signal, okay?

387
00:28:44,490 --> 00:28:45,330
 So let's see what happens.

388
00:28:45,330 --> 00:28:49,590
 So it's Hoare, what happens when you execute this signal,

389
00:28:49,590 --> 00:28:55,510
 you automatically release a lock, the buff lock here,

390
00:28:55,510 --> 00:29:00,510
 and the CPU, and you schedule immediately the sled,

391
00:29:01,190 --> 00:29:06,190
 which is waiting for the buff CV conditional variable.

392
00:29:06,190 --> 00:29:08,650
 You are going to execute it,

393
00:29:08,650 --> 00:29:13,650
 and then at the end, you are going to release the lock,

394
00:29:13,650 --> 00:29:18,050
 and then you go back and continue to execute

395
00:29:18,050 --> 00:29:23,050
 the first thread, which signal the second one, right?

396
00:29:23,050 --> 00:29:29,550
 And that's what it is, right?

397
00:29:30,650 --> 00:29:32,650
 So this is the implementation.

398
00:29:32,650 --> 00:29:36,350
 Now, so this seems like good, right?

399
00:29:36,350 --> 00:29:38,170
 It's basically in the signal.

400
00:29:38,170 --> 00:29:40,190
 When I signal someone, I stop,

401
00:29:40,190 --> 00:29:43,830
 I give the lock to the thread which is waiting,

402
00:29:43,830 --> 00:29:48,830
 and the operating system will schedule that thread

403
00:29:48,830 --> 00:29:53,970
 to execute, exit the critical section,

404
00:29:53,970 --> 00:29:56,970
 and after that, I get the control back, okay?

405
00:29:59,770 --> 00:30:01,210
 This is correct.

406
00:30:01,210 --> 00:30:02,650
 What is the problem?

407
00:30:02,650 --> 00:30:06,370
 The problem here is it's a little bit harder to implement

408
00:30:06,370 --> 00:30:09,210
 and may lead to a lot of context switches.

409
00:30:09,210 --> 00:30:12,570
 Furthermore, as you'll see

410
00:30:12,570 --> 00:30:15,250
 from the next Mesa-style implementation,

411
00:30:15,250 --> 00:30:16,550
 it's not really necessary.

412
00:30:16,550 --> 00:30:21,770
 And here it's about Mesa implementation.

413
00:30:21,770 --> 00:30:24,570
 With a Mesa implementation, after you signal,

414
00:30:24,570 --> 00:30:28,390
 you do not give the control.

415
00:30:29,390 --> 00:30:32,790
 To the thread waiting for a condition variable.

416
00:30:32,790 --> 00:30:37,250
 Instead, what you do, you just take that thread,

417
00:30:37,250 --> 00:30:40,230
 waiting on the conditional variable,

418
00:30:40,230 --> 00:30:44,810
 and you put it, move it from the waiting queue

419
00:30:44,810 --> 00:30:46,350
 to the ready queue.

420
00:30:46,350 --> 00:30:47,510
 It's ready to execute.

421
00:30:47,510 --> 00:30:52,910
 And then you continue, okay?

422
00:30:52,910 --> 00:30:56,590
 And eventually later when you are done,

423
00:30:57,450 --> 00:30:59,890
 you are going to schedule the operating system,

424
00:30:59,890 --> 00:31:04,390
 is going to schedule the thread,

425
00:31:04,390 --> 00:31:05,990
 which is now in the ready queue.

426
00:31:05,990 --> 00:31:09,230
 Okay?

427
00:31:09,230 --> 00:31:11,390
 Sometimes later.

428
00:31:11,390 --> 00:31:17,790
 But you see now, so what is,

429
00:31:17,790 --> 00:31:22,150
 but we see now that now you need to check

430
00:31:22,150 --> 00:31:26,830
 this condition again, this empty queue.

431
00:31:26,830 --> 00:31:27,810
 Why?

432
00:31:27,810 --> 00:31:32,090
 Because in the meantime, there can be another between,

433
00:31:32,090 --> 00:31:34,210
 in the meantime, you can.

434
00:31:34,270 --> 00:31:41,790
 have a race condition and another thread comes and wants to acquire the lock because it's free,

435
00:31:41,790 --> 00:31:50,750
 and now you are going to have two threads on the ready queue which want to enter the

436
00:31:50,750 --> 00:31:59,870
 same critical section. So that is not good. So that's kind of the problem.

437
00:32:01,470 --> 00:32:08,750
 But by doing so, you are going to have less context switches. In this case, you have

438
00:32:08,750 --> 00:32:15,630
 the first thread finishes exiting the critical section, then you are going to,

439
00:32:15,630 --> 00:32:22,190
 after that you are going to execute the second thread. So it's one context switch. In the

440
00:32:22,190 --> 00:32:27,310
 previous case, you have one context switch going from the signaling thread to the thread which is

441
00:32:27,310 --> 00:32:39,950
 waiting and back. So at least you have two. Okay, any questions?

442
00:32:39,950 --> 00:32:55,310
 So let's look now at our buffer queue example and use

443
00:32:55,870 --> 00:33:07,230
 a more, and now we are using two condition variables for producer and the consumer. Let

444
00:33:07,230 --> 00:33:15,150
 me give you the code. And we are also looking now is bounded buffer. So in previous case,

445
00:33:15,150 --> 00:33:20,350
 we use only one condition variable and it was unbounded buffer, infinite buffer size.

446
00:33:20,910 --> 00:33:26,750
 Here is bounded. Okay, so how do you have two variables? You can check whether the buffer is

447
00:33:26,750 --> 00:33:38,990
 full or empty. And then if the buffer is full, while the buffer is full, obviously, the producer

448
00:33:38,990 --> 00:33:48,110
 waits. Otherwise, you enqueue an item in the buffer and you signal the consumer because now

449
00:33:49,070 --> 00:33:55,870
 the buffer is no longer empty and the consumer can drain, can take that element from the buffer.

450
00:33:55,870 --> 00:34:03,630
 Okay, and the consumer is the same. If the buffer was, if the buffer is empty,

451
00:34:03,630 --> 00:34:08,430
 you can do anything. There is no item you can take from the buffer.

452
00:34:08,430 --> 00:34:16,510
 Okay, if the buffer is not empty, you dequeue it and you signal a producer

453
00:34:17,070 --> 00:34:21,710
 that there is at least one free slot in the buffer, you can insert a new item.

454
00:34:21,710 --> 00:34:29,230
 So this is how this is work. Okay.

455
00:34:29,230 --> 00:34:33,230
 Any questions?

456
00:34:33,230 --> 00:34:42,830
 So you see that fundamentally what you do is condition variable here is like we mentioned

457
00:34:42,830 --> 00:34:52,910
 earlier is to signal between threads when an event occurs. In this particular case,

458
00:34:52,910 --> 00:34:59,630
 the producer signal to consumer when it's inserted an element in the buffer

459
00:34:59,630 --> 00:35:11,070
 and the consumer signals to the producer when it removed an element from the buffer.

460
00:35:12,350 --> 00:35:19,630
 So now the producer knows that for sure it can add a new element to the buffer.

461
00:35:19,630 --> 00:35:33,150
 Also, again, I want to reiterate that the thread when it's waiting, it doesn't do busy waiting,

462
00:35:34,750 --> 00:35:43,470
 it's sleeping. The condition variable, the semantics there or conduit is to take that thread,

463
00:35:43,470 --> 00:35:51,310
 put it on the wait queue and release the lock to the critical section, buff lock.

464
00:35:51,310 --> 00:35:59,150
 Okay, can you construct monitors from semaphores?

465
00:36:00,910 --> 00:36:08,510
 The locking aspect, it's easy, remember? You can use a semaphore which has only two values

466
00:36:08,510 --> 00:36:16,670
 and the wait is basically decrementing the semaphore. If it's one, you initialize

467
00:36:16,670 --> 00:36:22,670
 semaphore to one. If it's one, you acquire the lock and it's zero. If someone else thread comes

468
00:36:22,670 --> 00:36:29,390
 and want to decrement it, then it cannot and it has to wait because you need to wait for

469
00:36:29,390 --> 00:36:39,230
 the someone else to increment the semaphore back to one. This will be the signal.

470
00:36:39,230 --> 00:36:50,590
 But the biggest problem here is that the wait, if you do that while you are in a critical section

471
00:36:50,590 --> 00:36:55,950
 and you have to do that to be in the critical section, then you are going to wait and you are

472
00:36:55,950 --> 00:37:02,910
 not going to release a lock. So that's the key. The monitors on the condition variable, condition

473
00:37:02,910 --> 00:37:08,510
 weight, that function is releasing the lock atomically when you go to sleep.

474
00:37:08,510 --> 00:37:23,870
 Are this working? What about this one? You release a lock immediately, you're after wait.

475
00:37:25,390 --> 00:37:34,830
 This will not work. And one of the reasons the condition variables have no history in the sense

476
00:37:34,830 --> 00:37:40,190
 that I always signal, if I signal you five times, you are going to be woken only once.

477
00:37:40,190 --> 00:37:44,750
 But semaphores have history. Let me see.

478
00:37:52,670 --> 00:37:57,630
 Yes, so this is exactly what I was saying. It's a great question, Thayu. So the question is,

479
00:37:57,630 --> 00:38:05,070
 it is half full. If the buffer is half full, will the condition variable still going to signal

480
00:38:05,070 --> 00:38:13,710
 in the either case? Absolutely. That's exactly what we mean here. The condition variable has no

481
00:38:13,710 --> 00:38:20,110
 history. Yes, you are going to be signaled. And in that case, a signal doesn't mean anything because

482
00:38:20,110 --> 00:38:27,470
 you may not, you know, if you signal and there is no thread on waiting, then nothing will happen.

483
00:38:27,470 --> 00:38:31,230
 Very good question.

484
00:38:31,230 --> 00:38:48,910
 And, and yes, this is exactly what I said, if the thread signals and no one is waiting,

485
00:38:48,910 --> 00:38:56,270
 there is no operation, there is no op. If a sled later waits, then it's a problem right now here,

486
00:38:56,270 --> 00:39:01,150
 because it's again, if that happens, then it's going to,

487
00:39:01,150 --> 00:39:12,590
 you wait with a lock and the other thread cannot increment the semaphore, which correspond to the

488
00:39:12,590 --> 00:39:24,110
 lock. So you are going to be, to be stuck. Okay, anyway, so there are a bunch of questions here,

489
00:39:24,110 --> 00:39:33,470
 and I invite you to answer the questions. And I just want to, as an exercise for you,

490
00:39:33,470 --> 00:39:41,230
 and you may be very well get some problem like this one and asking you these questions.

491
00:39:41,950 --> 00:39:47,790
 But instead, instead, because we are, you know, running a little bit out of time,

492
00:39:47,790 --> 00:39:55,710
 I want to go to the next part of the lecture, which is extremely important part of the lecture.

493
00:39:55,710 --> 00:40:07,790
 And this is about reader and writer problem. Okay, let me just see.

494
00:40:07,950 --> 00:40:15,470
 Okay, let me just, I think I don't have the announcement before going there.

495
00:40:15,470 --> 00:40:24,110
 Let me do verbally and I'm going to add the slide about the announcement to the lecture right after,

496
00:40:24,110 --> 00:40:29,550
 the lecture slide right after the lecture. So basically, the most important thing

497
00:40:29,550 --> 00:40:37,070
 is that obviously next week, you are going to, we are going to be doing a lot of work

498
00:40:37,070 --> 00:40:42,510
 and we are going to have the first meetup, and it will be between seven and nine on Wednesday.

499
00:40:42,510 --> 00:40:58,350
 Okay. And we are going to have also a session for between seven and nine p.m. on Monday

500
00:40:58,350 --> 00:41:04,030
 for the meetup. So you can come and ask any questions you have.

501
00:41:05,470 --> 00:41:12,670
 And, you know, this is pretty much it. We are going to provide more

502
00:41:12,670 --> 00:41:20,350
 information as we go close to the meetup. But if you have now any questions, let me know.

503
00:41:26,910 --> 00:41:38,030
 Okay. So now this is a more complex problem, and this will illustrate very clearly the use of

504
00:41:38,030 --> 00:41:46,910
 monitors. Okay, so here is a problem. The problem is about accessing a database,

505
00:41:46,910 --> 00:41:56,830
 which is shared by multiple people. So you have a bunch, can have a bunch of people who want to

506
00:41:56,830 --> 00:42:03,870
 write and a bunch of people who want to read to the database. And these writes and read operations

507
00:42:03,870 --> 00:42:05,390
 happen concurrently.

508
00:42:05,700 --> 00:42:09,020
 and they modify the same data.

509
00:42:09,020 --> 00:42:14,360
 So how you are going to implement it?

510
00:42:14,360 --> 00:42:18,280
 One thing is to use a lock for the entire database.

511
00:42:18,280 --> 00:42:24,520
 You read or write, acquire the lock,

512
00:42:24,520 --> 00:42:26,880
 you do your job and release the lock.

513
00:42:26,880 --> 00:42:32,080
 So is that sufficient?

514
00:42:32,080 --> 00:42:34,240
 (silence)

515
00:42:34,240 --> 00:42:43,160
 That's a question for you.

516
00:42:43,160 --> 00:42:56,560
 Yes, it is sufficient, meaning that it's correct,

517
00:42:56,560 --> 00:42:59,760
 but it can be very slow, right?

518
00:42:59,760 --> 00:43:03,600
 I mean, if you think about fundamentally,

519
00:43:03,600 --> 00:43:05,900
 give me two examples why this is inefficient.

520
00:43:05,900 --> 00:43:11,560
 It's exactly, Aaron.

521
00:43:11,560 --> 00:43:13,280
 Aaron gave a great answer.

522
00:43:13,280 --> 00:43:15,700
 So basically, for instance,

523
00:43:15,700 --> 00:43:18,720
 if people only read from the database,

524
00:43:18,720 --> 00:43:21,520
 there is no need to lock it because nothing will change.

525
00:43:21,520 --> 00:43:23,760
 Okay?

526
00:43:23,760 --> 00:43:28,040
 Also, there are other reasons we are going to discuss later,

527
00:43:28,040 --> 00:43:31,680
 but even if you have writes,

528
00:43:31,680 --> 00:43:37,440
 then the writes can be different records.

529
00:43:37,440 --> 00:43:41,240
 They don't need to wait after each other.

530
00:43:41,240 --> 00:43:43,560
 We are not going to solve this problem here.

531
00:43:43,560 --> 00:43:46,980
 We are going to solve the first problem on multiple readers.

532
00:43:46,980 --> 00:43:50,680
 We should allow them to read the database

533
00:43:50,680 --> 00:43:53,000
 if there are no writers.

534
00:43:53,000 --> 00:43:54,460
 Read writers, yeah.

535
00:43:54,460 --> 00:43:56,560
 Okay?

536
00:43:56,560 --> 00:44:00,000
 Very good.

537
00:44:00,000 --> 00:44:03,400
 So let's see what you want from the solution.

538
00:44:03,400 --> 00:44:09,620
 Readers can access database when there are no writers.

539
00:44:09,620 --> 00:44:11,000
 It's exactly like we said.

540
00:44:11,000 --> 00:44:16,920
 If there are no writers, no value will change.

541
00:44:16,920 --> 00:44:23,600
 So therefore, any number of readers can read concurrently.

542
00:44:23,600 --> 00:44:28,600
 Writers can access database.

543
00:44:28,600 --> 00:44:31,680
 A writer can access a database

544
00:44:31,680 --> 00:44:34,480
 when there is no reader reading

545
00:44:34,480 --> 00:44:37,420
 and no other writer modifying the database.

546
00:44:37,420 --> 00:44:43,320
 And finally, we have some state variables

547
00:44:43,320 --> 00:44:48,880
 and we want only one thread to modify them at a given time.

548
00:44:48,880 --> 00:44:51,840
 Right?

549
00:44:51,840 --> 00:44:56,760
 This is, so this is the basic solution.

550
00:44:56,760 --> 00:44:58,560
 It's a structure.

551
00:44:58,560 --> 00:45:02,840
 For the reader, you wait until there are no writers,

552
00:45:02,840 --> 00:45:06,520
 access a database, check out,

553
00:45:06,520 --> 00:45:09,980
 and wake up waiting writers.

554
00:45:09,980 --> 00:45:17,160
 And the writer wait until there are no active readers

555
00:45:17,160 --> 00:45:20,240
 or writers, access database,

556
00:45:20,240 --> 00:45:23,120
 and then you check out and you wake up

557
00:45:23,120 --> 00:45:25,200
 other waiting readers or writers.

558
00:45:25,200 --> 00:45:27,220
 Right?

559
00:45:27,220 --> 00:45:34,060
 So let me ask you this question.

560
00:45:34,060 --> 00:45:39,680
 You see here, there is some asymmetry

561
00:45:39,680 --> 00:45:44,680
 and some asymmetry is derived from our constraints.

562
00:45:44,680 --> 00:45:46,760
 Right?

563
00:45:47,800 --> 00:45:50,760
 If a reader, it doesn't need to wait

564
00:45:50,760 --> 00:45:52,520
 until there are no other readers

565
00:45:52,520 --> 00:45:54,840
 because it doesn't conflict with other readers.

566
00:45:54,840 --> 00:45:57,400
 It can only conflict with writers.

567
00:45:57,400 --> 00:45:59,840
 So that's why you wait until no writers.

568
00:45:59,840 --> 00:46:03,080
 The writers is going to conflict both with the readers

569
00:46:03,080 --> 00:46:07,460
 and writers because if a reader is going to read the data

570
00:46:07,460 --> 00:46:09,660
 while the writer changing the data,

571
00:46:09,660 --> 00:46:12,320
 it can read, the reader can read garbage.

572
00:46:12,320 --> 00:46:15,680
 But then there is another asymmetry.

573
00:46:15,680 --> 00:46:17,920
 When a writer is done,

574
00:46:17,920 --> 00:46:22,920
 is going to wake up readers and writers,

575
00:46:22,920 --> 00:46:25,600
 while when the reader is done,

576
00:46:25,600 --> 00:46:28,760
 it's only try to wake up writers.

577
00:46:28,760 --> 00:46:30,340
 Why this asymmetry?

578
00:46:30,340 --> 00:46:32,120
 Why do you think?

579
00:46:32,120 --> 00:46:33,880
 Why do you think the reader

580
00:46:33,880 --> 00:46:35,960
 is not just waiting as the readers,

581
00:46:35,960 --> 00:46:37,400
 waking up as the readers?

582
00:46:37,400 --> 00:46:39,560
 (silence)

583
00:46:39,560 --> 00:46:54,640
 Very good.

584
00:46:54,640 --> 00:46:56,080
 The readers are all concurrent

585
00:46:56,080 --> 00:46:59,180
 so that it should be no as any other reader wake up.

586
00:46:59,180 --> 00:47:01,860
 Very good. Okay.

587
00:47:01,860 --> 00:47:04,160
 So let's move on.

588
00:47:05,140 --> 00:47:08,320
 So how do we implement this with our monitor?

589
00:47:08,320 --> 00:47:11,420
 It's a beautiful abstraction we just learned about.

590
00:47:11,420 --> 00:47:12,680
 All right.

591
00:47:12,680 --> 00:47:16,780
 So you see, wake up a waiting writer

592
00:47:16,780 --> 00:47:19,960
 and wake up waiting readers or writers.

593
00:47:19,960 --> 00:47:21,660
 These are, what are these?

594
00:47:21,660 --> 00:47:26,080
 You can implement them condition variables.

595
00:47:26,080 --> 00:47:29,740
 It's like signals and waiting

596
00:47:29,740 --> 00:47:31,280
 on that condition variable.

597
00:47:31,280 --> 00:47:33,060
 Okay.

598
00:47:33,980 --> 00:47:35,640
 So you have two condition variables.

599
00:47:35,640 --> 00:47:37,300
 Okay to read, okay to write.

600
00:47:37,300 --> 00:47:42,140
 And then what are the state variables?

601
00:47:42,140 --> 00:47:46,200
 Well, the number of active readers,

602
00:47:46,200 --> 00:47:50,280
 number of active writers.

603
00:47:50,280 --> 00:47:54,160
 How many active writers can have at a given time?

604
00:47:54,160 --> 00:47:57,880
 One, right?

605
00:47:57,880 --> 00:48:01,620
 Remember, we cannot have two writers at the same time.

606
00:48:03,880 --> 00:48:06,040
 Then you have the number of waiting readers.

607
00:48:06,040 --> 00:48:08,900
 Are there readers which are waiting to read?

608
00:48:08,900 --> 00:48:10,580
 And the number of waiting writers.

609
00:48:10,580 --> 00:48:14,560
 When do you have readers waiting?

610
00:48:14,560 --> 00:48:30,440
 Yes. When there is one active writer.

611
00:48:30,440 --> 00:48:33,560
 Very good.

612
00:48:33,560 --> 00:48:38,560
 So let's write the code for the reader.

613
00:48:38,560 --> 00:48:53,180
 So here it now look like.

614
00:48:53,180 --> 00:48:58,460
 Acquire lock, release lock.

615
00:49:00,640 --> 00:49:05,640
 Because within this code

616
00:49:05,640 --> 00:49:10,440
 manipulates the state variables.

617
00:49:10,440 --> 00:49:12,260
 Okay.

618
00:49:12,260 --> 00:49:16,360
 It's a reader.

619
00:49:16,360 --> 00:49:22,880
 So I am looking if there are no active writers

620
00:49:22,880 --> 00:49:24,840
 or waiting writers.

621
00:49:24,840 --> 00:49:27,120
 Right?

622
00:49:29,080 --> 00:49:32,920
 So if there are, is there active writers

623
00:49:32,920 --> 00:49:37,920
 and waiting writers, then you wait.

624
00:49:37,920 --> 00:49:42,720
 You implement the number of waiting readers

625
00:49:42,720 --> 00:49:46,540
 because now is myself.

626
00:49:46,540 --> 00:49:47,640
 I'm going to wait.

627
00:49:47,640 --> 00:49:56,420
 And then I'm going to wait on the condition variables.

628
00:49:56,420 --> 00:49:58,340
 Okay to read.

629
00:49:58,340 --> 00:50:01,160
 And I need to wait until it's okay for me to read.

630
00:50:01,160 --> 00:50:03,640
 And release a lock.

631
00:50:03,640 --> 00:50:13,100
 Now, why I'm doing here, I am waiting for both.

632
00:50:13,100 --> 00:50:15,980
 Active writers is normal, right?

633
00:50:15,980 --> 00:50:18,680
 I cannot read on someone who is writing.

634
00:50:18,680 --> 00:50:21,360
 But why I'm waiting also for waiting writers?

635
00:50:21,360 --> 00:50:26,360
 Because this means that I'm going to wait for other writers

636
00:50:26,360 --> 00:50:30,940
 to write before me, before I can read.

637
00:50:30,940 --> 00:50:33,620
 Why is that?

638
00:50:33,620 --> 00:50:34,780
 Why do you think it's that?

639
00:50:55,100 --> 00:51:00,100
 So a few people say we don't read garbage

640
00:51:00,100 --> 00:51:03,100
 or we don't read what are our results.

641
00:51:03,100 --> 00:51:04,280
 But why is that?

642
00:51:04,280 --> 00:51:06,480
 Because why would we do that?

643
00:51:06,480 --> 00:51:09,840
 Because in that case, you can have,

644
00:51:09,840 --> 00:51:11,300
 so here is what can happen.

645
00:51:11,300 --> 00:51:19,280
 You have a bunch of readers, no writers in the system.

646
00:51:21,440 --> 00:51:25,100
 And now I have a writer who wants to write.

647
00:51:25,100 --> 00:51:28,480
 And that writer has to wait

648
00:51:28,480 --> 00:51:30,360
 for the current readers to complete.

649
00:51:30,360 --> 00:51:33,880
 And in the meantime, I have another reader

650
00:51:33,880 --> 00:51:34,880
 which wants to read.

651
00:51:34,880 --> 00:51:40,280
 And I'm not going to let this reader read the database

652
00:51:40,280 --> 00:51:44,400
 together with the other readers before the writer

653
00:51:44,400 --> 00:51:49,040
 is scheduled to write and update the database.

654
00:51:50,780 --> 00:51:51,620
 Okay.

655
00:51:51,620 --> 00:51:57,620
 So it won't result in wrong results, right?

656
00:51:57,620 --> 00:52:05,340
 What the reason you do this, right?

657
00:52:05,340 --> 00:52:09,040
 So, but it is fundamentally what this gives.

658
00:52:09,040 --> 00:52:14,040
 It gives priority to the waiting writers, right?

659
00:52:14,040 --> 00:52:19,680
 That what happens, right?

660
00:52:20,680 --> 00:52:24,560
 And why do we do give priority to the waiting writers?

661
00:52:24,560 --> 00:52:30,300
 Is the reason was, you know, the answer is correct

662
00:52:30,300 --> 00:52:35,300
 is from Akshay is that you want to read the most up to date.

663
00:52:35,300 --> 00:52:36,920
 to read the most up-to-date.

664
00:52:37,130 --> 00:52:46,970
 information. Otherwise, you can starve writers. If you always have readers coming in, you

665
00:52:46,970 --> 00:52:58,010
 will never update the database. Before a reader terminates, finishes, you have another reader.

666
00:52:58,010 --> 00:53:05,690
 You are going to schedule that reader and so forth. So the writer will not be able to

667
00:53:05,690 --> 00:53:18,910
 be scheduled. OK, sounds good. So anyway, so after if there is no active writers or

668
00:53:18,910 --> 00:53:26,570
 waiting writers, then you are going to increment the number of active readers, because now

669
00:53:26,570 --> 00:53:31,770
 you are becoming you are allowed to read. So you are active reader and you release a

670
00:53:31,770 --> 00:53:45,690
 lock. You access the database, it's read only, right? And then after you are done, you acquire

671
00:53:45,690 --> 00:53:59,090
 the lock and to manipulate the state variables and you decrement the active readers because

672
00:53:59,090 --> 00:54:11,290
 I'm done. And now what do I need to do? Well, what I need to do is to wait, wake up threads

673
00:54:11,290 --> 00:54:20,650
 which may wait. For instance, to write to the database. So here, if active readers is

674
00:54:20,650 --> 00:54:47,410
 zero. And there are waiting writers. Then I'm going to send a signal OK to write. OK.

675
00:54:47,410 --> 00:54:56,930
 Simon has a great question here. What if new writers are coming all the time? When do you

676
00:54:56,930 --> 00:55:04,050
 get to read if you keep waiting for all writers to finish? That's correct. OK. So in this

677
00:55:04,050 --> 00:55:09,490
 particular case, you know, yeah, if writers come up all the time, you are not going to

678
00:55:09,490 --> 00:55:18,450
 get a chance to read. In practice, you need to be a little bit more sophisticated. But

679
00:55:18,450 --> 00:55:27,690
 that's a good point.

680
00:55:27,690 --> 00:55:33,970
 So this is one question here is why do you want why you release locks there? Why don't

681
00:55:33,970 --> 00:55:47,650
 you release a lock all the way to the end? Why is not access database part of the critical

682
00:55:47,650 --> 00:56:04,410
 section here? Yes, so any readers can get the lock. Right. You don't change the state

683
00:56:04,410 --> 00:56:10,450
 variables. The locks are for changing the state variables. And in this particular case,

684
00:56:10,450 --> 00:56:16,330
 you also want all the readers. If they are only active readers in the system. If they

685
00:56:16,330 --> 00:56:31,850
 are only that's in the system, you want them to read concurrently. Right. Very good answers.

686
00:56:31,850 --> 00:56:40,690
 Now let's see the code for the writer. It's very similar. Right. You acquire the lock

687
00:56:40,690 --> 00:56:48,490
 and now you check whether you can write. And what is that is there? There should be no

688
00:56:48,490 --> 00:56:54,970
 active readers. You cannot write while you have readers reading the data, manipulating

689
00:56:54,970 --> 00:57:06,650
 the state variables. And obviously you cannot have writers, active writers. You don't if

690
00:57:06,650 --> 00:57:12,530
 you have any of those, you go to wait and you wait on the conditional variable. OK,

691
00:57:12,530 --> 00:57:18,690
 to write because you are a writer. If not, you are going to increment active writers

692
00:57:18,690 --> 00:57:28,010
 because now you are an active writer. Release a lock. You access a database read write.

693
00:57:28,010 --> 00:57:32,250
 And then once you are done, you acquire the lock again to manipulate the state variables

694
00:57:32,250 --> 00:57:38,490
 to decrement the number of active writers, because now you are no longer writing. And

695
00:57:38,490 --> 00:57:44,410
 then you check if the number of if there are still waiting writers, you are going to wake

696
00:57:44,410 --> 00:57:56,970
 up. One of those by sending signal. And now, if that's not the case and the number of waiting

697
00:57:56,970 --> 00:58:04,170
 writers is zero. But there are waiting readers. Then you send a broadcast. OK, to read. So

698
00:58:04,170 --> 00:58:13,610
 now you can you see that use of the broadcast. You are going to wake up all the readers.

699
00:58:13,610 --> 00:58:33,130
 Because all the readers can read at the same time. Concurrent. OK. OK, let me ask this

700
00:58:33,130 --> 00:58:41,130
 answer this question. Does the question is, does there exist some situations that the

701
00:58:41,130 --> 00:58:50,410
 reader is waiting to read some intermediate state while some writer joins the wait? Yes,

702
00:58:50,410 --> 00:58:57,050
 definitely. Yeah, but the writer is not going to be able to modify that state. So we are

703
00:58:57,050 --> 00:58:59,930
 going to be fine.

704
00:58:59,930 --> 00:59:12,890
 Oh, sorry. So basically, you say if I read. Yes. So the reader is already waiting. And

705
00:59:12,890 --> 00:59:24,050
 now, yes, a new writer joins the wait. Yes, so that's valid. And in that particular case,

706
00:59:24,050 --> 00:59:35,130
 the writer will be prioritized over the reader. But it's again, at a given time, only one reader

707
00:59:35,130 --> 00:59:50,330
 and only one writer can manipulate the state variables. So it should be fine. OK, we discussed

708
00:59:50,330 --> 01:00:02,770
 why giving the priority to writers earlier on. OK, so now. Let's do the following we

709
01:00:02,770 --> 01:00:16,250
 are going to in order to. You know, get. Hopefully, you better understand what's happening here.

710
01:00:16,250 --> 01:00:26,490
 Let's go through a simulation. OK. So. Let's see, let's assume the following sequence of

711
01:00:26,490 --> 01:00:38,450
 operators operations. We have three writers and one writer, a series of three readers

712
01:00:38,450 --> 01:00:48,010
 are one or two and three and one writer. OK, so first to get the first reader, the second,

713
01:00:48,010 --> 01:00:54,650
 the second reader, then the writer and then the third reader. Initially, all the state

714
01:00:54,650 --> 01:01:05,770
 variables are set to zero. So let's see what happens. R1 comes along. There are no waiting

715
01:01:05,770 --> 01:01:14,870
 states, there are no other states in the system. So let's see what happens. It acquires a lock.

716
01:01:14,870 --> 01:01:20,850
 Check whether there is an active writer or a waiting writer. Both of these variables

717
01:01:20,850 --> 01:01:30,290
 are zero. None of them, none of such state in the system. So you exit the while loop.

718
01:01:30,290 --> 01:01:40,130
 And R1 can start reading. You increment the active reader variable. You read the lock.

719
01:01:40,130 --> 01:01:49,690
 OK, we know that why. You access the database. And let's say that while you are accessing

720
01:01:49,690 --> 01:02:03,290
 the database. R2 comes along. OK. Remember, now the number of active readers, it's one

721
01:02:03,290 --> 01:02:13,370
 because R1 is still accessing the database. So what is R1, R2 doing? Obviously, it's going

722
01:02:13,370 --> 01:02:19,130
 to execute the same code. It's acquiring the lock. Now it's checking whether it's an active

723
01:02:19,130 --> 01:02:31,330
 writer or a waiting writer. None of this, none such thread is in the system. So again,

724
01:02:31,330 --> 01:02:40,130
 you skip the while loop and increment the number of active writers. Release the lock

725
01:02:40,130 --> 01:02:46,450
 and you access the database. So now both R1 and R2 are accessing the database. The number

726
01:02:46,450 --> 01:03:05,170
 of active writers is two. All the other state variables are zero. OK. So now it's again,

727
01:03:05,170 --> 01:03:08,090
 Assume that it does take a while to access database.

728
01:03:08,550 --> 01:03:24,590
 And assume that during this time, now when W, the writer,

729
01:03:24,590 --> 01:03:26,150
 the writer comes along, W1.

730
01:03:26,150 --> 01:03:30,510
 So what is that?

731
01:03:30,510 --> 01:03:33,270
 The writer is going to execute the writer code.

732
01:03:33,270 --> 01:03:37,790
 So it acquires a lock.

733
01:03:37,790 --> 01:03:40,990
 And now it looks at active writers and active readers

734
01:03:40,990 --> 01:03:43,350
 in the system.

735
01:03:43,350 --> 01:03:47,830
 There are two active readers, now active writers.

736
01:03:47,830 --> 01:03:55,070
 Still, because there are two active readers,

737
01:03:55,070 --> 01:03:59,830
 the writer cannot proceed.

738
01:03:59,830 --> 01:04:01,470
 So what do you do?

739
01:04:01,470 --> 01:04:06,070
 You increment the number of waiting writers,

740
01:04:06,070 --> 01:04:08,790
 because now you have to wait.

741
01:04:08,790 --> 01:04:15,150
 And you wait on OK to write condition variable,

742
01:04:15,150 --> 01:04:16,190
 and you release a lock.

743
01:04:16,190 --> 01:04:26,430
 So W1 cannot start because of readers.

744
01:04:26,430 --> 01:04:31,590
 Finally, R3 comes along.

745
01:04:34,190 --> 01:04:37,630
 Acquires a lock.

746
01:04:37,630 --> 01:04:40,390
 And now it checks whether there are active writers or waiting

747
01:04:40,390 --> 01:04:41,990
 writers.

748
01:04:41,990 --> 01:04:45,670
 There are no active writers, but there is one waiting writers,

749
01:04:45,670 --> 01:04:47,910
 W1.

750
01:04:47,910 --> 01:04:54,190
 So therefore, the new reader, R3, has to wait.

751
01:04:54,190 --> 01:05:03,550
 So increment waiting readers now by one.

752
01:05:03,550 --> 01:05:08,270
 And you are going to wait for the condition variable OK to read.

753
01:05:08,270 --> 01:05:09,390
 And you release a lock.

754
01:05:09,390 --> 01:05:17,870
 Any questions here?

755
01:05:17,870 --> 01:05:18,950
 Is that clear so far?

756
01:05:18,950 --> 01:05:33,910
 [AUDIO OUT]

757
01:05:33,910 --> 01:05:36,030
 OK, so let's go with our simulation.

758
01:05:36,030 --> 01:05:38,070
 So status rate is time.

759
01:05:38,070 --> 01:05:40,630
 R1 and R2 are still reading.

760
01:05:40,630 --> 01:05:43,990
 W and R3 are waiting.

761
01:05:43,990 --> 01:05:44,470
 OK?

762
01:05:47,390 --> 01:05:49,150
 So let's say R2 finishes.

763
01:05:49,150 --> 01:06:00,470
 R1, still accessing database, W1 and R3 are still waiting.

764
01:06:00,470 --> 01:06:06,030
 So R2 is going to acquire the lock

765
01:06:06,030 --> 01:06:07,670
 to update the state variables.

766
01:06:07,670 --> 01:06:10,750
 In particular, to update the number of active readers now

767
01:06:10,750 --> 01:06:15,750
 is less to decrement it, because R2 finishes.

768
01:06:15,750 --> 01:06:18,990
 And now it's looking whether the active--

769
01:06:18,990 --> 01:06:23,310
 whether it can wake up any threat.

770
01:06:23,310 --> 01:06:25,430
 And he's looking whether there are active readers,

771
01:06:25,430 --> 01:06:30,510
 if there are no active readers, and there are waiting writers.

772
01:06:30,510 --> 01:06:31,830
 OK?

773
01:06:31,830 --> 01:06:34,510
 So he's looking for that.

774
01:06:34,510 --> 01:06:42,430
 And then the condition is false, because there are still

775
01:06:42,430 --> 01:06:44,510
 active readers.

776
01:06:44,510 --> 01:06:46,510
 This is R1.

777
01:06:46,510 --> 01:06:49,550
 So then you release the lock.

778
01:06:49,550 --> 01:06:51,310
 And R1 now is done.

779
01:06:51,310 --> 01:06:56,590
 OK?

780
01:06:56,590 --> 01:07:02,830
 Now let's say R1 finishes--

781
01:07:02,830 --> 01:07:04,830
 sorry, R2 is done.

782
01:07:04,830 --> 01:07:05,470
 Right?

783
01:07:05,470 --> 01:07:07,110
 Now say R1 finishes.

784
01:07:07,110 --> 01:07:08,830
 He's doing the same thing.

785
01:07:08,830 --> 01:07:12,190
 Acquires the lock, decrements the number of active readers.

786
01:07:12,190 --> 01:07:15,510
 Now both R1 and R2 are going to be done.

787
01:07:15,510 --> 01:07:19,230
 And now active readers become 0.

788
01:07:19,230 --> 01:07:21,110
 And are there waiting writers?

789
01:07:21,110 --> 01:07:24,470
 Yes, there is W1.

790
01:07:24,470 --> 01:07:28,510
 So now this condition is true.

791
01:07:28,510 --> 01:07:33,230
 And now you are going to signal to the writer

792
01:07:33,230 --> 01:07:36,670
 that it's OK to write.

793
01:07:36,670 --> 01:07:37,150
 OK?

794
01:07:41,590 --> 01:07:43,350
 So all right readers are done.

795
01:07:43,350 --> 01:07:45,710
 You can signal to writer that W1.

796
01:07:45,710 --> 01:07:54,110
 So now the writer, which was waiting

797
01:07:54,110 --> 01:07:59,270
 on the condition variable OK to write, receives a signal.

798
01:07:59,270 --> 01:08:00,950
 It's moved to the ready queue.

799
01:08:00,950 --> 01:08:05,870
 And now we can start executing it, executing this thread.

800
01:08:05,870 --> 01:08:09,910
 It acquires a lock back, because remember, we are still

801
01:08:09,910 --> 01:08:13,750
 in the critical section.

802
01:08:13,750 --> 01:08:16,630
 Decrements number of waiting writers.

803
01:08:16,630 --> 01:08:19,670
 I am no longer waiting now.

804
01:08:19,670 --> 01:08:21,790
 Increments the number of active writers.

805
01:08:21,790 --> 01:08:24,590
 I am active now.

806
01:08:24,590 --> 01:08:27,070
 But it is a lock and access a database.

807
01:08:27,070 --> 01:08:31,750
 And again, although I am writing now,

808
01:08:31,750 --> 01:08:37,510
 it's still OK to access a database outside the locks,

809
01:08:37,510 --> 01:08:39,990
 because this database is going to be accessed.

810
01:08:39,990 --> 01:08:47,790
 You can show only if the number of active writers is 1.

811
01:08:47,790 --> 01:08:50,150
 You are guaranteed that it will not be greater than 1.

812
01:08:50,150 --> 01:08:56,790
 Then say you are done.

813
01:08:56,790 --> 01:08:59,430
 You acquire the lock.

814
01:08:59,430 --> 01:09:03,510
 You decrement the number of active writers.

815
01:09:03,510 --> 01:09:06,670
 And now you look to signal.

816
01:09:06,670 --> 01:09:10,110
 Again, you give priority to the waiting writers,

817
01:09:10,110 --> 01:09:14,670
 because you want prioritized writings of readings.

818
01:09:14,670 --> 01:09:18,350
 So if there are waiting writers, you'll call OK to write.

819
01:09:18,350 --> 01:09:20,590
 But in this case, there are no longer waiting writers.

820
01:09:20,590 --> 01:09:26,510
 So therefore, you are going to look

821
01:09:26,510 --> 01:09:28,550
 where there are waiting readers.

822
01:09:28,550 --> 01:09:29,870
 And yes, there is one.

823
01:09:29,870 --> 01:09:32,550
 It's R3.

824
01:09:32,550 --> 01:09:36,270
 So then you are going to signal to R3

825
01:09:36,270 --> 01:09:40,110
 that it's OK to continue to read.

826
01:09:40,110 --> 01:09:49,190
 And now I start executing the code for R3,

827
01:09:49,190 --> 01:09:55,870
 who is resuming the execution, acquires a lock back,

828
01:09:55,870 --> 01:10:00,910
 decrements the waiting readers, access the database,

829
01:10:00,910 --> 01:10:04,630
 acquires a lock, decrements the number of active readers,

830
01:10:04,630 --> 01:10:07,070
 reads a lock.

831
01:10:07,070 --> 01:10:09,310
 So we are done.

832
01:10:09,310 --> 01:10:11,630
 So now all the readers are done.

833
01:10:11,630 --> 01:10:12,830
 All the writers are done.

834
01:10:12,830 --> 01:10:29,870
 So here is a question from Haoyuan.

835
01:10:29,870 --> 01:10:33,790
 If we want to signal the writer with a fixed order,

836
01:10:33,790 --> 01:10:36,870
 how should we modify our code?

837
01:10:36,870 --> 01:10:38,510
 Any suggestion here?

838
01:10:38,510 --> 01:10:41,470
 So the question, the way I understand it,

839
01:10:41,470 --> 01:10:45,190
 if we want to signal the writers in a particular order,

840
01:10:45,190 --> 01:10:46,350
 how do we signal them?

841
01:10:46,350 --> 01:10:48,790
 [SILENCE]

842
01:10:48,790 --> 01:11:05,750
 Any suggestion here from the class?

843
01:11:05,750 --> 01:11:07,710
 [SILENCE]

844
01:11:07,710 --> 01:11:18,190
 Yes, that's great.

845
01:11:18,190 --> 01:11:25,870
 Yeah, there are two ways to do it.

846
01:11:25,870 --> 01:11:26,710
 One is the way.

847
01:11:26,710 --> 01:11:33,670
 You can use a different condition variable

848
01:11:33,670 --> 01:11:35,270
 for each writer.

849
01:11:35,270 --> 01:11:37,510
 Very good.

850
01:11:37,510 --> 01:11:40,950
 The other one is to have more condition variables

851
01:11:40,950 --> 01:11:49,270
 than to have a queue of writers to maintain it,

852
01:11:49,270 --> 01:11:53,710
 and only wake up the one from the head of the queue.

853
01:11:53,710 --> 01:11:57,070
 But it's pretty complicated.

854
01:11:57,070 --> 01:11:59,390
 But anyway, it's a possibility.

855
01:12:03,670 --> 01:12:06,510
 Very good.

856
01:12:06,510 --> 01:12:08,190
 OK.

857
01:12:08,190 --> 01:12:10,230
 So we are all done.

858
01:12:10,230 --> 01:12:12,390
 So here are some questions.

859
01:12:12,390 --> 01:12:12,950
 Let's see.

860
01:12:12,950 --> 01:12:17,390
 Let's check your understanding.

861
01:12:17,390 --> 01:12:27,390
 So let's say-- sorry.

862
01:12:30,830 --> 01:12:33,710
 Can readers starve?

863
01:12:33,710 --> 01:12:34,230
 Yeah.

864
01:12:34,230 --> 01:12:41,630
 You-- we answered this question.

865
01:12:41,630 --> 01:12:47,230
 Readers can starve if you have continuous stream of writers.

866
01:12:47,230 --> 01:12:48,430
 Here's the second question.

867
01:12:48,430 --> 01:12:53,230
 What if we erase a condition check in reader exit?

868
01:12:53,230 --> 01:12:53,750
 This one.

869
01:12:59,710 --> 01:13:05,310
 So basically, we say, whatever a reader finishes,

870
01:13:05,310 --> 01:13:06,430
 say it's OK to write.

871
01:13:06,430 --> 01:13:12,270
 What will happen?

872
01:13:12,270 --> 01:13:21,750
 Is this a good idea?

873
01:13:21,750 --> 01:13:24,710
 Is this work going to work?

874
01:13:24,710 --> 01:13:25,750
 Any drawbacks?

875
01:13:25,750 --> 01:13:38,710
 [BLANK_AUDIO]

876
01:13:38,710 --> 01:13:39,670
 OK.

877
01:13:39,980 --> 01:13:42,900
 One answer here is writers can start writing

878
01:13:42,900 --> 01:13:44,340
 when readers are reading,

879
01:13:44,340 --> 01:13:47,280
 other set can be reading.

880
01:13:47,280 --> 01:13:48,680
 Okay, let's look.

881
01:13:48,680 --> 01:13:51,380
 Let's look at this one.

882
01:13:51,380 --> 01:13:55,260
 In order to answer that question,

883
01:13:55,260 --> 01:13:57,360
 let's look at the code.

884
01:13:57,360 --> 01:13:59,980
 Okay to write.

885
01:13:59,980 --> 01:14:01,800
 So this is a writer code.

886
01:14:01,800 --> 01:14:03,820
 Here.

887
01:14:03,820 --> 01:14:07,860
 Okay.

888
01:14:08,980 --> 01:14:10,580
 So what will happen here guys?

889
01:14:10,580 --> 01:14:15,540
 You see, you get okay to write.

890
01:14:15,540 --> 01:14:19,100
 You go out here,

891
01:14:19,100 --> 01:14:24,540
 it's waiting write to your decrement waiting writers.

892
01:14:24,540 --> 01:14:26,640
 But then what do you do next?

893
01:14:26,640 --> 01:14:28,260
 You go back to the while loop.

894
01:14:28,260 --> 01:14:32,180
 And in the while loop,

895
01:14:32,180 --> 01:14:35,060
 if there are still active writers or active readers,

896
01:14:37,740 --> 01:14:40,620
 you still cannot write.

897
01:14:40,620 --> 01:14:41,820
 You go to sleep again.

898
01:14:41,820 --> 01:14:45,300
 You see?

899
01:14:45,300 --> 01:14:46,540
 Because this while,

900
01:14:46,540 --> 01:14:49,540
 because you check again this state variables,

901
01:14:49,540 --> 01:14:56,220
 you are going to be fine.

902
01:14:56,220 --> 01:15:02,960
 What this will happen is that it just wakes a writer

903
01:15:02,960 --> 01:15:06,320
 just for the writer to go immediately back to sleep.

904
01:15:07,580 --> 01:15:09,740
 So you just graduate to context switching.

905
01:15:09,740 --> 01:15:13,940
 So it's a efficiency problem.

906
01:15:13,940 --> 01:15:15,500
 It's not a correctness problem.

907
01:15:15,500 --> 01:15:18,860
 Okay?

908
01:15:18,860 --> 01:15:23,440
 Good.

909
01:15:23,440 --> 01:15:25,480
 Let's go to the next one.

910
01:15:25,480 --> 01:15:33,040
 Let's go.

911
01:15:33,040 --> 01:15:33,880
 Okay.

912
01:15:33,880 --> 01:15:42,900
 Further, what if we turn the signal into broadcast?

913
01:15:42,900 --> 01:15:47,600
 Okay, instead of having a condition broadcast okay to write,

914
01:15:47,600 --> 01:15:50,760
 you broadcast okay to write to everyone

915
01:15:50,760 --> 01:15:52,480
 instead of the signal.

916
01:15:52,480 --> 01:15:54,440
 What will happen in this case?

917
01:15:54,440 --> 01:15:55,400
 Is it correct?

918
01:15:55,400 --> 01:15:59,300
 First question.

919
01:15:59,300 --> 01:16:02,060
 (mouse clicking)

920
01:16:02,060 --> 01:16:14,620
 Okay, let's try to give an answer.

921
01:16:14,620 --> 01:16:15,460
 Anyone?

922
01:16:15,460 --> 01:16:18,220
 (mouse clicking)

923
01:16:18,220 --> 01:16:30,140
 Yes.

924
01:16:30,140 --> 01:16:37,980
 It's actually, it's correct Sonali.

925
01:16:37,980 --> 01:16:41,100
 Yeah.

926
01:16:41,100 --> 01:16:41,940
 Yes.

927
01:16:41,940 --> 01:16:44,060
 And it's absolutely correct.

928
01:16:44,060 --> 01:16:46,220
 It's for the same reasons.

929
01:16:46,220 --> 01:16:49,020
 You see the fundamental observation here,

930
01:16:49,020 --> 01:16:52,500
 let me just, it's again.

931
01:16:52,500 --> 01:16:54,260
 The fundamental observation here,

932
01:16:54,260 --> 01:16:58,320
 it's again for the writer, I'm going here to the code.

933
01:16:58,320 --> 01:16:59,920
 You are still in the while loop.

934
01:16:59,920 --> 01:17:02,400
 So no matter, even if you are going to be

935
01:17:02,400 --> 01:17:05,620
 open up by mistake, no matter who is waking you up,

936
01:17:05,620 --> 01:17:07,980
 you are still going to check

937
01:17:07,980 --> 01:17:10,980
 whether there are active writers and active readers.

938
01:17:10,980 --> 01:17:12,860
 And if they are, you go back to sleep.

939
01:17:13,860 --> 01:17:16,900
 So it's inefficiency problem again.

940
01:17:16,900 --> 01:17:18,980
 It doesn't matter how many times you are waking up,

941
01:17:18,980 --> 01:17:21,880
 open up, you are not going to do stupid things.

942
01:17:21,880 --> 01:17:23,660
 Okay.

943
01:17:23,660 --> 01:17:27,240
 And the last one, finally,

944
01:17:27,240 --> 01:17:30,840
 if we use only one condition variable,

945
01:17:30,840 --> 01:17:34,280
 call it okay continue instead of two separate ones,

946
01:17:34,280 --> 01:17:37,580
 both readers and writers are going to wake up.

947
01:17:37,580 --> 01:17:40,980
 Is that going to be correct?

948
01:17:40,980 --> 01:17:43,140
 (silence)

949
01:17:43,140 --> 01:17:53,680
 Yes, it's going to be correct for the same reason.

950
01:17:53,680 --> 01:17:56,060
 Neither writer nor the right reader

951
01:17:56,060 --> 01:18:01,980
 are going to continue if the test for the while loop

952
01:18:01,980 --> 01:18:05,700
 is still true.

953
01:18:05,700 --> 01:18:07,900
 Okay.

954
01:18:10,860 --> 01:18:12,340
 So here is what happens.

955
01:18:12,340 --> 01:18:17,420
 Right, and this is what I'm going to end up with this one.

956
01:18:17,420 --> 01:18:19,900
 Okay.

957
01:18:19,900 --> 01:18:23,780
 So you can use one.

958
01:18:23,780 --> 01:18:28,220
 Right.

959
01:18:28,220 --> 01:18:31,060
 Okay.

960
01:18:31,060 --> 01:18:34,300
 Although there is in theory,

961
01:18:34,300 --> 01:18:37,860
 there is one thing here, right?

962
01:18:37,860 --> 01:18:39,340
 And this is subtle things.

963
01:18:40,440 --> 01:18:43,640
 This is correct with one condition, okay, to continue.

964
01:18:43,640 --> 01:18:46,560
 Right.

965
01:18:46,560 --> 01:18:51,560
 It's actually, if I, okay, continue,

966
01:18:51,560 --> 01:18:55,320
 is going to wake up one single thread

967
01:18:55,320 --> 01:18:58,060
 and that single thread is an incorrect one and go to sleep.

968
01:18:58,060 --> 01:18:59,900
 So here is the thing.

969
01:18:59,900 --> 01:19:03,240
 If I wake up, if I do,

970
01:19:03,240 --> 01:19:05,200
 if I have only one okay, okay,

971
01:19:05,200 --> 01:19:07,540
 continue conditional variable,

972
01:19:07,540 --> 01:19:11,700
 both the writers and the readers are going to wake up on that

973
01:19:11,700 --> 01:19:16,200
 and now assume that by mistake, not by mistake,

974
01:19:16,200 --> 01:19:17,560
 it just happens.

975
01:19:17,560 --> 01:19:19,640
 I wake up the reader.

976
01:19:19,640 --> 01:19:23,040
 The reader is going to check and there are waiting writers

977
01:19:23,040 --> 01:19:25,080
 and it's going to go immediately to sleep.

978
01:19:25,080 --> 01:19:28,420
 But now the signals were spent out.

979
01:19:28,420 --> 01:19:30,900
 Okay.

980
01:19:30,900 --> 01:19:33,920
 And the writer cannot continue.

981
01:19:33,920 --> 01:19:36,580
 It's already, it's asleep.

982
01:19:36,580 --> 01:19:37,940
 The reader is asleep.

983
01:19:37,940 --> 01:19:41,600
 And if there is no other thread coming in,

984
01:19:41,600 --> 01:19:42,500
 we are deadlocked.

985
01:19:42,500 --> 01:19:45,540
 In order for this to work,

986
01:19:45,540 --> 01:19:50,480
 it will also change this signal

987
01:19:50,480 --> 01:19:52,640
 from the writer reader to broadcast.

988
01:19:52,640 --> 01:19:54,440
 Okay.

989
01:19:54,440 --> 01:19:58,300
 Okay. So you need to broadcast.

990
01:19:58,300 --> 01:20:01,340
 Okay.

991
01:20:01,340 --> 01:20:03,720
 And you also need to broadcast.

992
01:20:03,720 --> 01:20:05,260
 So you need to do some changes.

993
01:20:06,260 --> 01:20:11,100
 So the summary here,

994
01:20:11,100 --> 01:20:13,180
 and we are going to end up with this,

995
01:20:13,180 --> 01:20:18,180
 is that these while loops are extremely powerful, right?

996
01:20:18,180 --> 01:20:23,880
 Because they are going to guard against doing stupid things

997
01:20:23,880 --> 01:20:25,420
 or incorrect things.

998
01:20:25,420 --> 01:20:28,600
 If you are woken up by mistake.

999
01:20:28,600 --> 01:20:32,100
 So we are safe.

1000
01:20:32,100 --> 01:20:34,580
 So what we need to be careful about

1001
01:20:34,580 --> 01:20:36,820
 is that because there is no history

1002
01:20:36,820 --> 01:20:38,520
 with this condition variables,

1003
01:20:38,520 --> 01:20:42,980
 I am protected to waking up the wrong thread.

1004
01:20:42,980 --> 01:20:47,100
 But then if I am waking up the wrong thread,

1005
01:20:47,100 --> 01:20:49,380
 that signal was wasted.

1006
01:20:49,380 --> 01:20:54,280
 And the correct thread will not be woken up.

1007
01:20:54,280 --> 01:20:55,780
 So you can have deadlocks.

1008
01:20:55,780 --> 01:21:00,780
 So that's why here you need to be careful.

1009
01:21:00,780 --> 01:21:03,360
 What do you need to be careful about?

1010
01:21:03,360 --> 01:21:05,960
 That's why you have to be liberal with the broadcast.

1011
01:21:05,960 --> 01:21:10,380
 So we are going to end up with this one.

1012
01:21:10,380 --> 01:21:13,180
 And I think that it's a good place.

1013
01:21:13,180 --> 01:21:14,700
 We are done with this example.

1014
01:21:14,700 --> 01:21:20,260
 Please take a look at these examples carefully

1015
01:21:20,260 --> 01:21:24,260
 and for the exam.

1016
01:21:24,260 --> 01:21:28,180
 And I'll stop here and the lecture is done.

1017
01:21:28,180 --> 01:21:30,100
 I am going, there is one last question

1018
01:21:30,100 --> 01:21:32,980
 I'm going to try to answer.

1019
01:21:32,980 --> 01:21:34,080
 And thank you.

1020
01:21:34,080 --> 01:21:39,080
 And I'll see you on Monday, on Tuesday and Monday.

1021
01:21:39,080 --> 01:21:45,220
 And thank you.

1022
01:21:45,220 --> 01:21:49,080
 So two questions.

1023
01:21:49,080 --> 01:21:51,880
 One question, the while loop give us good protection,

1024
01:21:51,880 --> 01:21:54,280
 but doesn't that cost a lot of CPU cycles

1025
01:21:54,280 --> 01:21:56,000
 since we are constantly pulling?

1026
01:21:56,000 --> 01:21:56,940
 Absolutely.

1027
01:21:56,940 --> 01:21:58,040
 It's inefficiency.

1028
01:21:58,040 --> 01:22:01,280
 It's you are absolutely correct.

1029
01:22:01,280 --> 01:22:02,320
 It's inefficient.

1030
01:22:03,020 --> 01:22:04,560
 It's correct, but inefficient.

1031
01:22:04,560 --> 01:22:08,420
 And from chat,

1032
01:22:08,420 --> 01:22:13,340
 wouldn't this possibly make a finished writers broadcast

1033
01:22:13,340 --> 01:22:16,300
 hit a waiting reader first before a waiting reader

1034
01:22:16,300 --> 01:22:18,900
 if there are voice boss waiting readers and writer,

1035
01:22:18,900 --> 01:22:22,220
 which mean observed ordering priority of writers

1036
01:22:22,220 --> 01:22:23,580
 before readers.

1037
01:22:23,580 --> 01:22:27,860
 Yes, this will no longer guarantee the priority order

1038
01:22:27,860 --> 01:22:29,780
 between writers and readers.

1039
01:22:29,780 --> 01:22:31,820
 If you have only one condition variables,

1040
01:22:31,820 --> 01:22:36,820
 you are no longer going to be guaranteed this one necessary.

1041
01:22:36,820 --> 01:22:42,120
 And yeah, although it is still,

1042
01:22:42,120 --> 01:22:49,860
 you are not guaranteed the readers when you wake up,

1043
01:22:49,860 --> 01:22:53,100
 but still if you want to proceed,

1044
01:22:53,100 --> 01:22:55,620
 you are, the while loop will take care of that.

1045
01:22:55,620 --> 01:23:00,380
 So being from the point of view of accessing the database,

1046
01:23:00,380 --> 01:23:03,180
 the while loop is going to enforce the priority

1047
01:23:03,180 --> 01:23:08,180
 because a reader it's going to look

1048
01:23:08,180 --> 01:23:11,980
 whether there are active writers or waiting writers.

1049
01:23:11,980 --> 01:23:13,820
 And if there are waiting writers,

1050
01:23:13,820 --> 01:23:16,580
 it's not going to proceed, right?

1051
01:23:16,580 --> 01:23:19,200
 So as long as there are waiting writers,

1052
01:23:19,200 --> 01:23:21,800
 this while conditions will ensure

1053
01:23:21,800 --> 01:23:23,920
 that the reader cannot proceed.

1054
01:23:23,920 --> 01:23:28,920
 So actually the priority is still enforced.

1055
01:23:28,920 --> 01:23:33,040
 Okay, so the priority is enforced

1056
01:23:33,040 --> 01:23:34,680
 by the while of conditions.

1057
01:23:34,680 --> 01:23:40,140
 But the priority is not enforced in the sense

1058
01:23:40,140 --> 01:23:44,120
 that you can wake up a reader

1059
01:23:44,120 --> 01:23:46,840
 while you shouldn't have woken up.

1060
01:23:46,840 --> 01:23:51,840
 And this can lead again to deadlocks

1061
01:23:51,840 --> 01:23:57,040
 without changing the code and be more liberal

1062
01:23:57,240 --> 01:24:00,000
 in broadcasting the okay continue.

1063
01:24:00,000 --> 01:24:01,920
 Okay, thank you.

1064
01:24:01,920 --> 01:24:05,120
 And I'll see you on Tuesday and Monday.

1065
01:24:05,120 --> 01:24:05,960
 Bye bye.

1066
01:24:05,960 --> 01:24:08,120
 (silence)

1067
01:24:08,120 --> 01:24:10,120
 Thank you.

1068
01:24:10,120 --> 01:24:39,100
 [ Silence ]

