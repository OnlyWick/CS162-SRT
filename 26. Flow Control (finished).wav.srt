1
00:00:00,000 --> 00:00:25,760
 Hello everyone. Welcome to the next to last lecture of this semester. And yeah, to the

2
00:00:25,760 --> 00:00:31,680
 next to the last week of classes. So today we are going to have a very interesting lecture

3
00:00:31,680 --> 00:00:39,040
 and that will be on the DCP flow control and actually congestion control. And remember,

4
00:00:39,040 --> 00:00:45,520
 here we are talking about the transport layer. So this is about the networking stack, the internet

5
00:00:45,520 --> 00:00:55,280
 stack. And as you can see, the transport layer, if you remember, sits on top of the network layer.

6
00:00:56,240 --> 00:01:03,760
 And the transport layer, it's implemented actually is a first layer if you go from bottom up,

7
00:01:03,760 --> 00:01:11,040
 which is only implemented by n hosts. It's not implemented by the network.

8
00:01:11,040 --> 00:01:23,520
 And one of the key services that the transport layer is providing, if you remember,

9
00:01:24,480 --> 00:01:31,920
 it's multiplexing and demultiplexing connections on the same machines,

10
00:01:31,920 --> 00:01:40,240
 between the processes on the same machines. So the network layer doesn't differentiate

11
00:01:40,240 --> 00:01:48,640
 between processes. The network layer addresses only machines, only n hosts. So network layer

12
00:01:48,640 --> 00:02:00,640
 is going to take a packet and send it to another n host whose address is in the packet header as

13
00:02:00,640 --> 00:02:08,960
 destination address. But once the packet gets to that n host, it needs to be delivered to a

14
00:02:08,960 --> 00:02:17,920
 particular process, to a particular application to be processed. And the way you differentiate

15
00:02:17,920 --> 00:02:24,240
 between these different processes is using port numbers. So the transport layer is the one who

16
00:02:24,240 --> 00:02:32,080
 uses port numbers to demultiplex a packet when it arrives of an n host and deliver it to the proper

17
00:02:32,080 --> 00:02:40,800
 process. And again, if you remember, in the internet as a transport layer, we have two

18
00:02:40,800 --> 00:02:52,960
 protocols, UDP and TCP, user datagram protocol and transport control protocol. And the UDP doesn't do

19
00:02:52,960 --> 00:03:05,440
 much more besides multiplexing and demultiplexing of packets from n to processes. So we are not

20
00:03:05,440 --> 00:03:12,000
 going to talk more about that. Now, the transport control protocol, which is the one we are going to

21
00:03:12,000 --> 00:03:19,040
 talk most mostly in this lecture, is providing two additional services, flow control,

22
00:03:19,040 --> 00:03:25,600
 and we talk a little bit at the end of the last lecture, but I'm going to start again talking

23
00:03:25,600 --> 00:03:31,600
 about it. We have more time during this lecture and it's a very important topic, and congestion

24
00:03:31,600 --> 00:03:37,520
 control. And the difference between the two is that the flow control, the goal of the flow

25
00:03:37,520 --> 00:03:45,840
 control is to not overflow the receiver, a slower receiver. The congestion control is to not overflow

26
00:03:45,840 --> 00:03:52,960
 the network. Overflowing means that the sender sends more data than the receiver or the network

27
00:03:52,960 --> 00:04:00,000
 can handle. So during this lecture, we are going to talk about flow control and congestion control.

28
00:04:00,000 --> 00:04:03,040
 Any questions?

29
00:04:03,040 --> 00:04:09,600
 Okay, so again from the last lecture and from many, many lectures ago,

30
00:04:09,600 --> 00:04:17,680
 if you remember this producer consumer is a bounded buffer. Bounded buffer meaning that it

31
00:04:17,680 --> 00:04:27,440
 can accept only a finer set of items in the buffer. So this provides, implements a natural

32
00:04:28,320 --> 00:04:36,160
 form of flow control because if the consumer cannot consume as fast as the producer sends

33
00:04:36,160 --> 00:04:43,040
 the data into the buffer, inserts item into the buffer, the buffer will get filled and when the

34
00:04:43,040 --> 00:04:50,880
 buffer is full, the producer can no longer add new items in the buffer.

35
00:04:52,400 --> 00:05:00,320
 So the producer has to stop. So it's going to slow down over time to match the speed that

36
00:05:00,320 --> 00:05:06,800
 with the consumer can read the data from the buffer. Right? Make sense?

37
00:05:06,800 --> 00:05:18,720
 So that's pretty much it now. So obviously the one problem you have with this one and we are

38
00:05:18,720 --> 00:05:26,240
 going to discuss more about it is that if producer and consumer as a buffer are not single machine,

39
00:05:26,240 --> 00:05:30,880
 things are easy. But here the producer and consumers are on different machines.

40
00:05:30,880 --> 00:05:36,640
 So how do you know producer being on one machine, how does it know the buffer

41
00:05:36,640 --> 00:05:46,960
 on the consumer side is full? Right? So it needs to somehow ways for some acknowledgement from the

42
00:05:46,960 --> 00:05:58,640
 consumer that it's okay to send more data. The simplest version of that is called stop and wait

43
00:05:58,640 --> 00:06:04,800
 and it's as simple as you can think of. We are going to use a lot of this kind of diagram.

44
00:06:04,800 --> 00:06:15,840
 And you see you have sender and the receiver on both sides. And then the time goes down. Okay?

45
00:06:15,840 --> 00:06:24,960
 So the oldest time is at the top, the newest time is at the bottom. So stop and wait is very simple.

46
00:06:24,960 --> 00:06:31,760
 You send a packet and you wait for an acknowledgement. And only after you

47
00:06:31,760 --> 00:06:34,800
 got the acknowledgement, you send another packet.

48
00:06:38,240 --> 00:06:48,560
 Okay? Now there are several important aspects, you know, metrics here. So this is D,

49
00:06:48,560 --> 00:06:58,240
 which is a delay or one-way delay, how long it takes a packet to get to the receiver from the

50
00:06:58,240 --> 00:07:06,080
 sender. Right? And this is, it takes some time, you know, there are different overheads in the

51
00:07:06,080 --> 00:07:14,640
 network. And on top of that, obviously there is the speed of light. Okay? So across the continent,

52
00:07:14,640 --> 00:07:19,680
 I think is what, maybe 10, 20 milliseconds in US, something like that.

53
00:07:19,680 --> 00:07:26,400
 And now you need to wait for acknowledgement. So acknowledgement, it might take another

54
00:07:26,400 --> 00:07:33,360
 same amount of time, assuming that it's symmetric, the path is symmetric. It's not necessary for the

55
00:07:33,360 --> 00:07:39,680
 path to be symmetric because the packet from the sender to the receiver can go on a different path

56
00:07:39,680 --> 00:07:44,560
 from the sender to the back, from the receiver to the sender. And even if they go to the, on the

57
00:07:44,560 --> 00:07:50,320
 same path, there can be different level of congestion in the network. For instance, at a

58
00:07:50,320 --> 00:07:59,120
 given time in the day, it's not taking you the same time to go from Auckland to San Jose as to go

59
00:07:59,120 --> 00:08:07,920
 from San Jose to Auckland. Right? Different level of congestion. But anyway, for simplicity, assuming,

60
00:08:07,920 --> 00:08:15,440
 assume that you have the same one-way latency, as this assume no congestion. So if there are

61
00:08:15,440 --> 00:08:24,960
 no congestion, it does take the same amount of time. And now, so, but then you need to wait for

62
00:08:24,960 --> 00:08:31,680
 two times D in the best case scenario to get the acknowledgement back. And these two times

63
00:08:31,680 --> 00:08:36,880
 these round trip time, it's called round trip time. The round trip time is how long it takes

64
00:08:36,880 --> 00:08:49,120
 a packet to travel from sender to receiver and back. Okay? So now, what is the throughput? You

65
00:08:49,120 --> 00:08:56,240
 know, how many packets you can send? So let's say, let me give you some numbers.

66
00:08:56,240 --> 00:09:06,160
 So say that one-way latency is one millisecond. Okay? Using this protocol,

67
00:09:06,160 --> 00:09:13,120
 assuming that everything is symmetric, all the one-way latencies are the same for all packets.

68
00:09:13,760 --> 00:09:20,320
 How many packets I can send in one second? So one-way latency is one millisecond.

69
00:09:20,320 --> 00:09:28,400
 And I am asking you how many packets I can send in one second.

70
00:09:28,400 --> 00:09:37,300
 Okay.

71
00:09:40,480 --> 00:09:49,920
 500. That's correct, Simon. Indeed, that's the correct answer. And it's very simple, right? It's

72
00:09:49,920 --> 00:09:55,120
 like we can send only one packet per round trip time because we need to wait for the

73
00:09:55,120 --> 00:10:00,480
 acknowledgement before you send another packet. So the round trip time is twice the one-way

74
00:10:00,530 --> 00:10:04,530
 one-way delay latency is two milliseconds.

75
00:10:04,530 --> 00:10:07,970
 So one second over two milliseconds,

76
00:10:07,970 --> 00:10:12,570
 it's 1,000 milliseconds over two is 500.

77
00:10:12,570 --> 00:10:15,850
 Okay, good.

78
00:10:15,850 --> 00:10:20,130
 Sounds good, okay.

79
00:10:20,130 --> 00:10:23,490
 So how fast can you send data?

80
00:10:23,490 --> 00:10:25,490
 You answer that question.

81
00:10:25,490 --> 00:10:28,730
 Again, the little law applies on this case

82
00:10:28,730 --> 00:10:30,610
 as a number of packets,

83
00:10:30,610 --> 00:10:34,370
 it's B, how many packets you have in the system

84
00:10:34,370 --> 00:10:35,570
 times the round-trip time,

85
00:10:35,570 --> 00:10:40,570
 and B will be the number of packets you have in the system.

86
00:10:40,570 --> 00:10:43,650
 Sorry, the number of packets you have in the system,

87
00:10:43,650 --> 00:10:46,330
 it's only one packet, right?

88
00:10:46,330 --> 00:10:49,210
 So you have one packet per RTD, right?

89
00:10:49,210 --> 00:10:52,370
 Like we discussed, okay?

90
00:10:55,970 --> 00:10:59,130
 Now, let's do a little bit more complicated here.

91
00:10:59,130 --> 00:11:02,530
 Now you have, in this particular case,

92
00:11:02,530 --> 00:11:06,250
 you have what is the throughput

93
00:11:06,250 --> 00:11:07,730
 in terms of the number of bytes,

94
00:11:07,730 --> 00:11:09,970
 not in the number of packets, like I mentioned,

95
00:11:09,970 --> 00:11:12,290
 I asked you a little bit earlier.

96
00:11:12,290 --> 00:11:15,730
 So if you have the round-trip time of 100 milliseconds,

97
00:11:15,730 --> 00:11:18,730
 so one-way delay latency is 50 milliseconds,

98
00:11:18,730 --> 00:11:23,610
 and a packet has 1,500 bytes,

99
00:11:23,610 --> 00:11:26,970
 that what is the throughput in terms of bits per second.

100
00:11:26,970 --> 00:11:28,210
 So it's very simple, right?

101
00:11:28,210 --> 00:11:31,010
 You can send one packet,

102
00:11:31,010 --> 00:11:36,010
 means 1,500 times eight bits in 0.1 seconds.

103
00:11:36,010 --> 00:11:42,090
 So it's 120 kilobits per second, okay?

104
00:11:42,090 --> 00:11:48,730
 So the main point here though, is that, as you can see,

105
00:11:48,730 --> 00:11:50,210
 this is very simple protocol,

106
00:11:50,210 --> 00:11:51,690
 you can implement it right away.

107
00:11:51,690 --> 00:11:56,690
 So the advantage of this protocol, it's simplicity.

108
00:11:56,690 --> 00:12:01,770
 On the other hand, it's very inefficient.

109
00:12:01,770 --> 00:12:04,170
 You see, it's taking you,

110
00:12:04,170 --> 00:12:09,170
 you cannot send more than at 120 kilobits per second,

111
00:12:09,170 --> 00:12:11,770
 no matter how fast the network is.

112
00:12:11,770 --> 00:12:18,730
 Because in this case,

113
00:12:18,730 --> 00:12:22,010
 this throughput is governed only by the one-way latency.

114
00:12:22,010 --> 00:12:27,570
 And the one-way latency will not depend, in most cases,

115
00:12:27,570 --> 00:12:30,210
 if you think about it's mostly speed of light,

116
00:12:30,210 --> 00:12:33,570
 it will not depend if it's a speed of light component

117
00:12:33,570 --> 00:12:36,810
 of the latency of how fast is a network,

118
00:12:36,810 --> 00:12:37,850
 how fast is a link.

119
00:12:37,850 --> 00:12:40,890
 So if you have 100 megabits per second,

120
00:12:40,890 --> 00:12:42,530
 or one gigabits per second link,

121
00:12:42,530 --> 00:12:44,370
 or 10 gigabits per second link,

122
00:12:44,370 --> 00:12:48,610
 you can still only send at 120 kilobits per second.

123
00:12:48,610 --> 00:12:52,890
 So how can you send more?

124
00:12:52,890 --> 00:12:59,130
 How would you modify this protocol to send more data?

125
00:12:59,130 --> 00:13:10,010
 Batch acknowledgements.

126
00:13:10,010 --> 00:13:11,370
 So if you batch, it's true.

127
00:13:11,370 --> 00:13:13,330
 So, but if you batch the acknowledgement,

128
00:13:13,330 --> 00:13:16,090
 this means that you have to send a packet

129
00:13:16,090 --> 00:13:19,610
 before you receive the acknowledgement for that packet.

130
00:13:19,610 --> 00:13:23,490
 Your intuition is correct, but of course,

131
00:13:23,490 --> 00:13:30,450
 as you'll see, and that's a big part of the solution,

132
00:13:30,450 --> 00:13:32,770
 but as you'll see, things will not be as easy.

133
00:13:32,770 --> 00:13:39,490
 It's exactly Simon and Allison, yeah, it's the same.

134
00:13:39,490 --> 00:13:41,490
 You don't need to get block on NAC,

135
00:13:41,490 --> 00:13:43,490
 because if you get block on NAC,

136
00:13:43,490 --> 00:13:48,210
 then it's no longer, you can send out, send packets, right?

137
00:13:48,210 --> 00:13:56,450
 But the problem is the following.

138
00:13:56,450 --> 00:13:57,930
 Okay, you don't draw,

139
00:13:57,930 --> 00:14:01,530
 your intuition is absolutely correct.

140
00:14:01,530 --> 00:14:04,650
 The main problem here is that I need to wait

141
00:14:04,650 --> 00:14:06,650
 for an acknowledgement from the previous packet

142
00:14:06,650 --> 00:14:08,330
 before I can send the next packet.

143
00:14:08,330 --> 00:14:12,930
 And the solution is, okay, don't wait for that, right?

144
00:14:12,930 --> 00:14:14,170
 Send more packets.

145
00:14:14,170 --> 00:14:20,330
 That's the problem, and if you don't have losses,

146
00:14:20,330 --> 00:14:21,890
 that will be great.

147
00:14:21,890 --> 00:14:25,130
 But if the packets are lost,

148
00:14:25,130 --> 00:14:30,330
 then here the acknowledgement serves two purposes.

149
00:14:30,330 --> 00:14:36,330
 One, to slow you down, to slow the sender down, right?

150
00:14:36,330 --> 00:14:37,850
 To block the sender.

151
00:14:37,850 --> 00:14:40,050
 But the other one is also to say

152
00:14:40,050 --> 00:14:42,930
 that the packet has been successfully received.

153
00:14:42,930 --> 00:14:47,490
 So let's talk about losses.

154
00:14:47,490 --> 00:14:50,450
 So in the internet, you are going to have losses

155
00:14:50,450 --> 00:14:53,050
 like we discussed last time, right?

156
00:14:53,050 --> 00:14:56,450
 And actually TCP, transfer control protocol,

157
00:14:56,450 --> 00:14:58,810
 is going also to provide reliability

158
00:14:58,810 --> 00:15:01,050
 besides flow control and congestion control.

159
00:15:01,050 --> 00:15:05,850
 But as a network layer, you are going to have losses

160
00:15:05,850 --> 00:15:09,090
 because many reasons.

161
00:15:09,090 --> 00:15:11,410
 It's like we discussed in the past.

162
00:15:11,410 --> 00:15:15,770
 We have, you know, your microwave

163
00:15:15,770 --> 00:15:18,210
 can corrupt your wireless link.

164
00:15:18,210 --> 00:15:23,170
 Even in optical networks, the bits can be corrupted.

165
00:15:23,170 --> 00:15:28,490
 The wire can be bad, not very well connected.

166
00:15:28,490 --> 00:15:29,970
 And many reasons.

167
00:15:29,970 --> 00:15:34,970
 Or like we all see, the buffers in the routers

168
00:15:34,970 --> 00:15:38,850
 are going to overflow and you are going to drop packets.

169
00:15:38,850 --> 00:15:40,010
 Okay?

170
00:15:40,010 --> 00:15:45,010
 So now, when you, with a packet, you have associated,

171
00:15:45,010 --> 00:15:58,850
 basically, as you'll see,

172
00:15:58,850 --> 00:16:05,210
 so there are two ways to lose a packet here.

173
00:16:06,930 --> 00:16:09,410
 First of all, the packet doesn't get

174
00:16:09,410 --> 00:16:10,810
 to the destination at all.

175
00:16:10,810 --> 00:16:13,330
 It's lost.

176
00:16:13,330 --> 00:16:16,850
 The second one, the packet is corrupted.

177
00:16:16,850 --> 00:16:22,090
 So you get the packet, but some bits are flipped.

178
00:16:22,090 --> 00:16:24,290
 Okay?

179
00:16:24,290 --> 00:16:29,210
 So on the receiver side, you need to know that,

180
00:16:29,210 --> 00:16:32,570
 you need to make sure that you get all the packets.

181
00:16:32,570 --> 00:16:35,810
 The packets you got are not corrupted.

182
00:16:36,690 --> 00:16:38,490
 And by the way, you also want to make sure

183
00:16:38,490 --> 00:16:40,250
 that you get each packet exactly once

184
00:16:40,250 --> 00:16:41,730
 to deliver to the application.

185
00:16:41,730 --> 00:16:51,570
 So this acknowledgement, like we saw earlier on,

186
00:16:51,570 --> 00:16:54,210
 they also serve as an acknowledgement

187
00:16:54,210 --> 00:16:59,090
 that the packet was delivered to the destination.

188
00:16:59,090 --> 00:17:01,890
 Okay?

189
00:17:01,890 --> 00:17:06,290
 So basically, if I am the receiver,

190
00:17:06,290 --> 00:17:11,010
 I get the packet, I check the packet, whether it's correct.

191
00:17:11,010 --> 00:17:13,050
 How do I check the packet that is correct?

192
00:17:13,050 --> 00:17:15,050
 They have the correct information.

193
00:17:15,050 --> 00:17:15,970
 How do you do it?

194
00:17:15,970 --> 00:17:20,890
 Say you are the designer.

195
00:17:20,890 --> 00:17:29,490
 Oh yeah, this is, yeah, you do have a checksum.

196
00:17:29,490 --> 00:17:32,570
 Like a checksum, like parity bit,

197
00:17:32,570 --> 00:17:33,970
 something more sophisticated than that,

198
00:17:33,970 --> 00:17:34,930
 but that's the idea.

199
00:17:35,810 --> 00:17:36,730
 Right?

200
00:17:36,730 --> 00:17:39,130
 So the packet has a data and has a checksum.

201
00:17:39,130 --> 00:17:41,690
 Right?

202
00:17:41,690 --> 00:17:44,450
 So you take the data and you pre-compute the checksum

203
00:17:44,450 --> 00:17:45,290
 using the same algorithms.

204
00:17:45,290 --> 00:17:47,810
 And you compare that the computed checksum

205
00:17:47,810 --> 00:17:50,170
 is the same as the checksum in the packet.

206
00:17:50,170 --> 00:17:53,930
 If they are the same, you say this packet,

207
00:17:53,930 --> 00:17:56,010
 the data is correct.

208
00:17:56,010 --> 00:17:58,010
 Otherwise, you drop the packet.

209
00:17:58,010 --> 00:18:01,410
 Right?

210
00:18:02,250 --> 00:18:06,410
 Now, if a packet is dropped, like in our previous case,

211
00:18:06,410 --> 00:18:11,410
 right, the question is that I'm sending a packet,

212
00:18:11,410 --> 00:18:15,130
 the packet is lost, for instance,

213
00:18:15,130 --> 00:18:20,730
 or it gets to the destination, is dropped.

214
00:18:20,730 --> 00:18:23,450
 What am I going to do?

215
00:18:23,450 --> 00:18:29,450
 So what I'm going to do,

216
00:18:29,450 --> 00:18:31,330
 because I'm going to wait indefinitely,

217
00:18:31,330 --> 00:18:33,770
 because I'm going to wait for a knack,

218
00:18:33,770 --> 00:18:34,970
 which will never come.

219
00:18:34,970 --> 00:18:41,010
 So what you do here is basically very simple solution.

220
00:18:41,010 --> 00:18:45,250
 Basically, you wait for a timeout.

221
00:18:45,250 --> 00:18:48,010
 It's like you in real life.

222
00:18:48,010 --> 00:18:51,290
 You are waiting for your friend to call.

223
00:18:51,290 --> 00:18:57,810
 And he doesn't call at when it was the time you expected.

224
00:19:00,930 --> 00:19:01,770
 What do you do?

225
00:19:01,770 --> 00:19:07,890
 After a while, you are calling your friend, right?

226
00:19:07,890 --> 00:19:14,130
 Or you go to meet someone and that person doesn't show up.

227
00:19:14,130 --> 00:19:15,250
 What do you do?

228
00:19:15,250 --> 00:19:19,450
 You wait for a while and then you leave, right?

229
00:19:19,450 --> 00:19:23,850
 So now, obviously,

230
00:19:26,530 --> 00:19:31,410
 it's again, it's very important to notice here,

231
00:19:31,410 --> 00:19:35,650
 by the way, that if you don't get the acknowledgement,

232
00:19:35,650 --> 00:19:38,730
 it doesn't mean that the receiver,

233
00:19:38,730 --> 00:19:40,930
 that he didn't give the original message.

234
00:19:40,930 --> 00:19:42,010
 No, right?

235
00:19:42,010 --> 00:19:43,730
 Can you give me an example?

236
00:19:43,730 --> 00:19:45,290
 You know, the receiver,

237
00:19:45,290 --> 00:19:47,730
 I didn't hear about the acknowledgement,

238
00:19:47,730 --> 00:19:50,610
 but the receiver got the packet and the packet is correct.

239
00:19:50,610 --> 00:19:55,770
 So I send you the packet.

240
00:19:55,770 --> 00:19:57,930
 I don't hear from you back.

241
00:20:01,060 --> 00:20:04,260
 the acknowledgement is lost.

242
00:20:04,260 --> 00:20:05,860
 The acknowledgement is also a packet

243
00:20:05,860 --> 00:20:08,500
 that can be lost as well, right?

244
00:20:08,500 --> 00:20:15,340
 So basically, you may send the packet,

245
00:20:15,340 --> 00:20:21,100
 you may resend the packet

246
00:20:21,100 --> 00:20:23,860
 because you don't get the acknowledgement on the timeout.

247
00:20:23,860 --> 00:20:27,700
 And now the receiver gets a duplicate of the packet.

248
00:20:27,700 --> 00:20:30,060
 So that's why the receiver has to have a way also

249
00:20:30,060 --> 00:20:32,620
 to differentiate between a duplicate

250
00:20:32,620 --> 00:20:34,220
 and the original packet.

251
00:20:34,220 --> 00:20:36,580
 Because if the original packet was already delivered

252
00:20:36,580 --> 00:20:38,540
 to the destination, to the process,

253
00:20:38,540 --> 00:20:44,500
 you need to drop the duplicate, right?

254
00:20:44,500 --> 00:20:50,580
 Okay, so this is an example.

255
00:20:50,580 --> 00:20:52,820
 When the arc is lost, you resend the packet

256
00:20:52,820 --> 00:20:56,540
 and now the receiver gets two packets, right?

257
00:20:58,860 --> 00:21:03,860
 Now, it's one of the challenge here

258
00:21:03,860 --> 00:21:06,620
 is how you are going to pick the timeout.

259
00:21:06,620 --> 00:21:13,740
 If the timeout is short, you may get lots of duplicates.

260
00:21:13,740 --> 00:21:17,660
 So why is that?

261
00:21:17,660 --> 00:21:21,620
 Right?

262
00:21:21,620 --> 00:21:26,620
 Remember that this, like in our simple examples,

263
00:21:26,660 --> 00:21:30,460
 we assume that the one-way latency is constant.

264
00:21:30,460 --> 00:21:31,660
 It's like in real life.

265
00:21:31,660 --> 00:21:36,660
 It's like on the highway, like we discussed.

266
00:21:36,660 --> 00:21:39,140
 So latency is not going to be the same.

267
00:21:39,140 --> 00:21:44,180
 So you are too trigger happy with the timeout

268
00:21:44,180 --> 00:21:45,300
 and to resend the packet,

269
00:21:45,300 --> 00:21:50,180
 I wait just for the timeout, the minimal timeout, right?

270
00:21:50,180 --> 00:21:54,260
 As far as the minimum round trip time.

271
00:21:55,100 --> 00:21:58,780
 Then if I send, I may send too early

272
00:21:58,780 --> 00:22:02,660
 because I didn't give enough time to the packet

273
00:22:02,660 --> 00:22:05,700
 to make the destination and the acknowledgement to come back.

274
00:22:05,700 --> 00:22:09,900
 Obviously, if I wait, it is too long,

275
00:22:09,900 --> 00:22:15,220
 then the performance suffers.

276
00:22:15,220 --> 00:22:16,580
 So for instance, the round trip time,

277
00:22:16,580 --> 00:22:19,500
 say it's 100 milliseconds and the timeout is one second.

278
00:22:19,500 --> 00:22:22,100
 Right?

279
00:22:24,860 --> 00:22:29,180
 So this means that if there is a timeout,

280
00:22:29,180 --> 00:22:33,780
 I lost the opportunity to send another nine packets, right?

281
00:22:33,780 --> 00:22:38,740
 Or 10, depends how you count.

282
00:22:38,740 --> 00:22:43,300
 So how do you do with the application?

283
00:22:43,300 --> 00:22:51,620
 Basically, you have somehow to put some sequence number

284
00:22:51,620 --> 00:22:54,700
 in the packets and the sequence numbers are unique.

285
00:22:54,700 --> 00:22:55,940
 And the acknowledgement will be

286
00:22:55,940 --> 00:22:59,580
 for a particular sequence number, right?

287
00:22:59,580 --> 00:23:03,500
 And the sender, when you send,

288
00:23:03,500 --> 00:23:08,500
 you keep the packets which are not acknowledged, right?

289
00:23:08,500 --> 00:23:15,260
 So you know about, you still have the packets

290
00:23:15,260 --> 00:23:17,020
 if they are lost.

291
00:23:17,020 --> 00:23:21,780
 If a packet is acknowledged, the sender can draw,

292
00:23:21,780 --> 00:23:23,740
 can remove that packet from his buffer.

293
00:23:23,740 --> 00:23:28,740
 And on the receiver side, I also keep a track

294
00:23:28,740 --> 00:23:34,060
 of the sequence numbers of the packets I got.

295
00:23:34,060 --> 00:23:37,660
 So if I get a duplicate packet

296
00:23:37,660 --> 00:23:39,940
 with a duplicate sequence number, I can drop it.

297
00:23:39,940 --> 00:23:42,900
 Okay.

298
00:23:42,900 --> 00:23:51,900
 Of course, you want to simplify it

299
00:23:51,900 --> 00:23:55,860
 by having only one message at a time again,

300
00:23:55,860 --> 00:23:59,940
 and you just don't move until the message has been sent,

301
00:23:59,940 --> 00:24:03,180
 has been received by the sender, by the receiver.

302
00:24:03,180 --> 00:24:10,020
 Okay. And this is exactly what we are talking about

303
00:24:10,020 --> 00:24:11,700
 in our example.

304
00:24:11,700 --> 00:24:16,700
 The problem obviously is that it's slow and bad performance.

305
00:24:16,700 --> 00:24:21,700
 So now let's go back to solve our problem.

306
00:24:21,700 --> 00:24:32,700
 And our problem was that how we are going

307
00:24:32,700 --> 00:24:38,140
 to improve the throughput over stop and wait, right?

308
00:24:38,140 --> 00:24:41,700
 We said that, you know,

309
00:24:41,700 --> 00:24:45,060
 in order to improve the throughput is quite easy,

310
00:24:45,060 --> 00:24:47,100
 is basically don't wait, send packets

311
00:24:47,100 --> 00:24:50,100
 without waiting for the acknowledgements.

312
00:24:50,100 --> 00:24:57,100
 And we saw that doing that won't be that easy

313
00:24:57,100 --> 00:25:00,140
 because the acknowledgement also acknowledge

314
00:25:00,140 --> 00:25:01,860
 whether the packet was received or not,

315
00:25:01,860 --> 00:25:06,860
 and if the packets are lost, things get complicated, right?

316
00:25:06,860 --> 00:25:13,220
 But this being said, this is a solution, right?

317
00:25:13,220 --> 00:25:18,220
 For improving the performance, right?

318
00:25:18,220 --> 00:25:20,620
 You send a lot of packets

319
00:25:20,620 --> 00:25:23,420
 without waiting for the acknowledgement.

320
00:25:23,420 --> 00:25:25,980
 So we pipeline the sending, right?

321
00:25:25,980 --> 00:25:30,180
 So that's very simple.

322
00:25:30,180 --> 00:25:40,580
 So now if you have this one, you know,

323
00:25:40,980 --> 00:25:45,740
 the natural way to implement this protocol

324
00:25:45,740 --> 00:25:49,660
 is to have what is called a window.

325
00:25:49,660 --> 00:25:56,060
 A window is how many packets or how many bytes

326
00:25:56,060 --> 00:26:02,660
 you can send without hearing for an acknowledgement.

327
00:26:02,660 --> 00:26:08,420
 So if the window size, let's think about

328
00:26:08,420 --> 00:26:10,300
 in terms of packets, and we say,

329
00:26:10,300 --> 00:26:11,820
 let me think in terms of bytes.

330
00:26:11,820 --> 00:26:16,900
 If a window size is 10 packets,

331
00:26:16,900 --> 00:26:20,620
 this means that I can send 10 packets

332
00:26:20,620 --> 00:26:26,460
 before I hear, I get back the acknowledgement

333
00:26:26,460 --> 00:26:27,860
 from the first packet I sent.

334
00:26:27,860 --> 00:26:31,780
 Okay?

335
00:26:31,780 --> 00:26:36,020
 So now in a round trip time,

336
00:26:36,020 --> 00:26:38,580
 I can send a window worth of packets.

337
00:26:38,580 --> 00:26:39,420
 Right?

338
00:26:39,420 --> 00:26:43,620
 Because this is how many packets I can send

339
00:26:43,620 --> 00:26:45,580
 without hearing for an acknowledgement.

340
00:26:45,580 --> 00:26:49,020
 Right?

341
00:26:49,020 --> 00:26:49,860
 So therefore, you know,

342
00:26:49,860 --> 00:26:54,100
 and in the number of packets which are in flight

343
00:26:54,100 --> 00:26:56,740
 are going to be without meaning in flight

344
00:26:56,740 --> 00:26:58,820
 from packets which are in flight,

345
00:26:58,820 --> 00:27:03,140
 I haven't heard an acknowledgement for these packets yet.

346
00:27:03,140 --> 00:27:05,540
 Is a window size over the packet size.

347
00:27:05,540 --> 00:27:07,700
 Right?

348
00:27:07,700 --> 00:27:12,700
 How long does the sender need to send packets around?

349
00:27:12,700 --> 00:27:17,380
 Well, what is your answer?

350
00:27:17,380 --> 00:27:20,460
 How many packets does the sender need to keep around?

351
00:27:20,460 --> 00:27:24,820
 So if the packets are lost, can still fix the loss.

352
00:27:24,820 --> 00:27:25,660
 Yes.

353
00:27:25,660 --> 00:27:44,580
 Allison, this is good.

354
00:27:44,580 --> 00:27:48,420
 So you need to keep at least a number of packets

355
00:27:48,420 --> 00:27:52,980
 which is equal with the window size.

356
00:27:53,980 --> 00:27:58,980
 How long does the receiver have to keep the packet data?

357
00:27:58,980 --> 00:28:05,540
 Remember, the receiver needs to keep the long packet data

358
00:28:05,540 --> 00:28:06,900
 or at least a sequence number

359
00:28:06,900 --> 00:28:08,460
 in order to avoid duplicates.

360
00:28:21,660 --> 00:28:24,380
 Until the packet in the window time is time out.

361
00:28:24,380 --> 00:28:34,500
 Let's think about, forget about the protocol.

362
00:28:34,500 --> 00:28:39,900
 When can you remove a packet?

363
00:28:39,900 --> 00:28:41,460
 Think about your receiver packet.

364
00:28:41,460 --> 00:28:45,140
 When can you remove the information about that packet?

365
00:28:45,140 --> 00:28:48,260
 Again, the main reason you are going to keep

366
00:28:48,260 --> 00:28:50,620
 that information around is to avoid duplicates.

367
00:28:50,620 --> 00:28:55,620
 So I send you a packet.

368
00:28:55,620 --> 00:29:05,020
 When do you know that I am not going to send you again

369
00:29:05,020 --> 00:29:05,860
 that packet?

370
00:29:06,780 --> 00:29:08,940
 (silence)

371
00:29:08,940 --> 00:29:26,260
 When I send the next packet, depends on the protocol, right?

372
00:29:26,260 --> 00:29:28,180
 It's the next sequence number.

373
00:29:28,180 --> 00:29:32,300
 It's a little more complicated, but that I think we are close.

374
00:29:32,300 --> 00:29:35,780
 But fundamentally the answer to my question is that

375
00:29:35,780 --> 00:29:39,460
 you know that you can remove the packet

376
00:29:39,460 --> 00:29:47,220
 when I know that you got the packet.

377
00:29:47,220 --> 00:29:49,980
 Once I know that you got the packet,

378
00:29:49,980 --> 00:29:52,420
 I'm no longer going to send you the packet again.

379
00:29:52,420 --> 00:29:59,860
 And we'll see a little bit of how that is done.

380
00:29:59,860 --> 00:30:01,500
 It's not that easy.

381
00:30:01,590 --> 00:30:03,190
 But yes, because you see,

382
00:30:03,190 --> 00:30:05,910
 if I'm getting user packet with an ex-sequence number,

383
00:30:05,910 --> 00:30:10,270
 it's not necessarily the case, right?

384
00:30:10,270 --> 00:30:15,270
 Because like here, if you look at this, in this figure,

385
00:30:15,270 --> 00:30:24,030
 a packet will be lost.

386
00:30:24,030 --> 00:30:28,530
 If a packet, the third packet is lost, right?

387
00:30:29,530 --> 00:30:34,530
 And I get the next packet, actually, in some cases,

388
00:30:34,530 --> 00:30:40,610
 you cannot remove the packet one or two,

389
00:30:40,610 --> 00:30:43,850
 because in some protocols,

390
00:30:43,850 --> 00:30:46,050
 the sender is going to start from the beginning

391
00:30:46,050 --> 00:30:47,250
 to send all the packets.

392
00:30:47,250 --> 00:30:52,050
 Okay, actually in TCP and MOS version of TCP,

393
00:30:52,050 --> 00:30:52,890
 this will happen.

394
00:30:52,890 --> 00:30:57,890
 What if the sender is sending packets faster

395
00:30:57,890 --> 00:30:59,850
 than the receiver can process the data?

396
00:30:59,850 --> 00:31:10,890
 In this case, it's quite simple.

397
00:31:10,890 --> 00:31:14,210
 You slow down the acknowledgements, right?

398
00:31:14,210 --> 00:31:20,170
 If you cannot get more packets, you slow down.

399
00:31:20,170 --> 00:31:22,930
 Okay, so now we are going to talk about,

400
00:31:22,930 --> 00:31:24,370
 these are some good questions,

401
00:31:24,370 --> 00:31:26,770
 and to keep in mind and see how they are solved.

402
00:31:27,770 --> 00:31:30,170
 In particular, the last one,

403
00:31:30,170 --> 00:31:33,250
 how long does the receiver have to keep the packets data?

404
00:31:33,250 --> 00:31:35,590
 What if the sender is sending packets faster

405
00:31:35,590 --> 00:31:38,850
 than the receiver can process the data,

406
00:31:38,850 --> 00:31:41,130
 which is exactly the flow control.

407
00:31:41,130 --> 00:31:46,730
 So now the TCP, again, I mentioned that last time,

408
00:31:46,730 --> 00:31:48,030
 but it was very quickly,

409
00:31:48,030 --> 00:31:52,050
 has a slide-down window protocol at the byte,

410
00:31:52,050 --> 00:31:53,170
 not packet level.

411
00:31:53,170 --> 00:31:54,930
 So, so far we talk about packets,

412
00:31:54,930 --> 00:31:57,570
 it was easier to visualize.

413
00:31:57,570 --> 00:32:01,210
 And it has two ways to recover.

414
00:32:01,210 --> 00:32:06,210
 Go back and, is that if I miss some packets, right?

415
00:32:06,210 --> 00:32:14,450
 I'm going to go back and I'm going to send the packets

416
00:32:14,450 --> 00:32:15,730
 from the one which I missed,

417
00:32:15,730 --> 00:32:17,410
 and also the subsequent packets,

418
00:32:17,410 --> 00:32:19,090
 whether you receive them or not.

419
00:32:19,090 --> 00:32:23,050
 Selective repeat, you only send all the packets,

420
00:32:23,050 --> 00:32:24,550
 it's called DCPSAC.

421
00:32:24,550 --> 00:32:28,930
 You only send all the packets which are lost,

422
00:32:28,930 --> 00:32:30,350
 or the bytes which are lost.

423
00:32:30,350 --> 00:32:39,490
 And the main way this TCP implements the flow control

424
00:32:39,490 --> 00:32:43,490
 is by the receiver telling the sender

425
00:32:43,490 --> 00:32:45,510
 how many more bytes it can receive.

426
00:32:45,510 --> 00:32:47,070
 And this is called advertiser.

427
00:32:47,070 --> 00:32:52,550
 And the acknowledgement contains the sequence number,

428
00:32:52,550 --> 00:32:57,290
 and of the next byte the receiver expects.

429
00:32:57,290 --> 00:33:03,330
 So this means that the receiver has received all bytes

430
00:33:03,330 --> 00:33:06,090
 in sequence up to and including L minus one.

431
00:33:06,090 --> 00:33:12,250
 If there is a gap, I receive the first 100 bytes,

432
00:33:12,250 --> 00:33:14,330
 and then there is a gap of 50 bytes,

433
00:33:14,330 --> 00:33:17,450
 and then I received the bytes from 150 to 150.

434
00:33:17,450 --> 00:33:21,250
 As a receiver, I am still going to send to the sender,

435
00:33:21,250 --> 00:33:26,250
 101, which is the next byte in sequence I am expecting.

436
00:33:26,250 --> 00:33:36,030
 So next we are going to go through a bunch of definitions

437
00:33:36,030 --> 00:33:41,830
 about some variables.

438
00:33:41,830 --> 00:33:43,590
 There are six of them.

439
00:33:43,590 --> 00:33:47,410
 And then we are going to take an example, a simple example.

440
00:33:47,410 --> 00:33:50,610
 So hopefully the examples will clarify things.

441
00:33:50,610 --> 00:33:51,990
 Okay?

442
00:33:51,990 --> 00:33:56,990
 But, you know, it's, please, you know, bear with me.

443
00:33:56,990 --> 00:34:02,230
 So this is a bounding, you know,

444
00:34:02,230 --> 00:34:04,830
 if I'm taking this bounding buffer example,

445
00:34:04,830 --> 00:34:07,550
 like I showed you earlier in the lecture,

446
00:34:07,550 --> 00:34:12,550
 and I try to map it on two hosts, sender and the receiver,

447
00:34:12,550 --> 00:34:18,870
 this is one I can show, I can do it.

448
00:34:19,310 --> 00:34:22,930
 I can have a buffer on the receiving process,

449
00:34:22,930 --> 00:34:24,010
 that's a bounding buffer,

450
00:34:24,010 --> 00:34:26,490
 and the sending was going to send it, you know,

451
00:34:26,490 --> 00:34:28,190
 and these packets are going to be,

452
00:34:28,190 --> 00:34:32,850
 and queued in that buffer,

453
00:34:32,850 --> 00:34:35,490
 and then delivered to the receiving process.

454
00:34:35,490 --> 00:34:41,050
 However, like I mentioned to you,

455
00:34:41,050 --> 00:34:44,510
 like we discussed last time,

456
00:34:46,450 --> 00:34:49,310
 this is not going to work well in practice,

457
00:34:49,310 --> 00:34:52,830
 because this means that for each packet,

458
00:34:52,830 --> 00:34:55,270
 the sender process sends,

459
00:34:55,270 --> 00:34:56,990
 you need to have a context switching,

460
00:34:56,990 --> 00:34:59,710
 because your operating system is going to be involved

461
00:34:59,710 --> 00:35:03,570
 in the act of sending the packet,

462
00:35:03,570 --> 00:35:08,010
 because the TCP/IP, the network stack,

463
00:35:08,010 --> 00:35:11,530
 is implemented in the operating system.

464
00:35:11,530 --> 00:35:15,150
 And if you do a context switching

465
00:35:15,150 --> 00:35:16,790
 on sending every packet,

466
00:35:16,790 --> 00:35:19,890
 like for instance, in the case of the internet,

467
00:35:19,890 --> 00:35:22,650
 the packet size is typically 1500 bytes,

468
00:35:22,650 --> 00:35:27,110
 then in order to sustain the throughput

469
00:35:27,110 --> 00:35:28,990
 of a one-gabit per second,

470
00:35:28,990 --> 00:35:30,690
 one-gabit per second link,

471
00:35:30,690 --> 00:35:35,290
 you need to send a packet every 12 microseconds.

472
00:35:35,290 --> 00:35:41,670
 And if the packet is smaller,

473
00:35:41,670 --> 00:35:43,830
 like 100 bytes in less than one microsecond,

474
00:35:44,830 --> 00:35:49,830
 and this is too little for the context switching, right?

475
00:35:49,830 --> 00:35:51,750
 So therefore, how you solve the problem?

476
00:35:51,750 --> 00:35:53,830
 You have other buffers.

477
00:35:53,830 --> 00:35:56,870
 So in general, you have one buffer on the sender side

478
00:35:56,870 --> 00:35:58,670
 and one buffer on the receiver side.

479
00:35:58,670 --> 00:36:04,830
 This is what operating system maintains.

480
00:36:04,830 --> 00:36:06,230
 And the processes themselves,

481
00:36:06,230 --> 00:36:11,230
 they can have other buffers, right?

482
00:36:11,590 --> 00:36:14,070
 So actually the process of sending

483
00:36:14,070 --> 00:36:18,630
 from one process towards another has three steps.

484
00:36:18,630 --> 00:36:20,630
 The sending process sends the data

485
00:36:20,630 --> 00:36:26,750
 to the operating system or is buffered in the TCP layer.

486
00:36:26,750 --> 00:36:31,790
 The operating system is using the IP layer

487
00:36:31,790 --> 00:36:34,550
 to send, to chop the data you send

488
00:36:34,550 --> 00:36:37,270
 from the sender into packets

489
00:36:37,270 --> 00:36:41,150
 and send it to the receiver, operating system.

490
00:36:41,150 --> 00:36:44,230
 The receiver operating system will put the data

491
00:36:44,230 --> 00:36:45,730
 it receives in a buffer.

492
00:36:45,730 --> 00:36:49,430
 And then from this buffer is going to deliver the data

493
00:36:49,430 --> 00:36:50,770
 to the receiving process.

494
00:36:50,770 --> 00:36:56,350
 Okay?

495
00:36:56,350 --> 00:36:59,510
 And by the way, the fact you see,

496
00:36:59,510 --> 00:37:02,770
 that I have a buffer allows me for something else.

497
00:37:02,770 --> 00:37:05,810
 The sending process can have a stream-oriented protocol

498
00:37:05,810 --> 00:37:06,650
 like we learned.

499
00:37:07,650 --> 00:37:11,170
 So I can send a stream of bytes, 1000 bytes,

500
00:37:11,170 --> 00:37:13,730
 four kilobytes, whatever.

501
00:37:13,730 --> 00:37:17,650
 And then the operating system, this buffer,

502
00:37:17,650 --> 00:37:19,450
 I put all this data into the buffer

503
00:37:19,450 --> 00:37:22,070
 and the operating system can then take the data

504
00:37:22,070 --> 00:37:23,250
 and chop it in packets

505
00:37:23,250 --> 00:37:26,270
 because that IP layer is not a streaming protocol.

506
00:37:26,270 --> 00:37:27,650
 You have to send packets.

507
00:37:27,650 --> 00:37:30,690
 I need to put, take some piece of data,

508
00:37:30,690 --> 00:37:34,450
 I'm putting the headers, port numbers

509
00:37:34,450 --> 00:37:36,450
 for a source and destination,

510
00:37:36,450 --> 00:37:41,170
 IP addresses, then at the lower level,

511
00:37:41,170 --> 00:37:43,650
 you put the MAC addresses and things like that.

512
00:37:43,650 --> 00:37:45,930
 Okay?

513
00:37:45,930 --> 00:37:53,730
 So now let's assume that the maximum IP packet size

514
00:37:53,730 --> 00:37:57,570
 for this example is 100 bytes.

515
00:37:57,570 --> 00:38:01,450
 Again, in general, in practice is 1500 bytes.

516
00:38:01,450 --> 00:38:05,490
 In the size of the receiving buffer is 300 bytes.

517
00:38:05,490 --> 00:38:09,230
 So the receiver can, this is a buffer, 300 bytes.

518
00:38:09,230 --> 00:38:12,770
 Also recalls that the acknowledgement

519
00:38:12,770 --> 00:38:16,090
 indicates the next expected byte in sequence,

520
00:38:16,090 --> 00:38:18,490
 not the last received bytes.

521
00:38:18,490 --> 00:38:20,090
 And like we discussed last time,

522
00:38:20,090 --> 00:38:22,570
 we use circular buffers, right?

523
00:38:22,570 --> 00:38:24,710
 If you remember.

524
00:38:24,710 --> 00:38:31,030
 So basically a circular buffer is like you see here,

525
00:38:31,030 --> 00:38:35,510
 is basically goes around and you keep the head

526
00:38:35,510 --> 00:38:36,870
 and the tail of the buffer.

527
00:38:36,870 --> 00:38:41,750
 Okay?

528
00:38:41,750 --> 00:38:45,910
 So now with all of this, let's see how things are working.

529
00:38:45,910 --> 00:38:48,670
 Like I mentioned, we are going to decide

530
00:38:48,670 --> 00:38:51,070
 to define six variables.

531
00:38:51,070 --> 00:38:54,110
 Last byte written.

532
00:38:54,110 --> 00:38:56,230
 So this is a sequence of the last byte written

533
00:38:56,230 --> 00:38:59,810
 by the sending process into the operating system buffer.

534
00:38:59,810 --> 00:39:04,810
 Last byte sent is the last byte sent

535
00:39:04,810 --> 00:39:08,090
 by the sender to the receiver.

536
00:39:08,090 --> 00:39:11,770
 Last byte act is the last act received

537
00:39:11,770 --> 00:39:13,290
 by sender from the receiver.

538
00:39:13,290 --> 00:39:16,650
 Last byte received is the last byte received

539
00:39:16,650 --> 00:39:19,210
 by receiver from the sender.

540
00:39:19,210 --> 00:39:21,930
 And next byte expected is the last in sequence byte

541
00:39:21,930 --> 00:39:23,250
 expected by the receiver.

542
00:39:28,570 --> 00:39:32,610
 Is it a convention to start a circular buffer at one index?

543
00:39:32,610 --> 00:39:34,890
 It depends.

544
00:39:34,890 --> 00:39:36,370
 Depends on language you are going to use.

545
00:39:36,370 --> 00:39:38,330
 If you see it's probably zero.

546
00:39:38,330 --> 00:39:42,610
 Yeah.

547
00:39:42,610 --> 00:39:48,170
 Okay.

548
00:39:48,170 --> 00:39:50,010
 So now let's take the examples.

549
00:39:50,010 --> 00:39:51,170
 And, oh, and sorry.

550
00:39:51,170 --> 00:39:53,370
 The last byte read is the last byte read

551
00:39:53,370 --> 00:39:54,730
 by the receiving process.

552
00:39:54,730 --> 00:39:55,570
 Okay.

553
00:39:57,650 --> 00:40:02,650
 So this basically says that you have

554
00:40:02,650 --> 00:40:07,720
 in this blue area in the receiving buffer

555
00:40:07,720 --> 00:40:09,600
 is how many bytes you have in the buffer,

556
00:40:09,600 --> 00:40:12,480
 in the receiving buffer.

557
00:40:12,480 --> 00:40:15,920
 You consume from one end, so this is the start.

558
00:40:15,920 --> 00:40:19,320
 The last byte read is the start of the buffer,

559
00:40:19,320 --> 00:40:21,840
 of the data in the buffer.

560
00:40:21,840 --> 00:40:25,480
 Last byte received is the last byte

561
00:40:25,480 --> 00:40:28,680
 in this data, of the data in the buffer.

562
00:40:28,680 --> 00:40:30,500
 And next byte expected in this case

563
00:40:30,500 --> 00:40:32,640
 is the last byte received plus one,

564
00:40:32,640 --> 00:40:34,200
 because that's the one you expect.

565
00:40:34,200 --> 00:40:39,000
 OK?

566
00:40:39,000 --> 00:40:43,240
 So now the advertised window is by definition,

567
00:40:43,240 --> 00:40:49,940
 again, how many bytes the receiver, the sender,

568
00:40:49,940 --> 00:40:54,920
 can send me without me overflowing.

569
00:40:54,920 --> 00:41:00,960
 [AUDIO OUT]

570
00:41:00,960 --> 00:41:04,700
 So basically, if I am the receiver

571
00:41:04,700 --> 00:41:12,680
 and my buffer size is 300 bytes, and the buffer is empty,

572
00:41:12,680 --> 00:41:17,000
 I tell you, you can send me 300 bytes.

573
00:41:20,960 --> 00:41:25,060
 If my buffer, I already have 100 bytes source of data

574
00:41:25,060 --> 00:41:31,220
 in the buffer, I tell you, well, you can send me only 200 bytes.

575
00:41:31,220 --> 00:41:34,340
 So this formula is computing exactly what I told you.

576
00:41:34,340 --> 00:41:39,620
 It's a maximum buffer minus how much data

577
00:41:39,620 --> 00:41:43,860
 I have in this contiguous region in the buffer, which

578
00:41:43,860 --> 00:41:46,820
 is last byte received minus last byte read.

579
00:41:46,820 --> 00:41:47,320
 OK?

580
00:41:50,060 --> 00:42:01,180
 The same thing, it's on the sending side or similar, right?

581
00:42:01,180 --> 00:42:02,780
 Here I have last byte act.

582
00:42:02,780 --> 00:42:09,840
 So here, if I get an acknowledgment

583
00:42:09,840 --> 00:42:12,140
 in this protocol, if I'm going to get

584
00:42:12,140 --> 00:42:15,860
 an acknowledgment for a byte, this

585
00:42:15,860 --> 00:42:19,420
 means that the receiving process receives that byte.

586
00:42:19,420 --> 00:42:27,060
 So I no longer need to keep it in the buffer as a sender.

587
00:42:27,060 --> 00:42:33,260
 So everything before last byte act can be dropped.

588
00:42:33,260 --> 00:42:35,220
 And then you have last byte sent.

589
00:42:35,220 --> 00:42:37,020
 So what is last byte act?

590
00:42:37,020 --> 00:42:41,060
 What is the things between last byte act and last byte sent?

591
00:42:41,060 --> 00:42:47,580
 This green area.

592
00:42:47,580 --> 00:42:54,540
 This green area represents the data

593
00:42:54,540 --> 00:43:01,300
 that the sending process send it without being acknowledged.

594
00:43:01,300 --> 00:43:01,900
 That's it.

595
00:43:01,900 --> 00:43:05,780
 OK?

596
00:43:05,780 --> 00:43:11,780
 So let me see.

597
00:43:11,780 --> 00:43:14,620
 It's exactly the same, yeah.

598
00:43:14,620 --> 00:43:17,300
 The packets we send that have not received an act.

599
00:43:17,300 --> 00:43:19,340
 So they are not acknowledged.

600
00:43:19,340 --> 00:43:21,780
 So now, think about send a window.

601
00:43:21,780 --> 00:43:23,380
 And again, you have the formula.

602
00:43:23,380 --> 00:43:24,500
 You can look at the formula.

603
00:43:24,500 --> 00:43:27,660
 But let's take an example.

604
00:43:27,660 --> 00:43:34,460
 Now let's think about from the sender perspective.

605
00:43:34,460 --> 00:43:39,260
 Say the receiver, you are the sender.

606
00:43:39,260 --> 00:43:43,540
 The receiver tells you, my advertised window is 300 bytes.

607
00:43:46,500 --> 00:43:49,660
 And since I love this information,

608
00:43:49,660 --> 00:43:54,980
 I already send you 100 bytes.

609
00:43:54,980 --> 00:43:56,860
 How many more bytes can I send you

610
00:43:56,860 --> 00:43:59,780
 before I'm hearing back from you?

611
00:43:59,780 --> 00:44:02,980
 So that I am absolutely certain I'm not going to overflow you.

612
00:44:02,980 --> 00:44:11,460
 Right?

613
00:44:11,460 --> 00:44:12,860
 See this again.

614
00:44:12,860 --> 00:44:16,460
 The receiver tells you, you can send me 300 bytes.

615
00:44:16,460 --> 00:44:19,140
 Since you heard that, then when you heard that,

616
00:44:19,140 --> 00:44:22,860
 you sent 100 bytes.

617
00:44:22,860 --> 00:44:25,580
 Still nothing from the receiver.

618
00:44:25,580 --> 00:44:27,860
 How many more bytes you can send before you

619
00:44:27,860 --> 00:44:28,820
 hear from the receiver?

620
00:44:28,820 --> 00:44:36,980
 Yes.

621
00:44:36,980 --> 00:44:40,260
 In my example, it was 200, right?

622
00:44:40,260 --> 00:44:41,740
 Right?

623
00:44:41,740 --> 00:44:43,940
 Receiver told you, you can send me 300 bytes.

624
00:44:43,940 --> 00:44:45,060
 You send 100 bytes.

625
00:44:45,060 --> 00:44:46,620
 You haven't heard yet.

626
00:44:46,620 --> 00:44:48,860
 You can send another 200 bytes.

627
00:44:48,860 --> 00:44:54,460
 So then you send in total 300 bytes before you hear back.

628
00:44:54,460 --> 00:44:55,460
 You cannot send more.

629
00:44:55,460 --> 00:45:01,900
 And this is exactly this next formula.

630
00:45:01,900 --> 00:45:04,060
 The sender window is how many more bytes

631
00:45:04,060 --> 00:45:07,180
 you can send without overflowing the receiver.

632
00:45:07,180 --> 00:45:14,260
 And it's advertised window minus the number of bytes

633
00:45:14,260 --> 00:45:19,740
 you send out without being acknowledged in that window.

634
00:45:19,740 --> 00:45:20,220
 OK?

635
00:45:20,220 --> 00:45:27,300
 It's still true.

636
00:45:27,300 --> 00:45:29,740
 It's a very important aspect.

637
00:45:29,740 --> 00:45:35,660
 This is still true if you miss the data, these formulas.

638
00:45:35,660 --> 00:45:36,580
 Right?

639
00:45:36,580 --> 00:45:40,540
 Because if you miss the data here on the receiver side,

640
00:45:40,540 --> 00:45:43,980
 the next byte expected, by the way, you see here,

641
00:45:43,980 --> 00:45:47,700
 the next byte expected is the one which is in sequence.

642
00:45:47,700 --> 00:45:48,740
 Right?

643
00:45:48,740 --> 00:45:50,660
 Because you have a gap, the gap doesn't

644
00:45:50,660 --> 00:45:52,620
 matter for the next byte expected.

645
00:45:52,620 --> 00:45:56,180
 But for the last byte received, it matters.

646
00:45:56,180 --> 00:45:58,860
 OK?

647
00:45:58,860 --> 00:46:01,700
 So remember that.

648
00:46:01,700 --> 00:46:05,100
 So these are the same formulas if you

649
00:46:05,100 --> 00:46:08,100
 miss the data in the middle.

650
00:46:08,100 --> 00:46:08,820
 OK.

651
00:46:08,820 --> 00:46:10,700
 So now let's take a simple example.

652
00:46:10,700 --> 00:46:20,900
 So let's say the sending application sends 350 bytes.

653
00:46:20,900 --> 00:46:23,100
 We assume the IP only access package

654
00:46:23,100 --> 00:46:25,700
 no larger than 100 bytes.

655
00:46:25,700 --> 00:46:28,780
 And let's say the MACs receive the advertised window.

656
00:46:28,780 --> 00:46:30,700
 MACs receiving buffer is 300 bytes.

657
00:46:30,700 --> 00:46:35,620
 And advertised window initially is 300 bytes.

658
00:46:35,620 --> 00:46:38,180
 So sender first, send buffer's packet.

659
00:46:38,180 --> 00:46:40,460
 How much big is the first packet?

660
00:46:40,460 --> 00:46:42,140
 100 bytes.

661
00:46:42,140 --> 00:46:45,940
 Because that's the maximum size of the packet.

662
00:46:45,940 --> 00:46:47,940
 With green, I showed the packet which

663
00:46:47,940 --> 00:46:52,140
 are sent without being acknowledged.

664
00:46:52,140 --> 00:46:54,820
 Here on each side, I'm saying 1 to 100

665
00:46:54,820 --> 00:46:59,140
 between these square brackets is the bytes

666
00:46:59,140 --> 00:47:01,460
 which have been sent.

667
00:47:01,460 --> 00:47:05,060
 I am starting from 1.

668
00:47:05,060 --> 00:47:07,060
 OK?

669
00:47:07,060 --> 00:47:09,860
 So eventually, the last byte sent

670
00:47:09,860 --> 00:47:11,780
 when I am doing, when I'm sending initially

671
00:47:11,780 --> 00:47:16,260
 the last byte back, it's 0.

672
00:47:16,260 --> 00:47:18,860
 No, nothing was hacked.

673
00:47:18,860 --> 00:47:24,260
 The last byte sent is 100 because I sent 100 bytes.

674
00:47:24,260 --> 00:47:25,900
 And now eventually, this packet is

675
00:47:25,900 --> 00:47:28,060
 delivered to the destination.

676
00:47:28,060 --> 00:47:30,740
 Last byte receives is 100.

677
00:47:30,740 --> 00:47:33,220
 Next byte is expected is 101.

678
00:47:33,220 --> 00:47:36,180
 Right?

679
00:47:36,180 --> 00:47:37,180
 Everything is good.

680
00:47:37,180 --> 00:47:46,020
 Now, the receiver sends back acknowledgment 101,

681
00:47:46,020 --> 00:47:49,020
 advertised window noise 200.

682
00:47:49,020 --> 00:47:50,980
 Because I had-- it was 300.

683
00:47:50,980 --> 00:47:52,020
 I got 100.

684
00:47:52,020 --> 00:47:56,780
 Now you can send me only 200.

685
00:47:56,780 --> 00:47:59,540
 OK?

686
00:47:59,540 --> 00:48:02,660
 Before receiving this acknowledgment,

687
00:48:02,660 --> 00:48:05,700
 because the window advertising is 300 bytes

688
00:48:05,700 --> 00:48:09,820
 and I sent only 100 bytes, I'm going to send the next packet,

689
00:48:09,820 --> 00:48:13,380
 me being the sender.

690
00:48:13,380 --> 00:48:18,500
 The bytes are between 101 and 200.

691
00:48:18,500 --> 00:48:19,420
 Right?

692
00:48:19,420 --> 00:48:21,460
 And again, sorry, here I am saying

693
00:48:21,460 --> 00:48:23,260
 all the packets which have been sent,

694
00:48:23,260 --> 00:48:25,020
 all the bytes which have been sent.

695
00:48:25,020 --> 00:48:32,700
 So now I send from the sender between 1 and 200.

696
00:48:32,700 --> 00:48:33,220
 OK?

697
00:48:33,220 --> 00:48:35,460
 This packet is going to--

698
00:48:35,460 --> 00:48:38,460
 now the last byte sent is 200.

699
00:48:38,460 --> 00:48:40,420
 And it's going to get to the receiver.

700
00:48:40,420 --> 00:48:42,740
 And the receiver, you have last byte receives 200,

701
00:48:42,740 --> 00:48:44,740
 next byte expected 201.

702
00:48:44,740 --> 00:48:51,260
 And I'm going to now write 201.

703
00:48:51,260 --> 00:48:53,500
 Now, assume that next thing what happened,

704
00:48:53,500 --> 00:48:56,220
 the receiving process, there is some data.

705
00:48:56,220 --> 00:49:01,540
 Let's say it is 100 bytes, the first 100 bytes.

706
00:49:01,540 --> 00:49:07,580
 So now in the receiving window, in the receiving buffer,

707
00:49:07,580 --> 00:49:10,780
 I only have 100 bytes, because 100 bytes already

708
00:49:10,780 --> 00:49:13,420
 were processed by the receiver.

709
00:49:13,420 --> 00:49:16,980
 We're already delivered to the receiver process.

710
00:49:16,980 --> 00:49:22,820
 So when I'm going to send back an acknowledgment,

711
00:49:22,820 --> 00:49:26,300
 I'm going to include the next sequence, next byte expected,

712
00:49:26,300 --> 00:49:29,420
 which is 201.

713
00:49:29,420 --> 00:49:33,260
 And then advertising window, it's again 200.

714
00:49:33,260 --> 00:49:36,380
 Because in the buffer, I have only 100 bytes,

715
00:49:36,380 --> 00:49:37,860
 and the buffer is 300 bytes.

716
00:49:37,860 --> 00:49:47,980
 Now, the sender, it's again.

717
00:49:47,980 --> 00:49:53,380
 I still have-- I know that I sent only 200 bytes.

718
00:49:53,380 --> 00:49:56,860
 The receiver told me initially that I can send 300 bytes.

719
00:49:56,860 --> 00:49:58,540
 So I still can send 100 bytes.

720
00:49:58,540 --> 00:50:01,900
 So let me send the next packet.

721
00:50:02,650 --> 00:50:06,170
 now to make things more interesting that this packet has been lost.

722
00:50:06,170 --> 00:50:20,010
 Okay. That's fine. In the meantime, I advance the last by set send on the sender to 300.

723
00:50:20,010 --> 00:50:28,010
 And in the meantime, the sending window now is zero. I can no longer send. You see,

724
00:50:28,010 --> 00:50:34,010
 the sending window magically now is zero because I sent 300 bytes. I knew that the advertising

725
00:50:34,010 --> 00:50:39,690
 noise 300 bytes. I haven't heard anything from the receiver. So therefore I have to stop sending.

726
00:50:39,690 --> 00:50:50,490
 Okay. Now, in the meantime, I get the first acknowledgement back.

727
00:50:52,570 --> 00:50:58,090
 The fact that acknowledgement back is telling me I have 101, the acknowledgement is 101,

728
00:50:58,090 --> 00:51:03,610
 and the advertised window is 200. Right? So the first packet was acknowledged.

729
00:51:03,610 --> 00:51:12,810
 Right? So because the first packet was acknowledged, it was acknowledged,

730
00:51:12,810 --> 00:51:21,690
 and also indicates the next packet to send. So the receiver no longer meets the first 100 bytes. So

731
00:51:21,690 --> 00:51:29,050
 I'm going to remove this from the sender buffer because the receiver told me that it got the first

732
00:51:29,050 --> 00:51:41,930
 100 bytes. Okay. So, and I am going to advance last byte act 100. But the sender window is still

733
00:51:41,930 --> 00:51:57,770
 zero because I sent 300 bytes. And now the sender told me, okay, I got 100 bytes, but I can receive

734
00:51:57,770 --> 00:52:09,930
 only 200 bytes, 200 more bytes. So yes. Okay. I removed the 100 bytes that sender sent told me

735
00:52:11,050 --> 00:52:16,570
 that the receiver told me that they receive, but still I have 200 bytes, which are not

736
00:52:16,570 --> 00:52:24,170
 acknowledged. And the receiver told me that it can only send, receive 200 bytes without

737
00:52:24,170 --> 00:52:34,650
 being acknowledged. So I cannot send anything. But finally, now I get the second acknowledgement

738
00:52:35,610 --> 00:52:44,250
 and the second acknowledgement tells me, it tells the receiver that the receiver got the first 200

739
00:52:44,250 --> 00:52:53,130
 bytes. So the next expected byte is 201 and the advertiser window is 200. So now when you compute

740
00:52:53,130 --> 00:53:04,170
 the advertise window, you get 100 because it's 200 advertised window. And now I have in flight

741
00:53:04,810 --> 00:53:12,570
 only 100 bytes. So I can send another 100 bytes. I don't have 100 bytes to send. I only have 50.

742
00:53:12,570 --> 00:53:20,810
 Right. Because I had only, I wanted to send 350 bytes. So I'm going to send these 350 bytes,

743
00:53:20,810 --> 00:53:28,890
 the last 50 bytes. And then they are going to be received by the receiver. But now I have a gap

744
00:53:28,890 --> 00:53:39,850
 and the gap is the third packet which was lost. So you see now next byte expected is 201. Right.

745
00:53:39,850 --> 00:53:48,170
 And the last byte received now is 350. So now I send back to the receiver and say, look,

746
00:53:48,170 --> 00:53:58,490
 I got the next byte I am expecting is 201, but the advertiser window is 50.

747
00:53:58,490 --> 00:54:14,090
 Okay. So if the advertiser window is 50, what is the sending process going to do?

748
00:54:27,290 --> 00:54:30,410
 Right.

749
00:54:30,410 --> 00:54:40,010
 Yes, you can send in this case, you can send the packet which was lost.

750
00:54:40,010 --> 00:54:44,410
 Why you can send this packet which was lost?

751
00:54:44,410 --> 00:54:52,650
 We'll do more about this in a while.

752
00:54:55,770 --> 00:55:04,890
 It's still in the green region. It's exact.

753
00:55:04,890 --> 00:55:23,450
 By the sending window is less, yeah, it's good. By the sending window is less than zero.

754
00:55:24,170 --> 00:55:30,410
 It's good. It's very good. Very good observation. But the point here that I can send the packet

755
00:55:30,410 --> 00:55:37,850
 because I already sent that packet. It doesn't count. I can always send a packet which I

756
00:55:37,850 --> 00:55:44,170
 previously sent. Right. Because in the worst case, it will be the duplicate.

757
00:55:44,170 --> 00:55:51,130
 In the worst case, it will be duplicated. In the best case, it's going to repair the loss.

758
00:55:52,810 --> 00:55:59,690
 You see, the receiver by this gap already accounted for the loss packet.

759
00:55:59,690 --> 00:56:12,410
 That's a key. Right. So you see, it's already accounted. The next expected byte is 350. So

760
00:56:12,410 --> 00:56:18,650
 therefore, if I'm going to send a packet, that's not going to change the window on anything.

761
00:56:20,890 --> 00:56:24,250
 It's again, either it's going to repair a loss or it's going to be duplicated.

762
00:56:24,250 --> 00:56:35,050
 So that's why I can send the packet. And why I'm going to send now? In this particular case,

763
00:56:35,050 --> 00:56:43,210
 I'm going to send it because you see, the second time I get

764
00:56:46,650 --> 00:56:53,690
 acknowledgement sender, the receiver told me that the acknowledgement, the next sequence number is

765
00:56:53,690 --> 00:57:03,610
 expecting is 201. So basically, if you, and we'll see this next, this is a way to detect the failure.

766
00:57:03,610 --> 00:57:12,490
 Okay. So I can, a packet loss. So one way to detect the packet loss is that if the receiver

767
00:57:12,490 --> 00:57:16,730
 tells me multiple times, I am waiting for the sequence number, next sequence number.

768
00:57:16,730 --> 00:57:22,890
 Right. Because this means that it gets the reason if the receiver can, it will tell me that it waits

769
00:57:22,890 --> 00:57:28,250
 for the same sequence number over and over again, is that I send him an ex pack, another packet,

770
00:57:28,250 --> 00:57:33,530
 but it's a gap. It's not in sequence. Because if it's in sequence, the next sequence number,

771
00:57:33,530 --> 00:57:38,090
 the receiver will tell me will advance as well. Okay.

772
00:57:40,730 --> 00:57:49,530
 So anyway, so and now if you have, if finally you get the next packet,

773
00:57:49,530 --> 00:57:58,970
 the last packet, the receiver gets the last packet, now he has everything, it's got up to 350,

774
00:57:58,970 --> 00:58:04,090
 is going that acknowledgement to contain 351, which the next sequence number is going to wait

775
00:58:04,090 --> 00:58:13,930
 for. Advertising window is still 50. And now when the receiver, the sender gets acknowledgement 351,

776
00:58:13,930 --> 00:58:19,450
 it can remove everything from its buffer because all the data is sent was acknowledged.

777
00:58:19,450 --> 00:58:23,290
 So now we are done.

778
00:58:23,290 --> 00:58:27,530
 Any questions?

779
00:58:27,530 --> 00:58:39,290
 Yeah, so please, you should, you know, you can go through this

780
00:58:39,290 --> 00:58:49,450
 example. It's very, it's very revealing, but you need to go a few times to really feel it,

781
00:58:49,450 --> 00:58:52,010
 understand it.

782
00:58:54,490 --> 00:58:57,370
 So let's have a short discussion before we move.

783
00:58:57,370 --> 00:59:12,810
 Yes, almost everything we talked, goes to back end and selective repeat.

784
00:59:12,810 --> 00:59:19,130
 The only difference is like it was said, someone said, for instance, the difference here,

785
00:59:20,250 --> 00:59:28,890
 this was mostly I shown you about selective acknowledgement. So I'm telling you what is

786
00:59:28,890 --> 00:59:41,050
 the difference. So with go back end, the sender is going to send everything up from 2001, including

787
00:59:41,050 --> 00:59:49,850
 the last 50 bytes, which are already received by the receiver. Okay. So you already go from the

788
00:59:49,850 --> 00:59:59,450
 first sequence number, which was expected by of the missing packet. Okay. In the case of selective

789
00:59:59,450 --> 01:00:02,970
 acknowledgement, there is a set.

790
01:00:03,190 --> 01:00:07,350
 sender is like in this case is going only to send out

791
01:00:07,350 --> 01:00:10,410
 the missing packets, the missing information.

792
01:00:10,410 --> 01:00:25,150
 Yes, would last byte read cause a bottleneck

793
01:00:25,150 --> 01:00:29,310
 on how is the question from Simon.

794
01:00:29,310 --> 01:00:34,310
 Would last byte read cause a bottleneck

795
01:00:34,310 --> 01:00:36,630
 on how fast we can clear the buffer.

796
01:00:36,630 --> 01:00:38,890
 If we are not spending enough cycles

797
01:00:38,890 --> 01:00:42,530
 to copy from buffer to process,

798
01:00:42,530 --> 01:00:45,530
 we cannot advance last byte read as fast.

799
01:00:45,530 --> 01:00:47,570
 So that limits our advertising.

800
01:00:47,570 --> 01:00:50,790
 Absolutely, and that exactly is a purpose,

801
01:00:50,790 --> 01:00:55,070
 the goal of having this last byte read.

802
01:00:55,070 --> 01:00:57,290
 The goal is basically, yes,

803
01:00:57,290 --> 01:01:01,450
 you know, it's here,

804
01:01:01,450 --> 01:01:04,370
 the ultimate receiver is a perceiving process.

805
01:01:04,370 --> 01:01:08,290
 So the receiving process for some reason cannot consume data

806
01:01:08,290 --> 01:01:10,370
 which the sender shouldn't send faster.

807
01:01:10,370 --> 01:01:14,790
 Okay.

808
01:01:14,790 --> 01:01:18,830
 Okay, so let's move on.

809
01:01:18,830 --> 01:01:23,450
 Let's go, so why not have a huge buffer

810
01:01:23,450 --> 01:01:25,830
 at the receiver, memory is cheap after all.

811
01:01:25,830 --> 01:01:27,990
 (silence)

812
01:01:27,990 --> 01:01:44,030
 A huge buffer at the receiver also mean

813
01:01:44,030 --> 01:01:47,910
 a huge buffer is a sender, right?

814
01:01:47,910 --> 01:01:50,010
 And we'll see that huge buffer actually also

815
01:01:50,010 --> 01:01:51,910
 in the network for congestion control

816
01:01:51,910 --> 01:01:55,190
 means that the latency is going to increase

817
01:01:55,190 --> 01:01:58,590
 significantly because the latency is going to increase

818
01:01:58,590 --> 01:02:00,870
 significantly because it's going to take more

819
01:02:00,870 --> 01:02:04,130
 to send to clear the buffer.

820
01:02:04,130 --> 01:02:12,590
 Yeah, so it's like the transmissions,

821
01:02:12,590 --> 01:02:14,510
 the round trip time, the transmission time

822
01:02:14,510 --> 01:02:15,930
 is going to grow a lot.

823
01:02:15,930 --> 01:02:21,430
 Sending window also depend on a third congestion

824
01:02:21,430 --> 01:02:23,230
 is what we're going to go on to do next.

825
01:02:23,230 --> 01:02:25,430
 There are a lot of details about if you're interested

826
01:02:25,430 --> 01:02:29,030
 about networking, take CS168.

827
01:02:29,030 --> 01:02:31,770
 And by the way, we talk about a few buffers,

828
01:02:31,770 --> 01:02:34,630
 two buffers here in the operating systems

829
01:02:34,630 --> 01:02:36,670
 for the sender and the receiver side.

830
01:02:36,670 --> 01:02:38,670
 In practice, there are more buffers.

831
01:02:38,670 --> 01:02:40,590
 There are network cards has buffers,

832
01:02:40,590 --> 01:02:42,430
 buffer in the network and everything.

833
01:02:42,430 --> 01:02:48,490
 So let's announcements.

834
01:02:48,490 --> 01:02:50,190
 Meet the three is tomorrow.

835
01:02:50,190 --> 01:02:55,190
 What we've done over today in the lecture is not for next,

836
01:02:55,190 --> 01:03:00,670
 is not included in the material for the exam

837
01:03:00,670 --> 01:03:02,870
 for the last midterm.

838
01:03:02,870 --> 01:03:07,590
 On Sunday, we are going this project three party

839
01:03:07,590 --> 01:03:09,110
 between 10 and 2 p.m.

840
01:03:09,110 --> 01:03:13,910
 The discussions will be converted in office hours

841
01:03:13,910 --> 01:03:17,110
 to help you with the projects, last project

842
01:03:17,110 --> 01:03:20,350
 and with the exam, it will be after the exam.

843
01:03:20,350 --> 01:03:22,730
 So it don't help you as much.

844
01:03:22,730 --> 01:03:26,670
 The office hours also will continue into that week,

845
01:03:26,670 --> 01:03:28,950
 again, to help you with the projects.

846
01:03:28,950 --> 01:03:32,950
 Homework C6 is due Friday, next Friday

847
01:03:32,950 --> 01:03:40,110
 and project, no, yeah, this Friday, sorry, not next Friday.

848
01:03:40,110 --> 01:03:45,110
 And the project three is due as you know on December 8th.

849
01:03:45,110 --> 01:03:50,110
 Okay, so now we have another 15 minutes.

850
01:03:50,110 --> 01:03:55,830
 So let me tell you a little bit about the congestion control.

851
01:03:55,830 --> 01:03:59,470
 So flow control don't overflow the receiver.

852
01:03:59,470 --> 01:04:03,710
 Congestion control don't overflow the network.

853
01:04:03,710 --> 01:04:06,310
 The network has routers, has buffers in between.

854
01:04:06,310 --> 01:04:12,230
 So now the question is how you are going to detect

855
01:04:13,090 --> 01:04:15,210
 the congestion in the network.

856
01:04:15,210 --> 01:04:18,010
 And remember the congestion, I'm going to detect

857
01:04:18,010 --> 01:04:20,130
 there's a transfer level layer.

858
01:04:20,130 --> 01:04:21,850
 There is no transfer layer in the network.

859
01:04:21,850 --> 01:04:23,170
 It's only between two end hosts.

860
01:04:23,170 --> 01:04:25,810
 So I can only observe the network.

861
01:04:25,810 --> 01:04:29,210
 There are a few ways to detect the congestions.

862
01:04:29,210 --> 01:04:32,770
 One, a packet is dropped.

863
01:04:32,770 --> 01:04:35,290
 You interpret this to be a sign of congestion

864
01:04:35,290 --> 01:04:37,670
 because you assume there's a reason

865
01:04:37,670 --> 01:04:40,330
 a packet has been dropped is that because a buffer

866
01:04:40,330 --> 01:04:42,830
 of the router has overflow, was overflow.

867
01:04:43,830 --> 01:04:48,830
 So filled in, the router cannot send packets

868
01:04:48,830 --> 01:04:52,510
 as fast as it gets, the buffer fills in packets are dropped.

869
01:04:52,510 --> 01:04:55,470
 There is a more refined version,

870
01:04:55,470 --> 01:04:57,190
 early congestion notification.

871
01:04:57,190 --> 01:05:01,590
 So when the buffer at the router increases

872
01:05:01,590 --> 01:05:05,350
 over some threshold, the router set up a bit,

873
01:05:05,350 --> 01:05:07,510
 it's called ECN bit in the packet.

874
01:05:08,870 --> 01:05:13,110
 And then the receiver sends back to the sender saying,

875
01:05:13,110 --> 01:05:17,370
 hey, don't slow down because this router

876
01:05:17,370 --> 01:05:21,430
 it's about to be, is congested.

877
01:05:21,430 --> 01:05:24,790
 And the other one is delayed packets.

878
01:05:24,790 --> 01:05:29,270
 When the buffer grows, the latency grows.

879
01:05:29,270 --> 01:05:30,510
 It's like on the highway.

880
01:05:30,510 --> 01:05:34,390
 So if I see that the delay has increased,

881
01:05:34,390 --> 01:05:35,750
 maybe I need to slow down.

882
01:05:37,770 --> 01:05:41,690
 The simplest one, it's drop packets.

883
01:05:41,690 --> 01:05:43,690
 And this is what we are going to assume.

884
01:05:43,690 --> 01:05:47,150
 It's still most used sign of congestion today.

885
01:05:47,150 --> 01:05:50,530
 And like we discussed, there are two ways

886
01:05:50,530 --> 01:05:52,670
 what to detect these drop packets.

887
01:05:52,670 --> 01:05:55,470
 Again, the question is how do you detect a drop packet?

888
01:05:55,470 --> 01:05:58,610
 Right?

889
01:05:58,610 --> 01:06:03,070
 Congestion means the router buffer is full.

890
01:06:03,070 --> 01:06:06,630
 And then because it's full, the packet is dropped.

891
01:06:06,630 --> 01:06:09,710
 But now if I'm the sender,

892
01:06:09,710 --> 01:06:14,110
 how I'm going to know that the packet was dropped?

893
01:06:14,110 --> 01:06:18,150
 How I'm going to decide the packet was dropped?

894
01:06:18,150 --> 01:06:24,150
 One way is like we discussed earlier on, timeout.

895
01:06:24,150 --> 01:06:25,530
 I wait for some time,

896
01:06:25,530 --> 01:06:28,190
 which is significantly larger than the router time.

897
01:06:28,190 --> 01:06:29,650
 I don't get an acknowledgement.

898
01:06:29,650 --> 01:06:34,410
 I assume the packet is lost, even if it doesn't.

899
01:06:34,410 --> 01:06:35,410
 So I resend it.

900
01:06:36,410 --> 01:06:40,370
 And the other one I just alluded to you earlier on,

901
01:06:40,370 --> 01:06:45,350
 it's when I received the same acknowledgements,

902
01:06:45,350 --> 01:06:47,510
 the same sequence number in the acknowledgement,

903
01:06:47,510 --> 01:06:48,430
 the next sequence number,

904
01:06:48,430 --> 01:06:51,470
 expecting sequence number over and over again.

905
01:06:51,470 --> 01:06:53,070
 Right?

906
01:06:53,070 --> 01:06:56,030
 Because again, in this case, I am going to send you,

907
01:06:56,030 --> 01:06:59,950
 so in this case, I send you the packet 200.

908
01:06:59,950 --> 01:07:04,350
 Right? From 100 to 200.

909
01:07:04,350 --> 01:07:06,150
 So you tell me, oh, the next sequence number,

910
01:07:06,150 --> 01:07:10,990
 I'm going to, I want, I am expecting from you is 201.

911
01:07:10,990 --> 01:07:12,330
 Now I'm sending you the next packet

912
01:07:12,330 --> 01:07:14,130
 with the bias 200 to 300.

913
01:07:14,130 --> 01:07:17,330
 You lost it.

914
01:07:17,330 --> 01:07:19,170
 You don't tell me anything.

915
01:07:19,170 --> 01:07:21,470
 Now I'm sending the next packet 300 to 400.

916
01:07:21,470 --> 01:07:24,690
 You give me the acknowledgement for that packet,

917
01:07:24,690 --> 01:07:25,810
 but if the sequence number,

918
01:07:25,810 --> 01:07:29,910
 next sequence expecting sequence number is still to 100,

919
01:07:29,910 --> 01:07:33,090
 because you are telling me about the sequence,

920
01:07:33,090 --> 01:07:37,270
 next expected in sequence number.

921
01:07:37,270 --> 01:07:40,470
 So now you told me two times, 200,

922
01:07:40,470 --> 01:07:43,290
 the next sequence in sequence number,

923
01:07:43,290 --> 01:07:46,330
 you expect is 201.

924
01:07:46,330 --> 01:07:51,330
 I'm sending you another packet now between 400 and 500 bytes.

925
01:07:51,330 --> 01:07:56,150
 Again, you tell me the next byte in sequence

926
01:07:56,150 --> 01:07:58,290
 I'm expecting is 201.

927
01:07:58,290 --> 01:08:01,990
 So again, an acknowledgement, which is duplicate.

928
01:08:01,990 --> 01:08:03,730
 This is what we call duplicate acknowledgement

929
01:08:03,730 --> 01:08:06,330
 because you tell me repeatedly over and over again,

930
01:08:06,330 --> 01:08:09,330
 you told me over and over again,

931
01:08:09,330 --> 01:08:12,850
 you on the next sequence number I'm expecting is 201.

932
01:08:12,850 --> 01:08:17,130
 So after a few of those, I decide, well,

933
01:08:17,130 --> 01:08:21,590
 that packet was lost and I'm going to resend it.

934
01:08:21,590 --> 01:08:23,290
 This is duplicate acknowledgement.

935
01:08:23,290 --> 01:08:28,890
 Make sense?

936
01:08:28,890 --> 01:08:29,730
 Okay.

937
01:08:29,730 --> 01:08:38,690
 So congestion control is a key idea is a sender increase,

938
01:08:38,690 --> 01:08:43,750
 to increase ascending rate of the network until congestion,

939
01:08:43,750 --> 01:08:48,370
 if the network is not congested.

940
01:08:48,370 --> 01:08:51,330
 They introduce ascending rate if the network is congested.

941
01:08:51,330 --> 01:08:56,330
 How does the sender control ascending rate?

942
01:08:56,330 --> 01:09:00,730
 Sender window size, ascending window size,

943
01:09:00,730 --> 01:09:03,610
 which is called right now in this context,

944
01:09:03,610 --> 01:09:05,210
 congestion window size.

945
01:09:05,210 --> 01:09:15,730
 Here is a great question from Alison

946
01:09:15,730 --> 01:09:20,230
 about the previous case, what I mentioned to you.

947
01:09:20,230 --> 01:09:23,250
 So the question from Alison is the following.

948
01:09:23,250 --> 01:09:26,570
 Can you not conclude it was lost,

949
01:09:26,570 --> 01:09:29,170
 the packet was lost after the first duplicate hack?

950
01:09:29,170 --> 01:09:39,190
 Tell me why you wouldn't do that.

951
01:09:39,190 --> 01:09:42,730
 You could do that, but why you wouldn't do it?

952
01:09:42,730 --> 01:09:44,890
 (silence)

953
01:09:44,890 --> 01:10:00,890
 Maybe out of order.

954
01:10:00,890 --> 01:10:03,570
 Yes, it's exactly out of order.

955
01:10:03,720 --> 01:10:15,720
 You see, look at this figure and assume that these packets, which is lost, instead of being lost, it travels on a different path in the network.

956
01:10:15,720 --> 01:10:35,720
 And arrives actually at the destination after the packet, the first packet, the one which, right after that, after the last packet, right, which was sent by the sender.

957
01:10:35,720 --> 01:10:43,720
 So the second packet is lost in this example, but assume is not lost, but it arrives after the first packet.

958
01:10:43,720 --> 01:10:53,720
 So if that's the case, the sender will see the same things. It cannot differentiate between the two.

959
01:10:53,720 --> 01:11:01,720
 So waiting for more duplicate acknowledgments is a way to make it more sure that the packet was really lost.

960
01:11:01,720 --> 01:11:10,720
 And it's not because the packets are reordered. And the packets are reordered because every packet can take a different route in the network.

961
01:11:10,720 --> 01:11:25,720
 Which means also is true, that three duplicate acknowledgments, missing three duplicate acknowledgments are not necessary, always guarantee a packet has been lost.

962
01:11:25,720 --> 01:11:32,720
 It's correct. It just increases the probability, that assertion, to be correct.

963
01:11:32,720 --> 01:11:41,720
 OK. So how does a sender control sending rate? It's using, again, a window. It's called congestion window size.

964
01:11:41,720 --> 01:11:58,720
 And congestion window size is going to take the minimum between the sending window size and this congestion window size, which is computed in the network.

965
01:11:58,720 --> 01:12:09,720
 And obviously it might be less than the receiver advertising window and increase the size of the windows until congestion and reduce the size of the window if congestion.

966
01:12:09,720 --> 01:12:19,720
 Because the window size, it tells me how many packets, how many bytes I can send without being acknowledged.

967
01:12:19,720 --> 01:12:35,720
 Right. So bigger window means higher throughput. I can send more data before being acknowledged. Smaller window size, I can send, you know, if it's one packet, it's top end way.

968
01:12:35,720 --> 01:12:52,720
 So finally, let me tell you, I'm going to spend a few minutes on this plot. And this is just to give you a taste about how the TCP is working and congestion control is working.

969
01:12:52,720 --> 01:13:08,720
 So first of all, I don't know how much, when I'm starting to send data as a sender, I know how much the receiver can handle.

970
01:13:08,720 --> 01:13:16,720
 Because the receiver, there is, initially when I established the connection and a three-way handshake protocol, and the receiver tells me about the advertisement.

971
01:13:16,720 --> 01:13:28,720
 It's advertisement. So I know that. I know how much to send without overflowing the receiver. But I don't know about how much I can send without overflowing the network.

972
01:13:28,720 --> 01:13:39,720
 So then what I'm sending, I'm going to send, start with a congestion window of one. Let's again think about congestion window one packet to simplify the discussion.

973
01:13:39,720 --> 01:13:46,720
 So I'm moving from window measuring in bytes into packets. Two packets again.

974
01:13:46,720 --> 01:13:51,720
 So I'm sending one packet and I'm waiting for acknowledgement. So I'm sending only one packet.

975
01:13:51,720 --> 01:14:02,720
 So it's like stop and wait. But now when I'm getting the first acknowledgement, I send a packet, it went through. Let me be more aggressive now.

976
01:14:02,720 --> 01:14:11,720
 So I'm going to increase the congestion window when I get the acknowledgement by one. So now I'm going to send two packets.

977
01:14:11,720 --> 01:14:21,720
 And each acknowledgement I get, I mean, add another one to the congestion window.

978
01:14:21,720 --> 01:14:34,720
 Now this is called slow start. Slow start is a terrible name because actually, if you think about in the slow start by using, by CWU is a congestion window here.

979
01:14:34,720 --> 01:14:44,720
 If you increase the congestion window every time you get a knock by one, you double the congestion window every round trip time. In the first round trip time, I send one packet,

980
01:14:44,720 --> 01:14:54,720
 I got one acknowledgement. So now in the second round trip time I send two packets. I get two acknowledgement. For each acknowledgement I get in the second round trip time,

981
01:14:54,720 --> 01:15:04,720
 I'm going to increase the window size by one. So from two is going to go to four. Now in the third congestion round trip time, I'm going to send four packets.

982
01:15:04,720 --> 01:15:09,720
 For each acknowledgement, I'm going to increase the congestion window by one. So I'm going to have eight.

983
01:15:09,720 --> 01:15:23,720
 Right. So this is what you see the congestion window size is on the vertical. So it's going from small, you know, double every time. And at some point, I am going

984
01:15:23,720 --> 01:15:28,720
 probably to lose a packet because I sent too much.

985
01:15:28,720 --> 01:15:36,720
 This is when the packet is lost. So what I'm going to do when that happened.

986
01:15:36,720 --> 01:15:46,720
 You need to be very aggressive, because it turns out that if you just are, you are not very aggressive, and this is, you know, it's a theory property we don't have time to go into it.

987
01:15:46,720 --> 01:15:56,720
 But if you don't reduce the sending rate very fast, you cannot really relieve the congestion.

988
01:15:56,720 --> 01:16:03,720
 Right. So in this case, okay, you are very dramatic. So you're going to go with the congestion window all the way to one.

989
01:16:03,720 --> 01:16:13,720
 Reduce it. And then you go again, slow start, again, exponential increase. But now you go through until to this threshold.

990
01:16:13,720 --> 01:16:19,720
 And this threshold is the last is a congestion window.

991
01:16:19,720 --> 01:16:26,720
 In the previous slow start, because you're still successful all the packets made it.

992
01:16:26,720 --> 01:16:47,720
 So congestion window, it was eight, I sent eight packets, I got eight acknowledgement, then and then when I congestion window increased to 16, I got, I lost packets, I'm going the next time, I'm only going to stop the slow start or aggressive start to eight.

993
01:16:47,720 --> 01:16:59,720
 Because I know that kind of a successful last time, and then I'm going to be much more timidly explore, you know how you increase and explore the capacity of the network.

994
01:16:59,720 --> 01:17:05,720
 Right. So I'm going to increase now with one, I'm going only to increase.

995
01:17:05,720 --> 01:17:25,720
 This is what I was talking about and now I'm going to increase only the congestion window by one, but round trip time. So this means that you now when I'm going to get an acknowledgement I'm going to increase the congestion window by one over n, where n is a current congestion window size.

996
01:17:25,720 --> 01:17:40,720
 Right. So if I have the congestion window size is 10, and every acknowledgement I'm going to increase the window size by one over 10. Now, in one round trip time I'm going to increase the congestion from 10 to 11.

997
01:17:40,720 --> 01:17:56,720
 So you get this one. So this is additive increase is called additive increase. Right. And then I get a loss here if I lost here maybe I is because three WK acknowledgement. Now I'm going back, if it's through the WK acknowledgement I'm going to get back to the threshold.

998
01:17:56,720 --> 01:18:02,720
 Right. And then I go, I grow again and things like that. Okay.

999
01:18:02,720 --> 01:18:13,720
 So, so that's basically what it is. So there is an early stage in which you grow very fast to explore the limits of the network.

1000
01:18:13,720 --> 01:18:21,720
 And then after that you get into this regime, which is at the end, you additively increase.

1001
01:18:21,720 --> 01:18:30,720
 Then the window size and you get a loss you multiply it decrease. This is called multiplicative decrease basically you're cutting to half in general.

1002
01:18:30,720 --> 01:18:36,720
 You grow linearly, you cut it to half, you grow linearly, you cut it to half.

1003
01:18:36,720 --> 01:18:41,720
 So that's pretty much it. It's again it's fascinating.

1004
01:18:41,720 --> 01:18:46,720
 Algorithm, very very simple but in dynamic the dynamics are fascinating.

1005
01:18:46,720 --> 01:18:57,720
 So, I'm going to stop here, and, you know, we talked about the network, the networking summary, we talk about this and we talk about networking.

1006
01:18:57,720 --> 01:19:01,720
 We have a few lectures on that.

1007
01:19:01,720 --> 01:19:07,720
 Remember, the internet has five layers physical layer data link layer network layer transport layer application layer.

1008
01:19:07,720 --> 01:19:16,720
 And we talked about end to end argument and to argument is saying that the higher layers can implement functionality correctly.

1009
01:19:16,720 --> 01:19:30,720
 You should implement the functionality as a lower layer only if it improves the performance significantly for applications that needs that functionality, and it does not impose burden on applications that do not require this functionality.

1010
01:19:30,720 --> 01:19:41,720
 And we discussed flow control, which is whose goal is not overflows the receiver buffer and congestion control is the main goal is to not overflow the network.

1011
01:19:41,720 --> 01:19:54,720
 Thank you and next lecture, I'm going to do it's a special topics. I'm going to tell you a little bit about some of the research, which we have been doing the Rice lab and AMLAB.

1012
01:19:54,720 --> 01:19:58,720
 Okay, see you all.

1013
01:19:58,720 --> 01:20:00,720
 So I'm going to stop here.

1014
01:20:00,720 --> 01:20:03,720
 And there is a question I'm going to take.

